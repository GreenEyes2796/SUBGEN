CCS PCH C Compiler, Version 5.071d, 1               03-Jul-17 14:16
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   115240 bytes (88%)
                           Largest free fragment is 15470
               RAM used:   2157 (56%) at main() level
                           2622 (68%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1B064
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0ED4
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0EFE
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   18F4
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E00
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   16D6
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   174C
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E64
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
....................              /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 3F,40
00668:  DATA 42,53
0066A:  DATA 59,0D
0066C:  DATA 0A,00
0066E:  DATA 40,52
00670:  DATA 44,59
00672:  DATA 0D,0A
00674:  DATA 00,00
00676:  DATA 40,46
00678:  DATA 53,3A
0067A:  DATA 44,69
0067C:  DATA 73,63
0067E:  DATA 6F,76
00680:  DATA 65,72
00682:  DATA 79,0D
00684:  DATA 0A,00
00686:  DATA 40,46
00688:  DATA 53,3A
0068A:  DATA 55,6E
0068C:  DATA 61,62
0068E:  DATA 6C,65
00690:  DATA 20,74
00692:  DATA 6F,20
00694:  DATA 70,75
00696:  DATA 74,20
00698:  DATA 63,61
0069A:  DATA 72,64
0069C:  DATA 20,69
0069E:  DATA 6E,20
006A0:  DATA 69,64
006A2:  DATA 6C,65
006A4:  DATA 20,73
006A6:  DATA 74,61
006A8:  DATA 74,65
006AA:  DATA 2C,20
006AC:  DATA 72,65
006AE:  DATA 73,70
006B0:  DATA 6F,6E
006B2:  DATA 73,65
006B4:  DATA 20,3D
006B6:  DATA 20,25
006B8:  DATA 30,32
006BA:  DATA 78,0D
006BC:  DATA 0A,00
006BE:  DATA 40,46
006C0:  DATA 53,3A
006C2:  DATA 43,61
006C4:  DATA 72,64
006C6:  DATA 20,69
006C8:  DATA 64,6C
006CA:  DATA 65,2C
006CC:  DATA 20,72
006CE:  DATA 65,73
006D0:  DATA 70,6F
006D2:  DATA 6E,73
006D4:  DATA 65,20
006D6:  DATA 3D,20
006D8:  DATA 25,30
006DA:  DATA 32,78
006DC:  DATA 0D,0A
006DE:  DATA 00,00
006E0:  DATA 40,46
006E2:  DATA 53,3A
006E4:  DATA 52,65
006E6:  DATA 73,70
006E8:  DATA 6F,6E
006EA:  DATA 73,65
006EC:  DATA 20,74
006EE:  DATA 6F,20
006F0:  DATA 53,44
006F2:  DATA 20,76
006F4:  DATA 65,72
006F6:  DATA 20,32
006F8:  DATA 20,74
006FA:  DATA 65,73
006FC:  DATA 74,20
006FE:  DATA 43,4D
00700:  DATA 44,38
00702:  DATA 20,3D
00704:  DATA 20,25
00706:  DATA 78,0D
00708:  DATA 0A,00
0070A:  DATA 40,46
0070C:  DATA 53,3A
0070E:  DATA 50,6F
00710:  DATA 73,73
00712:  DATA 69,62
00714:  DATA 6C,65
00716:  DATA 20,53
00718:  DATA 44,76
0071A:  DATA 32,20
0071C:  DATA 63,61
0071E:  DATA 72,64
00720:  DATA 20,64
00722:  DATA 65,74
00724:  DATA 65,63
00726:  DATA 74,65
00728:  DATA 64,0D
0072A:  DATA 0A,00
0072C:  DATA 40,46
0072E:  DATA 53,3A
00730:  DATA 56,6F
00732:  DATA 6C,74
00734:  DATA 61,67
00736:  DATA 65,20
00738:  DATA 72,61
0073A:  DATA 6E,67
0073C:  DATA 65,20
0073E:  DATA 63,68
00740:  DATA 65,63
00742:  DATA 6B,2C
00744:  DATA 20,6F
00746:  DATA 63,72
00748:  DATA 20,3D
0074A:  DATA 20,25
0074C:  DATA 30,32
0074E:  DATA 78,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,0D
0075C:  DATA 0A,00
0075E:  DATA 40,46
00760:  DATA 53,3A
00762:  DATA 43,61
00764:  DATA 72,64
00766:  DATA 20,56
00768:  DATA 64,64
0076A:  DATA 20,72
0076C:  DATA 61,6E
0076E:  DATA 67,65
00770:  DATA 20,3D
00772:  DATA 20,32
00774:  DATA 2E,37
00776:  DATA 2D,33
00778:  DATA 2E,36
0077A:  DATA 20,76
0077C:  DATA 6F,6C
0077E:  DATA 74,73
00780:  DATA 0D,0A
00782:  DATA 00,00
00784:  DATA 40,46
00786:  DATA 53,3A
00788:  DATA 53,65
0078A:  DATA 6E,64
0078C:  DATA 69,6E
0078E:  DATA 67,20
00790:  DATA 41,43
00792:  DATA 4D,44
00794:  DATA 34,31
00796:  DATA 20,63
00798:  DATA 6F,6D
0079A:  DATA 6D,61
0079C:  DATA 6E,64
0079E:  DATA 20,74
007A0:  DATA 6F,20
007A2:  DATA 53,44
007A4:  DATA 20,76
007A6:  DATA 65,72
007A8:  DATA 20,32
007AA:  DATA 20,63
007AC:  DATA 61,72
007AE:  DATA 64,0D
007B0:  DATA 0A,00
007B2:  DATA 40,46
007B4:  DATA 53,3A
007B6:  DATA 52,65
007B8:  DATA 73,70
007BA:  DATA 6F,6E
007BC:  DATA 73,65
007BE:  DATA 20,66
007C0:  DATA 72,6F
007C2:  DATA 6D,20
007C4:  DATA 73,65
007C6:  DATA 6E,64
007C8:  DATA 69,6E
007CA:  DATA 67,20
007CC:  DATA 41,43
007CE:  DATA 4D,44
007D0:  DATA 34,31
007D2:  DATA 20,3D
007D4:  DATA 20,25
007D6:  DATA 30,32
007D8:  DATA 78,2C
007DA:  DATA 20,54
007DC:  DATA 69,6D
007DE:  DATA 65,72
007E0:  DATA 20,3D
007E2:  DATA 20,25
007E4:  DATA 6C,75
007E6:  DATA 0D,0A
007E8:  DATA 00,00
007EA:  DATA 40,46
007EC:  DATA 53,3A
007EE:  DATA 52,65
007F0:  DATA 73,70
007F2:  DATA 6F,6E
007F4:  DATA 73,65
007F6:  DATA 20,74
007F8:  DATA 6F,20
007FA:  DATA 43,4D
007FC:  DATA 44,35
007FE:  DATA 38,20
00800:  DATA 3D,20
00802:  DATA 25,78
00804:  DATA 0D,0A
00806:  DATA 00,00
00808:  DATA 40,46
0080A:  DATA 53,3A
0080C:  DATA 53,65
0080E:  DATA 6E,74
00810:  DATA 20,43
00812:  DATA 4D,44
00814:  DATA 20,35
00816:  DATA 38,2C
00818:  DATA 20,54
0081A:  DATA 69,6D
0081C:  DATA 65,72
0081E:  DATA 20,76
00820:  DATA 61,6C
00822:  DATA 75,65
00824:  DATA 20,3D
00826:  DATA 20,25
00828:  DATA 6C,75
0082A:  DATA 2C,20
0082C:  DATA 6F,63
0082E:  DATA 72,20
00830:  DATA 3D,20
00832:  DATA 25,30
00834:  DATA 32,78
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 0D,0A
00844:  DATA 00,00
00846:  DATA 40,46
00848:  DATA 53,3A
0084A:  DATA 43,61
0084C:  DATA 72,64
0084E:  DATA 20,43
00850:  DATA 41,4E
00852:  DATA 4E,4F
00854:  DATA 54,20
00856:  DATA 77,6F
00858:  DATA 72,6B
0085A:  DATA 20,56
0085C:  DATA 64,64
0085E:  DATA 20,72
00860:  DATA 61,6E
00862:  DATA 67,65
00864:  DATA 20,6F
00866:  DATA 66,20
00868:  DATA 32,2E
0086A:  DATA 37,2D
0086C:  DATA 33,2E
0086E:  DATA 36,20
00870:  DATA 76,6F
00872:  DATA 6C,74
00874:  DATA 73,0D
00876:  DATA 0A,00
00878:  DATA 40,46
0087A:  DATA 53,3A
0087C:  DATA 4E,6F
0087E:  DATA 74,20
00880:  DATA 61,6E
00882:  DATA 20,53
00884:  DATA 44,53
00886:  DATA 43,20
00888:  DATA 6F,72
0088A:  DATA 20,53
0088C:  DATA 44,48
0088E:  DATA 43,20
00890:  DATA 63,61
00892:  DATA 72,64
00894:  DATA 2C,20
00896:  DATA 54,65
00898:  DATA 73,74
0089A:  DATA 69,6E
0089C:  DATA 67,20
0089E:  DATA 66,6F
008A0:  DATA 72,20
008A2:  DATA 53,44
008A4:  DATA 20,56
008A6:  DATA 65,72
008A8:  DATA 31,20
008AA:  DATA 6F,72
008AC:  DATA 20,4D
008AE:  DATA 4D,43
008B0:  DATA 20,43
008B2:  DATA 61,72
008B4:  DATA 64,0D
008B6:  DATA 0A,00
008B8:  DATA 40,46
008BA:  DATA 53,3A
008BC:  DATA 52,65
008BE:  DATA 73,70
008C0:  DATA 6F,6E
008C2:  DATA 73,65
008C4:  DATA 20,66
008C6:  DATA 72,6F
008C8:  DATA 6D,20
008CA:  DATA 47,4F
008CC:  DATA 5F,49
008CE:  DATA 44,4C
008D0:  DATA 45,20
008D2:  DATA 3D,20
008D4:  DATA 25,30
008D6:  DATA 32,78
008D8:  DATA 0D,0A
008DA:  DATA 00,00
008DC:  DATA 40,46
008DE:  DATA 53,3A
008E0:  DATA 52,65
008E2:  DATA 73,70
008E4:  DATA 6F,6E
008E6:  DATA 73,65
008E8:  DATA 20,66
008EA:  DATA 72,6F
008EC:  DATA 6D,20
008EE:  DATA 53,44
008F0:  DATA 5F,43
008F2:  DATA 4D,44
008F4:  DATA 5F,53
008F6:  DATA 45,4E
008F8:  DATA 44,5F
008FA:  DATA 4F,50
008FC:  DATA 5F,43
008FE:  DATA 4F,4E
00900:  DATA 44,20
00902:  DATA 3D,20
00904:  DATA 25,30
00906:  DATA 32,78
00908:  DATA 2C,20
0090A:  DATA 54,69
0090C:  DATA 6D,65
0090E:  DATA 72,20
00910:  DATA 3D,20
00912:  DATA 25,6C
00914:  DATA 75,0D
00916:  DATA 0A,00
00918:  DATA 40,46
0091A:  DATA 53,3A
0091C:  DATA 41,74
0091E:  DATA 74,65
00920:  DATA 6D,70
00922:  DATA 74,69
00924:  DATA 6E,67
00926:  DATA 20,53
00928:  DATA 44,76
0092A:  DATA 31,20
0092C:  DATA 76,65
0092E:  DATA 72,73
00930:  DATA 75,73
00932:  DATA 20,4D
00934:  DATA 4D,43
00936:  DATA 20,49
00938:  DATA 44,2C
0093A:  DATA 20,52
0093C:  DATA 65,73
0093E:  DATA 70,6F
00940:  DATA 6E,73
00942:  DATA 65,20
00944:  DATA 66,72
00946:  DATA 6F,6D
00948:  DATA 20,53
0094A:  DATA 44,5F
0094C:  DATA 43,4D
0094E:  DATA 44,5F
00950:  DATA 41,50
00952:  DATA 50,4C
00954:  DATA 5F,43
00956:  DATA 4D,44
00958:  DATA 20,3D
0095A:  DATA 20,25
0095C:  DATA 30,32
0095E:  DATA 78,0D
00960:  DATA 0A,00
00962:  DATA 40,46
00964:  DATA 53,3A
00966:  DATA 49,6E
00968:  DATA 76,61
0096A:  DATA 6C,69
0096C:  DATA 64,20
0096E:  DATA 72,65
00970:  DATA 73,70
00972:  DATA 6F,6E
00974:  DATA 73,65
00976:  DATA 20,74
00978:  DATA 6F,20
0097A:  DATA 53,44
0097C:  DATA 5F,41
0097E:  DATA 43,4D
00980:  DATA 44,34
00982:  DATA 31,2C
00984:  DATA 20,72
00986:  DATA 65,73
00988:  DATA 70,6F
0098A:  DATA 6E,73
0098C:  DATA 65,20
0098E:  DATA 3D,20
00990:  DATA 25,30
00992:  DATA 32,58
00994:  DATA 2C,20
00996:  DATA 72,65
00998:  DATA 69,6E
0099A:  DATA 69,74
0099C:  DATA 69,61
0099E:  DATA 6C,69
009A0:  DATA 7A,69
009A2:  DATA 6E,67
009A4:  DATA 20,61
009A6:  DATA 73,20
009A8:  DATA 4D,4D
009AA:  DATA 43,0D
009AC:  DATA 0A,00
009AE:  DATA 40,46
009B0:  DATA 53,3A
009B2:  DATA 46,61
009B4:  DATA 69,6C
009B6:  DATA 65,64
009B8:  DATA 20,74
009BA:  DATA 6F,20
009BC:  DATA 69,6E
009BE:  DATA 69,74
009C0:  DATA 69,61
009C2:  DATA 6C,69
009C4:  DATA 7A,65
009C6:  DATA 20,61
009C8:  DATA 73,20
009CA:  DATA 4D,4D
009CC:  DATA 43,2C
009CE:  DATA 20,72
009D0:  DATA 65,73
009D2:  DATA 70,6F
009D4:  DATA 6E,73
009D6:  DATA 65,20
009D8:  DATA 3D,20
009DA:  DATA 25,30
009DC:  DATA 32,58
009DE:  DATA 2C,20
009E0:  DATA 65,78
009E2:  DATA 69,74
009E4:  DATA 69,6E
009E6:  DATA 67,0D
009E8:  DATA 0A,00
009EA:  DATA 40,46
009EC:  DATA 53,3A
009EE:  DATA 43,61
009F0:  DATA 72,64
009F2:  DATA 20,66
009F4:  DATA 61,69
009F6:  DATA 6C,65
009F8:  DATA 64,20
009FA:  DATA 74,6F
009FC:  DATA 20,72
009FE:  DATA 65,73
00A00:  DATA 70,6F
00A02:  DATA 6E,64
00A04:  DATA 20,63
00A06:  DATA 6F,72
00A08:  DATA 72,65
00A0A:  DATA 63,6C
00A0C:  DATA 79,20
00A0E:  DATA 61,66
00A10:  DATA 74,65
00A12:  DATA 72,20
00A14:  DATA 53,44
00A16:  DATA 5F,43
00A18:  DATA 4D,44
00A1A:  DATA 5F,53
00A1C:  DATA 45,4E
00A1E:  DATA 44,5F
00A20:  DATA 4F,50
00A22:  DATA 5F,43
00A24:  DATA 4F,4E
00A26:  DATA 44,2C
00A28:  DATA 20,72
00A2A:  DATA 65,73
00A2C:  DATA 70,6F
00A2E:  DATA 6E,73
00A30:  DATA 65,20
00A32:  DATA 3D,20
00A34:  DATA 25,30
00A36:  DATA 32,58
00A38:  DATA 2C,20
00A3A:  DATA 54,69
00A3C:  DATA 6D,65
00A3E:  DATA 72,20
00A40:  DATA 3D,20
00A42:  DATA 25,6C
00A44:  DATA 75,0D
00A46:  DATA 0A,00
00A48:  DATA 40,46
00A4A:  DATA 53,3A
00A4C:  DATA 53,65
00A4E:  DATA 74,74
00A50:  DATA 69,6E
00A52:  DATA 67,20
00A54:  DATA 62,6C
00A56:  DATA 6F,63
00A58:  DATA 6B,20
00A5A:  DATA 6C,65
00A5C:  DATA 6E,67
00A5E:  DATA 74,68
00A60:  DATA 0D,0A
00A62:  DATA 00,00
00A64:  DATA 40,46
00A66:  DATA 53,3A
00A68:  DATA 45,72
00A6A:  DATA 72,6F
00A6C:  DATA 72,20
00A6E:  DATA 73,65
00A70:  DATA 74,74
00A72:  DATA 69,6E
00A74:  DATA 67,20
00A76:  DATA 62,6C
00A78:  DATA 6F,63
00A7A:  DATA 6B,20
00A7C:  DATA 6C,65
00A7E:  DATA 6E,67
00A80:  DATA 74,68
00A82:  DATA 2C,20
00A84:  DATA 72,65
00A86:  DATA 73,70
00A88:  DATA 6F,6E
00A8A:  DATA 73,65
00A8C:  DATA 20,3D
00A8E:  DATA 20,25
00A90:  DATA 30,32
00A92:  DATA 78,2C
00A94:  DATA 20,74
00A96:  DATA 69,6D
00A98:  DATA 65,72
00A9A:  DATA 20,3D
00A9C:  DATA 20,25
00A9E:  DATA 6C,75
00AA0:  DATA 0D,0A
00AA2:  DATA 00,00
00AA4:  DATA 40,46
00AA6:  DATA 53,3A
00AA8:  DATA 43,61
00AAA:  DATA 72,64
00AAC:  DATA 20,54
00AAE:  DATA 79,70
00AB0:  DATA 65,20
00AB2:  DATA 44,69
00AB4:  DATA 73,63
00AB6:  DATA 6F,76
00AB8:  DATA 65,72
00ABA:  DATA 79,20
00ABC:  DATA 45,72
00ABE:  DATA 72,6F
00AC0:  DATA 72,0D
00AC2:  DATA 0A,00
00AC4:  DATA 40,46
00AC6:  DATA 53,3A
00AC8:  DATA 4D,4D
00ACA:  DATA 43,20
00ACC:  DATA 43,61
00ACE:  DATA 72,64
00AD0:  DATA 20,66
00AD2:  DATA 6F,75
00AD4:  DATA 6E,64
00AD6:  DATA 0D,0A
00AD8:  DATA 00,00
00ADA:  DATA 40,46
00ADC:  DATA 53,3A
00ADE:  DATA 53,44
00AE0:  DATA 76,31
00AE2:  DATA 20,43
00AE4:  DATA 61,72
00AE6:  DATA 64,20
00AE8:  DATA 66,6F
00AEA:  DATA 75,6E
00AEC:  DATA 64,0D
00AEE:  DATA 0A,00
00AF0:  DATA 40,46
00AF2:  DATA 53,3A
00AF4:  DATA 53,44
00AF6:  DATA 53,43
00AF8:  DATA 20,43
00AFA:  DATA 61,72
00AFC:  DATA 64,20
00AFE:  DATA 66,6F
00B00:  DATA 75,6E
00B02:  DATA 64,0D
00B04:  DATA 0A,00
00B06:  DATA 40,46
00B08:  DATA 53,3A
00B0A:  DATA 53,44
00B0C:  DATA 48,43
00B0E:  DATA 20,43
00B10:  DATA 61,72
00B12:  DATA 64,20
00B14:  DATA 66,6F
00B16:  DATA 75,6E
00B18:  DATA 64,0D
00B1A:  DATA 0A,00
00B1C:  DATA 40,46
00B1E:  DATA 53,3A
00B20:  DATA 43,61
00B22:  DATA 72,64
00B24:  DATA 20,54
00B26:  DATA 79,70
00B28:  DATA 65,20
00B2A:  DATA 44,69
00B2C:  DATA 73,63
00B2E:  DATA 6F,76
00B30:  DATA 65,72
00B32:  DATA 79,20
00B34:  DATA 45,72
00B36:  DATA 72,6F
00B38:  DATA 72,2C
00B3A:  DATA 20,43
00B3C:  DATA 61,72
00B3E:  DATA 64,20
00B40:  DATA 3D,20
00B42:  DATA 25,30
00B44:  DATA 32,58
00B46:  DATA 0D,0A
00B48:  DATA 00,00
00B4A:  DATA 40,46
00B4C:  DATA 53,3A
00B4E:  DATA 43,61
00B50:  DATA 72,64
00B52:  DATA 20,72
00B54:  DATA 65,73
00B56:  DATA 65,74
00B58:  DATA 20,73
00B5A:  DATA 75,63
00B5C:  DATA 63,65
00B5E:  DATA 73,73
00B60:  DATA 20,2D
00B62:  DATA 20,43
00B64:  DATA 6D,64
00B66:  DATA 20,74
00B68:  DATA 6F,20
00B6A:  DATA 52,65
00B6C:  DATA 61,64
00B6E:  DATA 79,20
00B70:  DATA 63,6F
00B72:  DATA 75,6E
00B74:  DATA 74,20
00B76:  DATA 3D,20
00B78:  DATA 25,6C
00B7A:  DATA 75,0D
00B7C:  DATA 0A,00
00B7E:  DATA 40,46
00B80:  DATA 53,3A
00B82:  DATA 53,50
00B84:  DATA 49,20
00B86:  DATA 62,75
00B88:  DATA 73,20
00B8A:  DATA 73,70
00B8C:  DATA 65,65
00B8E:  DATA 64,20
00B90:  DATA 73,65
00B92:  DATA 74,20
00B94:  DATA 74,6F
00B96:  DATA 20,68
00B98:  DATA 69,67
00B9A:  DATA 68,0D
00B9C:  DATA 0A,00
00B9E:  DATA 40,46
00BA0:  DATA 53,3A
00BA2:  DATA 43,61
00BA4:  DATA 72,64
00BA6:  DATA 20,61
00BA8:  DATA 63,74
00BAA:  DATA 69,76
00BAC:  DATA 61,74
00BAE:  DATA 65,20
00BB0:  DATA 66,61
00BB2:  DATA 69,6C
00BB4:  DATA 75,72
00BB6:  DATA 65,2C
00BB8:  DATA 20,72
00BBA:  DATA 65,73
00BBC:  DATA 70,6F
00BBE:  DATA 6E,73
00BC0:  DATA 65,20
00BC2:  DATA 3D,20
00BC4:  DATA 25,30
00BC6:  DATA 32,58
00BC8:  DATA 2C,20
00BCA:  DATA 54,69
00BCC:  DATA 6D,65
00BCE:  DATA 72,20
00BD0:  DATA 3D,20
00BD2:  DATA 25,6C
00BD4:  DATA 75,0D
00BD6:  DATA 0A,00
00BD8:  DATA 40,46
00BDA:  DATA 53,3A
00BDC:  DATA 43,61
00BDE:  DATA 72,64
00BE0:  DATA 20,61
00BE2:  DATA 63,74
00BE4:  DATA 69,76
00BE6:  DATA 61,74
00BE8:  DATA 65,20
00BEA:  DATA 73,75
00BEC:  DATA 63,63
00BEE:  DATA 65,73
00BF0:  DATA 73,20
00BF2:  DATA 6F,6E
00BF4:  DATA 20,61
00BF6:  DATA 74,74
00BF8:  DATA 65,6D
00BFA:  DATA 70,74
00BFC:  DATA 20,25
00BFE:  DATA 6C,75
00C00:  DATA 0D,0A
00C02:  DATA 00,00
00C04:  DATA 46,41
00C06:  DATA 54,20
00C08:  DATA 61,74
00C0A:  DATA 20,73
00C0C:  DATA 65,63
00C0E:  DATA 74,6F
00C10:  DATA 72,20
00C12:  DATA 30,0D
00C14:  DATA 0A,00
00C16:  DATA 54,59
00C18:  DATA 50,45
00C1A:  DATA 20,63
00C1C:  DATA 6F,6D
00C1E:  DATA 6D,61
00C20:  DATA 6E,64
00C22:  DATA 20,45
00C24:  DATA 52,52
00C26:  DATA 4F,52
00C28:  DATA 0D,0A
00C2A:  DATA 00,00
00C2C:  DATA 40,46
00C2E:  DATA 53,3A
00C30:  DATA 20,25
00C32:  DATA 73,0D
00C34:  DATA 0A,00
00C36:  DATA 40,46
00C38:  DATA 53,3A
00C3A:  DATA 20,25
00C3C:  DATA 73,0D
00C3E:  DATA 0A,00
00C40:  DATA 2A,2A
00C42:  DATA 20,40
00C44:  DATA 46,53
00C46:  DATA 3A,20
00C48:  DATA 45,52
00C4A:  DATA 52,4F
00C4C:  DATA 52,0D
00C4E:  DATA 0A,00
00C50:  DATA 20,20
00C52:  DATA 20,4E
00C54:  DATA 6F,45
00C56:  DATA 72,72
00C58:  DATA 6F,72
00C5A:  DATA 0D,0A
00C5C:  DATA 00,00
00C5E:  DATA 20,20
00C60:  DATA 20,4D
00C62:  DATA 65,64
00C64:  DATA 69,61
00C66:  DATA 20,4E
00C68:  DATA 6F,74
00C6A:  DATA 20,52
00C6C:  DATA 65,61
00C6E:  DATA 64,79
00C70:  DATA 0D,0A
00C72:  DATA 00,00
00C74:  DATA 20,20
00C76:  DATA 20,46
00C78:  DATA 69,6C
00C7A:  DATA 65,20
00C7C:  DATA 4E,6F
00C7E:  DATA 74,20
00C80:  DATA 46,6F
00C82:  DATA 75,6E
00C84:  DATA 64,0D
00C86:  DATA 0A,00
00C88:  DATA 20,20
00C8A:  DATA 20,49
00C8C:  DATA 6E,76
00C8E:  DATA 61,6C
00C90:  DATA 69,64
00C92:  DATA 20,50
00C94:  DATA 61,74
00C96:  DATA 68,0D
00C98:  DATA 0A,00
00C9A:  DATA 20,20
00C9C:  DATA 20,49
00C9E:  DATA 6E,76
00CA0:  DATA 61,6C
00CA2:  DATA 69,64
00CA4:  DATA 20,4E
00CA6:  DATA 61,6D
00CA8:  DATA 65,0D
00CAA:  DATA 0A,00
00CAC:  DATA 20,20
00CAE:  DATA 20,41
00CB0:  DATA 63,63
00CB2:  DATA 65,73
00CB4:  DATA 73,20
00CB6:  DATA 44,65
00CB8:  DATA 6E,69
00CBA:  DATA 65,64
00CBC:  DATA 0D,0A
00CBE:  DATA 00,00
00CC0:  DATA 20,20
00CC2:  DATA 20,44
00CC4:  DATA 69,73
00CC6:  DATA 6B,20
00CC8:  DATA 46,75
00CCA:  DATA 6C,6C
00CCC:  DATA 0D,0A
00CCE:  DATA 00,00
00CD0:  DATA 20,20
00CD2:  DATA 20,52
00CD4:  DATA 65,61
00CD6:  DATA 64,2F
00CD8:  DATA 57,72
00CDA:  DATA 69,74
00CDC:  DATA 65,20
00CDE:  DATA 45,72
00CE0:  DATA 72,6F
00CE2:  DATA 72,0D
00CE4:  DATA 0A,00
00CE6:  DATA 20,20
00CE8:  DATA 20,49
00CEA:  DATA 6E,63
00CEC:  DATA 6F,72
00CEE:  DATA 72,65
00CF0:  DATA 63,74
00CF2:  DATA 20,4D
00CF4:  DATA 65,64
00CF6:  DATA 69,61
00CF8:  DATA 20,43
00CFA:  DATA 68,61
00CFC:  DATA 6E,67
00CFE:  DATA 65,0D
00D00:  DATA 0A,00
00D02:  DATA 20,20
00D04:  DATA 20,57
00D06:  DATA 72,69
00D08:  DATA 74,65
00D0A:  DATA 20,50
00D0C:  DATA 72,6F
00D0E:  DATA 74,65
00D10:  DATA 63,74
00D12:  DATA 65,64
00D14:  DATA 0D,0A
00D16:  DATA 00,00
00D18:  DATA 20,20
00D1A:  DATA 20,4E
00D1C:  DATA 6F,74
00D1E:  DATA 20,45
00D20:  DATA 6E,61
00D22:  DATA 62,6C
00D24:  DATA 65,64
00D26:  DATA 0D,0A
00D28:  DATA 00,00
00D2A:  DATA 20,20
00D2C:  DATA 20,4E
00D2E:  DATA 6F,20
00D30:  DATA 46,69
00D32:  DATA 6C,65
00D34:  DATA 20,53
00D36:  DATA 79,73
00D38:  DATA 74,65
00D3A:  DATA 6D,0D
00D3C:  DATA 0A,00
00D3E:  DATA 61,70
00D40:  DATA 70,65
00D42:  DATA 6E,64
00D44:  DATA 3A,20
00D46:  DATA 46,53
00D48:  DATA 20,45
00D4A:  DATA 52,52
00D4C:  DATA 4F,52
00D4E:  DATA 20,6F
00D50:  DATA 6E,20
00D52:  DATA 66,69
00D54:  DATA 6C,65
00D56:  DATA 5F,6F
00D58:  DATA 70,65
00D5A:  DATA 6E,0D
00D5C:  DATA 0A,00
00D5E:  DATA 40,46
00D60:  DATA 53,3A
00D62:  DATA 57,72
00D64:  DATA 69,74
00D66:  DATA 69,6E
00D68:  DATA 67,0D
00D6A:  DATA 0A,5B
00D6C:  DATA 25,73
00D6E:  DATA 5D,0D
00D70:  DATA 0A,00
00D72:  DATA 40,46
00D74:  DATA 53,3A
00D76:  DATA 45,52
00D78:  DATA 52,4F
00D7A:  DATA 52,5B
00D7C:  DATA 61,70
00D7E:  DATA 70,65
00D80:  DATA 6E,64
00D82:  DATA 5D,0D
00D84:  DATA 0A,00
00D86:  DATA 40,46
00D88:  DATA 53,3A
00D8A:  DATA 43,6C
00D8C:  DATA 6F,73
00D8E:  DATA 69,6E
00D90:  DATA 67,0D
00D92:  DATA 0A,00
00D94:  DATA 40,52
00D96:  DATA 54,43
00D98:  DATA 3A,25
00D9A:  DATA 30,32
00D9C:  DATA 75,2F
00D9E:  DATA 00,00
00DA0:  DATA 40,52
00DA2:  DATA 54,43
00DA4:  DATA 3A,25
00DA6:  DATA 30,32
00DA8:  DATA 75,2F
00DAA:  DATA 00,00
00DAC:  DATA 40,41
00DAE:  DATA 4C,4D
00DB0:  DATA 3A,25
00DB2:  DATA 30,32
00DB4:  DATA 75,2F
00DB6:  DATA 00,00
00DB8:  DATA 40,41
00DBA:  DATA 4C,4D
00DBC:  DATA 3A,25
00DBE:  DATA 30,32
00DC0:  DATA 75,2F
00DC2:  DATA 00,00
00DC4:  DATA 40,41
00DC6:  DATA 4C,4D
00DC8:  DATA 0D,0A
00DCA:  DATA 00,00
*
00E3A:  TBLRD*+
00E3C:  MOVF   FF5,F
00E3E:  BZ    0E62
00E40:  MOVFF  FF6,A1D
00E44:  MOVFF  FF7,A1E
00E48:  MOVFF  FF8,A1F
00E4C:  MOVF   FF5,W
00E4E:  BTFSS  F9E.4
00E50:  BRA    0E4E
00E52:  MOVWF  FAD
00E54:  MOVFF  A1D,FF6
00E58:  MOVFF  A1E,FF7
00E5C:  MOVFF  A1F,FF8
00E60:  BRA    0E3A
00E62:  RETURN 0
*
00EC4:  DATA 3F,40
00EC6:  DATA 42,53
00EC8:  DATA 59,0D
00ECA:  DATA 0A,00
00ECC:  DATA 40,52
00ECE:  DATA 44,59
00ED0:  DATA 0D,0A
00ED2:  DATA 00,00
*
00F14:  DATA 40,5B
00F16:  DATA 4F,5D
00F18:  DATA 0D,0A
00F1A:  DATA 00,00
00F1C:  DATA 40,43
00F1E:  DATA 4D,44
00F20:  DATA 20,74
00F22:  DATA 6F,6F
00F24:  DATA 20,6C
00F26:  DATA 6F,6E
00F28:  DATA 67,0D
00F2A:  DATA 0A,00
00F2C:  DATA 40,5B
00F2E:  DATA 43,5D
00F30:  DATA 0D,0A
00F32:  DATA 00,00
00F34:  DATA 40,53
00F36:  DATA 4C,45
00F38:  DATA 45,50
00F3A:  DATA 0D,0A
00F3C:  DATA 00,00
00F3E:  DATA 40,4D
00F40:  DATA 45,52
00F42:  DATA 2C,25
00F44:  DATA 4C,75
00F46:  DATA 2C,25
00F48:  DATA 4C,75
00F4A:  DATA 0D,0A
00F4C:  DATA 00,00
00F4E:  DATA 6D,3A
00F50:  DATA 25,75
00F52:  DATA 2C,25
00F54:  DATA 75,20
00F56:  DATA 63,3A
00F58:  DATA 25,4C
00F5A:  DATA 75,2C
00F5C:  DATA 25,4C
00F5E:  DATA 75,2C
00F60:  DATA 25,4C
00F62:  DATA 75,0D
00F64:  DATA 0A,00
00F66:  MOVLB  A
00F68:  MOVF   x28,W
00F6A:  CLRF   01
00F6C:  SUBWF  x27,W
00F6E:  BC    0F76
00F70:  MOVFF  A27,00
00F74:  BRA    0F8E
00F76:  CLRF   00
00F78:  MOVLW  08
00F7A:  MOVWF  x29
00F7C:  RLCF   x27,F
00F7E:  RLCF   00,F
00F80:  MOVF   x28,W
00F82:  SUBWF  00,W
00F84:  BTFSC  FD8.0
00F86:  MOVWF  00
00F88:  RLCF   01,F
00F8A:  DECFSZ x29,F
00F8C:  BRA    0F7C
00F8E:  MOVLB  0
00F90:  RETURN 0
00F92:  MOVF   01,W
00F94:  MOVFF  A25,A27
00F98:  MOVLW  64
00F9A:  MOVLB  A
00F9C:  MOVWF  x28
00F9E:  MOVLB  0
00FA0:  RCALL  0F66
00FA2:  MOVFF  00,A25
00FA6:  MOVF   01,W
00FA8:  MOVLW  30
00FAA:  BNZ   0FBC
00FAC:  MOVLB  A
00FAE:  BTFSS  x26.1
00FB0:  BRA    0FCE
00FB2:  BTFSC  x26.3
00FB4:  BRA    0FCE
00FB6:  BTFSC  x26.4
00FB8:  MOVLW  20
00FBA:  BRA    0FC4
00FBC:  MOVLB  A
00FBE:  BCF    x26.3
00FC0:  BCF    x26.4
00FC2:  BSF    x26.0
00FC4:  ADDWF  01,F
00FC6:  MOVF   01,W
00FC8:  BTFSS  F9E.4
00FCA:  BRA    0FC8
00FCC:  MOVWF  FAD
00FCE:  MOVFF  A25,A27
00FD2:  MOVLW  0A
00FD4:  MOVWF  x28
00FD6:  MOVLB  0
00FD8:  RCALL  0F66
00FDA:  MOVFF  00,A25
00FDE:  MOVF   01,W
00FE0:  MOVLW  30
00FE2:  BNZ   0FF4
00FE4:  MOVLB  A
00FE6:  BTFSC  x26.3
00FE8:  BRA    1000
00FEA:  BTFSS  x26.0
00FEC:  BRA    1000
00FEE:  BTFSC  x26.4
00FF0:  MOVLW  20
00FF2:  MOVLB  0
00FF4:  ADDWF  01,F
00FF6:  MOVF   01,W
00FF8:  BTFSS  F9E.4
00FFA:  BRA    0FF8
00FFC:  MOVWF  FAD
00FFE:  MOVLB  A
01000:  MOVLW  30
01002:  ADDWF  x25,F
01004:  MOVF   x25,W
01006:  BTFSS  F9E.4
01008:  BRA    1006
0100A:  MOVWF  FAD
0100C:  MOVLB  0
0100E:  RETURN 0
01010:  TBLRD*+
01012:  MOVFF  FF6,A26
01016:  MOVFF  FF7,A27
0101A:  MOVFF  FF8,A28
0101E:  MOVF   FF5,W
01020:  BTFSS  F9E.4
01022:  BRA    1020
01024:  MOVWF  FAD
01026:  MOVFF  A26,FF6
0102A:  MOVFF  A27,FF7
0102E:  MOVFF  A28,FF8
01032:  MOVLB  A
01034:  DECFSZ x25,F
01036:  BRA    103A
01038:  BRA    103E
0103A:  MOVLB  0
0103C:  BRA    1010
0103E:  MOVLB  0
01040:  RETURN 0
01042:  BTFSC  FD8.1
01044:  BRA    104E
01046:  MOVLW  0A
01048:  MOVWF  FEA
0104A:  MOVLW  39
0104C:  MOVWF  FE9
0104E:  CLRF   00
01050:  CLRF   01
01052:  CLRF   02
01054:  CLRF   03
01056:  MOVLB  A
01058:  CLRF   x39
0105A:  CLRF   x3A
0105C:  CLRF   x3B
0105E:  CLRF   x3C
01060:  MOVF   x38,W
01062:  IORWF  x37,W
01064:  IORWF  x36,W
01066:  IORWF  x35,W
01068:  BZ    10C2
0106A:  MOVLW  20
0106C:  MOVWF  x3D
0106E:  BCF    FD8.0
01070:  RLCF   x31,F
01072:  RLCF   x32,F
01074:  RLCF   x33,F
01076:  RLCF   x34,F
01078:  RLCF   x39,F
0107A:  RLCF   x3A,F
0107C:  RLCF   x3B,F
0107E:  RLCF   x3C,F
01080:  MOVF   x38,W
01082:  SUBWF  x3C,W
01084:  BNZ   1096
01086:  MOVF   x37,W
01088:  SUBWF  x3B,W
0108A:  BNZ   1096
0108C:  MOVF   x36,W
0108E:  SUBWF  x3A,W
01090:  BNZ   1096
01092:  MOVF   x35,W
01094:  SUBWF  x39,W
01096:  BNC   10B6
01098:  MOVF   x35,W
0109A:  SUBWF  x39,F
0109C:  MOVF   x36,W
0109E:  BTFSS  FD8.0
010A0:  INCFSZ x36,W
010A2:  SUBWF  x3A,F
010A4:  MOVF   x37,W
010A6:  BTFSS  FD8.0
010A8:  INCFSZ x37,W
010AA:  SUBWF  x3B,F
010AC:  MOVF   x38,W
010AE:  BTFSS  FD8.0
010B0:  INCFSZ x38,W
010B2:  SUBWF  x3C,F
010B4:  BSF    FD8.0
010B6:  RLCF   00,F
010B8:  RLCF   01,F
010BA:  RLCF   02,F
010BC:  RLCF   03,F
010BE:  DECFSZ x3D,F
010C0:  BRA    106E
010C2:  MOVFF  A39,FEF
010C6:  MOVFF  A3A,FEC
010CA:  MOVFF  A3B,FEC
010CE:  MOVFF  A3C,FEC
010D2:  MOVLB  0
010D4:  RETURN 0
010D6:  MOVF   FE9,W
010D8:  MOVLB  A
010DA:  MOVWF  x29
010DC:  MOVLW  3B
010DE:  MOVWF  x30
010E0:  MOVLW  9A
010E2:  MOVWF  x2F
010E4:  MOVLW  CA
010E6:  MOVWF  x2E
010E8:  CLRF   x2D
010EA:  MOVLW  0A
010EC:  MOVWF  x2B
010EE:  BSF    FD8.1
010F0:  MOVLW  0A
010F2:  MOVWF  FEA
010F4:  MOVLW  25
010F6:  MOVWF  FE9
010F8:  MOVFF  A28,A34
010FC:  MOVFF  A27,A33
01100:  MOVFF  A26,A32
01104:  MOVFF  A25,A31
01108:  MOVFF  A30,A38
0110C:  MOVFF  A2F,A37
01110:  MOVFF  A2E,A36
01114:  MOVFF  A2D,A35
01118:  MOVLB  0
0111A:  RCALL  1042
0111C:  MOVF   01,W
0111E:  MOVF   00,F
01120:  BNZ   1148
01122:  MOVLB  A
01124:  MOVF   x2B,W
01126:  XORLW  01
01128:  BTFSS  FD8.2
0112A:  BRA    1130
0112C:  MOVLB  0
0112E:  BRA    1148
01130:  MOVF   x29,W
01132:  BZ    114C
01134:  ANDLW  0F
01136:  SUBWF  x2B,W
01138:  BZ    113C
0113A:  BC    1158
0113C:  BTFSC  x29.7
0113E:  BRA    1158
01140:  BTFSC  x29.6
01142:  BRA    114C
01144:  MOVLW  20
01146:  BRA    114E
01148:  MOVLB  A
0114A:  CLRF   x29
0114C:  MOVLW  30
0114E:  ADDWF  00,F
01150:  MOVF   00,W
01152:  BTFSS  F9E.4
01154:  BRA    1152
01156:  MOVWF  FAD
01158:  BCF    FD8.1
0115A:  MOVFF  A30,A34
0115E:  MOVFF  A2F,A33
01162:  MOVFF  A2E,A32
01166:  MOVFF  A2D,A31
0116A:  CLRF   x38
0116C:  CLRF   x37
0116E:  CLRF   x36
01170:  MOVLW  0A
01172:  MOVWF  x35
01174:  MOVLB  0
01176:  RCALL  1042
01178:  MOVFF  03,A30
0117C:  MOVFF  02,A2F
01180:  MOVFF  01,A2E
01184:  MOVFF  00,A2D
01188:  MOVLB  A
0118A:  DECFSZ x2B,F
0118C:  BRA    10EE
0118E:  MOVLB  0
01190:  RETURN 0
01192:  MOVFF  FEA,A2D
01196:  MOVFF  FE9,A2C
0119A:  MOVLB  A
0119C:  SWAPF  x26,W
0119E:  IORLW  F0
011A0:  MOVWF  x28
011A2:  ADDWF  x28,F
011A4:  ADDLW  E2
011A6:  MOVWF  x29
011A8:  ADDLW  32
011AA:  MOVWF  x2B
011AC:  MOVF   x26,W
011AE:  ANDLW  0F
011B0:  ADDWF  x29,F
011B2:  ADDWF  x29,F
011B4:  ADDWF  x2B,F
011B6:  ADDLW  E9
011B8:  MOVWF  x2A
011BA:  ADDWF  x2A,F
011BC:  ADDWF  x2A,F
011BE:  SWAPF  x25,W
011C0:  ANDLW  0F
011C2:  ADDWF  x2A,F
011C4:  ADDWF  x2B,F
011C6:  RLCF   x2A,F
011C8:  RLCF   x2B,F
011CA:  COMF   x2B,F
011CC:  RLCF   x2B,F
011CE:  MOVF   x25,W
011D0:  ANDLW  0F
011D2:  ADDWF  x2B,F
011D4:  RLCF   x28,F
011D6:  MOVLW  07
011D8:  MOVWF  x27
011DA:  MOVLW  0A
011DC:  DECF   x2A,F
011DE:  ADDWF  x2B,F
011E0:  BNC   11DC
011E2:  DECF   x29,F
011E4:  ADDWF  x2A,F
011E6:  BNC   11E2
011E8:  DECF   x28,F
011EA:  ADDWF  x29,F
011EC:  BNC   11E8
011EE:  DECF   x27,F
011F0:  ADDWF  x28,F
011F2:  BNC   11EE
011F4:  MOVLW  0A
011F6:  MOVWF  FEA
011F8:  MOVLW  27
011FA:  MOVWF  FE9
011FC:  MOVLW  07
011FE:  ANDWF  x2C,W
01200:  BCF    x2C.6
01202:  ADDWF  FE9,F
01204:  MOVLW  00
01206:  ADDWFC FEA,F
01208:  MOVF   FE9,W
0120A:  SUBLW  2B
0120C:  BNZ   1216
0120E:  MOVF   FEA,W
01210:  SUBLW  0A
01212:  BNZ   1216
01214:  BSF    x2C.6
01216:  MOVF   FEF,W
01218:  MOVWF  00
0121A:  BNZ   122C
0121C:  BTFSC  x2C.6
0121E:  BRA    122C
01220:  BTFSC  x2C.4
01222:  BRA    123C
01224:  BTFSC  x2C.3
01226:  BRA    122C
01228:  MOVLW  20
0122A:  BRA    1232
0122C:  BSF    x2C.3
0122E:  BCF    x2C.4
01230:  MOVLW  30
01232:  ADDWF  00,F
01234:  MOVF   00,W
01236:  BTFSS  F9E.4
01238:  BRA    1236
0123A:  MOVWF  FAD
0123C:  MOVF   FEE,W
0123E:  BTFSS  x2C.6
01240:  BRA    1208
01242:  MOVLB  0
01244:  RETURN 0
*
01A4A:  DATA 40,4C
01A4C:  DATA 50,43
01A4E:  DATA 2C,25
01A50:  DATA 4C,75
01A52:  DATA 2C,25
01A54:  DATA 4C,64
01A56:  DATA 0D,0A
01A58:  DATA 00,00
01A5A:  DATA 40,4D
01A5C:  DATA 4D,45
01A5E:  DATA 2C,25
01A60:  DATA 75,2C
01A62:  DATA 25,4C
01A64:  DATA 64,2C
01A66:  DATA 25,4C
01A68:  DATA 75,2C
01A6A:  DATA 25,4C
01A6C:  DATA 75,2C
01A6E:  DATA 25,4C
01A70:  DATA 64,2C
01A72:  DATA 25,4C
01A74:  DATA 64,0D
01A76:  DATA 0A,00
01A78:  DATA 56,41
01A7A:  DATA 4C,56
01A7C:  DATA 45,20
01A7E:  DATA 53,54
01A80:  DATA 4F,50
01A82:  DATA 20,25
01A84:  DATA 4C,75
01A86:  DATA 2C,25
01A88:  DATA 4C,75
01A8A:  DATA 0D,0A
01A8C:  DATA 00,00
01A8E:  DATA 69,6E
01A90:  DATA 64,3A
01A92:  DATA 25,75
01A94:  DATA 20,2F
01A96:  DATA 20,70
01A98:  DATA 68,61
01A9A:  DATA 3A,25
01A9C:  DATA 75,0D
01A9E:  DATA 0A,00
01AA0:  DATA 40,52
01AA2:  DATA 45,43
01AA4:  DATA 20,2D
01AA6:  DATA 20,68
01AA8:  DATA 6F,6D
01AAA:  DATA 69,6E
01AAC:  DATA 67,20
01AAE:  DATA 73,79
01AB0:  DATA 72,69
01AB2:  DATA 6E,67
01AB4:  DATA 65,20
01AB6:  DATA 61,6E
01AB8:  DATA 64,20
01ABA:  DATA 61,6C
01ABC:  DATA 69,67
01ABE:  DATA 6E,69
01AC0:  DATA 6E,67
01AC2:  DATA 20,76
01AC4:  DATA 61,6C
01AC6:  DATA 76,65
01AC8:  DATA 20,74
01ACA:  DATA 6F,20
01ACC:  DATA 70,6F
01ACE:  DATA 72,74
01AD0:  DATA 20,31
01AD2:  DATA 0D,0A
01AD4:  DATA 00,00
01AD6:  DATA 2C,73
01AD8:  DATA 65,72
01ADA:  DATA 69,61
01ADC:  DATA 6C,20
01ADE:  DATA 77,61
01AE0:  DATA 6B,65
01AE2:  DATA 2D,75
01AE4:  DATA 70,2C
01AE6:  DATA 53,44
01AE8:  DATA 20,69
01AEA:  DATA 6E,69
01AEC:  DATA 74,69
01AEE:  DATA 61,6C
01AF0:  DATA 69,7A
01AF2:  DATA 65,64
01AF4:  DATA 0D,0A
01AF6:  DATA 00,00
01AF8:  DATA 40,52
01AFA:  DATA 53,54
01AFC:  DATA 0D,0A
01AFE:  DATA 00,00
01B00:  DATA 40,57
01B02:  DATA 44,54
01B04:  DATA 0D,0A
01B06:  DATA 00,00
01B08:  DATA 2C,72
01B0A:  DATA 65,73
01B0C:  DATA 74,61
01B0E:  DATA 72,74
01B10:  DATA 20,63
01B12:  DATA 61,75
01B14:  DATA 73,65
01B16:  DATA 2C,57
01B18:  DATA 44,20
01B1A:  DATA 74,69
01B1C:  DATA 6D,65
01B1E:  DATA 2D,6F
01B20:  DATA 75,74
01B22:  DATA 0D,0A
01B24:  DATA 00,00
01B26:  DATA 40,57
01B28:  DATA 44,53
01B2A:  DATA 0D,0A
01B2C:  DATA 00,00
01B2E:  DATA 2C,72
01B30:  DATA 65,73
01B32:  DATA 74,61
01B34:  DATA 72,74
01B36:  DATA 20,63
01B38:  DATA 61,75
01B3A:  DATA 73,65
01B3C:  DATA 2C,57
01B3E:  DATA 44,20
01B40:  DATA 66,72
01B42:  DATA 6F,6D
01B44:  DATA 20,73
01B46:  DATA 6C,65
01B48:  DATA 65,70
01B4A:  DATA 0D,0A
01B4C:  DATA 00,00
01B4E:  DATA 40,4E
01B50:  DATA 50,55
01B52:  DATA 0D,0A
01B54:  DATA 00,00
01B56:  DATA 2C,69
01B58:  DATA 64,23
01B5A:  DATA 5B,25
01B5C:  DATA 4C,75
01B5E:  DATA 5D,2C
01B60:  DATA 70,6F
01B62:  DATA 77,65
01B64:  DATA 72,20
01B66:  DATA 61,70
01B68:  DATA 70,6C
01B6A:  DATA 69,65
01B6C:  DATA 64,2C
01B6E:  DATA 53,44
01B70:  DATA 20,69
01B72:  DATA 6E,69
01B74:  DATA 74,69
01B76:  DATA 61,6C
01B78:  DATA 69,7A
01B7A:  DATA 65,64
01B7C:  DATA 0D,0A
01B7E:  DATA 00,00
01B80:  DATA 40,52
01B82:  DATA 53,54
01B84:  DATA 0D,0A
01B86:  DATA 00,00
01B88:  DATA 2C,72
01B8A:  DATA 65,73
01B8C:  DATA 74,61
01B8E:  DATA 72,74
01B90:  DATA 20,63
01B92:  DATA 61,75
01B94:  DATA 73,65
01B96:  DATA 2C,72
01B98:  DATA 65,73
01B9A:  DATA 65,74
01B9C:  DATA 20,69
01B9E:  DATA 6E,73
01BA0:  DATA 74,72
01BA2:  DATA 75,63
01BA4:  DATA 74,69
01BA6:  DATA 6F,6E
01BA8:  DATA 0D,0A
01BAA:  DATA 00,00
01BAC:  DATA 40,42
01BAE:  DATA 4F,52
01BB0:  DATA 0D,0A
01BB2:  DATA 00,00
01BB4:  DATA 2C,72
01BB6:  DATA 65,73
01BB8:  DATA 74,61
01BBA:  DATA 72,74
01BBC:  DATA 20,63
01BBE:  DATA 61,75
01BC0:  DATA 73,65
01BC2:  DATA 2C,62
01BC4:  DATA 72,6F
01BC6:  DATA 77,6E
01BC8:  DATA 2D,6F
01BCA:  DATA 75,74
01BCC:  DATA 0D,0A
01BCE:  DATA 00,00
01BD0:  DATA 40,4D
01BD2:  DATA 52,53
01BD4:  DATA 0D,0A
01BD6:  DATA 00,00
01BD8:  DATA 2C,72
01BDA:  DATA 65,73
01BDC:  DATA 74,61
01BDE:  DATA 72,74
01BE0:  DATA 20,63
01BE2:  DATA 61,75
01BE4:  DATA 73,65
01BE6:  DATA 2C,4D
01BE8:  DATA 43,4C
01BEA:  DATA 52,20
01BEC:  DATA 66,72
01BEE:  DATA 6F,6D
01BF0:  DATA 20,73
01BF2:  DATA 6C,65
01BF4:  DATA 65,70
01BF6:  DATA 0D,0A
01BF8:  DATA 00,00
01BFA:  DATA 40,4D
01BFC:  DATA 52,52
01BFE:  DATA 0D,0A
01C00:  DATA 00,00
01C02:  DATA 2C,72
01C04:  DATA 65,73
01C06:  DATA 74,61
01C08:  DATA 72,74
01C0A:  DATA 20,63
01C0C:  DATA 61,75
01C0E:  DATA 73,65
01C10:  DATA 2C,4D
01C12:  DATA 43,4C
01C14:  DATA 52,20
01C16:  DATA 77,68
01C18:  DATA 65,6E
01C1A:  DATA 20,72
01C1C:  DATA 75,6E
01C1E:  DATA 6E,69
01C20:  DATA 6E,67
01C22:  DATA 0D,0A
01C24:  DATA 00,00
01C26:  DATA 4E,4F
01C28:  DATA 33,00
01C2A:  DATA 4E,4F
01C2C:  DATA 32,00
01C2E:  DATA 50,4F
01C30:  DATA 34,00
01C32:  DATA 4E,48
01C34:  DATA 34,00
01C36:  DATA 53,69
01C38:  DATA 4F,00
01C3A:  DATA 00,00
01C3C:  DATA 40,44
01C3E:  DATA 45,54
01C40:  DATA 5B,2F
01C42:  DATA 25,75
01C44:  DATA 5D,5B
01C46:  DATA 25,63
01C48:  DATA 5D,41
01C4A:  DATA 52,47
01C4C:  DATA 5B,25
01C4E:  DATA 4C,75
01C50:  DATA 5D,0D
01C52:  DATA 0A,00
01C54:  DATA 20,74
01C56:  DATA 69,6D
01C58:  DATA 65,2D
01C5A:  DATA 6F,75
01C5C:  DATA 74,00
01C5E:  DATA 20,64
01C60:  DATA 61,74
01C62:  DATA 61,20
01C64:  DATA 74,6F
01C66:  DATA 6F,20
01C68:  DATA 73,68
01C6A:  DATA 6F,72
01C6C:  DATA 74,00
01C6E:  DATA 20,64
01C70:  DATA 61,74
01C72:  DATA 61,20
01C74:  DATA 74,6F
01C76:  DATA 6F,20
01C78:  DATA 6C,6F
01C7A:  DATA 6E,67
01C7C:  DATA 00,00
01C7E:  DATA 2C,64
01C80:  DATA 65,74
01C82:  DATA 65,63
01C84:  DATA 74,6F
01C86:  DATA 72,5B
01C88:  DATA 25,73
01C8A:  DATA 5D,2C
01C8C:  DATA 6C,65
01C8E:  DATA 6E,5B
01C90:  DATA 25,75
01C92:  DATA 5D,00
01C94:  DATA 40,52
01C96:  DATA 54,59
01C98:  DATA 2C,25
01C9A:  DATA 75,0D
01C9C:  DATA 0A,00
01C9E:  DATA 2C,73
01CA0:  DATA 74,61
01CA2:  DATA 72,74
01CA4:  DATA 20,68
01CA6:  DATA 65,61
01CA8:  DATA 74,69
01CAA:  DATA 6E,67
01CAC:  DATA 2C,74
01CAE:  DATA 61,72
01CB0:  DATA 67,65
01CB2:  DATA 74,5B
01CB4:  DATA 25,4C
01CB6:  DATA 75,5D
01CB8:  DATA 2C,61
01CBA:  DATA 63,74
01CBC:  DATA 75,61
01CBE:  DATA 6C,5B
01CC0:  DATA 25,4C
01CC2:  DATA 75,5D
01CC4:  DATA 2C,72
01CC6:  DATA 65,61
01CC8:  DATA 64,69
01CCA:  DATA 6E,67
01CCC:  DATA 73,5B
01CCE:  DATA 25,4C
01CD0:  DATA 75,5D
01CD2:  DATA 0D,0A
01CD4:  DATA 00,00
01CD6:  DATA 2C,65
01CD8:  DATA 6E,64
01CDA:  DATA 20,68
01CDC:  DATA 65,61
01CDE:  DATA 74,69
01CE0:  DATA 6E,67
01CE2:  DATA 2C,74
01CE4:  DATA 61,72
01CE6:  DATA 67,65
01CE8:  DATA 74,5B
01CEA:  DATA 25,4C
01CEC:  DATA 75,5D
01CEE:  DATA 2C,61
01CF0:  DATA 63,74
01CF2:  DATA 75,61
01CF4:  DATA 6C,5B
01CF6:  DATA 25,4C
01CF8:  DATA 75,5D
01CFA:  DATA 2C,72
01CFC:  DATA 65,61
01CFE:  DATA 64,69
01D00:  DATA 6E,67
01D02:  DATA 73,5B
01D04:  DATA 25,4C
01D06:  DATA 75,5D
01D08:  DATA 0D,0A
01D0A:  DATA 00,00
01D0C:  DATA 4E,4F
01D0E:  DATA 33,00
01D10:  DATA 4E,4F
01D12:  DATA 32,00
01D14:  DATA 50,4F
01D16:  DATA 34,00
01D18:  DATA 4E,48
01D1A:  DATA 34,00
01D1C:  DATA 53,69
01D1E:  DATA 4F,00
01D20:  DATA 00,00
01D22:  DATA 40,44
01D24:  DATA 41,43
01D26:  DATA 2C,25
01D28:  DATA 4C,75
01D2A:  DATA 2C,25
01D2C:  DATA 4C,75
01D2E:  DATA 2C,00
01D30:  DATA 40,53
01D32:  DATA 41,52
01D34:  DATA 2C,31
01D36:  DATA 2C,25
01D38:  DATA 4C,75
01D3A:  DATA 2C,00
01D3C:  DATA 40,56
01D3E:  DATA 41,4C
01D40:  DATA 20,00
01D42:  DATA 40,56
01D44:  DATA 41,4C
01D46:  DATA 20,00
01D48:  DATA 40,56
01D4A:  DATA 41,4C
01D4C:  DATA 20,00
01D4E:  DATA 40,56
01D50:  DATA 41,4C
01D52:  DATA 20,00
01D54:  DATA 40,53
01D56:  DATA 4F,4C
01D58:  DATA 5B,2F
01D5A:  DATA 31,5D
01D5C:  DATA 5B,73
01D5E:  DATA 5D,5B
01D60:  DATA 25,4C
01D62:  DATA 75,5D
01D64:  DATA 0D,0A
01D66:  DATA 00,00
01D68:  DATA 2F,31
01D6A:  DATA 73,25
01D6C:  DATA 4C,75
01D6E:  DATA 0D,00
01D70:  DATA 40,53
01D72:  DATA 4F,4C
01D74:  DATA 5B,2F
01D76:  DATA 31,5D
01D78:  DATA 5B,63
01D7A:  DATA 5D,5B
01D7C:  DATA 25,75
01D7E:  DATA 5D,0D
01D80:  DATA 0A,00
01D82:  DATA 2F,31
01D84:  DATA 63,25
01D86:  DATA 75,0D
01D88:  DATA 00,00
01D8A:  DATA 2F,31
01D8C:  DATA 73,32
01D8E:  DATA 35,36
01D90:  DATA 0D,00
01D92:  DATA 28,49
01D94:  DATA 30,73
01D96:  DATA 29,2C
01D98:  DATA 25,4C
01D9A:  DATA 75,2C
01D9C:  DATA 28,49
01D9E:  DATA 31,73
01DA0:  DATA 29,2C
01DA2:  DATA 25,4C
01DA4:  DATA 75,2C
01DA6:  DATA 28,41
01DA8:  DATA 62,73
01DAA:  DATA 2D,73
01DAC:  DATA 29,2C
01DAE:  DATA 25,31
01DB0:  DATA 2E,34
01DB2:  DATA 67,2C
01DB4:  DATA 28,49
01DB6:  DATA 30,74
01DB8:  DATA 29,2C
01DBA:  DATA 25,4C
01DBC:  DATA 75,2C
01DBE:  DATA 28,49
01DC0:  DATA 31,74
01DC2:  DATA 29,2C
01DC4:  DATA 25,4C
01DC6:  DATA 75,2C
01DC8:  DATA 28,41
01DCA:  DATA 62,73
01DCC:  DATA 2D,74
01DCE:  DATA 29,2C
01DD0:  DATA 25,31
01DD2:  DATA 2E,34
01DD4:  DATA 67,2C
01DD6:  DATA 28,49
01DD8:  DATA 30,72
01DDA:  DATA 29,2C
01DDC:  DATA 25,4C
01DDE:  DATA 75,2C
01DE0:  DATA 28,49
01DE2:  DATA 31,72
01DE4:  DATA 29,2C
01DE6:  DATA 25,4C
01DE8:  DATA 75,2C
01DEA:  DATA 28,41
01DEC:  DATA 62,73
01DEE:  DATA 2D,72
01DF0:  DATA 29,2C
01DF2:  DATA 25,31
01DF4:  DATA 2E,34
01DF6:  DATA 67,00
01DF8:  DATA 40,41
01DFA:  DATA 62,73
01DFC:  DATA 2C,4E
01DFE:  DATA 4F,33
01E00:  DATA 2C,25
01E02:  DATA 73,0D
01E04:  DATA 0A,00
01E06:  DATA 28,49
01E08:  DATA 30,73
01E0A:  DATA 29,2C
01E0C:  DATA 25,4C
01E0E:  DATA 75,2C
01E10:  DATA 28,49
01E12:  DATA 31,73
01E14:  DATA 29,2C
01E16:  DATA 25,4C
01E18:  DATA 75,2C
01E1A:  DATA 28,41
01E1C:  DATA 62,73
01E1E:  DATA 2D,73
01E20:  DATA 29,2C
01E22:  DATA 25,31
01E24:  DATA 2E,34
01E26:  DATA 67,2C
01E28:  DATA 28,49
01E2A:  DATA 30,74
01E2C:  DATA 29,2C
01E2E:  DATA 25,4C
01E30:  DATA 75,2C
01E32:  DATA 28,49
01E34:  DATA 31,74
01E36:  DATA 29,2C
01E38:  DATA 25,4C
01E3A:  DATA 75,2C
01E3C:  DATA 28,41
01E3E:  DATA 62,73
01E40:  DATA 2D,74
01E42:  DATA 29,2C
01E44:  DATA 25,31
01E46:  DATA 2E,34
01E48:  DATA 67,2C
01E4A:  DATA 28,49
01E4C:  DATA 30,72
01E4E:  DATA 29,2C
01E50:  DATA 25,4C
01E52:  DATA 75,2C
01E54:  DATA 28,49
01E56:  DATA 31,72
01E58:  DATA 29,2C
01E5A:  DATA 25,4C
01E5C:  DATA 75,2C
01E5E:  DATA 28,41
01E60:  DATA 62,73
01E62:  DATA 2D,72
01E64:  DATA 29,2C
01E66:  DATA 25,31
01E68:  DATA 2E,34
01E6A:  DATA 67,00
01E6C:  DATA 40,41
01E6E:  DATA 62,73
01E70:  DATA 2C,4E
01E72:  DATA 4F,32
01E74:  DATA 2C,25
01E76:  DATA 73,0D
01E78:  DATA 0A,00
01E7A:  DATA 28,49
01E7C:  DATA 30,73
01E7E:  DATA 29,2C
01E80:  DATA 25,4C
01E82:  DATA 75,2C
01E84:  DATA 28,49
01E86:  DATA 31,73
01E88:  DATA 29,2C
01E8A:  DATA 25,4C
01E8C:  DATA 75,2C
01E8E:  DATA 28,41
01E90:  DATA 62,73
01E92:  DATA 2D,73
01E94:  DATA 29,2C
01E96:  DATA 25,31
01E98:  DATA 2E,34
01E9A:  DATA 67,2C
01E9C:  DATA 28,49
01E9E:  DATA 30,74
01EA0:  DATA 29,2C
01EA2:  DATA 25,4C
01EA4:  DATA 75,2C
01EA6:  DATA 28,49
01EA8:  DATA 31,74
01EAA:  DATA 29,2C
01EAC:  DATA 25,4C
01EAE:  DATA 75,2C
01EB0:  DATA 28,41
01EB2:  DATA 62,73
01EB4:  DATA 2D,74
01EB6:  DATA 29,2C
01EB8:  DATA 25,31
01EBA:  DATA 2E,34
01EBC:  DATA 67,2C
01EBE:  DATA 28,49
01EC0:  DATA 30,72
01EC2:  DATA 29,2C
01EC4:  DATA 25,4C
01EC6:  DATA 75,2C
01EC8:  DATA 28,49
01ECA:  DATA 31,72
01ECC:  DATA 29,2C
01ECE:  DATA 25,4C
01ED0:  DATA 75,2C
01ED2:  DATA 28,41
01ED4:  DATA 62,73
01ED6:  DATA 2D,72
01ED8:  DATA 29,2C
01EDA:  DATA 25,31
01EDC:  DATA 2E,34
01EDE:  DATA 67,00
01EE0:  DATA 40,41
01EE2:  DATA 62,73
01EE4:  DATA 2C,50
01EE6:  DATA 4F,34
01EE8:  DATA 2C,25
01EEA:  DATA 73,0D
01EEC:  DATA 0A,00
01EEE:  DATA 28,49
01EF0:  DATA 30,73
01EF2:  DATA 29,2C
01EF4:  DATA 25,4C
01EF6:  DATA 75,2C
01EF8:  DATA 28,49
01EFA:  DATA 31,73
01EFC:  DATA 29,2C
01EFE:  DATA 25,4C
01F00:  DATA 75,2C
01F02:  DATA 28,41
01F04:  DATA 62,73
01F06:  DATA 2D,73
01F08:  DATA 29,2C
01F0A:  DATA 25,31
01F0C:  DATA 2E,34
01F0E:  DATA 67,2C
01F10:  DATA 28,49
01F12:  DATA 30,74
01F14:  DATA 29,2C
01F16:  DATA 25,4C
01F18:  DATA 75,2C
01F1A:  DATA 28,49
01F1C:  DATA 31,74
01F1E:  DATA 29,2C
01F20:  DATA 25,4C
01F22:  DATA 75,2C
01F24:  DATA 28,41
01F26:  DATA 62,73
01F28:  DATA 2D,74
01F2A:  DATA 29,2C
01F2C:  DATA 25,31
01F2E:  DATA 2E,34
01F30:  DATA 67,2C
01F32:  DATA 28,49
01F34:  DATA 30,72
01F36:  DATA 29,2C
01F38:  DATA 25,4C
01F3A:  DATA 75,2C
01F3C:  DATA 28,49
01F3E:  DATA 31,72
01F40:  DATA 29,2C
01F42:  DATA 25,4C
01F44:  DATA 75,2C
01F46:  DATA 28,41
01F48:  DATA 62,73
01F4A:  DATA 2D,72
01F4C:  DATA 29,2C
01F4E:  DATA 25,31
01F50:  DATA 2E,34
01F52:  DATA 67,00
01F54:  DATA 40,41
01F56:  DATA 62,73
01F58:  DATA 2C,4E
01F5A:  DATA 48,34
01F5C:  DATA 2C,25
01F5E:  DATA 73,0D
01F60:  DATA 0A,00
01F62:  DATA 28,49
01F64:  DATA 30,73
01F66:  DATA 29,2C
01F68:  DATA 25,4C
01F6A:  DATA 75,2C
01F6C:  DATA 28,49
01F6E:  DATA 31,73
01F70:  DATA 29,2C
01F72:  DATA 25,4C
01F74:  DATA 75,2C
01F76:  DATA 28,41
01F78:  DATA 62,73
01F7A:  DATA 2D,73
01F7C:  DATA 29,2C
01F7E:  DATA 25,31
01F80:  DATA 2E,34
01F82:  DATA 67,2C
01F84:  DATA 28,49
01F86:  DATA 30,74
01F88:  DATA 29,2C
01F8A:  DATA 25,4C
01F8C:  DATA 75,2C
01F8E:  DATA 28,49
01F90:  DATA 31,74
01F92:  DATA 29,2C
01F94:  DATA 25,4C
01F96:  DATA 75,2C
01F98:  DATA 28,41
01F9A:  DATA 62,73
01F9C:  DATA 2D,74
01F9E:  DATA 29,2C
01FA0:  DATA 25,31
01FA2:  DATA 2E,34
01FA4:  DATA 67,2C
01FA6:  DATA 28,49
01FA8:  DATA 30,72
01FAA:  DATA 29,2C
01FAC:  DATA 25,4C
01FAE:  DATA 75,2C
01FB0:  DATA 28,49
01FB2:  DATA 31,72
01FB4:  DATA 29,2C
01FB6:  DATA 25,4C
01FB8:  DATA 75,2C
01FBA:  DATA 28,41
01FBC:  DATA 62,73
01FBE:  DATA 2D,72
01FC0:  DATA 29,2C
01FC2:  DATA 25,31
01FC4:  DATA 2E,34
01FC6:  DATA 67,00
01FC8:  DATA 40,41
01FCA:  DATA 42,53
01FCC:  DATA 2C,53
01FCE:  DATA 69,4F
01FD0:  DATA 2C,25
01FD2:  DATA 73,0D
01FD4:  DATA 0A,00
01FD6:  DATA 4E,4F
01FD8:  DATA 33,00
01FDA:  DATA 4E,4F
01FDC:  DATA 32,00
01FDE:  DATA 50,4F
01FE0:  DATA 34,00
01FE2:  DATA 4E,48
01FE4:  DATA 34,00
01FE6:  DATA 53,69
01FE8:  DATA 4F,00
01FEA:  DATA 00,00
01FEC:  DATA 28,6D
01FEE:  DATA 29,2C
01FF0:  DATA 25,33
01FF2:  DATA 2E,33
01FF4:  DATA 67,2C
01FF6:  DATA 28,63
01FF8:  DATA 29,2C
01FFA:  DATA 25,33
01FFC:  DATA 2E,33
01FFE:  DATA 67,00
02000:  DATA 28,43
02002:  DATA 73,29
02004:  DATA 2C,25
02006:  DATA 33,2E
02008:  DATA 33,67
0200A:  DATA 0D,0A
0200C:  DATA 00,00
0200E:  DATA 40,43
02010:  DATA 4F,4E
02012:  DATA 2C,4E
02014:  DATA 4F,33
02016:  DATA 2C,25
02018:  DATA 73,0D
0201A:  DATA 0A,00
0201C:  DATA 28,6D
0201E:  DATA 29,2C
02020:  DATA 25,33
02022:  DATA 2E,33
02024:  DATA 67,2C
02026:  DATA 28,63
02028:  DATA 29,2C
0202A:  DATA 25,33
0202C:  DATA 2E,33
0202E:  DATA 67,00
02030:  DATA 28,43
02032:  DATA 73,29
02034:  DATA 2C,25
02036:  DATA 33,2E
02038:  DATA 33,67
0203A:  DATA 0D,0A
0203C:  DATA 00,00
0203E:  DATA 40,43
02040:  DATA 4F,4E
02042:  DATA 2C,50
02044:  DATA 4F,34
02046:  DATA 2C,25
02048:  DATA 73,0D
0204A:  DATA 0A,00
0204C:  DATA 28,6D
0204E:  DATA 29,2C
02050:  DATA 25,33
02052:  DATA 2E,33
02054:  DATA 67,2C
02056:  DATA 28,63
02058:  DATA 29,2C
0205A:  DATA 25,33
0205C:  DATA 2E,33
0205E:  DATA 67,00
02060:  DATA 28,43
02062:  DATA 73,29
02064:  DATA 2C,25
02066:  DATA 33,2E
02068:  DATA 33,67
0206A:  DATA 0D,0A
0206C:  DATA 00,00
0206E:  DATA 40,43
02070:  DATA 4F,4E
02072:  DATA 2C,4E
02074:  DATA 48,34
02076:  DATA 2C,25
02078:  DATA 73,0D
0207A:  DATA 0A,00
0207C:  DATA 28,6D
0207E:  DATA 29,2C
02080:  DATA 25,33
02082:  DATA 2E,33
02084:  DATA 67,2C
02086:  DATA 28,63
02088:  DATA 29,2C
0208A:  DATA 25,33
0208C:  DATA 2E,33
0208E:  DATA 67,00
02090:  DATA 28,43
02092:  DATA 73,29
02094:  DATA 2C,25
02096:  DATA 33,2E
02098:  DATA 33,67
0209A:  DATA 0D,0A
0209C:  DATA 00,00
0209E:  DATA 40,43
020A0:  DATA 4F,4E
020A2:  DATA 2C,53
020A4:  DATA 69,4F
020A6:  DATA 2C,25
020A8:  DATA 73,0D
020AA:  DATA 0A,00
020AC:  DATA 4E,4F
020AE:  DATA 33,00
020B0:  DATA 50,4F
020B2:  DATA 34,00
020B4:  DATA 4E,48
020B6:  DATA 34,00
020B8:  DATA 53,69
020BA:  DATA 4F,00
020BC:  DATA 00,00
020BE:  DATA 4D,45
020C0:  DATA 4D,4F
020C2:  DATA 52,59
020C4:  DATA 20,4F
020C6:  DATA 56,45
020C8:  DATA 52,46
020CA:  DATA 4C,4F
020CC:  DATA 57,20
020CE:  DATA 45,52
020D0:  DATA 52,4F
020D2:  DATA 52,20
020D4:  DATA 40,20
020D6:  DATA 4C,69
020D8:  DATA 6E,65
020DA:  DATA 20,3A
020DC:  DATA 25,4C
020DE:  DATA 75,0A
020E0:  DATA 0D,00
020E2:  DATA 0D,0A
020E4:  DATA 3A,00
020E6:  DATA 0D,0A
020E8:  DATA 57,41
020EA:  DATA 52,4E
020EC:  DATA 49,4E
020EE:  DATA 47,3A
020F0:  DATA 20,49
020F2:  DATA 4E,56
020F4:  DATA 41,4C
020F6:  DATA 49,44
020F8:  DATA 20,43
020FA:  DATA 4F,4D
020FC:  DATA 4D,41
020FE:  DATA 4E,44
02100:  DATA 20,49
02102:  DATA 4E,20
02104:  DATA 4D,41
02106:  DATA 43,52
02108:  DATA 4F,21
0210A:  DATA 0D,0A
0210C:  DATA 00,00
0210E:  DATA 42,61
02110:  DATA 64,20
02112:  DATA 63,6F
02114:  DATA 6D,6D
02116:  DATA 61,6E
02118:  DATA 64,20
0211A:  DATA 61,74
0211C:  DATA 20,6C
0211E:  DATA 69,6E
02120:  DATA 65,3A
02122:  DATA 20,25
02124:  DATA 4C,64
02126:  DATA 20,0D
02128:  DATA 0A,00
0212A:  DATA 50,6C
0212C:  DATA 65,61
0212E:  DATA 73,65
02130:  DATA 20,72
02132:  DATA 65,2D
02134:  DATA 75,70
02136:  DATA 6C,6F
02138:  DATA 61,64
0213A:  DATA 20,6D
0213C:  DATA 61,63
0213E:  DATA 72,6F
02140:  DATA 00,00
02142:  DATA 49,74
02144:  DATA 65,72
02146:  DATA 61,74
02148:  DATA 69,6F
0214A:  DATA 6E,73
0214C:  DATA 20,6C
0214E:  DATA 65,66
02150:  DATA 74,3A
02152:  DATA 20,25
02154:  DATA 4C,75
02156:  DATA 0D,0A
02158:  DATA 00,00
0215A:  DATA 2C,6D
0215C:  DATA 61,63
0215E:  DATA 72,6F
02160:  DATA 5B,25
02162:  DATA 75,5D
02164:  DATA 2C,73
02166:  DATA 74,61
02168:  DATA 72,74
0216A:  DATA 0D,0A
0216C:  DATA 00,00
0216E:  DATA 40,4D
02170:  DATA 43,4C
02172:  DATA 5B,25
02174:  DATA 63,5D
02176:  DATA 5B,25
02178:  DATA 4C,75
0217A:  DATA 5D,0D
0217C:  DATA 0A,00
0217E:  DATA 40,4C
02180:  DATA 4E,45
02182:  DATA 0D,0A
02184:  DATA 00,00
02186:  DATA 40,52
02188:  DATA 55,4E
0218A:  DATA 0D,0A
0218C:  DATA 00,00
0218E:  DATA 40,42
02190:  DATA 41,44
02192:  DATA 0D,0A
02194:  DATA 00,00
02196:  DATA 40,54
02198:  DATA 2F,4F
0219A:  DATA 0D,0A
0219C:  DATA 00,00
0219E:  DATA 40,45
021A0:  DATA 52,52
021A2:  DATA 0D,0A
021A4:  DATA 00,00
021A6:  DATA 40,45
021A8:  DATA 4E,44
021AA:  DATA 0D,0A
021AC:  DATA 00,00
021AE:  DATA 40,48
021B0:  DATA 4C,54
021B2:  DATA 0D,0A
021B4:  DATA 00,00
021B6:  DATA 2C,6D
021B8:  DATA 61,63
021BA:  DATA 72,6F
021BC:  DATA 5B,25
021BE:  DATA 75,5D
021C0:  DATA 2C,73
021C2:  DATA 74,61
021C4:  DATA 74,75
021C6:  DATA 73,5B
021C8:  DATA 25,63
021CA:  DATA 5D,2C
021CC:  DATA 6C,69
021CE:  DATA 6E,65
021D0:  DATA 5B,25
021D2:  DATA 4C,75
021D4:  DATA 5D,0D
021D6:  DATA 0A,00
021D8:  DATA 40,52
021DA:  DATA 75,6E
021DC:  DATA 6E,69
021DE:  DATA 6E,67
021E0:  DATA 20,25
021E2:  DATA 63,25
021E4:  DATA 4C,75
021E6:  DATA 20,0D
021E8:  DATA 0A,00
021EA:  DATA 40,4D
021EC:  DATA 61,63
021EE:  DATA 72,6F
021F0:  DATA 20,25
021F2:  DATA 30,34
021F4:  DATA 4C,75
021F6:  DATA 20,6F
021F8:  DATA 66,20
021FA:  DATA 25,30
021FC:  DATA 34,4C
021FE:  DATA 75,0D
02200:  DATA 0A,00
02202:  DATA 40,4C
02204:  DATA 4E,45
02206:  DATA 0D,0A
02208:  DATA 00,00
0220A:  DATA 40,52
0220C:  DATA 55,4E
0220E:  DATA 0D,0A
02210:  DATA 00,00
02212:  DATA 40,42
02214:  DATA 41,44
02216:  DATA 0D,0A
02218:  DATA 00,00
0221A:  DATA 40,54
0221C:  DATA 2F,4F
0221E:  DATA 0D,0A
02220:  DATA 00,00
02222:  DATA 40,45
02224:  DATA 52,52
02226:  DATA 0D,0A
02228:  DATA 00,00
0222A:  DATA 40,45
0222C:  DATA 4E,44
0222E:  DATA 0D,0A
02230:  DATA 00,00
02232:  DATA 2C,61
02234:  DATA 75,74
02236:  DATA 6F,2D
02238:  DATA 73,61
0223A:  DATA 6D,70
0223C:  DATA 6C,65
0223E:  DATA 2C,73
02240:  DATA 61,6D
02242:  DATA 70,6C
02244:  DATA 65,5B
02246:  DATA 25,4C
02248:  DATA 75,5D
0224A:  DATA 2C,73
0224C:  DATA 74,61
0224E:  DATA 72,74
02250:  DATA 0D,0A
02252:  DATA 00,00
02254:  DATA 2C,61
02256:  DATA 75,74
02258:  DATA 6F,2D
0225A:  DATA 73,61
0225C:  DATA 6D,70
0225E:  DATA 6C,65
02260:  DATA 2C,73
02262:  DATA 61,6D
02264:  DATA 70,6C
02266:  DATA 65,5B
02268:  DATA 25,4C
0226A:  DATA 75,5D
0226C:  DATA 2C,63
0226E:  DATA 6F,6D
02270:  DATA 70,6C
02272:  DATA 65,74
02274:  DATA 65,0D
02276:  DATA 0A,00
02278:  DATA 2C,61
0227A:  DATA 75,74
0227C:  DATA 6F,2D
0227E:  DATA 73,61
02280:  DATA 6D,70
02282:  DATA 6C,65
02284:  DATA 2C,73
02286:  DATA 61,6D
02288:  DATA 70,6C
0228A:  DATA 65,5B
0228C:  DATA 25,4C
0228E:  DATA 75,5D
02290:  DATA 2C,65
02292:  DATA 72,72
02294:  DATA 6F,72
02296:  DATA 0D,0A
02298:  DATA 00,00
0229A:  DATA 2C,61
0229C:  DATA 75,74
0229E:  DATA 6F,2D
022A0:  DATA 73,61
022A2:  DATA 6D,70
022A4:  DATA 6C,65
022A6:  DATA 2C,73
022A8:  DATA 61,6D
022AA:  DATA 70,6C
022AC:  DATA 65,5B
022AE:  DATA 25,4C
022B0:  DATA 75,5D
022B2:  DATA 2C,6D
022B4:  DATA 61,78
022B6:  DATA 20,73
022B8:  DATA 61,6D
022BA:  DATA 70,6C
022BC:  DATA 65,73
022BE:  DATA 0D,0A
022C0:  DATA 00,00
022C2:  DATA 2C,61
022C4:  DATA 75,74
022C6:  DATA 6F,2D
022C8:  DATA 73,61
022CA:  DATA 6D,70
022CC:  DATA 6C,65
022CE:  DATA 2C,73
022D0:  DATA 61,6D
022D2:  DATA 70,6C
022D4:  DATA 65,5B
022D6:  DATA 25,4C
022D8:  DATA 75,5D
022DA:  DATA 2C,73
022DC:  DATA 74,61
022DE:  DATA 72,74
022E0:  DATA 0D,0A
022E2:  DATA 00,00
022E4:  DATA 2C,61
022E6:  DATA 75,74
022E8:  DATA 6F,2D
022EA:  DATA 73,61
022EC:  DATA 6D,70
022EE:  DATA 6C,65
022F0:  DATA 2C,73
022F2:  DATA 61,6D
022F4:  DATA 70,6C
022F6:  DATA 65,5B
022F8:  DATA 25,4C
022FA:  DATA 75,5D
022FC:  DATA 2C,63
022FE:  DATA 6F,6D
02300:  DATA 70,6C
02302:  DATA 65,74
02304:  DATA 65,0D
02306:  DATA 0A,00
02308:  DATA 2C,61
0230A:  DATA 75,74
0230C:  DATA 6F,2D
0230E:  DATA 73,61
02310:  DATA 6D,70
02312:  DATA 6C,65
02314:  DATA 2C,73
02316:  DATA 61,6D
02318:  DATA 70,6C
0231A:  DATA 65,5B
0231C:  DATA 25,4C
0231E:  DATA 75,5D
02320:  DATA 2C,73
02322:  DATA 74,61
02324:  DATA 72,74
02326:  DATA 0D,0A
02328:  DATA 00,00
0232A:  DATA 2C,61
0232C:  DATA 75,74
0232E:  DATA 6F,2D
02330:  DATA 73,61
02332:  DATA 6D,70
02334:  DATA 6C,65
02336:  DATA 2C,73
02338:  DATA 61,6D
0233A:  DATA 70,6C
0233C:  DATA 65,5B
0233E:  DATA 25,4C
02340:  DATA 75,5D
02342:  DATA 2C,63
02344:  DATA 6F,6D
02346:  DATA 70,6C
02348:  DATA 65,74
0234A:  DATA 65,0D
0234C:  DATA 0A,00
0234E:  DATA 2C,61
02350:  DATA 75,74
02352:  DATA 6F,2D
02354:  DATA 73,61
02356:  DATA 6D,70
02358:  DATA 6C,65
0235A:  DATA 2C,73
0235C:  DATA 61,6D
0235E:  DATA 70,6C
02360:  DATA 65,5B
02362:  DATA 25,4C
02364:  DATA 75,5D
02366:  DATA 2C,6D
02368:  DATA 61,78
0236A:  DATA 20,73
0236C:  DATA 61,6D
0236E:  DATA 70,6C
02370:  DATA 65,73
02372:  DATA 0D,0A
02374:  DATA 00,00
02376:  DATA 2C,61
02378:  DATA 75,74
0237A:  DATA 6F,2D
0237C:  DATA 73,61
0237E:  DATA 6D,70
02380:  DATA 6C,65
02382:  DATA 2C,69
02384:  DATA 6E,69
02386:  DATA 74,69
02388:  DATA 61,6C
0238A:  DATA 69,7A
0238C:  DATA 65,0D
0238E:  DATA 0A,00
02390:  DATA 2C,68
02392:  DATA 65,61
02394:  DATA 64,65
02396:  DATA 72,2C
02398:  DATA 69,64
0239A:  DATA 23,5B
0239C:  DATA 25,4C
0239E:  DATA 75,5D
023A0:  DATA 2C,69
023A2:  DATA 6E,74
023A4:  DATA 5B,25
023A6:  DATA 4C,75
023A8:  DATA 5D,2C
023AA:  DATA 6D,61
023AC:  DATA 78,5B
023AE:  DATA 25,4C
023B0:  DATA 75,5D
023B2:  DATA 0D,0A
023B4:  DATA 00,00
023B6:  DATA 2C,61
023B8:  DATA 75,74
023BA:  DATA 6F,2D
023BC:  DATA 73,61
023BE:  DATA 6D,70
023C0:  DATA 6C,65
023C2:  DATA 2C,73
023C4:  DATA 61,6D
023C6:  DATA 70,6C
023C8:  DATA 65,5B
023CA:  DATA 25,4C
023CC:  DATA 75,5D
023CE:  DATA 2C,61
023D0:  DATA 6C,61
023D2:  DATA 72,6D
023D4:  DATA 5B,25
023D6:  DATA 75,5D
023D8:  DATA 0D,0A
023DA:  DATA 00,00
023DC:  DATA 2C,61
023DE:  DATA 75,74
023E0:  DATA 6F,2D
023E2:  DATA 73,61
023E4:  DATA 6D,70
023E6:  DATA 6C,65
023E8:  DATA 2C,73
023EA:  DATA 6C,65
023EC:  DATA 65,70
023EE:  DATA 0D,0A
023F0:  DATA 00,00
023F2:  DATA 74,31
023F4:  DATA 3A,25
023F6:  DATA 4C,75
023F8:  DATA 20,74
023FA:  DATA 32,3A
023FC:  DATA 25,4C
023FE:  DATA 75,0D
02400:  DATA 0A,00
02402:  DATA 40,44
02404:  DATA 45,54
02406:  DATA 2C,25
02408:  DATA 4C,75
0240A:  DATA 0D,0A
0240C:  DATA 00,00
0240E:  DATA 4E,4F
02410:  DATA 33,2C
02412:  DATA 25,31
02414:  DATA 2E,35
02416:  DATA 67,2C
02418:  DATA 25,31
0241A:  DATA 2E,35
0241C:  DATA 67,0D
0241E:  DATA 0A,00
02420:  DATA 50,4F
02422:  DATA 34,2C
02424:  DATA 25,31
02426:  DATA 2E,35
02428:  DATA 67,2C
0242A:  DATA 25,31
0242C:  DATA 2E,35
0242E:  DATA 67,0D
02430:  DATA 0A,00
02432:  DATA 4E,48
02434:  DATA 34,2C
02436:  DATA 25,31
02438:  DATA 2E,35
0243A:  DATA 67,2C
0243C:  DATA 25,31
0243E:  DATA 2E,35
02440:  DATA 67,0D
02442:  DATA 0A,00
02444:  DATA 53,69
02446:  DATA 4F,34
02448:  DATA 2C,25
0244A:  DATA 31,2E
0244C:  DATA 35,67
0244E:  DATA 2C,25
02450:  DATA 31,2E
02452:  DATA 35,67
02454:  DATA 0D,0A
02456:  DATA 00,00
02458:  DATA 4E,4F
0245A:  DATA 33,28
0245C:  DATA 6D,29
0245E:  DATA 3A,00
02460:  DATA 4E,4F
02462:  DATA 33,28
02464:  DATA 63,29
02466:  DATA 3A,00
02468:  DATA 50,4F
0246A:  DATA 34,28
0246C:  DATA 6D,29
0246E:  DATA 3A,00
02470:  DATA 50,4F
02472:  DATA 34,28
02474:  DATA 63,29
02476:  DATA 3A,00
02478:  DATA 4E,48
0247A:  DATA 34,28
0247C:  DATA 6D,29
0247E:  DATA 3A,00
02480:  DATA 4E,48
02482:  DATA 34,28
02484:  DATA 63,29
02486:  DATA 3A,00
02488:  DATA 53,69
0248A:  DATA 4F,34
0248C:  DATA 28,6D
0248E:  DATA 29,3A
02490:  DATA 00,00
02492:  DATA 53,69
02494:  DATA 4F,34
02496:  DATA 28,63
02498:  DATA 29,3A
0249A:  DATA 00,00
0249C:  DATA 41,72
0249E:  DATA 65,20
024A0:  DATA 79,6F
024A2:  DATA 75,20
024A4:  DATA 73,75
024A6:  DATA 72,65
024A8:  DATA 20,79
024AA:  DATA 6F,75
024AC:  DATA 20,77
024AE:  DATA 61,6E
024B0:  DATA 74,20
024B2:  DATA 74,6F
024B4:  DATA 20,65
024B6:  DATA 72,61
024B8:  DATA 73,65
024BA:  DATA 20,74
024BC:  DATA 68,65
024BE:  DATA 20,72
024C0:  DATA 61,77
024C2:  DATA 20,64
024C4:  DATA 61,74
024C6:  DATA 61,20
024C8:  DATA 66,69
024CA:  DATA 6C,65
024CC:  DATA 3F,20
024CE:  DATA 59,20
024D0:  DATA 6F,72
024D2:  DATA 20,4E
024D4:  DATA 21,0D
024D6:  DATA 0A,00
024D8:  DATA 46,69
024DA:  DATA 6C,65
024DC:  DATA 20,64
024DE:  DATA 65,6C
024E0:  DATA 65,74
024E2:  DATA 65,64
024E4:  DATA 21,0A
024E6:  DATA 0D,00
024E8:  DATA 4F,70
024EA:  DATA 65,72
024EC:  DATA 61,74
024EE:  DATA 69,6F
024F0:  DATA 6E,20
024F2:  DATA 63,61
024F4:  DATA 6E,63
024F6:  DATA 65,6C
024F8:  DATA 65,64
024FA:  DATA 21,0D
024FC:  DATA 0A,00
024FE:  DATA 41,72
02500:  DATA 65,20
02502:  DATA 79,6F
02504:  DATA 75,20
02506:  DATA 73,75
02508:  DATA 72,65
0250A:  DATA 20,79
0250C:  DATA 6F,75
0250E:  DATA 20,77
02510:  DATA 61,6E
02512:  DATA 74,20
02514:  DATA 74,6F
02516:  DATA 20,65
02518:  DATA 72,61
0251A:  DATA 73,65
0251C:  DATA 20,74
0251E:  DATA 68,65
02520:  DATA 20,63
02522:  DATA 61,6C
02524:  DATA 63,75
02526:  DATA 6C,61
02528:  DATA 74,65
0252A:  DATA 64,20
0252C:  DATA 64,61
0252E:  DATA 74,61
02530:  DATA 20,66
02532:  DATA 69,6C
02534:  DATA 65,3F
02536:  DATA 20,59
02538:  DATA 20,6F
0253A:  DATA 72,20
0253C:  DATA 4E,21
0253E:  DATA 0D,0A
02540:  DATA 00,00
02542:  DATA 46,69
02544:  DATA 6C,65
02546:  DATA 20,64
02548:  DATA 65,6C
0254A:  DATA 65,74
0254C:  DATA 65,64
0254E:  DATA 21,0A
02550:  DATA 0D,00
02552:  DATA 4F,70
02554:  DATA 65,72
02556:  DATA 61,74
02558:  DATA 69,6F
0255A:  DATA 6E,20
0255C:  DATA 63,61
0255E:  DATA 6E,63
02560:  DATA 65,6C
02562:  DATA 65,64
02564:  DATA 21,0D
02566:  DATA 0A,00
02568:  DATA 40,49
0256A:  DATA 44,23
0256C:  DATA 25,4C
0256E:  DATA 75,20
02570:  DATA 49,25
02572:  DATA 4C,75
02574:  DATA 20,4E
02576:  DATA 25,4C
02578:  DATA 75,2F
0257A:  DATA 25,4C
0257C:  DATA 75,20
0257E:  DATA 58,25
02580:  DATA 4C,75
02582:  DATA 20,55
02584:  DATA 25,75
02586:  DATA 20,25
02588:  DATA 34,2E
0258A:  DATA 32,77
0258C:  DATA 56,0D
0258E:  DATA 0A,00
02590:  DATA 40,4D
02592:  DATA 4F,54
02594:  DATA 3A,56
02596:  DATA 41,4C
02598:  DATA 3D,25
0259A:  DATA 4C,75
0259C:  DATA 20,53
0259E:  DATA 59,52
025A0:  DATA 3D,25
025A2:  DATA 4C,64
025A4:  DATA 0D,0A
025A6:  DATA 00,00
025A8:  DATA 40,50
025AA:  DATA 57,52
025AC:  DATA 3A,25
025AE:  DATA 30,32
025B0:  DATA 75,2F
025B2:  DATA 25,30
025B4:  DATA 32,75
025B6:  DATA 2F,25
025B8:  DATA 30,32
025BA:  DATA 75,20
025BC:  DATA 25,30
025BE:  DATA 32,75
025C0:  DATA 3A,25
025C2:  DATA 30,32
025C4:  DATA 75,3A
025C6:  DATA 25,30
025C8:  DATA 32,75
025CA:  DATA 0D,0A
025CC:  DATA 00,00
025CE:  DATA 40,50
025D0:  DATA 57,52
025D2:  DATA 3A,25
025D4:  DATA 30,32
025D6:  DATA 75,2F
025D8:  DATA 25,30
025DA:  DATA 32,75
025DC:  DATA 2F,25
025DE:  DATA 30,32
025E0:  DATA 75,20
025E2:  DATA 25,30
025E4:  DATA 32,75
025E6:  DATA 3A,25
025E8:  DATA 30,32
025EA:  DATA 75,3A
025EC:  DATA 25,30
025EE:  DATA 32,75
025F0:  DATA 0D,0A
025F2:  DATA 00,00
025F4:  DATA 41,25
025F6:  DATA 4C,75
025F8:  DATA 20,49
025FA:  DATA 25,4C
025FC:  DATA 75,20
025FE:  DATA 4C,25
02600:  DATA 4C,75
02602:  DATA 20,51
02604:  DATA 25,4C
02606:  DATA 75,20
02608:  DATA 53,25
0260A:  DATA 4C,75
0260C:  DATA 20,25
0260E:  DATA 34,2E
02610:  DATA 32,77
02612:  DATA 56,0D
02614:  DATA 0A,00
02616:  DATA 40,4D
02618:  DATA 4F,54
0261A:  DATA 3A,56
0261C:  DATA 41,4C
0261E:  DATA 3D,25
02620:  DATA 4C,75
02622:  DATA 20,53
02624:  DATA 59,52
02626:  DATA 3D,25
02628:  DATA 4C,64
0262A:  DATA 0D,0A
0262C:  DATA 00,00
0262E:  DATA 40,50
02630:  DATA 57,52
02632:  DATA 3A,25
02634:  DATA 30,32
02636:  DATA 75,2F
02638:  DATA 25,30
0263A:  DATA 32,75
0263C:  DATA 2F,25
0263E:  DATA 30,32
02640:  DATA 75,20
02642:  DATA 25,30
02644:  DATA 32,75
02646:  DATA 3A,25
02648:  DATA 30,32
0264A:  DATA 75,3A
0264C:  DATA 25,30
0264E:  DATA 32,75
02650:  DATA 0D,0A
02652:  DATA 00,00
02654:  DATA 49,25
02656:  DATA 4C,75
02658:  DATA 20,4E
0265A:  DATA 25,4C
0265C:  DATA 75,2F
0265E:  DATA 25,4C
02660:  DATA 75,20
02662:  DATA 50,25
02664:  DATA 4C,75
02666:  DATA 20,25
02668:  DATA 34,2E
0266A:  DATA 32,77
0266C:  DATA 56,0D
0266E:  DATA 0A,00
02670:  DATA 40,4D
02672:  DATA 4F,54
02674:  DATA 3A,53
02676:  DATA 59,52
02678:  DATA 3D,25
0267A:  DATA 4C,64
0267C:  DATA 0D,0A
0267E:  DATA 00,00
02680:  DATA 40,50
02682:  DATA 57,52
02684:  DATA 3A,25
02686:  DATA 30,32
02688:  DATA 75,2F
0268A:  DATA 25,30
0268C:  DATA 32,75
0268E:  DATA 2F,25
02690:  DATA 30,32
02692:  DATA 75,20
02694:  DATA 25,30
02696:  DATA 32,75
02698:  DATA 3A,25
0269A:  DATA 30,32
0269C:  DATA 75,3A
0269E:  DATA 25,30
026A0:  DATA 32,75
026A2:  DATA 0D,0A
026A4:  DATA 00,00
026A6:  DATA 40,53
026A8:  DATA 4D,50
026AA:  DATA 20,25
026AC:  DATA 30,34
026AE:  DATA 4C,75
026B0:  DATA 0D,0A
026B2:  DATA 00,00
026B4:  DATA 40,53
026B6:  DATA 4D,50
026B8:  DATA 20,25
026BA:  DATA 30,34
026BC:  DATA 4C,75
026BE:  DATA 0D,0A
026C0:  DATA 00,00
026C2:  DATA 45,6E
026C4:  DATA 74,65
026C6:  DATA 72,20
026C8:  DATA 64,61
026CA:  DATA 74,65
026CC:  DATA 20,66
026CE:  DATA 6F,72
026D0:  DATA 6D,61
026D2:  DATA 74,20
026D4:  DATA 30,3D
026D6:  DATA 4D,4D
026D8:  DATA 2F,44
026DA:  DATA 44,2F
026DC:  DATA 59,59
026DE:  DATA 20,20
026E0:  DATA 31,3D
026E2:  DATA 44,44
026E4:  DATA 2F,4D
026E6:  DATA 4D,2F
026E8:  DATA 59,59
026EA:  DATA 0D,0A
026EC:  DATA 00,00
026EE:  DATA 40,4F
026F0:  DATA 4B,21
026F2:  DATA 0D,0A
026F4:  DATA 20,00
026F6:  DATA 40,45
026F8:  DATA 52,52
026FA:  DATA 0D,0A
026FC:  DATA 00,00
026FE:  DATA 40,52
02700:  DATA 55,4E
02702:  DATA 0D,0A
02704:  DATA 00,00
02706:  DATA 5B,6D
02708:  DATA 6F,74
0270A:  DATA 6F,72
0270C:  DATA 3A,31
0270E:  DATA 5D,0D
02710:  DATA 0A,00
02712:  DATA 5B,6D
02714:  DATA 6F,74
02716:  DATA 6F,72
02718:  DATA 3A,32
0271A:  DATA 5D,0D
0271C:  DATA 0A,00
0271E:  DATA 2C,45
02720:  DATA 43,4F
02722:  DATA 20,6D
02724:  DATA 6F,64
02726:  DATA 65,20
02728:  DATA 73,65
0272A:  DATA 74,0D
0272C:  DATA 0A,00
0272E:  DATA 2C,57
02730:  DATA 4D,53
02732:  DATA 2D,34
02734:  DATA 2D,53
02736:  DATA 44,20
02738:  DATA 6D,6F
0273A:  DATA 64,65
0273C:  DATA 20,73
0273E:  DATA 65,74
02740:  DATA 0D,0A
02742:  DATA 00,00
02744:  DATA 2C,41
02746:  DATA 57,53
02748:  DATA 20,6D
0274A:  DATA 6F,64
0274C:  DATA 65,20
0274E:  DATA 73,65
02750:  DATA 74,0D
02752:  DATA 0A,00
02754:  DATA 2C,57
02756:  DATA 4D,53
02758:  DATA 2D,34
0275A:  DATA 2D,51
0275C:  DATA 45,20
0275E:  DATA 6D,6F
02760:  DATA 64,65
02762:  DATA 20,73
02764:  DATA 65,74
02766:  DATA 0D,0A
02768:  DATA 00,00
0276A:  DATA 30,33
0276C:  DATA 2D,4A
0276E:  DATA 75,6C
02770:  DATA 2D,31
02772:  DATA 37,00
02774:  DATA 31,34
02776:  DATA 3A,31
02778:  DATA 36,3A
0277A:  DATA 33,39
0277C:  DATA 00,00
0277E:  DATA 53,45
02780:  DATA 4E,44
02782:  DATA 20,48
02784:  DATA 45,58
02786:  DATA 20,46
02788:  DATA 49,4C
0278A:  DATA 45,20
0278C:  DATA 28,31
0278E:  DATA 39,32
02790:  DATA 30,30
02792:  DATA 2C,4E
02794:  DATA 38,31
02796:  DATA 2C,58
02798:  DATA 4F,4E
0279A:  DATA 2D,58
0279C:  DATA 4F,46
0279E:  DATA 46,29
027A0:  DATA 0D,0A
027A2:  DATA 00,00
027A4:  DATA 40,4F
027A6:  DATA 4B,21
027A8:  DATA 20,00
027AA:  DATA 40,41
027AC:  DATA 52,47
027AE:  DATA 20,00
027B0:  DATA 40,49
027B2:  DATA 4E,56
027B4:  DATA 00,00
027B6:  DATA 40,43
027B8:  DATA 4D,44
027BA:  DATA 00,00
027BC:  DATA 2C,63
027BE:  DATA 6F,6D
027C0:  DATA 6D,61
027C2:  DATA 6E,64
027C4:  DATA 20,70
027C6:  DATA 72,6F
027C8:  DATA 6D,70
027CA:  DATA 74,0D
027CC:  DATA 0A,00
027CE:  DATA 40,53
027D0:  DATA 44,3D
027D2:  DATA 25,4C
027D4:  DATA 75,0D
027D6:  DATA 0A,00
027D8:  DATA 40,4D
027DA:  DATA 43,31
027DC:  DATA 2C,25
027DE:  DATA 4C,75
027E0:  DATA 2C,25
027E2:  DATA 4C,64
027E4:  DATA 0D,0A
027E6:  DATA 00,00
027E8:  DATA 40,4D
027EA:  DATA 43,32
027EC:  DATA 2C,25
027EE:  DATA 4C,75
027F0:  DATA 2C,25
027F2:  DATA 4C,64
027F4:  DATA 0D,0A
027F6:  DATA 00,00
027F8:  DATA 50,72
027FA:  DATA 65,73
027FC:  DATA 73,20
027FE:  DATA 61,6E
02800:  DATA 64,20
02802:  DATA 68,6F
02804:  DATA 6C,64
02806:  DATA 20,74
02808:  DATA 68,65
0280A:  DATA 20,45
0280C:  DATA 73,63
0280E:  DATA 20,6B
02810:  DATA 65,79
02812:  DATA 20,74
02814:  DATA 6F,20
02816:  DATA 72,65
02818:  DATA 74,75
0281A:  DATA 72,6E
0281C:  DATA 20,74
0281E:  DATA 6F,20
02820:  DATA 43,6F
02822:  DATA 6D,6D
02824:  DATA 61,6E
02826:  DATA 64,20
02828:  DATA 4D,6F
0282A:  DATA 64,65
0282C:  DATA 0D,0A
0282E:  DATA 00,00
02830:  DATA 52,65
02832:  DATA 74,75
02834:  DATA 72,6E
02836:  DATA 69,6E
02838:  DATA 67,20
0283A:  DATA 74,6F
0283C:  DATA 20,4C
0283E:  DATA 6F,67
02840:  DATA 67,69
02842:  DATA 6E,67
02844:  DATA 20,4D
02846:  DATA 6F,64
02848:  DATA 65,0D
0284A:  DATA 0A,00
0284C:  DATA 63,72
0284E:  DATA 61,70
02850:  DATA 3A,20
02852:  DATA 25,75
02854:  DATA 0D,0A
02856:  DATA 00,00
02858:  DATA 72,65
0285A:  DATA 67,30
0285C:  DATA 3A,20
0285E:  DATA 25,75
02860:  DATA 0D,0A
02862:  DATA 00,00
02864:  DATA 72,65
02866:  DATA 67,31
02868:  DATA 3A,20
0286A:  DATA 25,75
0286C:  DATA 0D,0A
0286E:  DATA 00,00
02870:  DATA 72,65
02872:  DATA 67,32
02874:  DATA 3A,20
02876:  DATA 25,75
02878:  DATA 0D,0A
0287A:  DATA 00,00
0287C:  DATA 72,65
0287E:  DATA 67,33
02880:  DATA 3A,20
02882:  DATA 25,75
02884:  DATA 0D,0A
02886:  DATA 00,00
02888:  DATA 72,65
0288A:  DATA 67,34
0288C:  DATA 3A,20
0288E:  DATA 25,75
02890:  DATA 0D,0A
02892:  DATA 00,00
02894:  DATA 72,65
02896:  DATA 67,35
02898:  DATA 3A,20
0289A:  DATA 25,75
0289C:  DATA 0D,0A
0289E:  DATA 00,00
028A0:  DATA 72,65
028A2:  DATA 67,36
028A4:  DATA 3A,20
028A6:  DATA 25,75
028A8:  DATA 0D,0A
028AA:  DATA 00,00
028AC:  DATA 72,65
028AE:  DATA 67,37
028B0:  DATA 3A,20
028B2:  DATA 25,75
028B4:  DATA 0D,0A
028B6:  DATA 00,00
028B8:  DATA 72,65
028BA:  DATA 67,38
028BC:  DATA 3A,20
028BE:  DATA 25,75
028C0:  DATA 0D,0A
028C2:  DATA 00,00
028C4:  DATA 72,65
028C6:  DATA 67,39
028C8:  DATA 3A,20
028CA:  DATA 25,75
028CC:  DATA 0D,0A
028CE:  DATA 00,00
028D0:  DATA 72,65
028D2:  DATA 67,41
028D4:  DATA 3A,20
028D6:  DATA 25,75
028D8:  DATA 0D,0A
028DA:  DATA 00,00
028DC:  DATA 72,65
028DE:  DATA 67,42
028E0:  DATA 3A,20
028E2:  DATA 25,75
028E4:  DATA 0D,0A
028E6:  DATA 00,00
028E8:  DATA 72,65
028EA:  DATA 67,43
028EC:  DATA 3A,20
028EE:  DATA 25,75
028F0:  DATA 0D,0A
028F2:  DATA 00,00
028F4:  DATA 72,65
028F6:  DATA 67,44
028F8:  DATA 3A,20
028FA:  DATA 25,75
028FC:  DATA 0D,0A
028FE:  DATA 00,00
02900:  DATA 72,65
02902:  DATA 67,45
02904:  DATA 3A,20
02906:  DATA 25,75
02908:  DATA 0D,0A
0290A:  DATA 00,00
0290C:  DATA 72,65
0290E:  DATA 67,46
02910:  DATA 3A,20
02912:  DATA 25,75
02914:  DATA 0D,0A
02916:  DATA 00,00
*
02D28:  CLRF   01
02D2A:  CLRF   02
02D2C:  CLRF   00
02D2E:  CLRF   03
02D30:  MOVLB  8
02D32:  MOVF   xC8,W
02D34:  BNZ   2D3A
02D36:  MOVF   xC7,W
02D38:  BZ    2D6A
02D3A:  MOVLW  10
02D3C:  MOVWF  xC9
02D3E:  BCF    FD8.0
02D40:  RLCF   xC5,F
02D42:  RLCF   xC6,F
02D44:  RLCF   00,F
02D46:  RLCF   03,F
02D48:  MOVF   xC8,W
02D4A:  SUBWF  03,W
02D4C:  BNZ   2D52
02D4E:  MOVF   xC7,W
02D50:  SUBWF  00,W
02D52:  BNC   2D62
02D54:  MOVF   xC7,W
02D56:  SUBWF  00,F
02D58:  BTFSS  FD8.0
02D5A:  DECF   03,F
02D5C:  MOVF   xC8,W
02D5E:  SUBWF  03,F
02D60:  BSF    FD8.0
02D62:  RLCF   01,F
02D64:  RLCF   02,F
02D66:  DECFSZ xC9,F
02D68:  BRA    2D3E
02D6A:  MOVLB  0
02D6C:  RETURN 0
*
0357A:  TSTFSZ 01
0357C:  BRA    3584
0357E:  TSTFSZ 02
03580:  BRA    3586
03582:  BRA    3592
03584:  INCF   02,F
03586:  MOVFF  00,FEE
0358A:  DECFSZ 01,F
0358C:  BRA    3586
0358E:  DECFSZ 02,F
03590:  BRA    3586
03592:  RETURN 0
*
03664:  MOVLB  9
03666:  BTFSC  xD7.7
03668:  BRA    368A
0366A:  MOVLW  0F
0366C:  MOVWF  00
0366E:  SWAPF  xD6,W
03670:  ANDWF  00,F
03672:  MOVLW  0A
03674:  SUBWF  00,W
03676:  BC    367E
03678:  MOVLW  30
0367A:  ADDWF  00,F
0367C:  BRA    3682
0367E:  MOVF   xD7,W
03680:  ADDWF  00,F
03682:  MOVF   00,W
03684:  BTFSS  F9E.4
03686:  BRA    3684
03688:  MOVWF  FAD
0368A:  MOVLW  0F
0368C:  ANDWF  xD6,F
0368E:  MOVLW  0A
03690:  SUBWF  xD6,W
03692:  BC    3698
03694:  MOVLW  30
03696:  BRA    369C
03698:  BCF    xD7.7
0369A:  MOVF   xD7,W
0369C:  ADDWF  xD6,F
0369E:  MOVF   xD6,W
036A0:  BTFSS  F9E.4
036A2:  BRA    36A0
036A4:  MOVWF  FAD
036A6:  MOVLB  0
036A8:  RETURN 0
*
04844:  MOVLB  9
04846:  CLRF   xE8
04848:  CLRF   xE9
0484A:  MOVLW  01
0484C:  MOVWF  xEA
0484E:  CLRF   FDA
04850:  CLRF   FD9
04852:  MOVLW  09
04854:  MOVWF  xED
04856:  MOVLW  E0
04858:  MOVWF  xEC
0485A:  MOVLW  09
0485C:  MOVWF  FEA
0485E:  MOVLW  E4
04860:  MOVWF  FE9
04862:  MOVFF  9ED,FE2
04866:  MOVFF  9EC,FE1
0486A:  MOVFF  9EA,9EB
0486E:  BCF    FD8.0
04870:  MOVF   FE5,W
04872:  MULWF  FEE
04874:  MOVF   FF3,W
04876:  ADDWFC xE8,F
04878:  MOVF   FF4,W
0487A:  ADDWFC xE9,F
0487C:  DECFSZ xEB,F
0487E:  BRA    486E
04880:  MOVFF  9E8,FDE
04884:  MOVFF  9E9,9E8
04888:  CLRF   xE9
0488A:  BTFSC  FD8.0
0488C:  INCF   xE9,F
0488E:  INCF   xEC,F
04890:  BTFSC  FD8.2
04892:  INCF   xED,F
04894:  INCF   xEA,F
04896:  MOVF   xEA,W
04898:  SUBLW  05
0489A:  BNZ   485A
0489C:  MOVLB  0
0489E:  RETURN 0
*
050E8:  MOVFF  1E,FEA
050EC:  MOVFF  1D,FE9
050F0:  MOVLB  8
050F2:  MOVFF  8E9,FEF
050F6:  INCF   FE9,F
050F8:  BTFSC  FD8.2
050FA:  INCF   FEA,F
050FC:  CLRF   FEF
050FE:  INCF   1D,F
05100:  BTFSC  FD8.2
05102:  INCF   1E,F
05104:  MOVLB  0
05106:  RETURN 0
05108:  TBLRD*+
0510A:  MOVF   FF5,F
0510C:  BZ    512E
0510E:  MOVFF  FF6,8D5
05112:  MOVFF  FF7,8D6
05116:  MOVFF  FF8,8D7
0511A:  MOVFF  FF5,8E9
0511E:  RCALL  50E8
05120:  MOVFF  8D5,FF6
05124:  MOVFF  8D6,FF7
05128:  MOVFF  8D7,FF8
0512C:  BRA    5108
0512E:  RETURN 0
*
052CA:  MOVF   01,W
052CC:  CLRF   1B
052CE:  BTFSC  FF2.7
052D0:  BSF    1B.7
052D2:  BCF    FF2.7
052D4:  MOVFF  8D7,A27
052D8:  MOVLW  64
052DA:  MOVLB  A
052DC:  MOVWF  x28
052DE:  MOVLB  0
052E0:  CALL   0F66
052E4:  BTFSC  1B.7
052E6:  BSF    FF2.7
052E8:  MOVFF  00,8D7
052EC:  MOVF   01,W
052EE:  MOVLW  30
052F0:  BNZ   5302
052F2:  MOVLB  8
052F4:  BTFSS  xD8.1
052F6:  BRA    5316
052F8:  BTFSC  xD8.3
052FA:  BRA    5316
052FC:  BTFSC  xD8.4
052FE:  MOVLW  20
05300:  BRA    530A
05302:  MOVLB  8
05304:  BCF    xD8.3
05306:  BCF    xD8.4
05308:  BSF    xD8.0
0530A:  ADDWF  01,F
0530C:  MOVFF  01,8E9
05310:  MOVLB  0
05312:  RCALL  50E8
05314:  MOVLB  8
05316:  CLRF   1B
05318:  BTFSC  FF2.7
0531A:  BSF    1B.7
0531C:  BCF    FF2.7
0531E:  MOVFF  8D7,A27
05322:  MOVLW  0A
05324:  MOVLB  A
05326:  MOVWF  x28
05328:  MOVLB  0
0532A:  CALL   0F66
0532E:  BTFSC  1B.7
05330:  BSF    FF2.7
05332:  MOVFF  00,8D7
05336:  MOVF   01,W
05338:  MOVLW  30
0533A:  BNZ   534C
0533C:  MOVLB  8
0533E:  BTFSC  xD8.3
05340:  BRA    5356
05342:  BTFSS  xD8.0
05344:  BRA    5356
05346:  BTFSC  xD8.4
05348:  MOVLW  20
0534A:  MOVLB  0
0534C:  ADDWF  01,F
0534E:  MOVFF  01,8E9
05352:  RCALL  50E8
05354:  MOVLB  8
05356:  MOVLW  30
05358:  ADDWF  xD7,F
0535A:  MOVFF  8D7,8E9
0535E:  MOVLB  0
05360:  RCALL  50E8
05362:  RETURN 0
05364:  MOVF   FE9,W
05366:  MOVLB  8
05368:  MOVWF  xDC
0536A:  MOVLW  3B
0536C:  MOVWF  xE3
0536E:  MOVLW  9A
05370:  MOVWF  xE2
05372:  MOVLW  CA
05374:  MOVWF  xE1
05376:  CLRF   xE0
05378:  MOVLW  0A
0537A:  MOVWF  xDE
0537C:  MOVF   xDB,W
0537E:  BTFSS  FD8.2
05380:  DECF   xDC,F
05382:  BSF    FD8.1
05384:  MOVLW  08
05386:  MOVWF  FEA
05388:  MOVLW  D7
0538A:  MOVWF  FE9
0538C:  CLRF   1B
0538E:  BTFSC  FF2.7
05390:  BSF    1B.7
05392:  BCF    FF2.7
05394:  MOVFF  8DA,A34
05398:  MOVFF  8D9,A33
0539C:  MOVFF  8D8,A32
053A0:  MOVFF  8D7,A31
053A4:  MOVFF  8E3,A38
053A8:  MOVFF  8E2,A37
053AC:  MOVFF  8E1,A36
053B0:  MOVFF  8E0,A35
053B4:  MOVLB  0
053B6:  CALL   1042
053BA:  BTFSC  1B.7
053BC:  BSF    FF2.7
053BE:  MOVF   01,W
053C0:  MOVF   00,F
053C2:  BNZ   53EA
053C4:  MOVLB  8
053C6:  INCF   xDB,W
053C8:  SUBWF  xDE,W
053CA:  BTFSS  FD8.2
053CC:  BRA    53D2
053CE:  MOVLB  0
053D0:  BRA    53EA
053D2:  MOVF   xDC,W
053D4:  BZ    53EE
053D6:  ANDLW  0F
053D8:  SUBWF  xDE,W
053DA:  BZ    53DE
053DC:  BC    541A
053DE:  BTFSC  xDC.7
053E0:  BRA    541A
053E2:  BTFSC  xDC.6
053E4:  BRA    53EE
053E6:  MOVLW  20
053E8:  BRA    540E
053EA:  MOVLB  8
053EC:  CLRF   xDC
053EE:  MOVF   xDB,W
053F0:  SUBWF  xDE,W
053F2:  BNZ   540C
053F4:  MOVFF  00,8DC
053F8:  MOVLW  2E
053FA:  MOVWF  xE9
053FC:  MOVLB  0
053FE:  RCALL  50E8
05400:  MOVLB  8
05402:  MOVFF  8DC,00
05406:  MOVLW  20
05408:  ANDWF  xDC,F
0540A:  MOVLW  00
0540C:  MOVLW  30
0540E:  ADDWF  00,F
05410:  MOVFF  00,8E9
05414:  MOVLB  0
05416:  RCALL  50E8
05418:  MOVLB  8
0541A:  BCF    FD8.1
0541C:  CLRF   1B
0541E:  BTFSC  FF2.7
05420:  BSF    1B.7
05422:  BCF    FF2.7
05424:  MOVFF  8E3,A34
05428:  MOVFF  8E2,A33
0542C:  MOVFF  8E1,A32
05430:  MOVFF  8E0,A31
05434:  MOVLB  A
05436:  CLRF   x38
05438:  CLRF   x37
0543A:  CLRF   x36
0543C:  MOVLW  0A
0543E:  MOVWF  x35
05440:  MOVLB  0
05442:  CALL   1042
05446:  BTFSC  1B.7
05448:  BSF    FF2.7
0544A:  MOVFF  03,8E3
0544E:  MOVFF  02,8E2
05452:  MOVFF  01,8E1
05456:  MOVFF  00,8E0
0545A:  MOVLB  8
0545C:  DECFSZ xDE,F
0545E:  BRA    5382
05460:  MOVLB  0
05462:  RETURN 0
*
05D06:  MOVLB  9
05D08:  MOVF   xF6,W
05D0A:  MULWF  xF8
05D0C:  MOVFF  FF3,01
05D10:  MOVFF  FF4,00
05D14:  MULWF  xF9
05D16:  MOVF   FF3,W
05D18:  ADDWF  00,F
05D1A:  MOVF   xF7,W
05D1C:  MULWF  xF8
05D1E:  MOVF   FF3,W
05D20:  ADDWFC 00,W
05D22:  MOVWF  02
05D24:  MOVLB  0
05D26:  RETURN 0
*
079CE:  MOVF   FEF,F
079D0:  BZ    79F2
079D2:  MOVFF  FEA,99B
079D6:  MOVFF  FE9,99A
079DA:  MOVF   FEF,W
079DC:  BTFSS  F9E.4
079DE:  BRA    79DC
079E0:  MOVWF  FAD
079E2:  MOVFF  99B,FEA
079E6:  MOVFF  99A,FE9
079EA:  INCF   FE9,F
079EC:  BTFSC  FD8.2
079EE:  INCF   FEA,F
079F0:  BRA    79CE
079F2:  RETURN 0
*
09016:  MOVFF  FEA,8E2
0901A:  MOVFF  FE9,8E1
0901E:  MOVLB  8
09020:  BTFSS  xDB.7
09022:  BRA    9034
09024:  BSF    xE1.7
09026:  BTFSS  xE1.4
09028:  INCF   xE1,F
0902A:  COMF   xDA,F
0902C:  COMF   xDB,F
0902E:  INCF   xDA,F
09030:  BTFSC  FD8.2
09032:  INCF   xDB,F
09034:  SWAPF  xDB,W
09036:  IORLW  F0
09038:  MOVWF  xDD
0903A:  ADDWF  xDD,F
0903C:  ADDLW  E2
0903E:  MOVWF  xDE
09040:  ADDLW  32
09042:  MOVWF  xE0
09044:  MOVF   xDB,W
09046:  ANDLW  0F
09048:  ADDWF  xDE,F
0904A:  ADDWF  xDE,F
0904C:  ADDWF  xE0,F
0904E:  ADDLW  E9
09050:  MOVWF  xDF
09052:  ADDWF  xDF,F
09054:  ADDWF  xDF,F
09056:  SWAPF  xDA,W
09058:  ANDLW  0F
0905A:  ADDWF  xDF,F
0905C:  ADDWF  xE0,F
0905E:  RLCF   xDF,F
09060:  RLCF   xE0,F
09062:  COMF   xE0,F
09064:  RLCF   xE0,F
09066:  MOVF   xDA,W
09068:  ANDLW  0F
0906A:  ADDWF  xE0,F
0906C:  RLCF   xDD,F
0906E:  MOVLW  07
09070:  MOVWF  xDC
09072:  MOVLW  0A
09074:  DECF   xDF,F
09076:  ADDWF  xE0,F
09078:  BNC   9074
0907A:  DECF   xDE,F
0907C:  ADDWF  xDF,F
0907E:  BNC   907A
09080:  DECF   xDD,F
09082:  ADDWF  xDE,F
09084:  BNC   9080
09086:  DECF   xDC,F
09088:  ADDWF  xDD,F
0908A:  BNC   9086
0908C:  MOVLW  08
0908E:  MOVWF  FEA
09090:  MOVLW  DC
09092:  MOVWF  FE9
09094:  MOVLW  07
09096:  ANDWF  xE1,W
09098:  BCF    xE1.6
0909A:  MOVF   FED,F
0909C:  ANDWF  xE1,W
0909E:  BNZ   90AE
090A0:  BTFSC  xE1.4
090A2:  MOVF   FEE,F
090A4:  BTFSC  xE1.4
090A6:  BRA    90AE
090A8:  MOVLW  20
090AA:  MOVWF  00
090AC:  BRA    90F0
090AE:  ADDWF  FE9,F
090B0:  MOVLW  00
090B2:  ADDWFC FEA,F
090B4:  MOVF   FE9,W
090B6:  SUBLW  E0
090B8:  BNZ   90C2
090BA:  MOVF   FEA,W
090BC:  SUBLW  08
090BE:  BNZ   90C2
090C0:  BSF    xE1.6
090C2:  MOVF   FEF,W
090C4:  MOVWF  00
090C6:  BNZ   90D8
090C8:  BTFSC  xE1.6
090CA:  BRA    90D8
090CC:  BTFSC  xE1.4
090CE:  BRA    90F8
090D0:  BTFSC  xE1.3
090D2:  BRA    90D8
090D4:  MOVLW  20
090D6:  BRA    90EE
090D8:  BTFSS  xE1.7
090DA:  BRA    90E8
090DC:  MOVLW  2D
090DE:  MOVWF  00
090E0:  MOVF   FED,W
090E2:  BCF    xE1.6
090E4:  BCF    xE1.7
090E6:  BRA    90F0
090E8:  BSF    xE1.3
090EA:  BCF    xE1.4
090EC:  MOVLW  30
090EE:  ADDWF  00,F
090F0:  MOVF   00,W
090F2:  BTFSS  F9E.4
090F4:  BRA    90F2
090F6:  MOVWF  FAD
090F8:  MOVF   FEE,W
090FA:  BTFSS  xE1.6
090FC:  BRA    90B4
090FE:  MOVLB  0
09100:  RETURN 0
*
09596:  MOVF   FE9,W
09598:  MOVLB  8
0959A:  MOVWF  xE0
0959C:  BTFSS  xDF.7
0959E:  BRA    95BA
095A0:  DECF   xE0,F
095A2:  BSF    xE0.5
095A4:  COMF   xDC,F
095A6:  COMF   xDD,F
095A8:  COMF   xDE,F
095AA:  COMF   xDF,F
095AC:  INCF   xDC,F
095AE:  BTFSC  FD8.2
095B0:  INCF   xDD,F
095B2:  BTFSC  FD8.2
095B4:  INCF   xDE,F
095B6:  BTFSC  FD8.2
095B8:  INCF   xDF,F
095BA:  MOVLW  3B
095BC:  MOVWF  xE7
095BE:  MOVLW  9A
095C0:  MOVWF  xE6
095C2:  MOVLW  CA
095C4:  MOVWF  xE5
095C6:  CLRF   xE4
095C8:  MOVLW  0A
095CA:  MOVWF  xE2
095CC:  BSF    FD8.1
095CE:  MOVLW  08
095D0:  MOVWF  FEA
095D2:  MOVLW  DC
095D4:  MOVWF  FE9
095D6:  CLRF   1B
095D8:  BTFSC  FF2.7
095DA:  BSF    1B.7
095DC:  BCF    FF2.7
095DE:  MOVFF  8DF,A34
095E2:  MOVFF  8DE,A33
095E6:  MOVFF  8DD,A32
095EA:  MOVFF  8DC,A31
095EE:  MOVFF  8E7,A38
095F2:  MOVFF  8E6,A37
095F6:  MOVFF  8E5,A36
095FA:  MOVFF  8E4,A35
095FE:  MOVLB  0
09600:  CALL   1042
09604:  BTFSC  1B.7
09606:  BSF    FF2.7
09608:  MOVF   01,W
0960A:  MOVF   00,F
0960C:  BNZ   9634
0960E:  MOVLB  8
09610:  MOVF   xE2,W
09612:  XORLW  01
09614:  BTFSS  FD8.2
09616:  BRA    961C
09618:  MOVLB  0
0961A:  BRA    9634
0961C:  MOVF   xE0,W
0961E:  BZ    963A
09620:  ANDLW  0F
09622:  SUBWF  xE2,W
09624:  BZ    9628
09626:  BC    9678
09628:  BTFSC  xE0.7
0962A:  BRA    9678
0962C:  BTFSC  xE0.6
0962E:  BRA    963A
09630:  MOVLW  20
09632:  BRA    966E
09634:  MOVLW  20
09636:  MOVLB  8
09638:  ANDWF  xE0,F
0963A:  BTFSS  xE0.5
0963C:  BRA    9652
0963E:  BCF    xE0.5
09640:  MOVFF  00,8E0
09644:  MOVLW  2D
09646:  BTFSS  F9E.4
09648:  BRA    9646
0964A:  MOVWF  FAD
0964C:  MOVFF  8E0,00
09650:  CLRF   xE0
09652:  MOVLW  30
09654:  BTFSS  xE0.5
09656:  BRA    966E
09658:  BCF    xE0.5
0965A:  MOVFF  00,8E0
0965E:  MOVLW  2D
09660:  BTFSS  F9E.4
09662:  BRA    9660
09664:  MOVWF  FAD
09666:  MOVFF  8E0,00
0966A:  CLRF   xE0
0966C:  MOVLW  30
0966E:  ADDWF  00,F
09670:  MOVF   00,W
09672:  BTFSS  F9E.4
09674:  BRA    9672
09676:  MOVWF  FAD
09678:  BCF    FD8.1
0967A:  CLRF   1B
0967C:  BTFSC  FF2.7
0967E:  BSF    1B.7
09680:  BCF    FF2.7
09682:  MOVFF  8E7,A34
09686:  MOVFF  8E6,A33
0968A:  MOVFF  8E5,A32
0968E:  MOVFF  8E4,A31
09692:  MOVLB  A
09694:  CLRF   x38
09696:  CLRF   x37
09698:  CLRF   x36
0969A:  MOVLW  0A
0969C:  MOVWF  x35
0969E:  MOVLB  0
096A0:  CALL   1042
096A4:  BTFSC  1B.7
096A6:  BSF    FF2.7
096A8:  MOVFF  03,8E7
096AC:  MOVFF  02,8E6
096B0:  MOVFF  01,8E5
096B4:  MOVFF  00,8E4
096B8:  MOVLB  8
096BA:  DECFSZ xE2,F
096BC:  BRA    95CC
096BE:  MOVLB  0
096C0:  RETURN 0
*
0A78A:  ADDWF  FE8,W
0A78C:  CLRF   FF7
0A78E:  RLCF   FF7,F
0A790:  ADDLW  AB
0A792:  MOVWF  FF6
0A794:  MOVLW  A7
0A796:  ADDWFC FF7,F
0A798:  MOVLW  00
0A79A:  MOVWF  FF8
0A79C:  MOVWF  FFB
0A79E:  TBLRD*-
0A7A0:  MOVF   FF5,W
0A7A2:  MOVWF  FFA
0A7A4:  TBLRD*
0A7A6:  MOVF   FF5,W
0A7A8:  MOVWF  FF9
0A7AA:  DATA E6,A0
0A7AC:  DATA 06,A1
0A7AE:  DATA 2E,A1
0A7B0:  DATA 5E,A1
0A7B2:  DATA 86,A1
*
0AAF6:  TBLRD*+
0AAF8:  MOVFF  FF6,8D6
0AAFC:  MOVFF  FF7,8D7
0AB00:  MOVFF  FF8,8D8
0AB04:  MOVFF  FF5,8E9
0AB08:  CALL   50E8
0AB0C:  MOVFF  8D6,FF6
0AB10:  MOVFF  8D7,FF7
0AB14:  MOVFF  8D8,FF8
0AB18:  MOVLB  8
0AB1A:  DECFSZ xD5,F
0AB1C:  BRA    AB20
0AB1E:  BRA    AB24
0AB20:  MOVLB  0
0AB22:  BRA    AAF6
0AB24:  MOVLB  0
0AB26:  RETURN 0
0AB28:  MOVFF  FEA,8E8
0AB2C:  MOVFF  FE9,8E7
0AB30:  MOVLB  8
0AB32:  SWAPF  xE1,W
0AB34:  IORLW  F0
0AB36:  MOVWF  xE3
0AB38:  ADDWF  xE3,F
0AB3A:  ADDLW  E2
0AB3C:  MOVWF  xE4
0AB3E:  ADDLW  32
0AB40:  MOVWF  xE6
0AB42:  MOVF   xE1,W
0AB44:  ANDLW  0F
0AB46:  ADDWF  xE4,F
0AB48:  ADDWF  xE4,F
0AB4A:  ADDWF  xE6,F
0AB4C:  ADDLW  E9
0AB4E:  MOVWF  xE5
0AB50:  ADDWF  xE5,F
0AB52:  ADDWF  xE5,F
0AB54:  SWAPF  xE0,W
0AB56:  ANDLW  0F
0AB58:  ADDWF  xE5,F
0AB5A:  ADDWF  xE6,F
0AB5C:  RLCF   xE5,F
0AB5E:  RLCF   xE6,F
0AB60:  COMF   xE6,F
0AB62:  RLCF   xE6,F
0AB64:  MOVF   xE0,W
0AB66:  ANDLW  0F
0AB68:  ADDWF  xE6,F
0AB6A:  RLCF   xE3,F
0AB6C:  MOVLW  07
0AB6E:  MOVWF  xE2
0AB70:  MOVLW  0A
0AB72:  DECF   xE5,F
0AB74:  ADDWF  xE6,F
0AB76:  BNC   AB72
0AB78:  DECF   xE4,F
0AB7A:  ADDWF  xE5,F
0AB7C:  BNC   AB78
0AB7E:  DECF   xE3,F
0AB80:  ADDWF  xE4,F
0AB82:  BNC   AB7E
0AB84:  DECF   xE2,F
0AB86:  ADDWF  xE3,F
0AB88:  BNC   AB84
0AB8A:  MOVLW  08
0AB8C:  MOVWF  FEA
0AB8E:  MOVLW  E2
0AB90:  MOVWF  FE9
0AB92:  MOVLW  07
0AB94:  ANDWF  xE7,W
0AB96:  BCF    xE7.6
0AB98:  ADDWF  FE9,F
0AB9A:  MOVLW  00
0AB9C:  ADDWFC FEA,F
0AB9E:  MOVF   FE9,W
0ABA0:  SUBLW  E6
0ABA2:  BNZ   ABAC
0ABA4:  MOVF   FEA,W
0ABA6:  SUBLW  08
0ABA8:  BNZ   ABAC
0ABAA:  BSF    xE7.6
0ABAC:  MOVF   FEF,W
0ABAE:  MOVWF  00
0ABB0:  BNZ   ABC2
0ABB2:  BTFSC  xE7.6
0ABB4:  BRA    ABC2
0ABB6:  BTFSC  xE7.4
0ABB8:  BRA    ABE6
0ABBA:  BTFSC  xE7.3
0ABBC:  BRA    ABC2
0ABBE:  MOVLW  20
0ABC0:  BRA    ABC8
0ABC2:  BSF    xE7.3
0ABC4:  BCF    xE7.4
0ABC6:  MOVLW  30
0ABC8:  ADDWF  00,F
0ABCA:  MOVFF  FEA,8E1
0ABCE:  MOVFF  FE9,8E0
0ABD2:  MOVFF  00,8E9
0ABD6:  MOVLB  0
0ABD8:  CALL   50E8
0ABDC:  MOVFF  8E1,FEA
0ABE0:  MOVFF  8E0,FE9
0ABE4:  MOVLB  8
0ABE6:  MOVF   FEE,W
0ABE8:  BTFSS  xE7.6
0ABEA:  BRA    AB9E
0ABEC:  MOVLB  0
0ABEE:  RETURN 0
*
0ADDA:  ADDWF  FE8,W
0ADDC:  CLRF   FF7
0ADDE:  RLCF   FF7,F
0ADE0:  ADDLW  FB
0ADE2:  MOVWF  FF6
0ADE4:  MOVLW  AD
0ADE6:  ADDWFC FF7,F
0ADE8:  MOVLW  00
0ADEA:  MOVWF  FF8
0ADEC:  MOVWF  FFB
0ADEE:  TBLRD*-
0ADF0:  MOVF   FF5,W
0ADF2:  MOVWF  FFA
0ADF4:  TBLRD*
0ADF6:  MOVF   FF5,W
0ADF8:  MOVWF  FF9
0ADFA:  DATA EA,AC
0ADFC:  DATA D6,AD
0ADFE:  DATA D6,AD
0AE00:  DATA 4A,AC
0AE02:  DATA D6,AD
0AE04:  DATA D6,AD
0AE06:  DATA D6,AD
0AE08:  DATA 0E,AC
0AE0A:  DATA D6,AD
0AE0C:  DATA D6,AD
0AE0E:  DATA D6,AD
0AE10:  DATA 60,AD
0AE12:  DATA 86,AC
0AE14:  DATA D6,AD
0AE16:  DATA 24,AD
0AE18:  DATA 9C,AD
*
0AE74:  TBLRD*+
0AE76:  MOVF   FF5,F
0AE78:  BZ    AE9C
0AE7A:  MOVFF  FF6,86F
0AE7E:  MOVFF  FF7,870
0AE82:  MOVFF  FF8,871
0AE86:  MOVF   FF5,W
0AE88:  BTFSS  F9E.4
0AE8A:  BRA    AE88
0AE8C:  MOVWF  FAD
0AE8E:  MOVFF  86F,FF6
0AE92:  MOVFF  870,FF7
0AE96:  MOVFF  871,FF8
0AE9A:  BRA    AE74
0AE9C:  RETURN 0
*
0C028:  MOVLB  8
0C02A:  MOVF   xFD,W
0C02C:  BTFSC  FD8.2
0C02E:  BRA    C144
0C030:  MOVWF  00
0C032:  MOVLB  9
0C034:  MOVF   x01,W
0C036:  BTFSS  FD8.2
0C038:  BRA    C03E
0C03A:  MOVLB  8
0C03C:  BRA    C144
0C03E:  ADDWF  00,F
0C040:  BNC   C050
0C042:  MOVLW  81
0C044:  ADDWF  00,F
0C046:  BTFSS  FD8.0
0C048:  BRA    C04E
0C04A:  MOVLB  8
0C04C:  BRA    C144
0C04E:  BRA    C064
0C050:  MOVLW  7F
0C052:  SUBWF  00,F
0C054:  BTFSC  FD8.0
0C056:  BRA    C05C
0C058:  MOVLB  8
0C05A:  BRA    C144
0C05C:  BTFSS  FD8.2
0C05E:  BRA    C064
0C060:  MOVLB  8
0C062:  BRA    C144
0C064:  MOVFF  8FE,905
0C068:  MOVF   x02,W
0C06A:  XORWF  x05,F
0C06C:  MOVLB  8
0C06E:  BSF    xFE.7
0C070:  MOVLB  9
0C072:  BSF    x02.7
0C074:  MOVF   x00,W
0C076:  MULWF  x04
0C078:  MOVFF  FF4,907
0C07C:  MOVLB  8
0C07E:  MOVF   xFF,W
0C080:  MOVLB  9
0C082:  MULWF  x03
0C084:  MOVFF  FF4,03
0C088:  MOVFF  FF3,906
0C08C:  MULWF  x04
0C08E:  MOVF   FF3,W
0C090:  ADDWF  x07,F
0C092:  MOVF   FF4,W
0C094:  ADDWFC x06,F
0C096:  MOVLW  00
0C098:  ADDWFC 03,F
0C09A:  MOVF   x00,W
0C09C:  MULWF  x03
0C09E:  MOVF   FF3,W
0C0A0:  ADDWF  x07,F
0C0A2:  MOVF   FF4,W
0C0A4:  ADDWFC x06,F
0C0A6:  MOVLW  00
0C0A8:  CLRF   02
0C0AA:  ADDWFC 03,F
0C0AC:  ADDWFC 02,F
0C0AE:  MOVLB  8
0C0B0:  MOVF   xFE,W
0C0B2:  MOVLB  9
0C0B4:  MULWF  x04
0C0B6:  MOVF   FF3,W
0C0B8:  ADDWF  x06,F
0C0BA:  MOVF   FF4,W
0C0BC:  ADDWFC 03,F
0C0BE:  MOVLW  00
0C0C0:  ADDWFC 02,F
0C0C2:  MOVLB  8
0C0C4:  MOVF   xFE,W
0C0C6:  MOVLB  9
0C0C8:  MULWF  x03
0C0CA:  MOVF   FF3,W
0C0CC:  ADDWF  03,F
0C0CE:  MOVF   FF4,W
0C0D0:  ADDWFC 02,F
0C0D2:  MOVLW  00
0C0D4:  CLRF   01
0C0D6:  ADDWFC 01,F
0C0D8:  MOVF   x00,W
0C0DA:  MULWF  x02
0C0DC:  MOVF   FF3,W
0C0DE:  ADDWF  x06,F
0C0E0:  MOVF   FF4,W
0C0E2:  ADDWFC 03,F
0C0E4:  MOVLW  00
0C0E6:  ADDWFC 02,F
0C0E8:  ADDWFC 01,F
0C0EA:  MOVLB  8
0C0EC:  MOVF   xFF,W
0C0EE:  MOVLB  9
0C0F0:  MULWF  x02
0C0F2:  MOVF   FF3,W
0C0F4:  ADDWF  03,F
0C0F6:  MOVF   FF4,W
0C0F8:  ADDWFC 02,F
0C0FA:  MOVLW  00
0C0FC:  ADDWFC 01,F
0C0FE:  MOVLB  8
0C100:  MOVF   xFE,W
0C102:  MOVLB  9
0C104:  MULWF  x02
0C106:  MOVF   FF3,W
0C108:  ADDWF  02,F
0C10A:  MOVF   FF4,W
0C10C:  ADDWFC 01,F
0C10E:  INCF   00,F
0C110:  BTFSC  01.7
0C112:  BRA    C11E
0C114:  RLCF   x06,F
0C116:  RLCF   03,F
0C118:  RLCF   02,F
0C11A:  RLCF   01,F
0C11C:  DECF   00,F
0C11E:  MOVLW  00
0C120:  BTFSS  x06.7
0C122:  BRA    C138
0C124:  INCF   03,F
0C126:  ADDWFC 02,F
0C128:  ADDWFC 01,F
0C12A:  MOVF   01,W
0C12C:  BNZ   C138
0C12E:  MOVF   02,W
0C130:  BNZ   C138
0C132:  MOVF   03,W
0C134:  BNZ   C138
0C136:  INCF   00,F
0C138:  BTFSC  x05.7
0C13A:  BSF    01.7
0C13C:  BTFSS  x05.7
0C13E:  BCF    01.7
0C140:  BRA    C14E
0C142:  MOVLB  8
0C144:  CLRF   00
0C146:  CLRF   01
0C148:  CLRF   02
0C14A:  CLRF   03
0C14C:  MOVLB  9
0C14E:  MOVLB  0
0C150:  RETURN 0
0C152:  MOVLW  80
0C154:  BTFSS  FD8.1
0C156:  BRA    C15C
0C158:  MOVLB  9
0C15A:  XORWF  x06,F
0C15C:  MOVLB  9
0C15E:  CLRF   x0B
0C160:  CLRF   x0C
0C162:  MOVFF  902,90A
0C166:  MOVF   x06,W
0C168:  XORWF  x0A,F
0C16A:  MOVF   x01,W
0C16C:  BTFSC  FD8.2
0C16E:  BRA    C32E
0C170:  MOVWF  x09
0C172:  MOVWF  00
0C174:  MOVF   x05,W
0C176:  BTFSC  FD8.2
0C178:  BRA    C340
0C17A:  SUBWF  x09,F
0C17C:  BTFSC  FD8.2
0C17E:  BRA    C286
0C180:  BNC   C1FE
0C182:  MOVFF  906,90F
0C186:  BSF    x0F.7
0C188:  MOVFF  907,90E
0C18C:  MOVFF  908,90D
0C190:  CLRF   x0C
0C192:  BCF    FD8.0
0C194:  RRCF   x0F,F
0C196:  RRCF   x0E,F
0C198:  RRCF   x0D,F
0C19A:  RRCF   x0C,F
0C19C:  DECFSZ x09,F
0C19E:  BRA    C190
0C1A0:  BTFSS  x0A.7
0C1A2:  BRA    C1AA
0C1A4:  BSF    x0B.0
0C1A6:  BRA    C368
0C1A8:  BCF    x0B.0
0C1AA:  BCF    x09.0
0C1AC:  BSF    x0B.4
0C1AE:  MOVLW  09
0C1B0:  MOVWF  FEA
0C1B2:  MOVLW  04
0C1B4:  MOVWF  FE9
0C1B6:  BRA    C38E
0C1B8:  BCF    x0B.4
0C1BA:  BTFSC  x0A.7
0C1BC:  BRA    C1D2
0C1BE:  BTFSS  x09.0
0C1C0:  BRA    C1E8
0C1C2:  RRCF   x0F,F
0C1C4:  RRCF   x0E,F
0C1C6:  RRCF   x0D,F
0C1C8:  RRCF   x0C,F
0C1CA:  INCF   00,F
0C1CC:  BTFSC  FD8.2
0C1CE:  BRA    C35E
0C1D0:  BRA    C1E8
0C1D2:  BTFSC  x0F.7
0C1D4:  BRA    C1EE
0C1D6:  BCF    FD8.0
0C1D8:  RLCF   x0C,F
0C1DA:  RLCF   x0D,F
0C1DC:  RLCF   x0E,F
0C1DE:  RLCF   x0F,F
0C1E0:  DECF   00,F
0C1E2:  BTFSC  FD8.2
0C1E4:  BRA    C35E
0C1E6:  BRA    C1D2
0C1E8:  BSF    x0B.6
0C1EA:  BRA    C2C6
0C1EC:  BCF    x0B.6
0C1EE:  MOVFF  902,90A
0C1F2:  BTFSS  x02.7
0C1F4:  BRA    C1FA
0C1F6:  BSF    x0F.7
0C1F8:  BRA    C350
0C1FA:  BCF    x0F.7
0C1FC:  BRA    C350
0C1FE:  MOVFF  905,909
0C202:  MOVFF  905,00
0C206:  MOVF   x01,W
0C208:  SUBWF  x09,F
0C20A:  MOVFF  902,90F
0C20E:  BSF    x0F.7
0C210:  MOVFF  903,90E
0C214:  MOVFF  904,90D
0C218:  CLRF   x0C
0C21A:  BCF    FD8.0
0C21C:  RRCF   x0F,F
0C21E:  RRCF   x0E,F
0C220:  RRCF   x0D,F
0C222:  RRCF   x0C,F
0C224:  DECFSZ x09,F
0C226:  BRA    C218
0C228:  BTFSS  x0A.7
0C22A:  BRA    C232
0C22C:  BSF    x0B.1
0C22E:  BRA    C368
0C230:  BCF    x0B.1
0C232:  BCF    x09.0
0C234:  BSF    x0B.5
0C236:  MOVLW  09
0C238:  MOVWF  FEA
0C23A:  MOVLW  08
0C23C:  MOVWF  FE9
0C23E:  BRA    C38E
0C240:  BCF    x0B.5
0C242:  BTFSC  x0A.7
0C244:  BRA    C25A
0C246:  BTFSS  x09.0
0C248:  BRA    C270
0C24A:  RRCF   x0F,F
0C24C:  RRCF   x0E,F
0C24E:  RRCF   x0D,F
0C250:  RRCF   x0C,F
0C252:  INCF   00,F
0C254:  BTFSC  FD8.2
0C256:  BRA    C35E
0C258:  BRA    C270
0C25A:  BTFSC  x0F.7
0C25C:  BRA    C276
0C25E:  BCF    FD8.0
0C260:  RLCF   x0C,F
0C262:  RLCF   x0D,F
0C264:  RLCF   x0E,F
0C266:  RLCF   x0F,F
0C268:  DECF   00,F
0C26A:  BTFSC  FD8.2
0C26C:  BRA    C35E
0C26E:  BRA    C25A
0C270:  BSF    x0B.7
0C272:  BRA    C2C6
0C274:  BCF    x0B.7
0C276:  MOVFF  906,90A
0C27A:  BTFSS  x06.7
0C27C:  BRA    C282
0C27E:  BSF    x0F.7
0C280:  BRA    C350
0C282:  BCF    x0F.7
0C284:  BRA    C350
0C286:  MOVFF  906,90F
0C28A:  BSF    x0F.7
0C28C:  MOVFF  907,90E
0C290:  MOVFF  908,90D
0C294:  BTFSS  x0A.7
0C296:  BRA    C2A0
0C298:  BCF    x0F.7
0C29A:  BSF    x0B.2
0C29C:  BRA    C368
0C29E:  BCF    x0B.2
0C2A0:  CLRF   x0C
0C2A2:  BCF    x09.0
0C2A4:  MOVLW  09
0C2A6:  MOVWF  FEA
0C2A8:  MOVLW  04
0C2AA:  MOVWF  FE9
0C2AC:  BRA    C38E
0C2AE:  BTFSC  x0A.7
0C2B0:  BRA    C2EA
0C2B2:  MOVFF  902,90A
0C2B6:  BTFSS  x09.0
0C2B8:  BRA    C2C6
0C2BA:  RRCF   x0F,F
0C2BC:  RRCF   x0E,F
0C2BE:  RRCF   x0D,F
0C2C0:  RRCF   x0C,F
0C2C2:  INCF   00,F
0C2C4:  BZ    C35E
0C2C6:  BTFSS  x0C.7
0C2C8:  BRA    C2E0
0C2CA:  INCF   x0D,F
0C2CC:  BNZ   C2E0
0C2CE:  INCF   x0E,F
0C2D0:  BNZ   C2E0
0C2D2:  INCF   x0F,F
0C2D4:  BNZ   C2E0
0C2D6:  RRCF   x0F,F
0C2D8:  RRCF   x0E,F
0C2DA:  RRCF   x0D,F
0C2DC:  INCF   00,F
0C2DE:  BZ    C35E
0C2E0:  BTFSC  x0B.6
0C2E2:  BRA    C1EC
0C2E4:  BTFSC  x0B.7
0C2E6:  BRA    C274
0C2E8:  BRA    C322
0C2EA:  MOVLW  80
0C2EC:  XORWF  x0F,F
0C2EE:  BTFSS  x0F.7
0C2F0:  BRA    C2FA
0C2F2:  BRA    C368
0C2F4:  MOVFF  906,90A
0C2F8:  BRA    C30E
0C2FA:  MOVFF  902,90A
0C2FE:  MOVF   x0F,F
0C300:  BNZ   C30E
0C302:  MOVF   x0E,F
0C304:  BNZ   C30E
0C306:  MOVF   x0D,F
0C308:  BNZ   C30E
0C30A:  CLRF   00
0C30C:  BRA    C350
0C30E:  BTFSC  x0F.7
0C310:  BRA    C322
0C312:  BCF    FD8.0
0C314:  RLCF   x0C,F
0C316:  RLCF   x0D,F
0C318:  RLCF   x0E,F
0C31A:  RLCF   x0F,F
0C31C:  DECFSZ 00,F
0C31E:  BRA    C30E
0C320:  BRA    C35E
0C322:  BTFSS  x0A.7
0C324:  BRA    C32A
0C326:  BSF    x0F.7
0C328:  BRA    C350
0C32A:  BCF    x0F.7
0C32C:  BRA    C350
0C32E:  MOVFF  905,00
0C332:  MOVFF  906,90F
0C336:  MOVFF  907,90E
0C33A:  MOVFF  908,90D
0C33E:  BRA    C350
0C340:  MOVFF  901,00
0C344:  MOVFF  902,90F
0C348:  MOVFF  903,90E
0C34C:  MOVFF  904,90D
0C350:  MOVFF  90F,01
0C354:  MOVFF  90E,02
0C358:  MOVFF  90D,03
0C35C:  BRA    C3C6
0C35E:  CLRF   00
0C360:  CLRF   01
0C362:  CLRF   02
0C364:  CLRF   03
0C366:  BRA    C3C6
0C368:  CLRF   x0C
0C36A:  COMF   x0D,F
0C36C:  COMF   x0E,F
0C36E:  COMF   x0F,F
0C370:  COMF   x0C,F
0C372:  INCF   x0C,F
0C374:  BNZ   C380
0C376:  INCF   x0D,F
0C378:  BNZ   C380
0C37A:  INCF   x0E,F
0C37C:  BNZ   C380
0C37E:  INCF   x0F,F
0C380:  BTFSC  x0B.0
0C382:  BRA    C1A8
0C384:  BTFSC  x0B.1
0C386:  BRA    C230
0C388:  BTFSC  x0B.2
0C38A:  BRA    C29E
0C38C:  BRA    C2F4
0C38E:  MOVF   FEF,W
0C390:  ADDWF  x0D,F
0C392:  BNC   C39E
0C394:  INCF   x0E,F
0C396:  BNZ   C39E
0C398:  INCF   x0F,F
0C39A:  BTFSC  FD8.2
0C39C:  BSF    x09.0
0C39E:  MOVF   FED,F
0C3A0:  MOVF   FEF,W
0C3A2:  ADDWF  x0E,F
0C3A4:  BNC   C3AC
0C3A6:  INCF   x0F,F
0C3A8:  BTFSC  FD8.2
0C3AA:  BSF    x09.0
0C3AC:  MOVF   FED,F
0C3AE:  MOVF   FEF,W
0C3B0:  BTFSC  FEF.7
0C3B2:  BRA    C3B6
0C3B4:  XORLW  80
0C3B6:  ADDWF  x0F,F
0C3B8:  BTFSC  FD8.0
0C3BA:  BSF    x09.0
0C3BC:  BTFSC  x0B.4
0C3BE:  BRA    C1B8
0C3C0:  BTFSC  x0B.5
0C3C2:  BRA    C240
0C3C4:  BRA    C2AE
0C3C6:  MOVLB  0
0C3C8:  RETURN 0
0C3CA:  MOVLB  8
0C3CC:  MOVF   xC6,W
0C3CE:  SUBLW  B6
0C3D0:  MOVWF  xC6
0C3D2:  CLRF   03
0C3D4:  MOVFF  8C7,8CA
0C3D8:  BSF    xC7.7
0C3DA:  BCF    FD8.0
0C3DC:  RRCF   xC7,F
0C3DE:  RRCF   xC8,F
0C3E0:  RRCF   xC9,F
0C3E2:  RRCF   03,F
0C3E4:  RRCF   02,F
0C3E6:  RRCF   01,F
0C3E8:  RRCF   00,F
0C3EA:  DECFSZ xC6,F
0C3EC:  BRA    C3DA
0C3EE:  BTFSS  xCA.7
0C3F0:  BRA    C408
0C3F2:  COMF   00,F
0C3F4:  COMF   01,F
0C3F6:  COMF   02,F
0C3F8:  COMF   03,F
0C3FA:  INCF   00,F
0C3FC:  BTFSC  FD8.2
0C3FE:  INCF   01,F
0C400:  BTFSC  FD8.2
0C402:  INCF   02,F
0C404:  BTFSC  FD8.2
0C406:  INCF   03,F
0C408:  MOVLB  0
0C40A:  RETURN 0
0C40C:  MOVF   FE9,W
0C40E:  MOVLB  8
0C410:  MOVWF  x74
0C412:  MOVF   x73,W
0C414:  MOVWF  x76
0C416:  BZ    C450
0C418:  MOVFF  872,900
0C41C:  MOVFF  871,8FF
0C420:  MOVFF  870,8FE
0C424:  MOVFF  86F,8FD
0C428:  MOVLB  9
0C42A:  CLRF   x04
0C42C:  CLRF   x03
0C42E:  MOVLW  20
0C430:  MOVWF  x02
0C432:  MOVLW  82
0C434:  MOVWF  x01
0C436:  MOVLB  0
0C438:  RCALL  C028
0C43A:  MOVFF  03,872
0C43E:  MOVFF  02,871
0C442:  MOVFF  01,870
0C446:  MOVFF  00,86F
0C44A:  MOVLB  8
0C44C:  DECFSZ x76,F
0C44E:  BRA    C418
0C450:  MOVLW  7E
0C452:  MOVWF  00
0C454:  CLRF   01
0C456:  BTFSC  x70.7
0C458:  BSF    01.7
0C45A:  CLRF   02
0C45C:  CLRF   03
0C45E:  BCF    FD8.1
0C460:  MOVFF  872,904
0C464:  MOVFF  871,903
0C468:  MOVFF  870,902
0C46C:  MOVFF  86F,901
0C470:  MOVFF  03,908
0C474:  MOVFF  02,907
0C478:  MOVFF  01,906
0C47C:  MOVFF  FE8,905
0C480:  MOVLB  0
0C482:  RCALL  C152
0C484:  MOVFF  03,872
0C488:  MOVFF  02,871
0C48C:  MOVFF  01,870
0C490:  MOVFF  00,86F
0C494:  MOVFF  872,8C9
0C498:  MOVFF  871,8C8
0C49C:  MOVFF  870,8C7
0C4A0:  MOVFF  86F,8C6
0C4A4:  RCALL  C3CA
0C4A6:  MOVFF  03,872
0C4AA:  MOVFF  02,871
0C4AE:  MOVFF  01,870
0C4B2:  MOVFF  00,86F
0C4B6:  MOVLB  8
0C4B8:  BTFSS  x72.7
0C4BA:  BRA    C4D6
0C4BC:  DECF   x74,F
0C4BE:  BSF    x74.5
0C4C0:  COMF   x6F,F
0C4C2:  COMF   x70,F
0C4C4:  COMF   x71,F
0C4C6:  COMF   x72,F
0C4C8:  INCF   x6F,F
0C4CA:  BTFSC  FD8.2
0C4CC:  INCF   x70,F
0C4CE:  BTFSC  FD8.2
0C4D0:  INCF   x71,F
0C4D2:  BTFSC  FD8.2
0C4D4:  INCF   x72,F
0C4D6:  MOVLW  3B
0C4D8:  MOVWF  x7B
0C4DA:  MOVLW  9A
0C4DC:  MOVWF  x7A
0C4DE:  MOVLW  CA
0C4E0:  MOVWF  x79
0C4E2:  CLRF   x78
0C4E4:  MOVLW  0A
0C4E6:  MOVWF  x76
0C4E8:  MOVF   x73,W
0C4EA:  BTFSC  FD8.2
0C4EC:  INCF   x74,F
0C4EE:  BSF    FD8.1
0C4F0:  MOVLW  08
0C4F2:  MOVWF  FEA
0C4F4:  MOVLW  6F
0C4F6:  MOVWF  FE9
0C4F8:  CLRF   1B
0C4FA:  BTFSC  FF2.7
0C4FC:  BSF    1B.7
0C4FE:  BCF    FF2.7
0C500:  MOVFF  872,A34
0C504:  MOVFF  871,A33
0C508:  MOVFF  870,A32
0C50C:  MOVFF  86F,A31
0C510:  MOVFF  87B,A38
0C514:  MOVFF  87A,A37
0C518:  MOVFF  879,A36
0C51C:  MOVFF  878,A35
0C520:  MOVLB  0
0C522:  CALL   1042
0C526:  BTFSC  1B.7
0C528:  BSF    FF2.7
0C52A:  MOVF   01,W
0C52C:  MOVF   00,F
0C52E:  BNZ   C556
0C530:  MOVLB  8
0C532:  INCF   x73,W
0C534:  SUBWF  x76,W
0C536:  BTFSS  FD8.2
0C538:  BRA    C53E
0C53A:  MOVLB  0
0C53C:  BRA    C556
0C53E:  MOVF   x74,W
0C540:  BZ    C55C
0C542:  ANDLW  0F
0C544:  SUBWF  x76,W
0C546:  BZ    C54A
0C548:  BC    C5C2
0C54A:  BTFSC  x74.7
0C54C:  BRA    C5C2
0C54E:  BTFSC  x74.6
0C550:  BRA    C55C
0C552:  MOVLW  20
0C554:  BRA    C5B8
0C556:  MOVLW  20
0C558:  MOVLB  8
0C55A:  ANDWF  x74,F
0C55C:  BTFSS  x74.5
0C55E:  BRA    C57A
0C560:  BCF    x74.5
0C562:  MOVF   x73,W
0C564:  BTFSS  FD8.2
0C566:  DECF   x74,F
0C568:  MOVF   00,W
0C56A:  MOVWF  x74
0C56C:  MOVLW  2D
0C56E:  BTFSS  F9E.4
0C570:  BRA    C56E
0C572:  MOVWF  FAD
0C574:  MOVF   x74,W
0C576:  MOVWF  00
0C578:  CLRF   x74
0C57A:  MOVF   x73,W
0C57C:  SUBWF  x76,W
0C57E:  BNZ   C596
0C580:  MOVF   00,W
0C582:  MOVWF  x74
0C584:  MOVLW  2E
0C586:  BTFSS  F9E.4
0C588:  BRA    C586
0C58A:  MOVWF  FAD
0C58C:  MOVF   x74,W
0C58E:  MOVWF  00
0C590:  MOVLW  20
0C592:  ANDWF  x74,F
0C594:  MOVLW  00
0C596:  MOVLW  30
0C598:  BTFSS  x74.5
0C59A:  BRA    C5B8
0C59C:  BCF    x74.5
0C59E:  MOVF   x73,W
0C5A0:  BTFSS  FD8.2
0C5A2:  DECF   x74,F
0C5A4:  MOVF   00,W
0C5A6:  MOVWF  x74
0C5A8:  MOVLW  2D
0C5AA:  BTFSS  F9E.4
0C5AC:  BRA    C5AA
0C5AE:  MOVWF  FAD
0C5B0:  MOVF   x74,W
0C5B2:  MOVWF  00
0C5B4:  CLRF   x74
0C5B6:  MOVLW  30
0C5B8:  ADDWF  00,F
0C5BA:  MOVF   00,W
0C5BC:  BTFSS  F9E.4
0C5BE:  BRA    C5BC
0C5C0:  MOVWF  FAD
0C5C2:  BCF    FD8.1
0C5C4:  CLRF   1B
0C5C6:  BTFSC  FF2.7
0C5C8:  BSF    1B.7
0C5CA:  BCF    FF2.7
0C5CC:  MOVFF  87B,A34
0C5D0:  MOVFF  87A,A33
0C5D4:  MOVFF  879,A32
0C5D8:  MOVFF  878,A31
0C5DC:  MOVLB  A
0C5DE:  CLRF   x38
0C5E0:  CLRF   x37
0C5E2:  CLRF   x36
0C5E4:  MOVLW  0A
0C5E6:  MOVWF  x35
0C5E8:  MOVLB  0
0C5EA:  CALL   1042
0C5EE:  BTFSC  1B.7
0C5F0:  BSF    FF2.7
0C5F2:  MOVFF  03,87B
0C5F6:  MOVFF  02,87A
0C5FA:  MOVFF  01,879
0C5FE:  MOVFF  00,878
0C602:  MOVLB  8
0C604:  DECFSZ x76,F
0C606:  BRA    C4EE
0C608:  MOVLB  0
0C60A:  RETURN 0
*
0C68E:  MOVLW  8E
0C690:  MOVWF  00
0C692:  MOVFF  902,01
0C696:  MOVFF  901,02
0C69A:  CLRF   03
0C69C:  MOVF   01,F
0C69E:  BNZ   C6B2
0C6A0:  MOVFF  02,01
0C6A4:  CLRF   02
0C6A6:  MOVLW  08
0C6A8:  SUBWF  00,F
0C6AA:  MOVF   01,F
0C6AC:  BNZ   C6B2
0C6AE:  CLRF   00
0C6B0:  BRA    C6C2
0C6B2:  BCF    FD8.0
0C6B4:  BTFSC  01.7
0C6B6:  BRA    C6C0
0C6B8:  RLCF   02,F
0C6BA:  RLCF   01,F
0C6BC:  DECF   00,F
0C6BE:  BRA    C6B2
0C6C0:  BCF    01.7
0C6C2:  RETURN 0
0C6C4:  MOVLB  8
0C6C6:  MOVF   xE5,W
0C6C8:  BTFSC  FD8.2
0C6CA:  BRA    C816
0C6CC:  MOVWF  xF1
0C6CE:  MOVF   xE9,W
0C6D0:  BTFSC  FD8.2
0C6D2:  BRA    C816
0C6D4:  SUBWF  xF1,F
0C6D6:  BNC   C6E2
0C6D8:  MOVLW  7F
0C6DA:  ADDWF  xF1,F
0C6DC:  BTFSC  FD8.0
0C6DE:  BRA    C816
0C6E0:  BRA    C6EE
0C6E2:  MOVLW  81
0C6E4:  SUBWF  xF1,F
0C6E6:  BTFSS  FD8.0
0C6E8:  BRA    C816
0C6EA:  BTFSC  FD8.2
0C6EC:  BRA    C816
0C6EE:  MOVFF  8F1,00
0C6F2:  CLRF   01
0C6F4:  CLRF   02
0C6F6:  CLRF   03
0C6F8:  CLRF   xF0
0C6FA:  MOVFF  8E6,8EF
0C6FE:  BSF    xEF.7
0C700:  MOVFF  8E7,8EE
0C704:  MOVFF  8E8,8ED
0C708:  MOVLW  19
0C70A:  MOVWF  xF1
0C70C:  MOVF   xEC,W
0C70E:  SUBWF  xED,F
0C710:  BC    C72C
0C712:  MOVLW  01
0C714:  SUBWF  xEE,F
0C716:  BC    C72C
0C718:  SUBWF  xEF,F
0C71A:  BC    C72C
0C71C:  SUBWF  xF0,F
0C71E:  BC    C72C
0C720:  INCF   xF0,F
0C722:  INCF   xEF,F
0C724:  INCF   xEE,F
0C726:  MOVF   xEC,W
0C728:  ADDWF  xED,F
0C72A:  BRA    C77C
0C72C:  MOVF   xEB,W
0C72E:  SUBWF  xEE,F
0C730:  BC    C756
0C732:  MOVLW  01
0C734:  SUBWF  xEF,F
0C736:  BC    C756
0C738:  SUBWF  xF0,F
0C73A:  BC    C756
0C73C:  INCF   xF0,F
0C73E:  INCF   xEF,F
0C740:  MOVF   xEB,W
0C742:  ADDWF  xEE,F
0C744:  MOVF   xEC,W
0C746:  ADDWF  xED,F
0C748:  BNC   C77C
0C74A:  INCF   xEE,F
0C74C:  BNZ   C77C
0C74E:  INCF   xEF,F
0C750:  BNZ   C77C
0C752:  INCF   xF0,F
0C754:  BRA    C77C
0C756:  MOVF   xEA,W
0C758:  IORLW  80
0C75A:  SUBWF  xEF,F
0C75C:  BC    C77A
0C75E:  MOVLW  01
0C760:  SUBWF  xF0,F
0C762:  BC    C77A
0C764:  INCF   xF0,F
0C766:  MOVF   xEA,W
0C768:  IORLW  80
0C76A:  ADDWF  xEF,F
0C76C:  MOVF   xEB,W
0C76E:  ADDWF  xEE,F
0C770:  BNC   C744
0C772:  INCF   xEF,F
0C774:  BNZ   C744
0C776:  INCF   xF0,F
0C778:  BRA    C744
0C77A:  BSF    03.0
0C77C:  DECFSZ xF1,F
0C77E:  BRA    C782
0C780:  BRA    C798
0C782:  BCF    FD8.0
0C784:  RLCF   xED,F
0C786:  RLCF   xEE,F
0C788:  RLCF   xEF,F
0C78A:  RLCF   xF0,F
0C78C:  BCF    FD8.0
0C78E:  RLCF   03,F
0C790:  RLCF   02,F
0C792:  RLCF   01,F
0C794:  RLCF   xF2,F
0C796:  BRA    C70C
0C798:  BTFSS  xF2.0
0C79A:  BRA    C7A8
0C79C:  BCF    FD8.0
0C79E:  RRCF   01,F
0C7A0:  RRCF   02,F
0C7A2:  RRCF   03,F
0C7A4:  RRCF   xF2,F
0C7A6:  BRA    C7AC
0C7A8:  DECF   00,F
0C7AA:  BZ    C816
0C7AC:  BTFSC  xF2.7
0C7AE:  BRA    C7EC
0C7B0:  BCF    FD8.0
0C7B2:  RLCF   xED,F
0C7B4:  RLCF   xEE,F
0C7B6:  RLCF   xEF,F
0C7B8:  RLCF   xF0,F
0C7BA:  MOVF   xEC,W
0C7BC:  SUBWF  xED,F
0C7BE:  BC    C7CE
0C7C0:  MOVLW  01
0C7C2:  SUBWF  xEE,F
0C7C4:  BC    C7CE
0C7C6:  SUBWF  xEF,F
0C7C8:  BC    C7CE
0C7CA:  SUBWF  xF0,F
0C7CC:  BNC   C802
0C7CE:  MOVF   xEB,W
0C7D0:  SUBWF  xEE,F
0C7D2:  BC    C7DE
0C7D4:  MOVLW  01
0C7D6:  SUBWF  xEF,F
0C7D8:  BC    C7DE
0C7DA:  SUBWF  xF0,F
0C7DC:  BNC   C802
0C7DE:  MOVF   xEA,W
0C7E0:  IORLW  80
0C7E2:  SUBWF  xEF,F
0C7E4:  BC    C7EC
0C7E6:  MOVLW  01
0C7E8:  SUBWF  xF0,F
0C7EA:  BNC   C802
0C7EC:  INCF   03,F
0C7EE:  BNZ   C802
0C7F0:  INCF   02,F
0C7F2:  BNZ   C802
0C7F4:  INCF   01,F
0C7F6:  BNZ   C802
0C7F8:  INCF   00,F
0C7FA:  BZ    C816
0C7FC:  RRCF   01,F
0C7FE:  RRCF   02,F
0C800:  RRCF   03,F
0C802:  MOVFF  8E6,8F1
0C806:  MOVF   xEA,W
0C808:  XORWF  xF1,F
0C80A:  BTFSS  xF1.7
0C80C:  BRA    C812
0C80E:  BSF    01.7
0C810:  BRA    C81E
0C812:  BCF    01.7
0C814:  BRA    C81E
0C816:  CLRF   00
0C818:  CLRF   01
0C81A:  CLRF   02
0C81C:  CLRF   03
0C81E:  MOVLB  0
0C820:  RETURN 0
*
0D2B4:  MOVFF  FEA,8B3
0D2B8:  MOVFF  FE9,8B2
0D2BC:  MOVLB  8
0D2BE:  BTFSS  xAC.7
0D2C0:  BRA    D2D2
0D2C2:  BSF    xB2.7
0D2C4:  BTFSS  xB2.4
0D2C6:  INCF   xB2,F
0D2C8:  COMF   xAB,F
0D2CA:  COMF   xAC,F
0D2CC:  INCF   xAB,F
0D2CE:  BTFSC  FD8.2
0D2D0:  INCF   xAC,F
0D2D2:  SWAPF  xAC,W
0D2D4:  IORLW  F0
0D2D6:  MOVWF  xAE
0D2D8:  ADDWF  xAE,F
0D2DA:  ADDLW  E2
0D2DC:  MOVWF  xAF
0D2DE:  ADDLW  32
0D2E0:  MOVWF  xB1
0D2E2:  MOVF   xAC,W
0D2E4:  ANDLW  0F
0D2E6:  ADDWF  xAF,F
0D2E8:  ADDWF  xAF,F
0D2EA:  ADDWF  xB1,F
0D2EC:  ADDLW  E9
0D2EE:  MOVWF  xB0
0D2F0:  ADDWF  xB0,F
0D2F2:  ADDWF  xB0,F
0D2F4:  SWAPF  xAB,W
0D2F6:  ANDLW  0F
0D2F8:  ADDWF  xB0,F
0D2FA:  ADDWF  xB1,F
0D2FC:  RLCF   xB0,F
0D2FE:  RLCF   xB1,F
0D300:  COMF   xB1,F
0D302:  RLCF   xB1,F
0D304:  MOVF   xAB,W
0D306:  ANDLW  0F
0D308:  ADDWF  xB1,F
0D30A:  RLCF   xAE,F
0D30C:  MOVLW  07
0D30E:  MOVWF  xAD
0D310:  MOVLW  0A
0D312:  DECF   xB0,F
0D314:  ADDWF  xB1,F
0D316:  BNC   D312
0D318:  DECF   xAF,F
0D31A:  ADDWF  xB0,F
0D31C:  BNC   D318
0D31E:  DECF   xAE,F
0D320:  ADDWF  xAF,F
0D322:  BNC   D31E
0D324:  DECF   xAD,F
0D326:  ADDWF  xAE,F
0D328:  BNC   D324
0D32A:  MOVLW  08
0D32C:  MOVWF  FEA
0D32E:  MOVLW  AD
0D330:  MOVWF  FE9
0D332:  MOVLW  07
0D334:  ANDWF  xB2,W
0D336:  BCF    xB2.6
0D338:  MOVF   FED,F
0D33A:  ANDWF  xB2,W
0D33C:  BNZ   D34C
0D33E:  BTFSC  xB2.4
0D340:  MOVF   FEE,F
0D342:  BTFSC  xB2.4
0D344:  BRA    D34C
0D346:  MOVLW  20
0D348:  MOVWF  00
0D34A:  BRA    D38E
0D34C:  ADDWF  FE9,F
0D34E:  MOVLW  00
0D350:  ADDWFC FEA,F
0D352:  MOVF   FE9,W
0D354:  SUBLW  B1
0D356:  BNZ   D360
0D358:  MOVF   FEA,W
0D35A:  SUBLW  08
0D35C:  BNZ   D360
0D35E:  BSF    xB2.6
0D360:  MOVF   FEF,W
0D362:  MOVWF  00
0D364:  BNZ   D376
0D366:  BTFSC  xB2.6
0D368:  BRA    D376
0D36A:  BTFSC  xB2.4
0D36C:  BRA    D3AA
0D36E:  BTFSC  xB2.3
0D370:  BRA    D376
0D372:  MOVLW  20
0D374:  BRA    D38C
0D376:  BTFSS  xB2.7
0D378:  BRA    D386
0D37A:  MOVLW  2D
0D37C:  MOVWF  00
0D37E:  MOVF   FED,W
0D380:  BCF    xB2.6
0D382:  BCF    xB2.7
0D384:  BRA    D38E
0D386:  BSF    xB2.3
0D388:  BCF    xB2.4
0D38A:  MOVLW  30
0D38C:  ADDWF  00,F
0D38E:  MOVFF  FEA,8AC
0D392:  MOVFF  FE9,8AB
0D396:  MOVFF  00,8E9
0D39A:  MOVLB  0
0D39C:  CALL   50E8
0D3A0:  MOVFF  8AC,FEA
0D3A4:  MOVFF  8AB,FE9
0D3A8:  MOVLB  8
0D3AA:  MOVF   FEE,W
0D3AC:  BTFSS  xB2.6
0D3AE:  BRA    D352
0D3B0:  MOVLB  0
0D3B2:  GOTO   D4D6 (RETURN)
*
0D75A:  ADDWF  FE8,W
0D75C:  CLRF   FF7
0D75E:  RLCF   FF7,F
0D760:  ADDLW  7B
0D762:  MOVWF  FF6
0D764:  MOVLW  D7
0D766:  ADDWFC FF7,F
0D768:  MOVLW  00
0D76A:  MOVWF  FF8
0D76C:  MOVWF  FFB
0D76E:  TBLRD*-
0D770:  MOVF   FF5,W
0D772:  MOVWF  FFA
0D774:  TBLRD*
0D776:  MOVF   FF5,W
0D778:  MOVWF  FF9
0D77A:  DATA 8C,D6
0D77C:  DATA B4,D6
0D77E:  DATA D4,D6
0D780:  DATA F4,D6
0D782:  DATA 14,D7
0D784:  DATA 34,D7
*
0D804:  TBLRD*+
0D806:  MOVFF  FF6,8A3
0D80A:  MOVFF  FF7,8A4
0D80E:  MOVFF  FF8,8A5
0D812:  MOVF   FF5,W
0D814:  BTFSS  FA4.4
0D816:  BRA    D814
0D818:  MOVLB  F
0D81A:  MOVWF  x1C
0D81C:  MOVFF  8A3,FF6
0D820:  MOVFF  8A4,FF7
0D824:  MOVFF  8A5,FF8
0D828:  MOVLB  8
0D82A:  DECFSZ xA2,F
0D82C:  BRA    D830
0D82E:  BRA    D834
0D830:  MOVLB  0
0D832:  BRA    D804
0D834:  MOVLB  0
0D836:  RETURN 0
0D838:  MOVF   01,W
0D83A:  CLRF   1B
0D83C:  BTFSC  FF2.7
0D83E:  BSF    1B.7
0D840:  BCF    FF2.7
0D842:  MOVFF  8DD,A27
0D846:  MOVLW  64
0D848:  MOVLB  A
0D84A:  MOVWF  x28
0D84C:  MOVLB  0
0D84E:  CALL   0F66
0D852:  BTFSC  1B.7
0D854:  BSF    FF2.7
0D856:  MOVFF  00,8DD
0D85A:  MOVF   01,W
0D85C:  MOVLW  30
0D85E:  BNZ   D870
0D860:  MOVLB  8
0D862:  BTFSS  xDE.1
0D864:  BRA    D886
0D866:  BTFSC  xDE.3
0D868:  BRA    D886
0D86A:  BTFSC  xDE.4
0D86C:  MOVLW  20
0D86E:  BRA    D878
0D870:  MOVLB  8
0D872:  BCF    xDE.3
0D874:  BCF    xDE.4
0D876:  BSF    xDE.0
0D878:  ADDWF  01,F
0D87A:  MOVF   01,W
0D87C:  BTFSS  FA4.4
0D87E:  BRA    D87C
0D880:  MOVLB  F
0D882:  MOVWF  x1C
0D884:  MOVLB  8
0D886:  CLRF   1B
0D888:  BTFSC  FF2.7
0D88A:  BSF    1B.7
0D88C:  BCF    FF2.7
0D88E:  MOVFF  8DD,A27
0D892:  MOVLW  0A
0D894:  MOVLB  A
0D896:  MOVWF  x28
0D898:  MOVLB  0
0D89A:  CALL   0F66
0D89E:  BTFSC  1B.7
0D8A0:  BSF    FF2.7
0D8A2:  MOVFF  00,8DD
0D8A6:  MOVF   01,W
0D8A8:  MOVLW  30
0D8AA:  BNZ   D8BC
0D8AC:  MOVLB  8
0D8AE:  BTFSC  xDE.3
0D8B0:  BRA    D8CA
0D8B2:  BTFSS  xDE.0
0D8B4:  BRA    D8CA
0D8B6:  BTFSC  xDE.4
0D8B8:  MOVLW  20
0D8BA:  MOVLB  0
0D8BC:  ADDWF  01,F
0D8BE:  MOVF   01,W
0D8C0:  BTFSS  FA4.4
0D8C2:  BRA    D8C0
0D8C4:  MOVLB  F
0D8C6:  MOVWF  x1C
0D8C8:  MOVLB  8
0D8CA:  MOVLW  30
0D8CC:  ADDWF  xDD,F
0D8CE:  MOVF   xDD,W
0D8D0:  BTFSS  FA4.4
0D8D2:  BRA    D8D0
0D8D4:  MOVLB  F
0D8D6:  MOVWF  x1C
0D8D8:  MOVLB  0
0D8DA:  RETURN 0
*
0D8FE:  TBLRD*+
0D900:  MOVF   FF5,F
0D902:  BZ    D92A
0D904:  MOVFF  FF6,8A1
0D908:  MOVFF  FF7,8A2
0D90C:  MOVFF  FF8,8A3
0D910:  MOVF   FF5,W
0D912:  BTFSS  FA4.4
0D914:  BRA    D912
0D916:  MOVLB  F
0D918:  MOVWF  x1C
0D91A:  MOVFF  8A1,FF6
0D91E:  MOVFF  8A2,FF7
0D922:  MOVFF  8A3,FF8
0D926:  MOVLB  0
0D928:  BRA    D8FE
0D92A:  GOTO   D9EC (RETURN)
*
0DF02:  MOVF   FE9,W
0DF04:  MOVLB  8
0DF06:  MOVWF  x76
0DF08:  MOVLW  3B
0DF0A:  MOVWF  x7D
0DF0C:  MOVLW  9A
0DF0E:  MOVWF  x7C
0DF10:  MOVLW  CA
0DF12:  MOVWF  x7B
0DF14:  CLRF   x7A
0DF16:  MOVLW  0A
0DF18:  MOVWF  x78
0DF1A:  MOVF   x75,W
0DF1C:  BTFSS  FD8.2
0DF1E:  DECF   x76,F
0DF20:  BSF    FD8.1
0DF22:  MOVLW  08
0DF24:  MOVWF  FEA
0DF26:  MOVLW  71
0DF28:  MOVWF  FE9
0DF2A:  CLRF   1B
0DF2C:  BTFSC  FF2.7
0DF2E:  BSF    1B.7
0DF30:  BCF    FF2.7
0DF32:  MOVFF  874,A34
0DF36:  MOVFF  873,A33
0DF3A:  MOVFF  872,A32
0DF3E:  MOVFF  871,A31
0DF42:  MOVFF  87D,A38
0DF46:  MOVFF  87C,A37
0DF4A:  MOVFF  87B,A36
0DF4E:  MOVFF  87A,A35
0DF52:  MOVLB  0
0DF54:  CALL   1042
0DF58:  BTFSC  1B.7
0DF5A:  BSF    FF2.7
0DF5C:  MOVF   01,W
0DF5E:  MOVF   00,F
0DF60:  BNZ   DF88
0DF62:  MOVLB  8
0DF64:  INCF   x75,W
0DF66:  SUBWF  x78,W
0DF68:  BTFSS  FD8.2
0DF6A:  BRA    DF70
0DF6C:  MOVLB  0
0DF6E:  BRA    DF88
0DF70:  MOVF   x76,W
0DF72:  BZ    DF8C
0DF74:  ANDLW  0F
0DF76:  SUBWF  x78,W
0DF78:  BZ    DF7C
0DF7A:  BC    DFB4
0DF7C:  BTFSC  x76.7
0DF7E:  BRA    DFB4
0DF80:  BTFSC  x76.6
0DF82:  BRA    DF8C
0DF84:  MOVLW  20
0DF86:  BRA    DFAA
0DF88:  MOVLB  8
0DF8A:  CLRF   x76
0DF8C:  MOVF   x75,W
0DF8E:  SUBWF  x78,W
0DF90:  BNZ   DFA8
0DF92:  MOVFF  00,876
0DF96:  MOVLW  2E
0DF98:  BTFSS  F9E.4
0DF9A:  BRA    DF98
0DF9C:  MOVWF  FAD
0DF9E:  MOVFF  876,00
0DFA2:  MOVLW  20
0DFA4:  ANDWF  x76,F
0DFA6:  MOVLW  00
0DFA8:  MOVLW  30
0DFAA:  ADDWF  00,F
0DFAC:  MOVF   00,W
0DFAE:  BTFSS  F9E.4
0DFB0:  BRA    DFAE
0DFB2:  MOVWF  FAD
0DFB4:  BCF    FD8.1
0DFB6:  CLRF   1B
0DFB8:  BTFSC  FF2.7
0DFBA:  BSF    1B.7
0DFBC:  BCF    FF2.7
0DFBE:  MOVFF  87D,A34
0DFC2:  MOVFF  87C,A33
0DFC6:  MOVFF  87B,A32
0DFCA:  MOVFF  87A,A31
0DFCE:  MOVLB  A
0DFD0:  CLRF   x38
0DFD2:  CLRF   x37
0DFD4:  CLRF   x36
0DFD6:  MOVLW  0A
0DFD8:  MOVWF  x35
0DFDA:  MOVLB  0
0DFDC:  CALL   1042
0DFE0:  BTFSC  1B.7
0DFE2:  BSF    FF2.7
0DFE4:  MOVFF  03,87D
0DFE8:  MOVFF  02,87C
0DFEC:  MOVFF  01,87B
0DFF0:  MOVFF  00,87A
0DFF4:  MOVLB  8
0DFF6:  DECFSZ x78,F
0DFF8:  BRA    DF20
0DFFA:  MOVLB  0
0DFFC:  RETURN 0
*
0F096:  MOVF   FE9,W
0F098:  MOVLB  8
0F09A:  MOVWF  xE1
0F09C:  MOVLW  3B
0F09E:  MOVWF  xE8
0F0A0:  MOVLW  9A
0F0A2:  MOVWF  xE7
0F0A4:  MOVLW  CA
0F0A6:  MOVWF  xE6
0F0A8:  CLRF   xE5
0F0AA:  MOVLW  0A
0F0AC:  MOVWF  xE3
0F0AE:  BSF    FD8.1
0F0B0:  MOVLW  08
0F0B2:  MOVWF  FEA
0F0B4:  MOVLW  DD
0F0B6:  MOVWF  FE9
0F0B8:  CLRF   1B
0F0BA:  BTFSC  FF2.7
0F0BC:  BSF    1B.7
0F0BE:  BCF    FF2.7
0F0C0:  MOVFF  8E0,A34
0F0C4:  MOVFF  8DF,A33
0F0C8:  MOVFF  8DE,A32
0F0CC:  MOVFF  8DD,A31
0F0D0:  MOVFF  8E8,A38
0F0D4:  MOVFF  8E7,A37
0F0D8:  MOVFF  8E6,A36
0F0DC:  MOVFF  8E5,A35
0F0E0:  MOVLB  0
0F0E2:  CALL   1042
0F0E6:  BTFSC  1B.7
0F0E8:  BSF    FF2.7
0F0EA:  MOVF   01,W
0F0EC:  MOVF   00,F
0F0EE:  BNZ   F116
0F0F0:  MOVLB  8
0F0F2:  MOVF   xE3,W
0F0F4:  XORLW  01
0F0F6:  BTFSS  FD8.2
0F0F8:  BRA    F0FE
0F0FA:  MOVLB  0
0F0FC:  BRA    F116
0F0FE:  MOVF   xE1,W
0F100:  BZ    F11A
0F102:  ANDLW  0F
0F104:  SUBWF  xE3,W
0F106:  BZ    F10A
0F108:  BC    F12A
0F10A:  BTFSC  xE1.7
0F10C:  BRA    F12A
0F10E:  BTFSC  xE1.6
0F110:  BRA    F11A
0F112:  MOVLW  20
0F114:  BRA    F11C
0F116:  MOVLB  8
0F118:  CLRF   xE1
0F11A:  MOVLW  30
0F11C:  ADDWF  00,F
0F11E:  MOVF   00,W
0F120:  BTFSS  FA4.4
0F122:  BRA    F120
0F124:  MOVLB  F
0F126:  MOVWF  x1C
0F128:  MOVLB  8
0F12A:  BCF    FD8.1
0F12C:  CLRF   1B
0F12E:  BTFSC  FF2.7
0F130:  BSF    1B.7
0F132:  BCF    FF2.7
0F134:  MOVFF  8E8,A34
0F138:  MOVFF  8E7,A33
0F13C:  MOVFF  8E6,A32
0F140:  MOVFF  8E5,A31
0F144:  MOVLB  A
0F146:  CLRF   x38
0F148:  CLRF   x37
0F14A:  CLRF   x36
0F14C:  MOVLW  0A
0F14E:  MOVWF  x35
0F150:  MOVLB  0
0F152:  CALL   1042
0F156:  BTFSC  1B.7
0F158:  BSF    FF2.7
0F15A:  MOVFF  03,8E8
0F15E:  MOVFF  02,8E7
0F162:  MOVFF  01,8E6
0F166:  MOVFF  00,8E5
0F16A:  MOVLB  8
0F16C:  DECFSZ xE3,F
0F16E:  BRA    F0AE
0F170:  MOVLB  0
0F172:  GOTO   F29C (RETURN)
*
0F36C:  ADDWF  FE8,W
0F36E:  CLRF   FF7
0F370:  RLCF   FF7,F
0F372:  ADDLW  8D
0F374:  MOVWF  FF6
0F376:  MOVLW  F3
0F378:  ADDWFC FF7,F
0F37A:  MOVLW  00
0F37C:  MOVWF  FF8
0F37E:  MOVWF  FFB
0F380:  TBLRD*-
0F382:  MOVF   FF5,W
0F384:  MOVWF  FFA
0F386:  TBLRD*
0F388:  MOVF   FF5,W
0F38A:  MOVWF  FF9
0F38C:  DATA 2C,F3
0F38E:  DATA 34,F3
0F390:  DATA 3C,F3
0F392:  DATA 44,F3
*
0FBB0:  MOVF   FEF,F
0FBB2:  BZ    FBD4
0FBB4:  MOVFF  FEA,8D6
0FBB8:  MOVFF  FE9,8D5
0FBBC:  MOVFF  FEF,8E9
0FBC0:  CALL   50E8
0FBC4:  MOVFF  8D6,FEA
0FBC8:  MOVFF  8D5,FE9
0FBCC:  INCF   FE9,F
0FBCE:  BTFSC  FD8.2
0FBD0:  INCF   FEA,F
0FBD2:  BRA    FBB0
0FBD4:  RETURN 0
0FBD6:  MOVFF  FEA,FE2
0FBDA:  MOVFF  FE9,FE1
0FBDE:  CLRF   01
0FBE0:  BSF    00.0
0FBE2:  TBLRD*+
0FBE4:  MOVF   FF5,W
0FBE6:  BTFSS  00.0
0FBE8:  BRA    FBF4
0FBEA:  SUBWF  FEE,W
0FBEC:  BNZ   FBF4
0FBEE:  MOVF   FF5,F
0FBF0:  BNZ   FBE2
0FBF2:  BRA    FC0E
0FBF4:  BCF    00.0
0FBF6:  MOVF   FF5,F
0FBF8:  BNZ   FBE2
0FBFA:  INCF   01,F
0FBFC:  BSF    00.0
0FBFE:  MOVFF  FE2,FEA
0FC02:  MOVFF  FE1,FE9
0FC06:  TBLRD*
0FC08:  MOVF   FF5,F
0FC0A:  BNZ   FBE2
0FC0C:  SETF   01
0FC0E:  RETURN 0
*
104EC:  MOVFF  8FE,905
104F0:  MOVLB  9
104F2:  MOVF   x02,W
104F4:  XORWF  x05,F
104F6:  BTFSS  x05.7
104F8:  BRA    10506
104FA:  BCF    FD8.2
104FC:  BCF    FD8.0
104FE:  MOVLB  8
10500:  BTFSC  xFE.7
10502:  BSF    FD8.0
10504:  BRA    1058E
10506:  MOVFF  8FE,905
1050A:  MOVFF  901,906
1050E:  MOVLB  8
10510:  MOVF   xFD,W
10512:  MOVLB  9
10514:  SUBWF  x06,F
10516:  BZ    1052A
10518:  BTFSC  x05.7
1051A:  BRA    10520
1051C:  MOVLB  8
1051E:  BRA    1058E
10520:  MOVF   FD8,W
10522:  XORLW  01
10524:  MOVWF  FD8
10526:  MOVLB  8
10528:  BRA    1058E
1052A:  MOVFF  902,906
1052E:  MOVLB  8
10530:  MOVF   xFE,W
10532:  MOVLB  9
10534:  SUBWF  x06,F
10536:  BZ    1054A
10538:  BTFSC  x05.7
1053A:  BRA    10540
1053C:  MOVLB  8
1053E:  BRA    1058E
10540:  MOVF   FD8,W
10542:  XORLW  01
10544:  MOVWF  FD8
10546:  MOVLB  8
10548:  BRA    1058E
1054A:  MOVFF  903,906
1054E:  MOVLB  8
10550:  MOVF   xFF,W
10552:  MOVLB  9
10554:  SUBWF  x06,F
10556:  BZ    1056C
10558:  BTFSC  x05.7
1055A:  BRA    10560
1055C:  MOVLB  8
1055E:  BRA    1058E
10560:  MOVF   FD8,W
10562:  XORLW  01
10564:  MOVWF  FD8
10566:  MOVLB  8
10568:  BRA    1058E
1056A:  MOVLB  9
1056C:  MOVFF  904,906
10570:  MOVF   x00,W
10572:  SUBWF  x06,F
10574:  BZ    1058A
10576:  BTFSC  x05.7
10578:  BRA    1057E
1057A:  MOVLB  8
1057C:  BRA    1058E
1057E:  MOVF   FD8,W
10580:  XORLW  01
10582:  MOVWF  FD8
10584:  MOVLB  8
10586:  BRA    1058E
10588:  MOVLB  9
1058A:  BCF    FD8.0
1058C:  MOVLB  8
1058E:  MOVLB  0
10590:  RETURN 0
10592:  MOVLW  8E
10594:  MOVWF  00
10596:  MOVFF  8D7,01
1059A:  MOVFF  8D6,02
1059E:  CLRF   03
105A0:  BTFSS  01.7
105A2:  BRA    105AE
105A4:  COMF   01,F
105A6:  COMF   02,F
105A8:  INCF   02,F
105AA:  BNZ   105AE
105AC:  INCF   01,F
105AE:  MOVF   01,F
105B0:  BNZ   105C4
105B2:  MOVFF  02,01
105B6:  CLRF   02
105B8:  MOVLW  08
105BA:  SUBWF  00,F
105BC:  MOVF   01,F
105BE:  BNZ   105C4
105C0:  CLRF   00
105C2:  BRA    105E0
105C4:  BCF    FD8.0
105C6:  BTFSC  01.7
105C8:  BRA    105D2
105CA:  RLCF   02,F
105CC:  RLCF   01,F
105CE:  DECF   00,F
105D0:  BRA    105C4
105D2:  MOVLB  8
105D4:  BTFSS  xD7.7
105D6:  BRA    105DC
105D8:  MOVLB  0
105DA:  BRA    105E0
105DC:  BCF    01.7
105DE:  MOVLB  0
105E0:  RETURN 0
*
109E6:  MOVF   FE9,W
109E8:  MOVLB  8
109EA:  MOVWF  xBE
109EC:  MOVF   xBD,W
109EE:  MOVWF  xC0
109F0:  BZ    10A2C
109F2:  MOVFF  8BC,900
109F6:  MOVFF  8BB,8FF
109FA:  MOVFF  8BA,8FE
109FE:  MOVFF  8B9,8FD
10A02:  MOVLB  9
10A04:  CLRF   x04
10A06:  CLRF   x03
10A08:  MOVLW  20
10A0A:  MOVWF  x02
10A0C:  MOVLW  82
10A0E:  MOVWF  x01
10A10:  MOVLB  0
10A12:  CALL   C028
10A16:  MOVFF  03,8BC
10A1A:  MOVFF  02,8BB
10A1E:  MOVFF  01,8BA
10A22:  MOVFF  00,8B9
10A26:  MOVLB  8
10A28:  DECFSZ xC0,F
10A2A:  BRA    109F2
10A2C:  MOVLW  7E
10A2E:  MOVWF  00
10A30:  CLRF   01
10A32:  BTFSC  xBA.7
10A34:  BSF    01.7
10A36:  CLRF   02
10A38:  CLRF   03
10A3A:  BCF    FD8.1
10A3C:  MOVFF  8BC,904
10A40:  MOVFF  8BB,903
10A44:  MOVFF  8BA,902
10A48:  MOVFF  8B9,901
10A4C:  MOVFF  03,908
10A50:  MOVFF  02,907
10A54:  MOVFF  01,906
10A58:  MOVFF  FE8,905
10A5C:  MOVLB  0
10A5E:  CALL   C152
10A62:  MOVFF  03,8BC
10A66:  MOVFF  02,8BB
10A6A:  MOVFF  01,8BA
10A6E:  MOVFF  00,8B9
10A72:  MOVFF  8BC,8C9
10A76:  MOVFF  8BB,8C8
10A7A:  MOVFF  8BA,8C7
10A7E:  MOVFF  8B9,8C6
10A82:  CALL   C3CA
10A86:  MOVFF  03,8BC
10A8A:  MOVFF  02,8BB
10A8E:  MOVFF  01,8BA
10A92:  MOVFF  00,8B9
10A96:  MOVLB  8
10A98:  BTFSS  xBC.7
10A9A:  BRA    10AB6
10A9C:  DECF   xBE,F
10A9E:  BSF    xBE.5
10AA0:  COMF   xB9,F
10AA2:  COMF   xBA,F
10AA4:  COMF   xBB,F
10AA6:  COMF   xBC,F
10AA8:  INCF   xB9,F
10AAA:  BTFSC  FD8.2
10AAC:  INCF   xBA,F
10AAE:  BTFSC  FD8.2
10AB0:  INCF   xBB,F
10AB2:  BTFSC  FD8.2
10AB4:  INCF   xBC,F
10AB6:  MOVLW  3B
10AB8:  MOVWF  xC5
10ABA:  MOVLW  9A
10ABC:  MOVWF  xC4
10ABE:  MOVLW  CA
10AC0:  MOVWF  xC3
10AC2:  CLRF   xC2
10AC4:  MOVLW  0A
10AC6:  MOVWF  xC0
10AC8:  MOVF   xBD,W
10ACA:  BTFSC  FD8.2
10ACC:  INCF   xBE,F
10ACE:  BSF    FD8.1
10AD0:  MOVLW  08
10AD2:  MOVWF  FEA
10AD4:  MOVLW  B9
10AD6:  MOVWF  FE9
10AD8:  CLRF   1B
10ADA:  BTFSC  FF2.7
10ADC:  BSF    1B.7
10ADE:  BCF    FF2.7
10AE0:  MOVFF  8BC,A34
10AE4:  MOVFF  8BB,A33
10AE8:  MOVFF  8BA,A32
10AEC:  MOVFF  8B9,A31
10AF0:  MOVFF  8C5,A38
10AF4:  MOVFF  8C4,A37
10AF8:  MOVFF  8C3,A36
10AFC:  MOVFF  8C2,A35
10B00:  MOVLB  0
10B02:  CALL   1042
10B06:  BTFSC  1B.7
10B08:  BSF    FF2.7
10B0A:  MOVF   01,W
10B0C:  MOVF   00,F
10B0E:  BNZ   10B36
10B10:  MOVLB  8
10B12:  INCF   xBD,W
10B14:  SUBWF  xC0,W
10B16:  BTFSS  FD8.2
10B18:  BRA    10B1E
10B1A:  MOVLB  0
10B1C:  BRA    10B36
10B1E:  MOVF   xBE,W
10B20:  BZ    10B3C
10B22:  ANDLW  0F
10B24:  SUBWF  xC0,W
10B26:  BZ    10B2A
10B28:  BC    10BB2
10B2A:  BTFSC  xBE.7
10B2C:  BRA    10BB2
10B2E:  BTFSC  xBE.6
10B30:  BRA    10B3C
10B32:  MOVLW  20
10B34:  BRA    10BA4
10B36:  MOVLW  20
10B38:  MOVLB  8
10B3A:  ANDWF  xBE,F
10B3C:  BTFSS  xBE.5
10B3E:  BRA    10B5E
10B40:  BCF    xBE.5
10B42:  MOVF   xBD,W
10B44:  BTFSS  FD8.2
10B46:  DECF   xBE,F
10B48:  MOVF   00,W
10B4A:  MOVWF  xBE
10B4C:  MOVLW  2D
10B4E:  MOVWF  xE9
10B50:  MOVLB  0
10B52:  CALL   50E8
10B56:  MOVLB  8
10B58:  MOVF   xBE,W
10B5A:  MOVWF  00
10B5C:  CLRF   xBE
10B5E:  MOVF   xBD,W
10B60:  SUBWF  xC0,W
10B62:  BNZ   10B7E
10B64:  MOVF   00,W
10B66:  MOVWF  xBE
10B68:  MOVLW  2E
10B6A:  MOVWF  xE9
10B6C:  MOVLB  0
10B6E:  CALL   50E8
10B72:  MOVLB  8
10B74:  MOVF   xBE,W
10B76:  MOVWF  00
10B78:  MOVLW  20
10B7A:  ANDWF  xBE,F
10B7C:  MOVLW  00
10B7E:  MOVLW  30
10B80:  BTFSS  xBE.5
10B82:  BRA    10BA4
10B84:  BCF    xBE.5
10B86:  MOVF   xBD,W
10B88:  BTFSS  FD8.2
10B8A:  DECF   xBE,F
10B8C:  MOVF   00,W
10B8E:  MOVWF  xBE
10B90:  MOVLW  2D
10B92:  MOVWF  xE9
10B94:  MOVLB  0
10B96:  CALL   50E8
10B9A:  MOVLB  8
10B9C:  MOVF   xBE,W
10B9E:  MOVWF  00
10BA0:  CLRF   xBE
10BA2:  MOVLW  30
10BA4:  ADDWF  00,F
10BA6:  MOVFF  00,8E9
10BAA:  MOVLB  0
10BAC:  CALL   50E8
10BB0:  MOVLB  8
10BB2:  BCF    FD8.1
10BB4:  CLRF   1B
10BB6:  BTFSC  FF2.7
10BB8:  BSF    1B.7
10BBA:  BCF    FF2.7
10BBC:  MOVFF  8C5,A34
10BC0:  MOVFF  8C4,A33
10BC4:  MOVFF  8C3,A32
10BC8:  MOVFF  8C2,A31
10BCC:  MOVLB  A
10BCE:  CLRF   x38
10BD0:  CLRF   x37
10BD2:  CLRF   x36
10BD4:  MOVLW  0A
10BD6:  MOVWF  x35
10BD8:  MOVLB  0
10BDA:  CALL   1042
10BDE:  BTFSC  1B.7
10BE0:  BSF    FF2.7
10BE2:  MOVFF  03,8C5
10BE6:  MOVFF  02,8C4
10BEA:  MOVFF  01,8C3
10BEE:  MOVFF  00,8C2
10BF2:  MOVLB  8
10BF4:  DECFSZ xC0,F
10BF6:  BRA    10ACE
10BF8:  MOVLB  0
10BFA:  RETURN 0
*
124FC:  ADDWF  FE8,W
124FE:  CLRF   FF7
12500:  RLCF   FF7,F
12502:  ADDLW  1D
12504:  MOVWF  FF6
12506:  MOVLW  25
12508:  ADDWFC FF7,F
1250A:  MOVLW  01
1250C:  MOVWF  FF8
1250E:  MOVWF  FFB
12510:  TBLRD*-
12512:  MOVF   FF5,W
12514:  MOVWF  FFA
12516:  TBLRD*
12518:  MOVF   FF5,W
1251A:  MOVWF  FF9
1251C:  DATA C0,24
1251E:  DATA C8,24
12520:  DATA CE,24
12522:  DATA D4,24
*
1259E:  MOVLW  8E
125A0:  MOVWF  00
125A2:  MOVLB  8
125A4:  MOVF   xFD,W
125A6:  SUBWF  00,F
125A8:  MOVFF  8FE,02
125AC:  MOVFF  8FF,01
125B0:  BSF    02.7
125B2:  MOVF   00,F
125B4:  BZ    125C8
125B6:  BCF    FD8.0
125B8:  MOVF   02,F
125BA:  BNZ   125C0
125BC:  MOVF   01,F
125BE:  BZ    125C8
125C0:  RRCF   02,F
125C2:  RRCF   01,F
125C4:  DECFSZ 00,F
125C6:  BRA    125B6
125C8:  BTFSS  xFE.7
125CA:  BRA    125D6
125CC:  COMF   01,F
125CE:  COMF   02,F
125D0:  INCF   01,F
125D2:  BTFSC  FD8.2
125D4:  INCF   02,F
125D6:  MOVLB  0
125D8:  RETURN 0
*
130A8:  ADDWF  FE8,W
130AA:  CLRF   FF7
130AC:  RLCF   FF7,F
130AE:  ADDLW  C9
130B0:  MOVWF  FF6
130B2:  MOVLW  30
130B4:  ADDWFC FF7,F
130B6:  MOVLW  01
130B8:  MOVWF  FF8
130BA:  MOVWF  FFB
130BC:  TBLRD*-
130BE:  MOVF   FF5,W
130C0:  MOVWF  FFA
130C2:  TBLRD*
130C4:  MOVF   FF5,W
130C6:  MOVWF  FF9
130C8:  DATA E4,2E
130CA:  DATA EA,2E
130CC:  DATA 08,2F
130CE:  DATA 26,2F
*
13140:  MOVLB  8
13142:  MOVF   xC7,W
13144:  XORWF  xC9,W
13146:  ANDLW  80
13148:  MOVWF  xCB
1314A:  BTFSS  xC7.7
1314C:  BRA    13158
1314E:  COMF   xC6,F
13150:  COMF   xC7,F
13152:  INCF   xC6,F
13154:  BTFSC  FD8.2
13156:  INCF   xC7,F
13158:  BTFSS  xC9.7
1315A:  BRA    13166
1315C:  COMF   xC8,F
1315E:  COMF   xC9,F
13160:  INCF   xC8,F
13162:  BTFSC  FD8.2
13164:  INCF   xC9,F
13166:  MOVF   xC6,W
13168:  MULWF  xC8
1316A:  MOVFF  FF3,01
1316E:  MOVFF  FF4,00
13172:  MULWF  xC9
13174:  MOVF   FF3,W
13176:  ADDWF  00,F
13178:  MOVF   xC7,W
1317A:  MULWF  xC8
1317C:  MOVF   FF3,W
1317E:  ADDWFC 00,W
13180:  MOVWF  02
13182:  BTFSS  xCB.7
13184:  BRA    13190
13186:  COMF   01,F
13188:  COMF   02,F
1318A:  INCF   01,F
1318C:  BTFSC  FD8.2
1318E:  INCF   02,F
13190:  MOVLB  0
13192:  GOTO   13270 (RETURN)
*
13EBA:  ADDWF  FE8,W
13EBC:  CLRF   FF7
13EBE:  RLCF   FF7,F
13EC0:  ADDLW  DB
13EC2:  MOVWF  FF6
13EC4:  MOVLW  3E
13EC6:  ADDWFC FF7,F
13EC8:  MOVLW  01
13ECA:  MOVWF  FF8
13ECC:  MOVWF  FFB
13ECE:  TBLRD*-
13ED0:  MOVF   FF5,W
13ED2:  MOVWF  FFA
13ED4:  TBLRD*
13ED6:  MOVF   FF5,W
13ED8:  MOVWF  FF9
13EDA:  DATA 86,3D
13EDC:  DATA AE,3E
13EDE:  DATA B2,3D
13EE0:  DATA AE,3E
13EE2:  DATA 7E,3C
13EE4:  DATA AE,3E
13EE6:  DATA AE,3E
13EE8:  DATA AE,3E
13EEA:  DATA AE,3E
13EEC:  DATA AE,3E
13EEE:  DATA AE,3E
13EF0:  DATA AE,3E
13EF2:  DATA AE,3E
13EF4:  DATA AE,3E
13EF6:  DATA AE,3E
13EF8:  DATA AE,3E
13EFA:  DATA A6,3E
13EFC:  DATA AE,3E
13EFE:  DATA AE,3E
13F00:  DATA AE,3E
13F02:  DATA AE,3E
13F04:  DATA AE,3E
13F06:  DATA 1E,3C
13F08:  DATA AE,3E
13F0A:  DATA 52,3C
13F0C:  DATA 5A,3C
13F0E:  DATA AE,3E
13F10:  DATA 6E,3C
13F12:  DATA DE,3D
13F14:  DATA A2,3C
13F16:  DATA AE,3E
13F18:  DATA AE,3E
13F1A:  DATA 34,3D
13F1C:  DATA 16,3D
13F1E:  DATA AE,3E
13F20:  DATA AE,3E
13F22:  DATA AE,3E
13F24:  DATA F8,3D
13F26:  DATA 24,3E
13F28:  DATA 50,3E
13F2A:  DATA 50,3D
13F2C:  DATA 7C,3D
13F2E:  DATA AE,3E
13F30:  DATA AE,3E
13F32:  DATA AE,3E
13F34:  DATA AE,3E
13F36:  DATA 7C,3E
13F38:  DATA AE,3E
13F3A:  DATA AE,3E
13F3C:  DATA AE,3E
13F3E:  DATA AE,3E
13F40:  DATA AE,3E
13F42:  DATA AE,3E
13F44:  DATA AE,3E
13F46:  DATA AE,3E
13F48:  DATA AE,3E
13F4A:  DATA AE,3E
13F4C:  DATA 8A,3C
13F4E:  DATA AE,3E
13F50:  DATA AE,3E
13F52:  DATA AE,3E
13F54:  DATA AE,3E
13F56:  DATA BA,3C
13F58:  DATA AE,3E
13F5A:  DATA AE,3E
13F5C:  DATA E0,3C
13F5E:  DATA AE,3E
13F60:  DATA AE,3E
13F62:  DATA AE,3E
13F64:  DATA 2E,3C
*
1401A:  MOVFF  FEA,8AA
1401E:  MOVFF  FE9,8A9
14022:  MOVLB  8
14024:  SWAPF  xA3,W
14026:  IORLW  F0
14028:  MOVWF  xA5
1402A:  ADDWF  xA5,F
1402C:  ADDLW  E2
1402E:  MOVWF  xA6
14030:  ADDLW  32
14032:  MOVWF  xA8
14034:  MOVF   xA3,W
14036:  ANDLW  0F
14038:  ADDWF  xA6,F
1403A:  ADDWF  xA6,F
1403C:  ADDWF  xA8,F
1403E:  ADDLW  E9
14040:  MOVWF  xA7
14042:  ADDWF  xA7,F
14044:  ADDWF  xA7,F
14046:  SWAPF  xA2,W
14048:  ANDLW  0F
1404A:  ADDWF  xA7,F
1404C:  ADDWF  xA8,F
1404E:  RLCF   xA7,F
14050:  RLCF   xA8,F
14052:  COMF   xA8,F
14054:  RLCF   xA8,F
14056:  MOVF   xA2,W
14058:  ANDLW  0F
1405A:  ADDWF  xA8,F
1405C:  RLCF   xA5,F
1405E:  MOVLW  07
14060:  MOVWF  xA4
14062:  MOVLW  0A
14064:  DECF   xA7,F
14066:  ADDWF  xA8,F
14068:  BNC   14064
1406A:  DECF   xA6,F
1406C:  ADDWF  xA7,F
1406E:  BNC   1406A
14070:  DECF   xA5,F
14072:  ADDWF  xA6,F
14074:  BNC   14070
14076:  DECF   xA4,F
14078:  ADDWF  xA5,F
1407A:  BNC   14076
1407C:  MOVLW  08
1407E:  MOVWF  FEA
14080:  MOVLW  A4
14082:  MOVWF  FE9
14084:  MOVLW  07
14086:  ANDWF  xA9,W
14088:  BCF    xA9.6
1408A:  ADDWF  FE9,F
1408C:  MOVLW  00
1408E:  ADDWFC FEA,F
14090:  MOVF   FE9,W
14092:  SUBLW  A8
14094:  BNZ   1409E
14096:  MOVF   FEA,W
14098:  SUBLW  08
1409A:  BNZ   1409E
1409C:  BSF    xA9.6
1409E:  MOVF   FEF,W
140A0:  MOVWF  00
140A2:  BNZ   140B4
140A4:  BTFSC  xA9.6
140A6:  BRA    140B4
140A8:  BTFSC  xA9.4
140AA:  BRA    140C8
140AC:  BTFSC  xA9.3
140AE:  BRA    140B4
140B0:  MOVLW  20
140B2:  BRA    140BA
140B4:  BSF    xA9.3
140B6:  BCF    xA9.4
140B8:  MOVLW  30
140BA:  ADDWF  00,F
140BC:  MOVF   00,W
140BE:  BTFSS  FA4.4
140C0:  BRA    140BE
140C2:  MOVLB  F
140C4:  MOVWF  x1C
140C6:  MOVLB  8
140C8:  MOVF   FEE,W
140CA:  BTFSS  xA9.6
140CC:  BRA    14090
140CE:  MOVLB  0
140D0:  GOTO   1416C (RETURN)
*
145B0:  ADDWF  FE8,W
145B2:  CLRF   FF7
145B4:  RLCF   FF7,F
145B6:  ADDLW  D1
145B8:  MOVWF  FF6
145BA:  MOVLW  45
145BC:  ADDWFC FF7,F
145BE:  MOVLW  01
145C0:  MOVWF  FF8
145C2:  MOVWF  FFB
145C4:  TBLRD*-
145C6:  MOVF   FF5,W
145C8:  MOVWF  FFA
145CA:  TBLRD*
145CC:  MOVF   FF5,W
145CE:  MOVWF  FF9
145D0:  DATA 9C,41
145D2:  DATA FC,41
145D4:  DATA 18,42
145D6:  DATA 34,42
145D8:  DATA 50,42
145DA:  DATA 6C,42
145DC:  DATA 88,42
145DE:  DATA A4,42
145E0:  DATA C0,42
145E2:  DATA DC,42
145E4:  DATA F8,42
145E6:  DATA 14,43
145E8:  DATA 30,43
145EA:  DATA 4C,43
145EC:  DATA 68,43
145EE:  DATA 84,43
145F0:  DATA A0,43
145F2:  DATA BC,43
145F4:  DATA D8,43
145F6:  DATA F4,43
145F8:  DATA 10,44
145FA:  DATA 2C,44
145FC:  DATA 48,44
145FE:  DATA 64,44
14600:  DATA 80,44
14602:  DATA 9C,44
14604:  DATA B8,44
14606:  DATA D4,44
14608:  DATA F0,44
1460A:  DATA 0C,45
1460C:  DATA 28,45
1460E:  DATA 44,45
14610:  DATA 60,45
*
14DE6:  ADDWF  FE8,W
14DE8:  CLRF   FF7
14DEA:  RLCF   FF7,F
14DEC:  ADDLW  07
14DEE:  MOVWF  FF6
14DF0:  MOVLW  4E
14DF2:  ADDWFC FF7,F
14DF4:  MOVLW  01
14DF6:  MOVWF  FF8
14DF8:  MOVWF  FFB
14DFA:  TBLRD*-
14DFC:  MOVF   FF5,W
14DFE:  MOVWF  FFA
14E00:  TBLRD*
14E02:  MOVF   FF5,W
14E04:  MOVWF  FF9
14E06:  DATA F2,49
14E08:  DATA 1A,4B
14E0A:  DATA 1E,4A
14E0C:  DATA 1A,4B
14E0E:  DATA E4,48
14E10:  DATA 1A,4B
14E12:  DATA 1A,4B
14E14:  DATA 1A,4B
14E16:  DATA 1A,4B
14E18:  DATA 1A,4B
14E1A:  DATA 1A,4B
14E1C:  DATA 1A,4B
14E1E:  DATA 1A,4B
14E20:  DATA 1A,4B
14E22:  DATA 1A,4B
14E24:  DATA 1A,4B
14E26:  DATA 12,4B
14E28:  DATA 1A,4B
14E2A:  DATA 1A,4B
14E2C:  DATA 1A,4B
14E2E:  DATA 1A,4B
14E30:  DATA 1A,4B
14E32:  DATA EE,46
14E34:  DATA 1A,4B
14E36:  DATA 22,47
14E38:  DATA C0,48
14E3A:  DATA 1A,4B
14E3C:  DATA D4,48
14E3E:  DATA 4A,4A
14E40:  DATA 08,49
14E42:  DATA 1A,4B
14E44:  DATA 1A,4B
14E46:  DATA 9A,49
14E48:  DATA 7C,49
14E4A:  DATA 1A,4B
14E4C:  DATA 1A,4B
14E4E:  DATA 1A,4B
14E50:  DATA 64,4A
14E52:  DATA 90,4A
14E54:  DATA BC,4A
14E56:  DATA B6,49
14E58:  DATA E6,49
14E5A:  DATA 1A,4B
14E5C:  DATA 1A,4B
14E5E:  DATA 1A,4B
14E60:  DATA 1A,4B
14E62:  DATA E8,4A
14E64:  DATA 1A,4B
14E66:  DATA 1A,4B
14E68:  DATA 1A,4B
14E6A:  DATA 1A,4B
14E6C:  DATA 1A,4B
14E6E:  DATA 1A,4B
14E70:  DATA 1A,4B
14E72:  DATA 1A,4B
14E74:  DATA 1A,4B
14E76:  DATA 1A,4B
14E78:  DATA F0,48
14E7A:  DATA 1A,4B
14E7C:  DATA 1A,4B
14E7E:  DATA 1A,4B
14E80:  DATA 1A,4B
14E82:  DATA 20,49
14E84:  DATA 1A,4B
14E86:  DATA 1A,4B
14E88:  DATA 46,49
14E8A:  DATA 1A,4B
14E8C:  DATA 1A,4B
14E8E:  DATA 1A,4B
14E90:  DATA FE,46
14E92:  DATA 1A,4B
14E94:  DATA 2A,47
*
152F8:  ADDWF  FE8,W
152FA:  CLRF   FF7
152FC:  RLCF   FF7,F
152FE:  ADDLW  19
15300:  MOVWF  FF6
15302:  MOVLW  53
15304:  ADDWFC FF7,F
15306:  MOVLW  01
15308:  MOVWF  FF8
1530A:  MOVWF  FFB
1530C:  TBLRD*-
1530E:  MOVF   FF5,W
15310:  MOVWF  FFA
15312:  TBLRD*
15314:  MOVF   FF5,W
15316:  MOVWF  FF9
15318:  DATA 6A,51
1531A:  DATA 8A,51
1531C:  DATA AA,51
1531E:  DATA CA,51
15320:  DATA EA,51
15322:  DATA 0A,52
15324:  DATA 2A,52
*
1ADEC:  ADDWF  FE8,W
1ADEE:  CLRF   FF7
1ADF0:  RLCF   FF7,F
1ADF2:  ADDLW  0D
1ADF4:  MOVWF  FF6
1ADF6:  MOVLW  AE
1ADF8:  ADDWFC FF7,F
1ADFA:  MOVLW  01
1ADFC:  MOVWF  FF8
1ADFE:  MOVWF  FFB
1AE00:  TBLRD*-
1AE02:  MOVF   FF5,W
1AE04:  MOVWF  FFA
1AE06:  TBLRD*
1AE08:  MOVF   FF5,W
1AE0A:  MOVWF  FF9
1AE0C:  DATA 6C,AC
1AE0E:  DATA E8,AD
1AE10:  DATA 72,AC
1AE12:  DATA 66,AC
1AE14:  DATA E8,AD
1AE16:  DATA E8,AD
1AE18:  DATA E8,AD
1AE1A:  DATA 78,AC
1AE1C:  DATA 2C,AD
1AE1E:  DATA E8,AD
1AE20:  DATA 48,AD
1AE22:  DATA E8,AD
1AE24:  DATA 7E,AC
1AE26:  DATA E8,AD
1AE28:  DATA E8,AD
1AE2A:  DATA E8,AD
1AE2C:  DATA E8,AD
1AE2E:  DATA E8,AD
1AE30:  DATA E8,AD
1AE32:  DATA E8,AD
1AE34:  DATA E8,AD
1AE36:  DATA E8,AD
1AE38:  DATA E8,AD
1AE3A:  DATA E8,AD
1AE3C:  DATA E8,AD
1AE3E:  DATA E8,AD
1AE40:  DATA E8,AD
1AE42:  DATA E8,AD
1AE44:  DATA E8,AD
1AE46:  DATA E8,AD
1AE48:  DATA 84,AC
1AE4A:  DATA 8A,AC
1AE4C:  DATA 90,AC
1AE4E:  DATA 96,AC
1AE50:  DATA 9C,AC
1AE52:  DATA A2,AC
1AE54:  DATA A8,AC
1AE56:  DATA AE,AC
1AE58:  DATA B4,AC
1AE5A:  DATA BA,AC
1AE5C:  DATA C0,AC
1AE5E:  DATA C6,AC
1AE60:  DATA CC,AC
1AE62:  DATA D8,AC
1AE64:  DATA DE,AC
1AE66:  DATA E4,AC
1AE68:  DATA EA,AC
1AE6A:  DATA F0,AC
1AE6C:  DATA F6,AC
1AE6E:  DATA FC,AC
1AE70:  DATA 02,AD
1AE72:  DATA 08,AD
1AE74:  DATA 0E,AD
1AE76:  DATA 14,AD
1AE78:  DATA 1A,AD
1AE7A:  DATA 20,AD
1AE7C:  DATA E8,AD
1AE7E:  DATA E8,AD
1AE80:  DATA E8,AD
1AE82:  DATA 26,AD
1AE84:  DATA E8,AD
1AE86:  DATA E8,AD
1AE88:  DATA 64,AD
1AE8A:  DATA 6A,AD
1AE8C:  DATA 70,AD
1AE8E:  DATA 76,AD
1AE90:  DATA 7C,AD
1AE92:  DATA 82,AD
1AE94:  DATA 88,AD
1AE96:  DATA 8E,AD
1AE98:  DATA 94,AD
1AE9A:  DATA 9A,AD
1AE9C:  DATA A0,AD
1AE9E:  DATA A6,AD
1AEA0:  DATA AC,AD
1AEA2:  DATA B2,AD
1AEA4:  DATA B8,AD
1AEA6:  DATA BE,AD
1AEA8:  DATA C4,AD
1AEAA:  DATA CA,AD
1AEAC:  DATA CE,AD
1AEAE:  DATA D2,AD
1AEB0:  DATA D6,AD
1AEB2:  DATA E8,AD
1AEB4:  DATA DA,AD
1AEB6:  DATA DE,AD
1AEB8:  DATA E2,AD
1AEBA:  DATA E6,AD
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8DE
1F8BA:  MOVFF  FF7,8DF
1F8BE:  MOVFF  FF8,8E0
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8DE,FF6
1F8CE:  MOVFF  8DF,FF7
1F8D2:  MOVFF  8E0,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8DF
1F8E0:  MOVFF  FF7,8E0
1F8E4:  MOVFF  FF8,8E1
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8DF,FF6
1F8F4:  MOVFF  8E0,FF7
1F8F8:  MOVFF  8E1,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xDE,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xDF.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xDE,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xDF,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xDE,F
1F936:  MOVLW  0A
1F938:  SUBWF  xDE,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xDF.7
1F942:  MOVF   xDF,W
1F944:  ADDWF  xDE,F
1F946:  MOVF   xDE,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xE1,W
1F956:  CLRF   01
1F958:  SUBWF  xE0,W
1F95A:  BC    1F962
1F95C:  MOVFF  8E0,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xE2
1F968:  RLCF   xE0,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xE1,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xE2,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8DE,8E0
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xE1
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8DE
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xDF.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xDF.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xDF.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xDF.3
1F9AC:  BCF    xDF.4
1F9AE:  BSF    xDF.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8DE,8E0
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xE1
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8DE
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xDF.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xDF.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xDF.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xDE,F
1F9F0:  MOVF   xDE,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8DE,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8DF,01
1FA60:  MOVFF  8DE,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... //#ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... //#else 
....................    //#FUSES NOMCLR 
.................... //#endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... //#FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... //#FUSES WDT_SW   
.................... //#fuses WDT//, WDT16 
.................... //#fuses WDT// WDT is s/w controlled 
.................... //#use delay(clock=2000000) 
....................  
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
02964:  MOVLW  09
02966:  MOVWF  FEA
02968:  MOVLW  D6
0296A:  MOVWF  FE9
0296C:  MOVF   FEF,W
0296E:  BZ    298C
02970:  MOVLW  14
02972:  MOVWF  01
02974:  CLRF   00
02976:  DECFSZ 00,F
02978:  BRA    2976
0297A:  DECFSZ 01,F
0297C:  BRA    2974
0297E:  MOVLW  BF
02980:  MOVWF  00
02982:  DECFSZ 00,F
02984:  BRA    2982
02986:  BRA    2988
02988:  DECFSZ FEF,F
0298A:  BRA    2970
0298C:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E24:  BTFSS  F9E.5
00E26:  BRA    0E24
00E28:  MOVFF  FAB,1C
00E2C:  MOVFF  FAE,01
00E30:  BTFSS  1C.1
00E32:  BRA    0E38
00E34:  BCF    FAB.4
00E36:  BSF    FAB.4
00E38:  RETURN 0
*
0AEA6:  BTFSS  F9E.4
0AEA8:  BRA    AEA6
0AEAA:  MOVWF  FAD
0AEAC:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12BD2:  BTFSS  FA4.5
12BD4:  BRA    12BD2
12BD6:  MOVLB  F
12BD8:  MOVFF  F22,1C
12BDC:  MOVFF  F1D,01
12BE0:  BTFSS  1C.1
12BE2:  BRA    12BE8
12BE4:  BCF    x22.4
12BE6:  BSF    x22.4
12BE8:  MOVLB  0
12BEA:  RETURN 0
*
16B28:  BTFSS  FA4.4
16B2A:  BRA    16B28
16B2C:  MOVLB  F
16B2E:  MOVWF  x1C
16B30:  MOVLB  0
16B32:  GOTO   16BD6 (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xE4
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xE5
1F850:  MOVF   xE5,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8E3,03
1F85A:  MOVFF  8E2,FE9
1F85E:  MOVFF  8E3,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xE4,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8E6
1F870:  MOVFF  8E2,FE9
1F874:  MOVFF  8E3,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xE6,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xE4
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xE4,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8E6
1F88C:  MOVFF  8E2,FE9
1F890:  MOVFF  8E3,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xE6,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xE4
....................       }  
1F89C:  MOVF   xE5,W
1F89E:  INCF   xE5,F
1F8A0:  INCF   xE2,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xE3,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8E4,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xE2,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8DF,03
1FA84:  MOVFF  8DE,FE9
1FA88:  MOVFF  8DF,FEA
1FA8C:  MOVFF  FEF,8E3
1FA90:  MOVFF  8E1,03
1FA94:  MOVFF  8E0,FE9
1FA98:  MOVFF  8E1,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xE3,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8DF,03
1FAA6:  MOVFF  8DE,FE9
1FAAA:  MOVFF  8DF,FEA
1FAAE:  MOVFF  FEF,8E3
1FAB2:  MOVFF  8E1,03
1FAB6:  MOVFF  8E0,FE9
1FABA:  MOVFF  8E1,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xE3,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8DF,03
1FAD4:  MOVFF  8DE,FE9
1FAD8:  MOVFF  8DF,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8DF,03
1FAEA:  MOVF   xDE,W
1FAEC:  INCF   xDE,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xDF,F
1FAF2:  MOVFF  8E1,03
1FAF6:  MOVF   xE0,W
1FAF8:  INCF   xE0,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xE1,F
1FAFE:  DECF   xE2,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x6F.1
1FB0E:  CLRF   x79
1FB10:  CLRF   x78
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xD6
1FB2A:  MOVLB  0
1FB2C:  CALL   2964
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x6F.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x75
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x75,W
1FB3C:  ADDLW  9E
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x75,W
1FB50:  INCF   x75,F
1FB52:  CLRF   03
1FB54:  ADDLW  9E
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x75,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x6F.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   x9E,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xE3
1FB80:  MOVLW  9F
1FB82:  MOVWF  xE2
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,874
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xE3
1FB92:  MOVLW  A1
1FB94:  MOVWF  xE2
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8DE
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xE3
1FBA4:  MOVLW  A3
1FBA6:  MOVWF  xE2
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8DE,877
1FBB0:  MOVFF  01,876
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xE3
1FBBA:  MOVLW  A5
1FBBC:  MOVWF  xE2
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,871
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  878,87C
1FBCA:  MOVFF  879,87D
1FBCE:  MOVFF  876,87A
1FBD2:  MOVFF  877,87B
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x71,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x6F.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x6F.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x7D,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x7C,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x7B,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x7D,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x7C,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x7D,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x7C,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x70
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x73
1FC26:  MOVLW  03
1FC28:  SUBWF  x75,W
1FC2A:  SUBWF  x73,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x73,W
1FC32:  ADDLW  9E
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8DE
1FC3E:  MOVFF  03,8DF
1FC42:  MOVFF  03,8E3
1FC46:  MOVFF  01,8E2
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x70,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x73,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x70,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x70
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x75,W
1FC68:  CLRF   03
1FC6A:  ADDLW  9E
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8DE
1FC76:  MOVFF  03,8DF
1FC7A:  MOVFF  03,8E3
1FC7E:  MOVFF  01,8E2
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x70,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x6F.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x71,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x73
1FCAE:  CLRF   x72
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x75,W
1FCB4:  SUBWF  x73,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x72,W
1FCBA:  INCF   x72,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  7E
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8DE
1FCCA:  MOVFF  03,8DF
1FCCE:  CLRF   03
1FCD0:  MOVF   x73,W
1FCD2:  ADDLW  9E
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8E0
1FCDE:  MOVFF  03,8E1
1FCE2:  MOVFF  03,8E3
1FCE6:  MOVFF  01,8E2
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8DF,FEA
1FCF2:  MOVFF  8DE,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x73,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xDE
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  87D,8DE
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xDF
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  87C,8DE
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xDF
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  87B,8DE
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xDF
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  87A,8DE
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xDF
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  874,8DE
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xDF
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  87C,FF8
1FD80:  MOVFF  87B,FF7
1FD84:  MOVFF  87A,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  7E
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  874,8DE
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  87C,FF8
1FD9A:  MOVFF  87B,FF7
1FD9E:  MOVFF  87A,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  9E
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xDF
1FDAE:  MOVFF  874,8DE
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xDF
1FDBC:  MOVLW  7E
1FDBE:  MOVWF  xDE
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xE1
1FDC4:  MOVLW  9E
1FDC6:  MOVWF  xE0
1FDC8:  MOVFF  874,8E2
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x6F.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x71,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xE3
1FE02:  MOVLW  A7
1FE04:  MOVWF  xE2
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8DE
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xE3
1FE14:  MOVLW  A9
1FE16:  MOVWF  xE2
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8DE,879
1FE20:  MOVFF  01,878
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xDE
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  878,8DE
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xDF
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x6F.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x6F.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xDE
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xD6
1FE8E:  MOVLB  0
1FE90:  CALL   2964
1FE94:  MOVLB  8
1FE96:  DECFSZ xDE,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
0559A:  BCF    FF2.5
....................    restart_wdt(); 
0559C:  CLRWDT
0559E:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
055A0:  CLRF   FCF
055A2:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
055A4:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
055A6:  MOVF   2F,W
055A8:  SUBLW  02
055AA:  BNZ   55B2
055AC:  MOVF   30,F
055AE:  BNZ   55B2
055B0:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
055B2:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
055B4:  BSF    F9D.0
055B6:  GOTO   55CA (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
055BA:  MOVLW  0B
055BC:  MOVWF  FD7
055BE:  MOVLW  DC
055C0:  MOVWF  FD6
....................    restart_wdt(); 
055C2:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
055C4:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
055C6:  BSF    FF2.5
....................    setup_led_pulse(); 
055C8:  BRA    55A0
055CA:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
055CC:  MOVLB  8
055CE:  MOVF   xD7,W
055D0:  XORLW  00
055D2:  MOVLB  0
055D4:  BZ    55DC
055D6:  XORLW  01
055D8:  BZ    55E0
055DA:  BRA    55E2
....................       case 0 : suspend_heartbeat(); 
055DC:  RCALL  559A
....................          break; 
055DE:  BRA    55E2
....................       case 1 : restart_heartbeat(); 
055E0:  RCALL  55BA
....................          break; 
....................    } 
055E2:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
0314A:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
0314C:  BCF    FD1.0
0314E:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
02954:  MOVLW  0B
02956:  MOVWF  FD7
02958:  MOVLW  DC
0295A:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
0295C:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
0295E:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
02960:  BSF    FD1.0
02962:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
07940:  MOVFF  99B,9A1
07944:  MOVFF  99A,9A0
07948:  MOVLB  9
0794A:  MOVF   x9E,F
0794C:  BNZ   7952
0794E:  MOVF   x9F,F
07950:  BZ    799C
07952:  MOVFF  99D,03
07956:  MOVFF  99C,FE9
0795A:  MOVFF  99D,FEA
0795E:  MOVF   FEF,F
07960:  BZ    799C
....................      *s++ = *s2++; 
07962:  MOVFF  9A1,9A3
07966:  MOVF   xA0,W
07968:  INCF   xA0,F
0796A:  BTFSC  FD8.2
0796C:  INCF   xA1,F
0796E:  MOVWF  xA2
07970:  MOVFF  99D,03
07974:  MOVF   x9C,W
07976:  INCF   x9C,F
07978:  BTFSC  FD8.2
0797A:  INCF   x9D,F
0797C:  MOVWF  FE9
0797E:  MOVFF  03,FEA
07982:  MOVFF  FEF,9A4
07986:  MOVFF  9A3,FEA
0798A:  MOVFF  9A2,FE9
0798E:  MOVFF  9A4,FEF
07992:  MOVF   x9E,W
07994:  BTFSC  FD8.2
07996:  DECF   x9F,F
07998:  DECF   x9E,F
0799A:  BRA    794A
....................   for (; n > 0; n--) 
0799C:  MOVF   x9E,F
0799E:  BNZ   79A4
079A0:  MOVF   x9F,F
079A2:  BZ    79C2
....................      *s++ = '\0'; 
079A4:  MOVFF  9A1,03
079A8:  MOVF   xA0,W
079AA:  INCF   xA0,F
079AC:  BTFSC  FD8.2
079AE:  INCF   xA1,F
079B0:  MOVWF  FE9
079B2:  MOVFF  03,FEA
079B6:  CLRF   FEF
079B8:  MOVF   x9E,W
079BA:  BTFSC  FD8.2
079BC:  DECF   x9F,F
079BE:  DECF   x9E,F
079C0:  BRA    799C
....................  
....................   return(s1); 
079C2:  MOVFF  99A,01
079C6:  MOVFF  99B,02
079CA:  MOVLB  0
079CC:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
05528:  MOVFF  8E3,8E7
0552C:  MOVFF  8E2,8E6
05530:  MOVFF  8E7,03
05534:  MOVLB  8
05536:  MOVFF  8E6,FE9
0553A:  MOVFF  8E7,FEA
0553E:  MOVF   FEF,F
05540:  BZ    554E
05542:  INCF   xE6,F
05544:  BTFSC  FD8.2
05546:  INCF   xE7,F
05548:  MOVLB  0
0554A:  BRA    5530
0554C:  MOVLB  8
....................    while(*s2 != '\0') 
0554E:  MOVFF  8E5,03
05552:  MOVFF  8E4,FE9
05556:  MOVFF  8E5,FEA
0555A:  MOVF   FEF,F
0555C:  BZ    5584
....................    { 
....................       *s = *s2; 
0555E:  MOVFF  8E4,FE9
05562:  MOVFF  8E5,FEA
05566:  MOVFF  FEF,8EA
0556A:  MOVFF  8E7,FEA
0556E:  MOVFF  8E6,FE9
05572:  MOVFF  8EA,FEF
....................       ++s; 
05576:  INCF   xE6,F
05578:  BTFSC  FD8.2
0557A:  INCF   xE7,F
....................       ++s2; 
0557C:  INCF   xE4,F
0557E:  BTFSC  FD8.2
05580:  INCF   xE5,F
05582:  BRA    554E
....................    } 
....................  
....................    *s = '\0'; 
05584:  MOVFF  8E6,FE9
05588:  MOVFF  8E7,FEA
0558C:  CLRF   FEF
....................    return(s1); 
0558E:  MOVFF  8E2,01
05592:  MOVFF  8E3,02
05596:  MOVLB  0
05598:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
12B4E:  MOVFF  8D8,8DE
12B52:  MOVFF  8D7,8DD
12B56:  MOVFF  8DE,03
12B5A:  MOVLB  8
12B5C:  MOVFF  8DD,FE9
12B60:  MOVFF  8DE,FEA
12B64:  MOVF   FEF,F
12B66:  BZ    12B74
12B68:  INCF   xDD,F
12B6A:  BTFSC  FD8.2
12B6C:  INCF   xDE,F
12B6E:  MOVLB  0
12B70:  BRA    12B56
12B72:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12B74:  MOVFF  8DA,03
12B78:  MOVFF  8D9,FE9
12B7C:  MOVFF  8DA,FEA
12B80:  MOVF   FEF,F
12B82:  BZ    12BBC
12B84:  MOVF   xDC,F
12B86:  BNZ   12B8E
12B88:  MOVF   xDB,W
12B8A:  SUBLW  00
12B8C:  BC    12BBC
....................    { 
....................       *s = *s2; 
12B8E:  MOVFF  8D9,FE9
12B92:  MOVFF  8DA,FEA
12B96:  MOVFF  FEF,8E1
12B9A:  MOVFF  8DE,FEA
12B9E:  MOVFF  8DD,FE9
12BA2:  MOVFF  8E1,FEF
....................       ++s; 
12BA6:  INCF   xDD,F
12BA8:  BTFSC  FD8.2
12BAA:  INCF   xDE,F
....................       ++s2; 
12BAC:  INCF   xD9,F
12BAE:  BTFSC  FD8.2
12BB0:  INCF   xDA,F
....................       --n; 
12BB2:  MOVF   xDB,W
12BB4:  BTFSC  FD8.2
12BB6:  DECF   xDC,F
12BB8:  DECF   xDB,F
12BBA:  BRA    12B74
....................    } 
....................  
....................    *s = '\0'; 
12BBC:  MOVFF  8DD,FE9
12BC0:  MOVFF  8DE,FEA
12BC4:  CLRF   FEF
....................    return(s1); 
12BC6:  MOVFF  8D7,01
12BCA:  MOVFF  8D8,02
12BCE:  MOVLB  0
12BD0:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
04660:  MOVFF  9D4,9DA
04664:  MOVFF  9D3,9D9
04668:  MOVFF  9D6,9DC
0466C:  MOVFF  9D5,9DB
04670:  MOVLB  9
04672:  MOVF   xD8,F
04674:  BNZ   467C
04676:  MOVF   xD7,W
04678:  SUBLW  00
0467A:  BC    46DC
.................... { 
....................    if(*su1!=*su2) 
0467C:  MOVFF  9D9,FE9
04680:  MOVFF  9DA,FEA
04684:  MOVFF  FEF,9DD
04688:  MOVFF  9DC,03
0468C:  MOVFF  9DB,FE9
04690:  MOVFF  9DC,FEA
04694:  MOVF   FEF,W
04696:  SUBWF  xDD,W
04698:  BZ    46C6
....................       return ((*su1<*su2)?-1:1); 
0469A:  MOVFF  9DA,03
0469E:  MOVFF  9D9,FE9
046A2:  MOVFF  03,FEA
046A6:  MOVFF  FEF,9DD
046AA:  MOVFF  9DC,03
046AE:  MOVFF  9DB,FE9
046B2:  MOVFF  9DC,FEA
046B6:  MOVF   FEF,W
046B8:  SUBWF  xDD,W
046BA:  BC    46C0
046BC:  MOVLW  FF
046BE:  BRA    46C2
046C0:  MOVLW  01
046C2:  MOVWF  01
046C4:  BRA    46E0
046C6:  INCF   xD9,F
046C8:  BTFSC  FD8.2
046CA:  INCF   xDA,F
046CC:  INCF   xDB,F
046CE:  BTFSC  FD8.2
046D0:  INCF   xDC,F
046D2:  MOVF   xD7,W
046D4:  BTFSC  FD8.2
046D6:  DECF   xD8,F
046D8:  DECF   xD7,F
046DA:  BRA    4672
.................... } 
.................... return 0; 
046DC:  MOVLW  00
046DE:  MOVWF  01
046E0:  MOVLB  0
046E2:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
12B12:  MOVFF  8D6,8D8
12B16:  MOVFF  8D5,8D7
12B1A:  MOVFF  8D8,03
12B1E:  MOVLB  8
12B20:  MOVFF  8D7,FE9
12B24:  MOVFF  8D8,FEA
12B28:  MOVF   FEF,F
12B2A:  BZ    12B38
12B2C:  INCF   xD7,F
12B2E:  BTFSC  FD8.2
12B30:  INCF   xD8,F
12B32:  MOVLB  0
12B34:  BRA    12B1A
12B36:  MOVLB  8
....................    return(sc - s); 
12B38:  MOVF   xD5,W
12B3A:  SUBWF  xD7,W
12B3C:  MOVWF  00
12B3E:  MOVF   xD6,W
12B40:  SUBWFB xD8,W
12B42:  MOVWF  03
12B44:  MOVFF  00,01
12B48:  MOVWF  02
12B4A:  MOVLB  0
12B4C:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
13196:  MOVLB  8
13198:  CLRF   xC4
....................    sign = 0; 
1319A:  CLRF   xC2
....................    base = 10; 
1319C:  MOVLW  0A
1319E:  MOVWF  xC3
....................    result = 0; 
131A0:  CLRF   xC1
131A2:  CLRF   xC0
....................  
....................    if (!s) 
131A4:  MOVF   xBE,W
131A6:  IORWF  xBF,W
131A8:  BNZ   131B2
....................       return 0; 
131AA:  MOVLW  00
131AC:  MOVWF  01
131AE:  MOVWF  02
131B0:  BRA    13376
....................    c = s[index++]; 
131B2:  MOVF   xC4,W
131B4:  INCF   xC4,F
131B6:  ADDWF  xBE,W
131B8:  MOVWF  FE9
131BA:  MOVLW  00
131BC:  ADDWFC xBF,W
131BE:  MOVWF  FEA
131C0:  MOVFF  FEF,8C5
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
131C4:  MOVF   xC5,W
131C6:  SUBLW  2D
131C8:  BNZ   131E2
....................    { 
....................       sign = 1;         // Set the sign to negative 
131CA:  MOVLW  01
131CC:  MOVWF  xC2
....................       c = s[index++]; 
131CE:  MOVF   xC4,W
131D0:  INCF   xC4,F
131D2:  ADDWF  xBE,W
131D4:  MOVWF  FE9
131D6:  MOVLW  00
131D8:  ADDWFC xBF,W
131DA:  MOVWF  FEA
131DC:  MOVFF  FEF,8C5
....................    } 
131E0:  BRA    131FA
....................    else if (c == '+') 
131E2:  MOVF   xC5,W
131E4:  SUBLW  2B
131E6:  BNZ   131FA
....................    { 
....................       c = s[index++]; 
131E8:  MOVF   xC4,W
131EA:  INCF   xC4,F
131EC:  ADDWF  xBE,W
131EE:  MOVWF  FE9
131F0:  MOVLW  00
131F2:  ADDWFC xBF,W
131F4:  MOVWF  FEA
131F6:  MOVFF  FEF,8C5
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
131FA:  MOVF   xC5,W
131FC:  SUBLW  2F
131FE:  BTFSC  FD8.0
13200:  BRA    1335A
13202:  MOVF   xC5,W
13204:  SUBLW  39
13206:  BTFSS  FD8.0
13208:  BRA    1335A
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
1320A:  MOVF   xC5,W
1320C:  SUBLW  30
1320E:  BNZ   1324C
13210:  MOVF   xC4,W
13212:  ADDWF  xBE,W
13214:  MOVWF  FE9
13216:  MOVLW  00
13218:  ADDWFC xBF,W
1321A:  MOVWF  FEA
1321C:  MOVF   FEF,W
1321E:  SUBLW  78
13220:  BZ    13234
13222:  MOVF   xC4,W
13224:  ADDWF  xBE,W
13226:  MOVWF  FE9
13228:  MOVLW  00
1322A:  ADDWFC xBF,W
1322C:  MOVWF  FEA
1322E:  MOVF   FEF,W
13230:  SUBLW  58
13232:  BNZ   1324C
....................       { 
....................          base = 16; 
13234:  MOVLW  10
13236:  MOVWF  xC3
....................          index++; 
13238:  INCF   xC4,F
....................          c = s[index++]; 
1323A:  MOVF   xC4,W
1323C:  INCF   xC4,F
1323E:  ADDWF  xBE,W
13240:  MOVWF  FE9
13242:  MOVLW  00
13244:  ADDWFC xBF,W
13246:  MOVWF  FEA
13248:  MOVFF  FEF,8C5
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
1324C:  MOVF   xC3,W
1324E:  SUBLW  0A
13250:  BNZ   13296
....................       { 
....................          while (c >= '0' && c <= '9') 
13252:  MOVF   xC5,W
13254:  SUBLW  2F
13256:  BC    13294
13258:  MOVF   xC5,W
1325A:  SUBLW  39
1325C:  BNC   13294
....................          { 
....................             result = 10*result + (c - '0'); 
1325E:  CLRF   xC7
13260:  MOVLW  0A
13262:  MOVWF  xC6
13264:  MOVFF  8C1,8C9
13268:  MOVFF  8C0,8C8
1326C:  MOVLB  0
1326E:  BRA    13140
13270:  MOVLW  30
13272:  MOVLB  8
13274:  SUBWF  xC5,W
13276:  ADDWF  01,W
13278:  MOVWF  xC0
1327A:  MOVLW  00
1327C:  ADDWFC 02,W
1327E:  MOVWF  xC1
....................             c = s[index++]; 
13280:  MOVF   xC4,W
13282:  INCF   xC4,F
13284:  ADDWF  xBE,W
13286:  MOVWF  FE9
13288:  MOVLW  00
1328A:  ADDWFC xBF,W
1328C:  MOVWF  FEA
1328E:  MOVFF  FEF,8C5
13292:  BRA    13252
....................          } 
....................       } 
13294:  BRA    1335A
....................       else if (base == 16)    // The number is a hexa number 
13296:  MOVF   xC3,W
13298:  SUBLW  10
1329A:  BNZ   1335A
....................       { 
....................          c = toupper(c); 
1329C:  MOVF   xC5,W
1329E:  SUBLW  60
132A0:  BC    132AE
132A2:  MOVF   xC5,W
132A4:  SUBLW  7A
132A6:  BNC   132AE
132A8:  MOVF   xC5,W
132AA:  ANDLW  DF
132AC:  BRA    132B0
132AE:  MOVF   xC5,W
132B0:  MOVWF  xC5
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
132B2:  MOVF   xC5,W
132B4:  SUBLW  2F
132B6:  BC    132BE
132B8:  MOVF   xC5,W
132BA:  SUBLW  39
132BC:  BC    132CA
132BE:  MOVF   xC5,W
132C0:  SUBLW  40
132C2:  BC    1335A
132C4:  MOVF   xC5,W
132C6:  SUBLW  46
132C8:  BNC   1335A
....................          { 
....................             if (c >= '0' && c <= '9') 
132CA:  MOVF   xC5,W
132CC:  SUBLW  2F
132CE:  BC    13304
132D0:  MOVF   xC5,W
132D2:  SUBLW  39
132D4:  BNC   13304
....................                result = (result << 4) + (c - '0'); 
132D6:  RLCF   xC0,W
132D8:  MOVWF  xC6
132DA:  RLCF   xC1,W
132DC:  MOVWF  xC7
132DE:  RLCF   xC6,F
132E0:  RLCF   xC7,F
132E2:  RLCF   xC6,F
132E4:  RLCF   xC7,F
132E6:  RLCF   xC6,F
132E8:  RLCF   xC7,F
132EA:  MOVLW  F0
132EC:  ANDWF  xC6,F
132EE:  MOVLW  30
132F0:  SUBWF  xC5,W
132F2:  ADDWF  xC6,W
132F4:  MOVWF  01
132F6:  MOVLW  00
132F8:  ADDWFC xC7,W
132FA:  MOVWF  03
132FC:  MOVFF  01,8C0
13300:  MOVWF  xC1
13302:  BRA    13330
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
13304:  RLCF   xC0,W
13306:  MOVWF  xC6
13308:  RLCF   xC1,W
1330A:  MOVWF  xC7
1330C:  RLCF   xC6,F
1330E:  RLCF   xC7,F
13310:  RLCF   xC6,F
13312:  RLCF   xC7,F
13314:  RLCF   xC6,F
13316:  RLCF   xC7,F
13318:  MOVLW  F0
1331A:  ANDWF  xC6,F
1331C:  MOVLW  41
1331E:  SUBWF  xC5,W
13320:  ADDLW  0A
13322:  ADDWF  xC6,W
13324:  MOVWF  01
13326:  MOVLW  00
13328:  ADDWFC xC7,W
1332A:  MOVFF  01,8C0
1332E:  MOVWF  xC1
....................  
....................             c = s[index++];c = toupper(c); 
13330:  MOVF   xC4,W
13332:  INCF   xC4,F
13334:  ADDWF  xBE,W
13336:  MOVWF  FE9
13338:  MOVLW  00
1333A:  ADDWFC xBF,W
1333C:  MOVWF  FEA
1333E:  MOVFF  FEF,8C5
13342:  MOVF   xC5,W
13344:  SUBLW  60
13346:  BC    13354
13348:  MOVF   xC5,W
1334A:  SUBLW  7A
1334C:  BNC   13354
1334E:  MOVF   xC5,W
13350:  ANDLW  DF
13352:  BRA    13356
13354:  MOVF   xC5,W
13356:  MOVWF  xC5
13358:  BRA    132B2
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
1335A:  MOVF   xC3,W
1335C:  SUBLW  0A
1335E:  BNZ   1336E
13360:  DECFSZ xC2,W
13362:  BRA    1336E
....................       result = -result; 
13364:  COMF   xC0,F
13366:  COMF   xC1,F
13368:  INCF   xC0,F
1336A:  BTFSC  FD8.2
1336C:  INCF   xC1,F
....................  
....................    return(result); 
1336E:  MOVFF  8C0,01
13372:  MOVFF  8C1,02
13376:  MOVLB  0
13378:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0C822:  MOVLB  8
0C824:  CLRF   x8E
0C826:  CLRF   x8D
0C828:  CLRF   x8C
0C82A:  MOVLW  7F
0C82C:  MOVWF  x8B
0C82E:  CLRF   x92
0C830:  CLRF   x91
0C832:  CLRF   x90
0C834:  CLRF   x8F
0C836:  BSF    x93.0
0C838:  BCF    x93.1
0C83A:  BCF    x93.2
0C83C:  CLRF   x95
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0C83E:  MOVF   x87,W
0C840:  IORWF  x88,W
0C842:  BNZ   C84E
....................       return 0; 
0C844:  CLRF   00
0C846:  CLRF   01
0C848:  CLRF   02
0C84A:  CLRF   03
0C84C:  BRA    CA7A
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0C84E:  MOVF   x95,W
0C850:  INCF   x95,F
0C852:  ADDWF  x87,W
0C854:  MOVWF  FE9
0C856:  MOVLW  00
0C858:  ADDWFC x88,W
0C85A:  MOVWF  FEA
0C85C:  MOVFF  FEF,894
0C860:  MOVF   x94,F
0C862:  BTFSC  FD8.2
0C864:  BRA    C9FA
....................    { 
....................       if (skip && !isspace(c)) 
0C866:  BTFSS  x93.0
0C868:  BRA    C888
0C86A:  MOVF   x94,W
0C86C:  SUBLW  20
0C86E:  BZ    C888
....................       { 
....................          skip = 0; 
0C870:  BCF    x93.0
....................          if (c == '+') 
0C872:  MOVF   x94,W
0C874:  SUBLW  2B
0C876:  BNZ   C87E
....................          { 
....................             sign = 0; 
0C878:  BCF    x93.1
....................             continue; 
0C87A:  BRA    C9E2
....................          }             
0C87C:  BRA    C888
....................          else if (c == '-') 
0C87E:  MOVF   x94,W
0C880:  SUBLW  2D
0C882:  BNZ   C888
....................          { 
....................             sign = 1; 
0C884:  BSF    x93.1
....................             continue; 
0C886:  BRA    C9E2
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0C888:  BTFSC  x93.0
0C88A:  BRA    C89A
0C88C:  MOVF   x94,W
0C88E:  SUBLW  2E
0C890:  BNZ   C89A
0C892:  BTFSC  x93.2
0C894:  BRA    C89A
....................          point = 1; 
0C896:  BSF    x93.2
0C898:  BRA    C9E2
....................       else if (!skip && isdigit(c)) 
0C89A:  BTFSC  x93.0
0C89C:  BRA    C9DC
0C89E:  MOVF   x94,W
0C8A0:  SUBLW  2F
0C8A2:  BTFSC  FD8.0
0C8A4:  BRA    C9DC
0C8A6:  MOVF   x94,W
0C8A8:  SUBLW  39
0C8AA:  BTFSS  FD8.0
0C8AC:  BRA    C9DC
....................       { 
....................          c -= '0'; 
0C8AE:  MOVLW  30
0C8B0:  SUBWF  x94,F
....................          if (point) 
0C8B2:  BTFSS  x93.2
0C8B4:  BRA    C960
....................          { 
....................             pow10 = pow10 * 10.0; 
0C8B6:  MOVFF  88E,900
0C8BA:  MOVFF  88D,8FF
0C8BE:  MOVFF  88C,8FE
0C8C2:  MOVFF  88B,8FD
0C8C6:  MOVLB  9
0C8C8:  CLRF   x04
0C8CA:  CLRF   x03
0C8CC:  MOVLW  20
0C8CE:  MOVWF  x02
0C8D0:  MOVLW  82
0C8D2:  MOVWF  x01
0C8D4:  MOVLB  0
0C8D6:  CALL   C028
0C8DA:  MOVFF  03,88E
0C8DE:  MOVFF  02,88D
0C8E2:  MOVFF  01,88C
0C8E6:  MOVFF  00,88B
....................             result += (float)c / pow10;    
0C8EA:  MOVLB  9
0C8EC:  CLRF   x02
0C8EE:  MOVFF  894,901
0C8F2:  MOVLB  0
0C8F4:  RCALL  C68E
0C8F6:  MOVFF  03,899
0C8FA:  MOVFF  02,898
0C8FE:  MOVFF  01,897
0C902:  MOVFF  00,896
0C906:  MOVFF  03,8E8
0C90A:  MOVFF  02,8E7
0C90E:  MOVFF  01,8E6
0C912:  MOVFF  00,8E5
0C916:  MOVFF  88E,8EC
0C91A:  MOVFF  88D,8EB
0C91E:  MOVFF  88C,8EA
0C922:  MOVFF  88B,8E9
0C926:  RCALL  C6C4
0C928:  BCF    FD8.1
0C92A:  MOVFF  892,904
0C92E:  MOVFF  891,903
0C932:  MOVFF  890,902
0C936:  MOVFF  88F,901
0C93A:  MOVFF  03,908
0C93E:  MOVFF  02,907
0C942:  MOVFF  01,906
0C946:  MOVFF  00,905
0C94A:  RCALL  C152
0C94C:  MOVFF  03,892
0C950:  MOVFF  02,891
0C954:  MOVFF  01,890
0C958:  MOVFF  00,88F
....................          } 
0C95C:  BRA    C9D8
0C95E:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0C960:  MOVLB  9
0C962:  CLRF   x00
0C964:  MOVLB  8
0C966:  CLRF   xFF
0C968:  MOVLW  20
0C96A:  MOVWF  xFE
0C96C:  MOVLW  82
0C96E:  MOVWF  xFD
0C970:  MOVFF  892,904
0C974:  MOVFF  891,903
0C978:  MOVFF  890,902
0C97C:  MOVFF  88F,901
0C980:  MOVLB  0
0C982:  CALL   C028
0C986:  MOVFF  03,899
0C98A:  MOVFF  02,898
0C98E:  MOVFF  01,897
0C992:  MOVFF  00,896
0C996:  MOVLB  9
0C998:  CLRF   x02
0C99A:  MOVFF  894,901
0C99E:  MOVLB  0
0C9A0:  RCALL  C68E
0C9A2:  BCF    FD8.1
0C9A4:  MOVFF  899,904
0C9A8:  MOVFF  898,903
0C9AC:  MOVFF  897,902
0C9B0:  MOVFF  896,901
0C9B4:  MOVFF  03,908
0C9B8:  MOVFF  02,907
0C9BC:  MOVFF  01,906
0C9C0:  MOVFF  00,905
0C9C4:  CALL   C152
0C9C8:  MOVFF  03,892
0C9CC:  MOVFF  02,891
0C9D0:  MOVFF  01,890
0C9D4:  MOVFF  00,88F
....................          } 
....................       } 
0C9D8:  BRA    C9E4
0C9DA:  MOVLB  8
....................       else if (!skip) 
0C9DC:  BTFSC  x93.0
0C9DE:  BRA    C9E2
....................          break; 
0C9E0:  BRA    C9FA
0C9E2:  MOVLB  0
0C9E4:  MOVLB  8
0C9E6:  MOVF   x95,W
0C9E8:  INCF   x95,F
0C9EA:  ADDWF  x87,W
0C9EC:  MOVWF  FE9
0C9EE:  MOVLW  00
0C9F0:  ADDWFC x88,W
0C9F2:  MOVWF  FEA
0C9F4:  MOVFF  FEF,894
0C9F8:  BRA    C860
....................    } 
....................  
....................    if (sign) 
0C9FA:  BTFSS  x93.1
0C9FC:  BRA    CA36
....................       result = -1*result; 
0C9FE:  MOVLB  9
0CA00:  CLRF   x00
0CA02:  MOVLB  8
0CA04:  CLRF   xFF
0CA06:  MOVLW  80
0CA08:  MOVWF  xFE
0CA0A:  MOVLW  7F
0CA0C:  MOVWF  xFD
0CA0E:  MOVFF  892,904
0CA12:  MOVFF  891,903
0CA16:  MOVFF  890,902
0CA1A:  MOVFF  88F,901
0CA1E:  MOVLB  0
0CA20:  CALL   C028
0CA24:  MOVFF  03,892
0CA28:  MOVFF  02,891
0CA2C:  MOVFF  01,890
0CA30:  MOVFF  00,88F
0CA34:  MOVLB  8
....................        
....................    if(endptr) 
0CA36:  MOVF   x89,W
0CA38:  IORWF  x8A,W
0CA3A:  BZ    CA6A
....................    { 
....................       if (ptr) { 
0CA3C:  MOVF   x95,F
0CA3E:  BZ    CA58
....................          ptr--; 
0CA40:  DECF   x95,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0CA42:  MOVFF  889,FE9
0CA46:  MOVFF  88A,FEA
0CA4A:  MOVF   x95,W
0CA4C:  ADDWF  x87,W
0CA4E:  MOVWF  FEF
0CA50:  MOVLW  00
0CA52:  ADDWFC x88,W
0CA54:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0CA56:  BRA    CA6A
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0CA58:  MOVFF  889,FE9
0CA5C:  MOVFF  88A,FEA
0CA60:  MOVFF  888,FEC
0CA64:  MOVF   FED,F
0CA66:  MOVFF  887,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0CA6A:  MOVFF  88F,00
0CA6E:  MOVFF  890,01
0CA72:  MOVFF  891,02
0CA76:  MOVFF  892,03
0CA7A:  MOVLB  0
0CA7C:  GOTO   CAA4 (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
125DA:  MOVLB  8
125DC:  BCF    xFC.0
....................    y = x; 
125DE:  MOVFF  8F0,8F5
125E2:  MOVFF  8EF,8F4
125E6:  MOVFF  8EE,8F3
125EA:  MOVFF  8ED,8F2
....................  
....................    if (x < 0) 
125EE:  MOVFF  8F0,900
125F2:  MOVFF  8EF,8FF
125F6:  MOVFF  8EE,8FE
125FA:  MOVFF  8ED,8FD
125FE:  MOVLB  9
12600:  CLRF   x04
12602:  CLRF   x03
12604:  CLRF   x02
12606:  CLRF   x01
12608:  MOVLB  0
1260A:  CALL   104EC
1260E:  BNC   1261C
....................    { 
....................       s = 1; 
12610:  MOVLB  8
12612:  BSF    xFC.0
....................       y = -y; 
12614:  MOVF   xF3,W
12616:  XORLW  80
12618:  MOVWF  xF3
1261A:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
1261C:  MOVFF  8F5,900
12620:  MOVFF  8F4,8FF
12624:  MOVFF  8F3,8FE
12628:  MOVFF  8F2,8FD
1262C:  MOVLB  9
1262E:  CLRF   x04
12630:  CLRF   x03
12632:  CLRF   x02
12634:  MOVLW  8E
12636:  MOVWF  x01
12638:  MOVLB  0
1263A:  CALL   104EC
1263E:  BC    12642
12640:  BNZ   12672
....................       res = (float32)(unsigned int16)y; 
12642:  MOVFF  8F5,900
12646:  MOVFF  8F4,8FF
1264A:  MOVFF  8F3,8FE
1264E:  MOVFF  8F2,8FD
12652:  RCALL  1259E
12654:  MOVFF  02,902
12658:  MOVFF  01,901
1265C:  CALL   C68E
12660:  MOVFF  03,8F9
12664:  MOVFF  02,8F8
12668:  MOVFF  01,8F7
1266C:  MOVFF  00,8F6
12670:  BRA    12818
....................  
....................  else if (y < 10000000.0) 
12672:  MOVFF  8F5,900
12676:  MOVFF  8F4,8FF
1267A:  MOVFF  8F3,8FE
1267E:  MOVFF  8F2,8FD
12682:  MOVLW  80
12684:  MOVLB  9
12686:  MOVWF  x04
12688:  MOVLW  96
1268A:  MOVWF  x03
1268C:  MOVLW  18
1268E:  MOVWF  x02
12690:  MOVLW  96
12692:  MOVWF  x01
12694:  MOVLB  0
12696:  CALL   104EC
1269A:  BTFSS  FD8.0
1269C:  BRA    12808
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
1269E:  MOVFF  8F5,900
126A2:  MOVFF  8F4,8FF
126A6:  MOVFF  8F3,8FE
126AA:  MOVFF  8F2,8FD
126AE:  MOVLB  9
126B0:  CLRF   x04
126B2:  CLRF   x03
126B4:  CLRF   x02
126B6:  MOVLW  70
126B8:  MOVWF  x01
126BA:  MOVLB  0
126BC:  CALL   C028
126C0:  MOVFF  03,900
126C4:  MOVFF  02,8FF
126C8:  MOVFF  01,8FE
126CC:  MOVFF  00,8FD
126D0:  RCALL  1259E
126D2:  MOVFF  02,8FB
126D6:  MOVFF  01,8FA
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
126DA:  MOVFF  8F5,900
126DE:  MOVFF  8F4,8FF
126E2:  MOVFF  8F3,8FE
126E6:  MOVFF  8F2,8FD
126EA:  MOVLB  9
126EC:  CLRF   x04
126EE:  CLRF   x03
126F0:  CLRF   x02
126F2:  MOVLW  70
126F4:  MOVWF  x01
126F6:  MOVLB  0
126F8:  CALL   C028
126FC:  MOVFF  03,900
12700:  MOVFF  02,8FF
12704:  MOVFF  01,8FE
12708:  MOVFF  00,8FD
1270C:  MOVFF  8FB,902
12710:  MOVFF  8FA,901
12714:  CALL   C68E
12718:  BSF    FD8.1
1271A:  MOVFF  900,904
1271E:  MOVFF  8FF,903
12722:  MOVFF  8FE,902
12726:  MOVFF  8FD,901
1272A:  MOVFF  03,908
1272E:  MOVFF  02,907
12732:  MOVFF  01,906
12736:  MOVFF  00,905
1273A:  CALL   C152
1273E:  MOVLB  9
12740:  CLRF   x00
12742:  MOVLB  8
12744:  CLRF   xFF
12746:  CLRF   xFE
12748:  MOVLW  8E
1274A:  MOVWF  xFD
1274C:  MOVFF  03,904
12750:  MOVFF  02,903
12754:  MOVFF  01,902
12758:  MOVFF  00,901
1275C:  MOVLB  0
1275E:  CALL   C028
12762:  MOVFF  03,8F5
12766:  MOVFF  02,8F4
1276A:  MOVFF  01,8F3
1276E:  MOVFF  00,8F2
....................       res = 32768.0*(float32)l; 
12772:  MOVFF  8FB,902
12776:  MOVFF  8FA,901
1277A:  CALL   C68E
1277E:  MOVLB  9
12780:  CLRF   x00
12782:  MOVLB  8
12784:  CLRF   xFF
12786:  CLRF   xFE
12788:  MOVLW  8E
1278A:  MOVWF  xFD
1278C:  MOVFF  03,904
12790:  MOVFF  02,903
12794:  MOVFF  01,902
12798:  MOVFF  00,901
1279C:  MOVLB  0
1279E:  CALL   C028
127A2:  MOVFF  03,8F9
127A6:  MOVFF  02,8F8
127AA:  MOVFF  01,8F7
127AE:  MOVFF  00,8F6
....................       res += (float32)(unsigned int16)y; 
127B2:  MOVFF  8F5,900
127B6:  MOVFF  8F4,8FF
127BA:  MOVFF  8F3,8FE
127BE:  MOVFF  8F2,8FD
127C2:  RCALL  1259E
127C4:  MOVFF  02,902
127C8:  MOVFF  01,901
127CC:  CALL   C68E
127D0:  BCF    FD8.1
127D2:  MOVFF  8F9,904
127D6:  MOVFF  8F8,903
127DA:  MOVFF  8F7,902
127DE:  MOVFF  8F6,901
127E2:  MOVFF  03,908
127E6:  MOVFF  02,907
127EA:  MOVFF  01,906
127EE:  MOVFF  00,905
127F2:  CALL   C152
127F6:  MOVFF  03,8F9
127FA:  MOVFF  02,8F8
127FE:  MOVFF  01,8F7
12802:  MOVFF  00,8F6
....................    } 
12806:  BRA    12818
....................  
....................  else 
....................   res = y; 
12808:  MOVFF  8F5,8F9
1280C:  MOVFF  8F4,8F8
12810:  MOVFF  8F3,8F7
12814:  MOVFF  8F2,8F6
....................  
....................  y = y - (float32)(unsigned int16)y; 
12818:  MOVFF  8F5,900
1281C:  MOVFF  8F4,8FF
12820:  MOVFF  8F3,8FE
12824:  MOVFF  8F2,8FD
12828:  RCALL  1259E
1282A:  MOVFF  02,902
1282E:  MOVFF  01,901
12832:  CALL   C68E
12836:  BSF    FD8.1
12838:  MOVFF  8F5,904
1283C:  MOVFF  8F4,903
12840:  MOVFF  8F3,902
12844:  MOVFF  8F2,901
12848:  MOVFF  03,908
1284C:  MOVFF  02,907
12850:  MOVFF  01,906
12854:  MOVFF  00,905
12858:  CALL   C152
1285C:  MOVFF  03,8F5
12860:  MOVFF  02,8F4
12864:  MOVFF  01,8F3
12868:  MOVFF  00,8F2
....................  
....................  if (s) 
1286C:  MOVLB  8
1286E:  BTFSS  xFC.0
12870:  BRA    12878
....................   res = -res; 
12872:  MOVF   xF7,W
12874:  XORLW  80
12876:  MOVWF  xF7
....................  
....................  if (y != 0) 
12878:  MOVFF  8F5,900
1287C:  MOVFF  8F4,8FF
12880:  MOVFF  8F3,8FE
12884:  MOVFF  8F2,8FD
12888:  MOVLB  9
1288A:  CLRF   x04
1288C:  CLRF   x03
1288E:  CLRF   x02
12890:  CLRF   x01
12892:  MOVLB  0
12894:  CALL   104EC
12898:  BZ    12916
....................  { 
....................   if (s == 1 && n == 0) 
1289A:  MOVLB  8
1289C:  BTFSS  xFC.0
1289E:  BRA    128DA
128A0:  MOVF   xF1,F
128A2:  BNZ   128DA
....................    res -= 1.0; 
128A4:  BSF    FD8.1
128A6:  MOVFF  8F9,904
128AA:  MOVFF  8F8,903
128AE:  MOVFF  8F7,902
128B2:  MOVFF  8F6,901
128B6:  MOVLB  9
128B8:  CLRF   x08
128BA:  CLRF   x07
128BC:  CLRF   x06
128BE:  MOVLW  7F
128C0:  MOVWF  x05
128C2:  MOVLB  0
128C4:  CALL   C152
128C8:  MOVFF  03,8F9
128CC:  MOVFF  02,8F8
128D0:  MOVFF  01,8F7
128D4:  MOVFF  00,8F6
128D8:  MOVLB  8
....................  
....................   if (s == 0 && n == 1) 
128DA:  BTFSC  xFC.0
128DC:  BRA    12918
128DE:  DECFSZ xF1,W
128E0:  BRA    12918
....................    res += 1.0; 
128E2:  BCF    FD8.1
128E4:  MOVFF  8F9,904
128E8:  MOVFF  8F8,903
128EC:  MOVFF  8F7,902
128F0:  MOVFF  8F6,901
128F4:  MOVLB  9
128F6:  CLRF   x08
128F8:  CLRF   x07
128FA:  CLRF   x06
128FC:  MOVLW  7F
128FE:  MOVWF  x05
12900:  MOVLB  0
12902:  CALL   C152
12906:  MOVFF  03,8F9
1290A:  MOVFF  02,8F8
1290E:  MOVFF  01,8F7
12912:  MOVFF  00,8F6
12916:  MOVLB  8
....................  } 
....................  if (x == 0) 
12918:  MOVFF  8F0,900
1291C:  MOVFF  8EF,8FF
12920:  MOVFF  8EE,8FE
12924:  MOVFF  8ED,8FD
12928:  MOVLB  9
1292A:  CLRF   x04
1292C:  CLRF   x03
1292E:  CLRF   x02
12930:  CLRF   x01
12932:  MOVLB  0
12934:  CALL   104EC
12938:  BNZ   12946
....................     res = 0; 
1293A:  MOVLB  8
1293C:  CLRF   xF9
1293E:  CLRF   xF8
12940:  CLRF   xF7
12942:  CLRF   xF6
12944:  MOVLB  0
....................  
....................  return (res); 
12946:  MOVFF  8F6,00
1294A:  MOVFF  8F7,01
1294E:  MOVFF  8F8,02
12952:  MOVFF  8F9,03
12956:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
12976:  MOVFF  8EC,8F0
1297A:  MOVFF  8EB,8EF
1297E:  MOVFF  8EA,8EE
12982:  MOVFF  8E9,8ED
12986:  MOVLB  8
12988:  CLRF   xF1
1298A:  MOVLB  0
1298C:  RCALL  125DA
1298E:  GOTO   12A9A (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
12958:  MOVFF  8EC,8F0
1295C:  MOVFF  8EB,8EF
12960:  MOVFF  8EA,8EE
12964:  MOVFF  8E9,8ED
12968:  MOVLW  01
1296A:  MOVLB  8
1296C:  MOVWF  xF1
1296E:  MOVLB  0
12970:  RCALL  125DA
12972:  GOTO   12A52 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
12992:  MOVFF  8E0,900
12996:  MOVFF  8DF,8FF
1299A:  MOVFF  8DE,8FE
1299E:  MOVFF  8DD,8FD
129A2:  MOVLB  9
129A4:  CLRF   x04
129A6:  CLRF   x03
129A8:  CLRF   x02
129AA:  CLRF   x01
129AC:  MOVLB  0
129AE:  CALL   104EC
129B2:  BTFSC  FD8.2
129B4:  BRA    12AF6
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
129B6:  MOVFF  8DC,8E8
129BA:  MOVFF  8DB,8E7
129BE:  MOVFF  8DA,8E6
129C2:  MOVFF  8D9,8E5
129C6:  MOVFF  8E0,8EC
129CA:  MOVFF  8DF,8EB
129CE:  MOVFF  8DE,8EA
129D2:  MOVFF  8DD,8E9
129D6:  CALL   C6C4
129DA:  MOVFF  03,8E8
129DE:  MOVFF  02,8E7
129E2:  MOVFF  01,8E6
129E6:  MOVFF  00,8E5
129EA:  MOVFF  03,900
129EE:  MOVFF  02,8FF
129F2:  MOVFF  01,8FE
129F6:  MOVFF  00,8FD
129FA:  MOVLB  9
129FC:  CLRF   x04
129FE:  CLRF   x03
12A00:  CLRF   x02
12A02:  CLRF   x01
12A04:  MOVLB  0
12A06:  CALL   104EC
12A0A:  BNC   12A54
12A0C:  MOVFF  8DC,8E8
12A10:  MOVFF  8DB,8E7
12A14:  MOVFF  8DA,8E6
12A18:  MOVFF  8D9,8E5
12A1C:  MOVFF  8E0,8EC
12A20:  MOVFF  8DF,8EB
12A24:  MOVFF  8DE,8EA
12A28:  MOVFF  8DD,8E9
12A2C:  CALL   C6C4
12A30:  MOVFF  03,8E8
12A34:  MOVFF  02,8E7
12A38:  MOVFF  01,8E6
12A3C:  MOVFF  00,8E5
12A40:  MOVFF  03,8EC
12A44:  MOVFF  02,8EB
12A48:  MOVFF  01,8EA
12A4C:  MOVFF  00,8E9
12A50:  BRA    12958
12A52:  BRA    12A9A
12A54:  MOVFF  8DC,8E8
12A58:  MOVFF  8DB,8E7
12A5C:  MOVFF  8DA,8E6
12A60:  MOVFF  8D9,8E5
12A64:  MOVFF  8E0,8EC
12A68:  MOVFF  8DF,8EB
12A6C:  MOVFF  8DE,8EA
12A70:  MOVFF  8DD,8E9
12A74:  CALL   C6C4
12A78:  MOVFF  03,8E8
12A7C:  MOVFF  02,8E7
12A80:  MOVFF  01,8E6
12A84:  MOVFF  00,8E5
12A88:  MOVFF  03,8EC
12A8C:  MOVFF  02,8EB
12A90:  MOVFF  01,8EA
12A94:  MOVFF  00,8E9
12A98:  BRA    12976
12A9A:  MOVFF  03,8E4
12A9E:  MOVFF  02,8E3
12AA2:  MOVFF  01,8E2
12AA6:  MOVFF  00,8E1
....................       return(x-(i*y)); 
12AAA:  MOVFF  8E4,900
12AAE:  MOVFF  8E3,8FF
12AB2:  MOVFF  8E2,8FE
12AB6:  MOVFF  8E1,8FD
12ABA:  MOVFF  8E0,904
12ABE:  MOVFF  8DF,903
12AC2:  MOVFF  8DE,902
12AC6:  MOVFF  8DD,901
12ACA:  CALL   C028
12ACE:  BSF    FD8.1
12AD0:  MOVFF  8DC,904
12AD4:  MOVFF  8DB,903
12AD8:  MOVFF  8DA,902
12ADC:  MOVFF  8D9,901
12AE0:  MOVFF  03,908
12AE4:  MOVFF  02,907
12AE8:  MOVFF  01,906
12AEC:  MOVFF  00,905
12AF0:  CALL   C152
12AF4:  BRA    12AF6
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
12AF6:  GOTO   12D90 (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
105E2:  MOVFF  8C4,8C8
105E6:  MOVFF  8C3,8C7
105EA:  MOVFF  8C2,8C6
105EE:  MOVFF  8C1,8C5
....................  
....................    if (y != 1.0) 
105F2:  MOVFF  8C8,900
105F6:  MOVFF  8C7,8FF
105FA:  MOVFF  8C6,8FE
105FE:  MOVFF  8C5,8FD
10602:  MOVLB  9
10604:  CLRF   x04
10606:  CLRF   x03
10608:  CLRF   x02
1060A:  MOVLW  7F
1060C:  MOVWF  x01
1060E:  MOVLB  0
10610:  RCALL  104EC
10612:  BTFSC  FD8.2
10614:  BRA    1095A
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
10616:  MOVLW  08
10618:  MOVLB  8
1061A:  MOVWF  xD7
1061C:  MOVLW  C5
1061E:  MOVWF  FE9
10620:  MOVFF  8D7,FEA
10624:  MOVLW  7E
10626:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
10628:  BSF    FD8.1
1062A:  MOVFF  8C8,904
1062E:  MOVFF  8C7,903
10632:  MOVFF  8C6,902
10636:  MOVFF  8C5,901
1063A:  MOVLB  9
1063C:  CLRF   x08
1063E:  CLRF   x07
10640:  CLRF   x06
10642:  MOVLW  7F
10644:  MOVWF  x05
10646:  MOVLB  0
10648:  CALL   C152
1064C:  MOVFF  03,8D9
10650:  MOVFF  02,8D8
10654:  MOVFF  01,8D7
10658:  MOVFF  00,8D6
1065C:  BCF    FD8.1
1065E:  MOVFF  8C8,904
10662:  MOVFF  8C7,903
10666:  MOVFF  8C6,902
1066A:  MOVFF  8C5,901
1066E:  MOVLB  9
10670:  CLRF   x08
10672:  CLRF   x07
10674:  CLRF   x06
10676:  MOVLW  7F
10678:  MOVWF  x05
1067A:  MOVLB  0
1067C:  CALL   C152
10680:  MOVFF  8D9,8E8
10684:  MOVFF  8D8,8E7
10688:  MOVFF  8D7,8E6
1068C:  MOVFF  8D6,8E5
10690:  MOVFF  03,8EC
10694:  MOVFF  02,8EB
10698:  MOVFF  01,8EA
1069C:  MOVFF  00,8E9
106A0:  CALL   C6C4
106A4:  MOVFF  03,8C8
106A8:  MOVFF  02,8C7
106AC:  MOVFF  01,8C6
106B0:  MOVFF  00,8C5
....................  
....................       y2=y*y; 
106B4:  MOVFF  8C8,900
106B8:  MOVFF  8C7,8FF
106BC:  MOVFF  8C6,8FE
106C0:  MOVFF  8C5,8FD
106C4:  MOVFF  8C8,904
106C8:  MOVFF  8C7,903
106CC:  MOVFF  8C6,902
106D0:  MOVFF  8C5,901
106D4:  CALL   C028
106D8:  MOVFF  03,8D4
106DC:  MOVFF  02,8D3
106E0:  MOVFF  01,8D2
106E4:  MOVFF  00,8D1
....................  
....................       res = pl[0]*y2 + pl[1]; 
106E8:  MOVLW  99
106EA:  MOVLB  9
106EC:  MOVWF  x00
106EE:  MOVLW  47
106F0:  MOVLB  8
106F2:  MOVWF  xFF
106F4:  MOVLW  8A
106F6:  MOVWF  xFE
106F8:  MOVLW  7F
106FA:  MOVWF  xFD
106FC:  MOVFF  8D4,904
10700:  MOVFF  8D3,903
10704:  MOVFF  8D2,902
10708:  MOVFF  8D1,901
1070C:  MOVLB  0
1070E:  CALL   C028
10712:  MOVFF  03,8D9
10716:  MOVFF  02,8D8
1071A:  MOVFF  01,8D7
1071E:  MOVFF  00,8D6
10722:  BCF    FD8.1
10724:  MOVFF  03,904
10728:  MOVFF  02,903
1072C:  MOVFF  01,902
10730:  MOVFF  00,901
10734:  MOVLB  9
10736:  CLRF   x08
10738:  CLRF   x07
1073A:  CLRF   x06
1073C:  MOVLW  80
1073E:  MOVWF  x05
10740:  MOVLB  0
10742:  CALL   C152
10746:  MOVFF  03,8CC
1074A:  MOVFF  02,8CB
1074E:  MOVFF  01,8CA
10752:  MOVFF  00,8C9
....................  
....................       r = ql[0]*y2 + ql[1]; 
10756:  MOVLW  4C
10758:  MOVLB  9
1075A:  MOVWF  x00
1075C:  MOVLW  F3
1075E:  MOVLB  8
10760:  MOVWF  xFF
10762:  MOVLW  3A
10764:  MOVWF  xFE
10766:  MOVLW  7B
10768:  MOVWF  xFD
1076A:  MOVFF  8D4,904
1076E:  MOVFF  8D3,903
10772:  MOVFF  8D2,902
10776:  MOVFF  8D1,901
1077A:  MOVLB  0
1077C:  CALL   C028
10780:  MOVFF  03,8D9
10784:  MOVFF  02,8D8
10788:  MOVFF  01,8D7
1078C:  MOVFF  00,8D6
10790:  BCF    FD8.1
10792:  MOVFF  03,904
10796:  MOVFF  02,903
1079A:  MOVFF  01,902
1079E:  MOVFF  00,901
107A2:  MOVLW  2B
107A4:  MOVLB  9
107A6:  MOVWF  x08
107A8:  MOVLW  9D
107AA:  MOVWF  x07
107AC:  MOVLW  DF
107AE:  MOVWF  x06
107B0:  MOVLW  7E
107B2:  MOVWF  x05
107B4:  MOVLB  0
107B6:  CALL   C152
107BA:  MOVFF  03,8D0
107BE:  MOVFF  02,8CF
107C2:  MOVFF  01,8CE
107C6:  MOVFF  00,8CD
....................       r = r*y2 + 1.0; 
107CA:  MOVFF  8D0,900
107CE:  MOVFF  8CF,8FF
107D2:  MOVFF  8CE,8FE
107D6:  MOVFF  8CD,8FD
107DA:  MOVFF  8D4,904
107DE:  MOVFF  8D3,903
107E2:  MOVFF  8D2,902
107E6:  MOVFF  8D1,901
107EA:  CALL   C028
107EE:  MOVFF  03,8D9
107F2:  MOVFF  02,8D8
107F6:  MOVFF  01,8D7
107FA:  MOVFF  00,8D6
107FE:  BCF    FD8.1
10800:  MOVFF  03,904
10804:  MOVFF  02,903
10808:  MOVFF  01,902
1080C:  MOVFF  00,901
10810:  MOVLB  9
10812:  CLRF   x08
10814:  CLRF   x07
10816:  CLRF   x06
10818:  MOVLW  7F
1081A:  MOVWF  x05
1081C:  MOVLB  0
1081E:  CALL   C152
10822:  MOVFF  03,8D0
10826:  MOVFF  02,8CF
1082A:  MOVFF  01,8CE
1082E:  MOVFF  00,8CD
....................  
....................       res = y*res/r; 
10832:  MOVFF  8C8,900
10836:  MOVFF  8C7,8FF
1083A:  MOVFF  8C6,8FE
1083E:  MOVFF  8C5,8FD
10842:  MOVFF  8CC,904
10846:  MOVFF  8CB,903
1084A:  MOVFF  8CA,902
1084E:  MOVFF  8C9,901
10852:  CALL   C028
10856:  MOVFF  03,8D9
1085A:  MOVFF  02,8D8
1085E:  MOVFF  01,8D7
10862:  MOVFF  00,8D6
10866:  MOVFF  03,8E8
1086A:  MOVFF  02,8E7
1086E:  MOVFF  01,8E6
10872:  MOVFF  00,8E5
10876:  MOVFF  8D0,8EC
1087A:  MOVFF  8CF,8EB
1087E:  MOVFF  8CE,8EA
10882:  MOVFF  8CD,8E9
10886:  CALL   C6C4
1088A:  MOVFF  03,8CC
1088E:  MOVFF  02,8CB
10892:  MOVFF  01,8CA
10896:  MOVFF  00,8C9
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
1089A:  MOVLW  08
1089C:  MOVLB  8
1089E:  MOVWF  xD7
108A0:  MOVLW  C1
108A2:  MOVWF  FE9
108A4:  MOVFF  8D7,FEA
108A8:  MOVLW  7E
108AA:  SUBWF  FEF,W
108AC:  MOVWF  xD5
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
108AE:  BTFSS  xD5.7
108B0:  BRA    108DA
....................          r = -(float32)-n; 
108B2:  MOVLW  00
108B4:  BSF    FD8.0
108B6:  SUBFWB xD5,W
108B8:  CLRF   xD7
108BA:  MOVWF  xD6
108BC:  BTFSC  xD6.7
108BE:  DECF   xD7,F
108C0:  MOVLB  0
108C2:  RCALL  10592
108C4:  MOVFF  00,8CD
108C8:  MOVF   01,W
108CA:  XORLW  80
108CC:  MOVLB  8
108CE:  MOVWF  xCE
108D0:  MOVFF  02,8CF
108D4:  MOVFF  03,8D0
108D8:  BRA    108FA
....................       else 
....................          r = (float32)n; 
108DA:  CLRF   xD7
108DC:  MOVFF  8D5,8D6
108E0:  BTFSC  xD6.7
108E2:  DECF   xD7,F
108E4:  MOVLB  0
108E6:  RCALL  10592
108E8:  MOVFF  03,8D0
108EC:  MOVFF  02,8CF
108F0:  MOVFF  01,8CE
108F4:  MOVFF  00,8CD
108F8:  MOVLB  8
....................  
....................       res += r*LN2; 
108FA:  MOVFF  8D0,900
108FE:  MOVFF  8CF,8FF
10902:  MOVFF  8CE,8FE
10906:  MOVFF  8CD,8FD
1090A:  MOVLW  18
1090C:  MOVLB  9
1090E:  MOVWF  x04
10910:  MOVLW  72
10912:  MOVWF  x03
10914:  MOVLW  31
10916:  MOVWF  x02
10918:  MOVLW  7E
1091A:  MOVWF  x01
1091C:  MOVLB  0
1091E:  CALL   C028
10922:  BCF    FD8.1
10924:  MOVFF  8CC,904
10928:  MOVFF  8CB,903
1092C:  MOVFF  8CA,902
10930:  MOVFF  8C9,901
10934:  MOVFF  03,908
10938:  MOVFF  02,907
1093C:  MOVFF  01,906
10940:  MOVFF  00,905
10944:  CALL   C152
10948:  MOVFF  03,8CC
1094C:  MOVFF  02,8CB
10950:  MOVFF  01,8CA
10954:  MOVFF  00,8C9
....................    } 
10958:  BRA    10966
....................  
....................    else 
....................       res = 0.0; 
1095A:  MOVLB  8
1095C:  CLRF   xCC
1095E:  CLRF   xCB
10960:  CLRF   xCA
10962:  CLRF   xC9
10964:  MOVLB  0
....................  
....................    return(res); 
10966:  MOVFF  8C9,00
1096A:  MOVFF  8CA,01
1096E:  MOVFF  8CB,02
10972:  MOVFF  8CC,03
10976:  GOTO   1098C (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
1097A:  MOVFF  8BC,8C4
1097E:  MOVFF  8BB,8C3
10982:  MOVFF  8BA,8C2
10986:  MOVFF  8B9,8C1
1098A:  BRA    105E2
1098C:  MOVFF  03,8C0
10990:  MOVFF  02,8BF
10994:  MOVFF  01,8BE
10998:  MOVFF  00,8BD
....................    r = r*LN10_INV; 
1099C:  MOVFF  8C0,900
109A0:  MOVFF  8BF,8FF
109A4:  MOVFF  8BE,8FE
109A8:  MOVFF  8BD,8FD
109AC:  MOVLW  D9
109AE:  MOVLB  9
109B0:  MOVWF  x04
109B2:  MOVLW  5B
109B4:  MOVWF  x03
109B6:  MOVLW  5E
109B8:  MOVWF  x02
109BA:  MOVLW  7D
109BC:  MOVWF  x01
109BE:  MOVLB  0
109C0:  CALL   C028
109C4:  MOVFF  03,8C0
109C8:  MOVFF  02,8BF
109CC:  MOVFF  01,8BE
109D0:  MOVFF  00,8BD
....................    return(r); 
109D4:  MOVFF  8BD,00
109D8:  MOVFF  8BE,01
109DC:  MOVFF  8BF,02
109E0:  MOVFF  8C0,03
109E4:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
0FFDA:  BCF    FC6.5
0FFDC:  MOVLW  21
0FFDE:  MOVWF  FC6
0FFE0:  MOVLW  40
0FFE2:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
0FFE4:  BSF    F91.2
....................    output_high(EEP_WP); 
0FFE6:  BSF    F91.3
0FFE8:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
*
10354:  BCF    F91.2
....................    spi_write(0x05);  
10356:  MOVF   FC9,W
10358:  MOVLW  05
1035A:  MOVWF  FC9
1035C:  RRCF   FC7,W
1035E:  BNC   1035C
....................    data = spi_read(0);  
10360:  MOVF   FC9,W
10362:  CLRF   FC9
10364:  RRCF   FC7,W
10366:  BNC   10364
10368:  MOVFF  FC9,8B8
....................    output_high(EEP_CS);  
1036C:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
1036E:  MOVLW  00
10370:  MOVLB  8
10372:  BTFSS  xB8.0
10374:  MOVLW  01
10376:  MOVWF  01
10378:  MOVLB  0
1037A:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
17C14:  MOVLB  8
17C16:  CLRF   xD7
17C18:  MOVLB  0
17C1A:  CALL   55CC
....................       while(!ext_eeprom_ready()); 
17C1E:  CALL   10354
17C22:  MOVF   01,F
17C24:  BZ    17C1E
....................     
....................       output_low(EEP_CS);  
17C26:  BCF    F91.2
....................       spi_write(0x06);  
17C28:  MOVF   FC9,W
17C2A:  MOVLW  06
17C2C:  MOVWF  FC9
17C2E:  RRCF   FC7,W
17C30:  BNC   17C2E
....................       output_high(EEP_CS);  
17C32:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
17C34:  BCF    F91.2
....................       spi_write(0x02);  
17C36:  MOVF   FC9,W
17C38:  MOVLW  02
17C3A:  MOVWF  FC9
17C3C:  RRCF   FC7,W
17C3E:  BNC   17C3C
....................       spi_write(address >> 8);  
17C40:  MOVFF  892,894
17C44:  MOVLB  8
17C46:  CLRF   x95
17C48:  MOVF   FC9,W
17C4A:  MOVFF  892,FC9
17C4E:  RRCF   FC7,W
17C50:  BNC   17C4E
....................       spi_write(address);  
17C52:  MOVF   FC9,W
17C54:  MOVFF  891,FC9
17C58:  RRCF   FC7,W
17C5A:  BNC   17C58
....................       spi_write(data);  
17C5C:  MOVF   FC9,W
17C5E:  MOVFF  893,FC9
17C62:  RRCF   FC7,W
17C64:  BNC   17C62
....................       output_high(EEP_CS);  
17C66:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
17C68:  MOVLW  01
17C6A:  MOVWF  xD7
17C6C:  MOVLB  0
17C6E:  CALL   55CC
17C72:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
1037C:  MOVLB  8
1037E:  CLRF   xD7
10380:  MOVLB  0
10382:  CALL   55CC
....................     
....................       while(!ext_eeprom_ready()); 
10386:  RCALL  10354
10388:  MOVF   01,F
1038A:  BZ    10386
....................        
....................       output_low(EEP_CS);  
1038C:  BCF    F91.2
....................       spi_write(0x03);  
1038E:  MOVF   FC9,W
10390:  MOVLW  03
10392:  MOVWF  FC9
10394:  RRCF   FC7,W
10396:  BNC   10394
....................       spi_write(address >> 8);  
10398:  MOVFF  8B6,8B8
1039C:  MOVLB  8
1039E:  CLRF   xB9
103A0:  MOVF   FC9,W
103A2:  MOVFF  8B6,FC9
103A6:  RRCF   FC7,W
103A8:  BNC   103A6
....................       spi_write(address);  
103AA:  MOVF   FC9,W
103AC:  MOVFF  8B5,FC9
103B0:  RRCF   FC7,W
103B2:  BNC   103B0
....................        
....................       data = spi_read(0);  
103B4:  MOVF   FC9,W
103B6:  CLRF   FC9
103B8:  RRCF   FC7,W
103BA:  BNC   103B8
103BC:  MOVFF  FC9,8B7
....................       output_high(EEP_CS);  
103C0:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
103C2:  MOVLW  01
103C4:  MOVWF  xD7
103C6:  MOVLB  0
103C8:  CALL   55CC
....................     
....................    return(data);  
103CC:  MOVLB  8
103CE:  MOVFF  8B7,01
103D2:  MOVLB  0
103D4:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
03466:  MOVF   FF2,W
03468:  MOVWF  00
0346A:  BCF    FF2.7
0346C:  CLRF   F63
0346E:  MOVFF  873,F62
03472:  MOVFF  874,F61
03476:  BCF    F7F.6
03478:  BCF    F7F.7
0347A:  BSF    F7F.2
0347C:  MOVLB  F
0347E:  MOVLW  55
03480:  MOVWF  F7E
03482:  MOVLW  AA
03484:  MOVWF  F7E
03486:  BSF    F7F.1
03488:  BTFSC  F7F.1
0348A:  BRA    3488
0348C:  BCF    F7F.2
0348E:  MOVF   00,W
03490:  IORWF  FF2,F
03492:  MOVLB  0
03494:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
02A78:  MOVLB  8
02A7A:  CLRF   xA2
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
02A7C:  MOVFF  FF2,8A3
02A80:  BCF    FF2.7
02A82:  CLRF   F63
02A84:  MOVFF  8A1,F62
02A88:  BCF    F7F.6
02A8A:  BCF    F7F.7
02A8C:  BSF    F7F.0
02A8E:  MOVF   F61,W
02A90:  BTFSC  xA3.7
02A92:  BSF    FF2.7
02A94:  MOVWF  xA2
....................    return(data); 
02A96:  MOVFF  8A2,01
02A9A:  MOVLB  0
02A9C:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
0501E:  MOVLB  8
05020:  CLRF   xDB
05022:  MOVF   xDB,W
05024:  SUBLW  01
05026:  BNC   5080
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
05028:  MOVF   xD8,W
0502A:  ADDWF  xDB,W
0502C:  MOVWF  xDC
0502E:  MOVLW  08
05030:  MOVWF  xDE
05032:  MOVLW  D9
05034:  MOVWF  xDD
05036:  MOVF   xDB,W
05038:  ADDWF  xDD,W
0503A:  MOVWF  01
0503C:  MOVLW  00
0503E:  ADDWFC xDE,W
05040:  MOVWF  03
05042:  MOVF   01,W
05044:  MOVWF  FE9
05046:  MOVFF  03,FEA
0504A:  MOVFF  FEF,8DD
0504E:  MOVF   FF2,W
05050:  MOVWF  00
05052:  BCF    FF2.7
05054:  CLRF   F63
05056:  MOVFF  8DC,F62
0505A:  MOVFF  8DD,F61
0505E:  BCF    F7F.6
05060:  BCF    F7F.7
05062:  BSF    F7F.2
05064:  MOVLB  F
05066:  MOVLW  55
05068:  MOVWF  F7E
0506A:  MOVLW  AA
0506C:  MOVWF  F7E
0506E:  BSF    F7F.1
05070:  BTFSC  F7F.1
05072:  BRA    5070
05074:  BCF    F7F.2
05076:  MOVF   00,W
05078:  IORWF  FF2,F
0507A:  MOVLB  8
0507C:  INCF   xDB,F
0507E:  BRA    5022
....................     }  
05080:  MOVLB  0
05082:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
02A1E:  MOVLB  8
02A20:  CLRF   x84
02A22:  CLRF   x83
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
02A24:  CLRF   x82
02A26:  MOVF   x82,W
02A28:  SUBLW  01
02A2A:  BNC   2A6C
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02A2C:  MOVLW  08
02A2E:  MOVWF  x86
02A30:  MOVLW  83
02A32:  MOVWF  x85
02A34:  MOVF   x82,W
02A36:  ADDWF  x85,W
02A38:  MOVWF  01
02A3A:  MOVLW  00
02A3C:  ADDWFC x86,W
02A3E:  MOVWF  03
02A40:  MOVF   01,W
02A42:  MOVWF  FE9
02A44:  MOVFF  03,FEA
02A48:  MOVF   x81,W
02A4A:  ADDWF  x82,W
02A4C:  MOVWF  x87
02A4E:  MOVFF  FF2,888
02A52:  BCF    FF2.7
02A54:  CLRF   F63
02A56:  MOVFF  887,F62
02A5A:  BCF    F7F.6
02A5C:  BCF    F7F.7
02A5E:  BSF    F7F.0
02A60:  MOVF   F61,W
02A62:  BTFSC  x88.7
02A64:  BSF    FF2.7
02A66:  MOVWF  FEF
02A68:  INCF   x82,F
02A6A:  BRA    2A26
....................    } 
....................  
....................    return(data);  
02A6C:  MOVFF  883,01
02A70:  MOVFF  884,02
02A74:  MOVLB  0
02A76:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0CAC6:  MOVLB  8
0CAC8:  CLRF   x75
0CACA:  MOVF   x75,W
0CACC:  SUBLW  03
0CACE:  BNC   CB30
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0CAD0:  MOVF   x75,W
0CAD2:  ADDWF  x6F,W
0CAD4:  MOVWF  x76
0CAD6:  MOVLW  00
0CAD8:  ADDWFC x70,W
0CADA:  MOVWF  x77
0CADC:  MOVLW  08
0CADE:  MOVWF  x79
0CAE0:  MOVLW  71
0CAE2:  MOVWF  x78
0CAE4:  MOVF   x75,W
0CAE6:  ADDWF  x78,W
0CAE8:  MOVWF  01
0CAEA:  MOVLW  00
0CAEC:  ADDWFC x79,W
0CAEE:  MOVWF  03
0CAF0:  MOVF   01,W
0CAF2:  MOVWF  FE9
0CAF4:  MOVFF  03,FEA
0CAF8:  MOVFF  FEF,878
0CAFC:  MOVF   FF2,W
0CAFE:  MOVWF  00
0CB00:  BCF    FF2.7
0CB02:  MOVFF  877,F63
0CB06:  MOVFF  876,F62
0CB0A:  MOVFF  878,F61
0CB0E:  BCF    F7F.6
0CB10:  BCF    F7F.7
0CB12:  BSF    F7F.2
0CB14:  MOVLB  F
0CB16:  MOVLW  55
0CB18:  MOVWF  F7E
0CB1A:  MOVLW  AA
0CB1C:  MOVWF  F7E
0CB1E:  BSF    F7F.1
0CB20:  BTFSC  F7F.1
0CB22:  BRA    CB20
0CB24:  BCF    F7F.2
0CB26:  MOVF   00,W
0CB28:  IORWF  FF2,F
0CB2A:  MOVLB  8
0CB2C:  INCF   x75,F
0CB2E:  BRA    CACA
....................    } 
0CB30:  MOVLB  0
0CB32:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
02A9E:  MOVLB  8
02AA0:  CLRF   x75
02AA2:  CLRF   x74
02AA4:  CLRF   x73
02AA6:  CLRF   x72
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
02AA8:  CLRF   x71
02AAA:  MOVF   x71,W
02AAC:  SUBLW  03
02AAE:  BNC   2AF8
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02AB0:  MOVLW  08
02AB2:  MOVWF  x77
02AB4:  MOVLW  72
02AB6:  MOVWF  x76
02AB8:  MOVF   x71,W
02ABA:  ADDWF  x76,W
02ABC:  MOVWF  01
02ABE:  MOVLW  00
02AC0:  ADDWFC x77,W
02AC2:  MOVWF  03
02AC4:  MOVF   01,W
02AC6:  MOVWF  FE9
02AC8:  MOVFF  03,FEA
02ACC:  MOVF   x71,W
02ACE:  ADDWF  x6F,W
02AD0:  MOVWF  x78
02AD2:  MOVLW  00
02AD4:  ADDWFC x70,W
02AD6:  MOVWF  x79
02AD8:  MOVFF  FF2,87A
02ADC:  BCF    FF2.7
02ADE:  MOVFF  879,F63
02AE2:  MOVFF  878,F62
02AE6:  BCF    F7F.6
02AE8:  BCF    F7F.7
02AEA:  BSF    F7F.0
02AEC:  MOVF   F61,W
02AEE:  BTFSC  x7A.7
02AF0:  BSF    FF2.7
02AF2:  MOVWF  FEF
02AF4:  INCF   x71,F
02AF6:  BRA    2AAA
....................    } 
....................  
....................    return(data);  
02AF8:  MOVFF  872,00
02AFC:  MOVFF  873,01
02B00:  MOVFF  874,02
02B04:  MOVFF  875,03
02B08:  MOVLB  0
02B0A:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
17E54:  MOVLB  8
17E56:  CLRF   x8D
17E58:  MOVF   x8D,W
17E5A:  SUBLW  01
17E5C:  BNC   17E9A
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
17E5E:  MOVF   x8D,W
17E60:  ADDWF  x89,W
17E62:  MOVWF  x8E
17E64:  MOVLW  00
17E66:  ADDWFC x8A,W
17E68:  MOVWF  x8F
17E6A:  MOVLW  08
17E6C:  MOVWF  x91
17E6E:  MOVLW  8B
17E70:  MOVWF  x90
17E72:  MOVF   x8D,W
17E74:  ADDWF  x90,W
17E76:  MOVWF  01
17E78:  MOVLW  00
17E7A:  ADDWFC x91,W
17E7C:  MOVWF  03
17E7E:  MOVFF  01,FE9
17E82:  MOVWF  FEA
17E84:  MOVFF  FEF,893
17E88:  MOVFF  88F,892
17E8C:  MOVFF  88E,891
17E90:  MOVLB  0
17E92:  RCALL  17C14
17E94:  MOVLB  8
17E96:  INCF   x8D,F
17E98:  BRA    17E58
....................     }  
17E9A:  MOVLB  0
17E9C:  GOTO   17F0C (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
10490:  MOVLB  8
10492:  CLRF   xB0
10494:  CLRF   xAF
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
10496:  CLRF   xAE
10498:  MOVF   xAE,W
1049A:  SUBLW  01
1049C:  BNC   104E0
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
1049E:  MOVLW  08
104A0:  MOVWF  xB2
104A2:  MOVLW  AF
104A4:  MOVWF  xB1
104A6:  MOVF   xAE,W
104A8:  ADDWF  xB1,W
104AA:  MOVWF  01
104AC:  MOVLW  00
104AE:  ADDWFC xB2,W
104B0:  MOVWF  03
104B2:  MOVFF  01,8B1
104B6:  MOVWF  xB2
104B8:  MOVF   xAE,W
104BA:  ADDWF  xAC,W
104BC:  MOVWF  xB3
104BE:  MOVLW  00
104C0:  ADDWFC xAD,W
104C2:  MOVWF  xB4
104C4:  MOVWF  xB6
104C6:  MOVFF  8B3,8B5
104CA:  MOVLB  0
104CC:  RCALL  1037C
104CE:  MOVFF  8B2,FEA
104D2:  MOVFF  8B1,FE9
104D6:  MOVFF  01,FEF
104DA:  MOVLB  8
104DC:  INCF   xAE,F
104DE:  BRA    10498
....................    } 
....................    return(data);  
104E0:  MOVFF  8AF,01
104E4:  MOVFF  8B0,02
104E8:  MOVLB  0
104EA:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
158F6:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
158F8:  MOVF   2F,W
158FA:  SUBLW  02
158FC:  BNZ   15904
158FE:  MOVF   30,F
15900:  BNZ   15904
15902:  BSF    F90.6
....................    delay_ms(32); 
15904:  MOVLW  20
15906:  MOVLB  9
15908:  MOVWF  xD6
1590A:  MOVLB  0
1590C:  CALL   2964
....................    output_bit(BOARD_LED, OFF); 
15910:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
15912:  MOVF   2F,W
15914:  SUBLW  02
15916:  BNZ   1591E
15918:  MOVF   30,F
1591A:  BNZ   1591E
1591C:  BCF    F90.6
....................    delay_ms(32); 
1591E:  MOVLW  20
15920:  MOVLB  9
15922:  MOVWF  xD6
15924:  MOVLB  0
15926:  CALL   2964
1592A:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
0319C:  MOVF   2F,W
0319E:  MOVWF  00
031A0:  MOVF   30,W
031A2:  MOVWF  03
031A4:  BNZ   31AA
031A6:  MOVF   00,F
031A8:  BZ    31CC
031AA:  MOVF   03,W
031AC:  BNZ   31B4
031AE:  MOVLW  01
031B0:  SUBWF  00,W
031B2:  BZ    321E
031B4:  MOVF   03,W
031B6:  BNZ   31BE
031B8:  MOVLW  02
031BA:  SUBWF  00,W
031BC:  BZ    3270
031BE:  MOVF   03,W
031C0:  BNZ   31CA
031C2:  MOVLW  03
031C4:  SUBWF  00,W
031C6:  BTFSC  FD8.2
031C8:  BRA    32C2
031CA:  BRA    3314
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
031CC:  MOVLW  BE
031CE:  MOVWF  FF6
031D0:  MOVLW  05
031D2:  MOVWF  FF7
031D4:  MOVLW  00
031D6:  MOVWF  FF8
031D8:  CLRF   1B
031DA:  BTFSC  FF2.7
031DC:  BSF    1B.7
031DE:  BCF    FF2.7
031E0:  MOVLW  06
031E2:  MOVLB  A
031E4:  MOVWF  x25
031E6:  MOVLB  0
031E8:  CALL   1010
031EC:  BTFSC  1B.7
031EE:  BSF    FF2.7
031F0:  MOVLW  CA
031F2:  MOVWF  FF6
031F4:  MOVLW  05
031F6:  MOVWF  FF7
031F8:  MOVLW  00
031FA:  MOVWF  FF8
031FC:  CLRF   1B
031FE:  BTFSC  FF2.7
03200:  BSF    1B.7
03202:  BCF    FF2.7
03204:  CALL   0E3A
03208:  BTFSC  1B.7
0320A:  BSF    FF2.7
0320C:  MOVLW  0D
0320E:  BTFSS  F9E.4
03210:  BRA    320E
03212:  MOVWF  FAD
03214:  MOVLW  0A
03216:  BTFSS  F9E.4
03218:  BRA    3216
0321A:  MOVWF  FAD
....................          break; 
0321C:  BRA    3364
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
0321E:  MOVLW  D2
03220:  MOVWF  FF6
03222:  MOVLW  05
03224:  MOVWF  FF7
03226:  MOVLW  00
03228:  MOVWF  FF8
0322A:  CLRF   1B
0322C:  BTFSC  FF2.7
0322E:  BSF    1B.7
03230:  BCF    FF2.7
03232:  MOVLW  09
03234:  MOVLB  A
03236:  MOVWF  x25
03238:  MOVLB  0
0323A:  CALL   1010
0323E:  BTFSC  1B.7
03240:  BSF    FF2.7
03242:  MOVLW  E0
03244:  MOVWF  FF6
03246:  MOVLW  05
03248:  MOVWF  FF7
0324A:  MOVLW  00
0324C:  MOVWF  FF8
0324E:  CLRF   1B
03250:  BTFSC  FF2.7
03252:  BSF    1B.7
03254:  BCF    FF2.7
03256:  CALL   0E3A
0325A:  BTFSC  1B.7
0325C:  BSF    FF2.7
0325E:  MOVLW  0D
03260:  BTFSS  F9E.4
03262:  BRA    3260
03264:  MOVWF  FAD
03266:  MOVLW  0A
03268:  BTFSS  F9E.4
0326A:  BRA    3268
0326C:  MOVWF  FAD
....................          break;  
0326E:  BRA    3364
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
03270:  MOVLW  E8
03272:  MOVWF  FF6
03274:  MOVLW  05
03276:  MOVWF  FF7
03278:  MOVLW  00
0327A:  MOVWF  FF8
0327C:  CLRF   1B
0327E:  BTFSC  FF2.7
03280:  BSF    1B.7
03282:  BCF    FF2.7
03284:  MOVLW  06
03286:  MOVLB  A
03288:  MOVWF  x25
0328A:  MOVLB  0
0328C:  CALL   1010
03290:  BTFSC  1B.7
03292:  BSF    FF2.7
03294:  MOVLW  F4
03296:  MOVWF  FF6
03298:  MOVLW  05
0329A:  MOVWF  FF7
0329C:  MOVLW  00
0329E:  MOVWF  FF8
032A0:  CLRF   1B
032A2:  BTFSC  FF2.7
032A4:  BSF    1B.7
032A6:  BCF    FF2.7
032A8:  CALL   0E3A
032AC:  BTFSC  1B.7
032AE:  BSF    FF2.7
032B0:  MOVLW  0D
032B2:  BTFSS  F9E.4
032B4:  BRA    32B2
032B6:  MOVWF  FAD
032B8:  MOVLW  0A
032BA:  BTFSS  F9E.4
032BC:  BRA    32BA
032BE:  MOVWF  FAD
....................          break; 
032C0:  BRA    3364
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
032C2:  MOVLW  FC
032C4:  MOVWF  FF6
032C6:  MOVLW  05
032C8:  MOVWF  FF7
032CA:  MOVLW  00
032CC:  MOVWF  FF8
032CE:  CLRF   1B
032D0:  BTFSC  FF2.7
032D2:  BSF    1B.7
032D4:  BCF    FF2.7
032D6:  MOVLW  09
032D8:  MOVLB  A
032DA:  MOVWF  x25
032DC:  MOVLB  0
032DE:  CALL   1010
032E2:  BTFSC  1B.7
032E4:  BSF    FF2.7
032E6:  MOVLW  0A
032E8:  MOVWF  FF6
032EA:  MOVLW  06
032EC:  MOVWF  FF7
032EE:  MOVLW  00
032F0:  MOVWF  FF8
032F2:  CLRF   1B
032F4:  BTFSC  FF2.7
032F6:  BSF    1B.7
032F8:  BCF    FF2.7
032FA:  CALL   0E3A
032FE:  BTFSC  1B.7
03300:  BSF    FF2.7
03302:  MOVLW  0D
03304:  BTFSS  F9E.4
03306:  BRA    3304
03308:  MOVWF  FAD
0330A:  MOVLW  0A
0330C:  BTFSS  F9E.4
0330E:  BRA    330C
03310:  MOVWF  FAD
....................          break;           
03312:  BRA    3364
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
03314:  MOVLW  12
03316:  MOVWF  FF6
03318:  MOVLW  06
0331A:  MOVWF  FF7
0331C:  MOVLW  00
0331E:  MOVWF  FF8
03320:  CLRF   1B
03322:  BTFSC  FF2.7
03324:  BSF    1B.7
03326:  BCF    FF2.7
03328:  MOVLW  06
0332A:  MOVLB  A
0332C:  MOVWF  x25
0332E:  MOVLB  0
03330:  CALL   1010
03334:  BTFSC  1B.7
03336:  BSF    FF2.7
03338:  MOVLW  1E
0333A:  MOVWF  FF6
0333C:  MOVLW  06
0333E:  MOVWF  FF7
03340:  MOVLW  00
03342:  MOVWF  FF8
03344:  CLRF   1B
03346:  BTFSC  FF2.7
03348:  BSF    1B.7
0334A:  BCF    FF2.7
0334C:  CALL   0E3A
03350:  BTFSC  1B.7
03352:  BSF    FF2.7
03354:  MOVLW  0D
03356:  BTFSS  F9E.4
03358:  BRA    3356
0335A:  MOVWF  FAD
0335C:  MOVLW  0A
0335E:  BTFSS  F9E.4
03360:  BRA    335E
03362:  MOVWF  FAD
....................          break; 
....................    } 
03364:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
1730A:  MOVLW  26
1730C:  MOVWF  FF6
1730E:  MOVLW  06
17310:  MOVWF  FF7
17312:  MOVLW  00
17314:  MOVWF  FF8
17316:  CLRF   1B
17318:  BTFSC  FF2.7
1731A:  BSF    1B.7
1731C:  BCF    FF2.7
1731E:  CALL   0E3A
17322:  BTFSC  1B.7
17324:  BSF    FF2.7
17326:  GOTO   176D0 (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0B062:  MOVLW  2E
0B064:  MOVWF  FF6
0B066:  MOVLW  06
0B068:  MOVWF  FF7
0B06A:  MOVLW  00
0B06C:  MOVWF  FF8
0B06E:  CLRF   1B
0B070:  BTFSC  FF2.7
0B072:  BSF    1B.7
0B074:  BCF    FF2.7
0B076:  CALL   0E3A
0B07A:  BTFSC  1B.7
0B07C:  BSF    FF2.7
0B07E:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BD24:  MOVLW  36
0BD26:  MOVWF  FF6
0BD28:  MOVLW  06
0BD2A:  MOVWF  FF7
0BD2C:  MOVLW  00
0BD2E:  MOVWF  FF8
0BD30:  CLRF   1B
0BD32:  BTFSC  FF2.7
0BD34:  BSF    1B.7
0BD36:  BCF    FF2.7
0BD38:  CALL   0E3A
0BD3C:  BTFSC  1B.7
0BD3E:  BSF    FF2.7
0BD40:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
036AA:  MOVLW  4E
036AC:  MOVWF  FF6
036AE:  MOVLW  06
036B0:  MOVWF  FF7
036B2:  MOVLW  00
036B4:  MOVWF  FF8
036B6:  CLRF   1B
036B8:  BTFSC  FF2.7
036BA:  BSF    1B.7
036BC:  BCF    FF2.7
036BE:  CALL   0E3A
036C2:  BTFSC  1B.7
036C4:  BSF    FF2.7
036C6:  GOTO   441C (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
050CA:  MOVLW  56
050CC:  MOVWF  FF6
050CE:  MOVLW  06
050D0:  MOVWF  FF7
050D2:  MOVLW  00
050D4:  MOVWF  FF8
050D6:  CLRF   1B
050D8:  BTFSC  FF2.7
050DA:  BSF    1B.7
050DC:  BCF    FF2.7
050DE:  CALL   0E3A
050E2:  BTFSC  1B.7
050E4:  BSF    FF2.7
050E6:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
15E1E:  MOVLW  5E
15E20:  MOVWF  FF6
15E22:  MOVLW  06
15E24:  MOVWF  FF7
15E26:  MOVLW  00
15E28:  MOVWF  FF8
15E2A:  CLRF   1B
15E2C:  BTFSC  FF2.7
15E2E:  BSF    1B.7
15E30:  BCF    FF2.7
15E32:  CALL   0E3A
15E36:  BTFSC  1B.7
15E38:  BSF    FF2.7
15E3A:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
*
0AEAE:  DECFSZ 4A,W
0AEB0:  BRA    AED0
0AEB2:  MOVLW  66
0AEB4:  MOVWF  FF6
0AEB6:  MOVLW  06
0AEB8:  MOVWF  FF7
0AEBA:  MOVLW  00
0AEBC:  MOVWF  FF8
0AEBE:  CLRF   1B
0AEC0:  BTFSC  FF2.7
0AEC2:  BSF    1B.7
0AEC4:  BCF    FF2.7
0AEC6:  CALL   0E3A
0AECA:  BTFSC  1B.7
0AECC:  BSF    FF2.7
0AECE:  BRA    AEEC
....................    else fprintf(COM_A, "@RDY\r\n"); 
0AED0:  MOVLW  6E
0AED2:  MOVWF  FF6
0AED4:  MOVLW  06
0AED6:  MOVWF  FF7
0AED8:  MOVLW  00
0AEDA:  MOVWF  FF8
0AEDC:  CLRF   1B
0AEDE:  BTFSC  FF2.7
0AEE0:  BSF    1B.7
0AEE2:  BCF    FF2.7
0AEE4:  CALL   0E3A
0AEE8:  BTFSC  1B.7
0AEEA:  BSF    FF2.7
0AEEC:  GOTO   1B05A (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
03594:  MOVLW  0A
03596:  MOVLB  A
03598:  MOVWF  x1B
0359A:  MOVLW  12
0359C:  MOVFF  A1B,A19
035A0:  MOVWF  x18
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
035A2:  MOVF   FC9,W
035A4:  SETF   FC9
035A6:  RRCF   FC7,W
035A8:  BNC   35A6
....................    SD_spi_read(sdcmd); 
035AA:  MOVF   FC9,W
035AC:  MOVFF  A11,FC9
035B0:  RRCF   FC7,W
035B2:  BNC   35B0
....................    SD_spi_read(value[3]); 
035B4:  MOVLW  03
035B6:  ADDWF  x18,W
035B8:  MOVWF  FE9
035BA:  MOVLW  00
035BC:  ADDWFC x19,W
035BE:  MOVWF  FEA
035C0:  MOVFF  FEF,A1A
035C4:  MOVF   FC9,W
035C6:  MOVFF  A1A,FC9
035CA:  RRCF   FC7,W
035CC:  BNC   35CA
....................    SD_spi_read(value[2]); 
035CE:  MOVLW  02
035D0:  ADDWF  x18,W
035D2:  MOVWF  FE9
035D4:  MOVLW  00
035D6:  ADDWFC x19,W
035D8:  MOVWF  FEA
035DA:  MOVFF  FEF,A1A
035DE:  MOVF   FC9,W
035E0:  MOVFF  A1A,FC9
035E4:  RRCF   FC7,W
035E6:  BNC   35E4
....................    SD_spi_read(value[1]); 
035E8:  MOVLW  01
035EA:  ADDWF  x18,W
035EC:  MOVWF  FE9
035EE:  MOVLW  00
035F0:  ADDWFC x19,W
035F2:  MOVWF  FEA
035F4:  MOVFF  FEF,A1A
035F8:  MOVF   FC9,W
035FA:  MOVFF  A1A,FC9
035FE:  RRCF   FC7,W
03600:  BNC   35FE
....................    SD_spi_read(value[0]); 
03602:  MOVFF  A18,FE9
03606:  MOVFF  A19,FEA
0360A:  MOVFF  FEF,A1A
0360E:  MOVF   FC9,W
03610:  MOVFF  A1A,FC9
03614:  RRCF   FC7,W
03616:  BNC   3614
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
03618:  MOVF   x11,W
0361A:  SUBLW  48
0361C:  BNZ   362A
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
0361E:  MOVF   FC9,W
03620:  MOVLW  87
03622:  MOVWF  FC9
03624:  RRCF   FC7,W
03626:  BNC   3624
03628:  BRA    3634
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
0362A:  MOVF   FC9,W
0362C:  MOVLW  95
0362E:  MOVWF  FC9
03630:  RRCF   FC7,W
03632:  BNC   3630
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
03634:  CLRF   x16
....................    response = SD_spi_read(0xFF); 
03636:  MOVF   FC9,W
03638:  SETF   FC9
0363A:  RRCF   FC7,W
0363C:  BNC   363A
0363E:  MOVFF  FC9,A17
....................    while ((response == 0xFF) && (i < 100)) 
03642:  INCFSZ x17,W
03644:  BRA    365C
03646:  MOVF   x16,W
03648:  SUBLW  63
0364A:  BNC   365C
....................       { 
....................       i++; 
0364C:  INCF   x16,F
....................       response = SD_spi_read(0xFF); 
0364E:  MOVF   FC9,W
03650:  SETF   FC9
03652:  RRCF   FC7,W
03654:  BNC   3652
03656:  MOVFF  FC9,A17
0365A:  BRA    3642
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
0365C:  MOVFF  A17,01
03660:  MOVLB  0
03662:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
04428:  MOVLW  50
0442A:  MOVLB  A
0442C:  MOVWF  x11
0442E:  MOVFF  A10,A15
04432:  MOVFF  A0F,A14
04436:  MOVFF  A0E,A13
0443A:  MOVFF  A0D,A12
0443E:  MOVLB  0
04440:  CALL   3594
04444:  MOVF   01,W
04446:  BZ    444E
04448:  XORLW  40
0444A:  BZ    4464
0444C:  BRA    446A
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
0444E:  MOVFF  A10,4E8
04452:  MOVFF  A0F,4E7
04456:  MOVFF  A0E,4E6
0445A:  MOVFF  A0D,4E5
....................          return(TRUE); 
0445E:  MOVLW  01
04460:  MOVWF  01
04462:  BRA    446E
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
04464:  MOVLW  00
04466:  MOVWF  01
04468:  BRA    446E
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
0446A:  MOVLW  00
0446C:  MOVWF  01
....................       } 
0446E:  GOTO   4552 (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
04472:  MOVF   FC9,W
04474:  SETF   FC9
04476:  RRCF   FC7,W
04478:  BNC   4476
0447A:  MOVFF  FC9,A15
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
0447E:  MOVLB  A
04480:  CLRF   x14
04482:  CLRF   x13
04484:  MOVF   x14,W
04486:  SUBLW  27
04488:  BNC   44B2
0448A:  BNZ   4492
0448C:  MOVF   x13,W
0448E:  SUBLW  0F
04490:  BNC   44B2
04492:  INCFSZ x15,W
04494:  BRA    44B2
....................       { 
....................       delay_us(10); 
04496:  MOVLW  35
04498:  MOVWF  00
0449A:  DECFSZ 00,F
0449C:  BRA    449A
....................       response = SD_spi_read(0xFF);  
0449E:  MOVF   FC9,W
044A0:  SETF   FC9
044A2:  RRCF   FC7,W
044A4:  BNC   44A2
044A6:  MOVFF  FC9,A15
044AA:  INCF   x13,F
044AC:  BTFSC  FD8.2
044AE:  INCF   x14,F
044B0:  BRA    4484
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
044B2:  MOVF   x15,W
044B4:  SUBLW  FE
044B6:  BZ    44C6
....................       { 
....................       if (!response) 
044B8:  MOVF   x15,F
044BA:  BNZ   44C0
....................          response = 0xFE; 
044BC:  MOVLW  FE
044BE:  MOVWF  x15
....................       return(response); 
044C0:  MOVFF  A15,01
044C4:  BRA    451C
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
044C6:  CLRF   x14
044C8:  CLRF   x13
044CA:  MOVF   x12,F
044CC:  BNZ   44E0
044CE:  MOVF   x11,F
044D0:  BNZ   44E0
044D2:  MOVF   x14,W
044D4:  SUBWF  x10,W
044D6:  BNC   4500
044D8:  BNZ   44E0
044DA:  MOVF   x0F,W
044DC:  SUBWF  x13,W
044DE:  BC    4500
....................       ptr[i]=SD_spi_read(0xFF); 
044E0:  MOVF   x0D,W
044E2:  ADDWF  x13,W
044E4:  MOVWF  FE9
044E6:  MOVF   x0E,W
044E8:  ADDWFC x14,W
044EA:  MOVWF  FEA
044EC:  MOVF   FC9,W
044EE:  SETF   FC9
044F0:  RRCF   FC7,W
044F2:  BNC   44F0
044F4:  MOVFF  FC9,FEF
044F8:  INCF   x13,F
044FA:  BTFSC  FD8.2
044FC:  INCF   x14,F
044FE:  BRA    44CA
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
04500:  MOVF   FC9,W
04502:  SETF   FC9
04504:  RRCF   FC7,W
04506:  BNC   4504
....................    SD_spi_read(0xFF); 
04508:  MOVF   FC9,W
0450A:  SETF   FC9
0450C:  RRCF   FC7,W
0450E:  BNC   450C
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
04510:  MOVF   FC9,W
04512:  SETF   FC9
04514:  RRCF   FC7,W
04516:  BNC   4514
....................    return(0); 
04518:  MOVLW  00
0451A:  MOVWF  01
0451C:  MOVLB  0
0451E:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
0588C:  MOVLW  C3
0588E:  MOVLB  A
05890:  MOVWF  x15
05892:  MOVLW  50
05894:  MOVWF  x14
....................    SD_spi_read(0xFF); 
05896:  MOVF   FC9,W
05898:  SETF   FC9
0589A:  RRCF   FC7,W
0589C:  BNC   589A
....................    do 
....................       { 
....................       delay_us(10); 
0589E:  MOVLW  35
058A0:  MOVWF  00
058A2:  DECFSZ 00,F
058A4:  BRA    58A2
....................       response = SD_spi_read(0xFF); 
058A6:  MOVF   FC9,W
058A8:  SETF   FC9
058AA:  RRCF   FC7,W
058AC:  BNC   58AA
058AE:  MOVFF  FC9,A13
....................       Timer--; 
058B2:  MOVF   x14,W
058B4:  BTFSC  FD8.2
058B6:  DECF   x15,F
058B8:  DECF   x14,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
058BA:  INCFSZ x13,W
058BC:  BRA    58C0
058BE:  BRA    58C6
058C0:  MOVF   x14,W
058C2:  IORWF  x15,W
058C4:  BNZ   589E
....................       ; 
....................  
....................    return (response); 
058C6:  MOVFF  A13,01
058CA:  MOVLB  0
058CC:  GOTO   58DC (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
058D0:  MOVLW  02
058D2:  MOVLB  A
058D4:  MOVWF  x12
058D6:  CLRF   x11
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
058D8:  MOVLB  0
058DA:  BRA    588C
058DC:  INCFSZ 01,W
058DE:  BRA    58E2
058E0:  BRA    58E8
....................       return (FALSE); 
058E2:  MOVLW  00
058E4:  MOVWF  01
058E6:  BRA    5982
....................  
....................    SD_spi_write(token);               // transmit data token 
058E8:  MOVF   FC9,W
058EA:  MOVFF  A0F,FC9
058EE:  RRCF   FC7,W
058F0:  BNC   58EE
....................    if (token != 0xFD) 
058F2:  MOVLB  A
058F4:  MOVF   x0F,W
058F6:  SUBLW  FD
058F8:  BZ    597C
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
058FA:  MOVFF  A12,03
058FE:  MOVF   x11,W
05900:  BTFSC  FD8.2
05902:  DECF   x12,F
05904:  DECF   x11,F
05906:  IORWF  03,W
05908:  BZ    592C
....................          SD_spi_write(*ptr++); 
0590A:  MOVFF  A0E,03
0590E:  MOVF   x0D,W
05910:  INCF   x0D,F
05912:  BTFSC  FD8.2
05914:  INCF   x0E,F
05916:  MOVWF  FE9
05918:  MOVFF  03,FEA
0591C:  MOVFF  FEF,A13
05920:  MOVF   FC9,W
05922:  MOVFF  A13,FC9
05926:  RRCF   FC7,W
05928:  BNC   5926
0592A:  BRA    58FA
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
0592C:  MOVF   FC9,W
0592E:  SETF   FC9
05930:  RRCF   FC7,W
05932:  BNC   5930
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
05934:  MOVF   FC9,W
05936:  SETF   FC9
05938:  RRCF   FC7,W
0593A:  BNC   5938
....................       response = SD_spi_read(0xFF);      // Receive data response 
0593C:  MOVF   FC9,W
0593E:  SETF   FC9
05940:  RRCF   FC7,W
05942:  BNC   5940
05944:  MOVFF  FC9,A10
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
05948:  CLRF   x12
0594A:  CLRF   x11
0594C:  MOVF   x12,W
0594E:  SUBLW  C3
05950:  BNC   597C
05952:  BNZ   595A
05954:  MOVF   x11,W
05956:  SUBLW  4F
05958:  BNC   597C
....................          { 
....................          delay_us(10); 
0595A:  MOVLW  35
0595C:  MOVWF  00
0595E:  DECFSZ 00,F
05960:  BRA    595E
....................          response = SD_spi_read(0xFF);   // digest prior operation 
05962:  MOVF   FC9,W
05964:  SETF   FC9
05966:  RRCF   FC7,W
05968:  BNC   5966
0596A:  MOVFF  FC9,A10
....................          if (response != 0x00) 
0596E:  MOVF   x10,F
05970:  BZ    5974
....................             break; 
05972:  BRA    597C
05974:  INCF   x11,F
05976:  BTFSC  FD8.2
05978:  INCF   x12,F
0597A:  BRA    594C
....................          } 
....................  
....................       } 
....................    return(TRUE); 
0597C:  MOVLW  01
0597E:  MOVWF  01
05980:  MOVLB  0
05982:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
05984:  MOVLB  4
05986:  BTFSS  xE9.0
05988:  BRA    5990
....................       return (RES_NOTRDY); 
0598A:  MOVLW  03
0598C:  MOVWF  01
0598E:  BRA    5AC4
....................  
....................    if (Media_Status & STA_PROTECT) 
05990:  BTFSS  xE9.2
05992:  BRA    599A
....................       return (RES_WRPRT); 
05994:  MOVLW  02
05996:  MOVWF  01
05998:  BRA    5AC4
....................  
....................    if (!SectorCount) 
0599A:  MOVLB  A
0599C:  MOVF   x0C,F
0599E:  BNZ   59AA
....................       return (RES_PARERR); 
059A0:  MOVLW  04
059A2:  MOVWF  01
059A4:  MOVLB  4
059A6:  BRA    5AC4
059A8:  MOVLB  A
....................  
....................    SelectSD; 
059AA:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
059AC:  MOVLB  4
059AE:  MOVF   xE3,W
059B0:  SUBLW  05
059B2:  BZ    59CE
....................       SectorNumber *= 512; 
059B4:  BCF    FD8.0
059B6:  MOVFF  A0A,A0B
059BA:  MOVFF  A09,A0A
059BE:  MOVFF  A08,A09
059C2:  MOVLB  A
059C4:  CLRF   x08
059C6:  RLCF   x09,F
059C8:  RLCF   x0A,F
059CA:  RLCF   x0B,F
059CC:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
059CE:  MOVLB  A
059D0:  DECFSZ x0C,W
059D2:  BRA    5A12
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
059D4:  MOVLW  58
059D6:  MOVWF  x11
059D8:  MOVFF  A0B,A15
059DC:  MOVFF  A0A,A14
059E0:  MOVFF  A09,A13
059E4:  MOVFF  A08,A12
059E8:  MOVLB  0
059EA:  CALL   3594
059EE:  MOVF   01,F
059F0:  BNZ   5A0E
....................          if (SD_write_data(Buffer, 0xFE)) 
059F2:  MOVFF  A07,A0E
059F6:  MOVFF  A06,A0D
059FA:  MOVLW  FE
059FC:  MOVLB  A
059FE:  MOVWF  x0F
05A00:  MOVLB  0
05A02:  RCALL  58D0
05A04:  MOVF   01,F
05A06:  BZ    5A0E
....................             SectorCount = 0; 
05A08:  MOVLB  A
05A0A:  CLRF   x0C
05A0C:  MOVLB  0
....................       } 
05A0E:  BRA    5AAA
05A10:  MOVLB  A
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
05A12:  MOVLB  4
05A14:  MOVF   xE3,W
05A16:  ANDLW  03
05A18:  BZ    5A46
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
05A1A:  MOVLW  77
05A1C:  MOVLB  A
05A1E:  MOVWF  x11
05A20:  CLRF   x15
05A22:  CLRF   x14
05A24:  CLRF   x13
05A26:  CLRF   x12
05A28:  MOVLB  0
05A2A:  CALL   3594
....................          SD_cmd(SD_ACMD23, SectorCount); 
05A2E:  MOVLW  57
05A30:  MOVLB  A
05A32:  MOVWF  x11
05A34:  CLRF   x15
05A36:  CLRF   x14
05A38:  CLRF   x13
05A3A:  MOVFF  A0C,A12
05A3E:  MOVLB  0
05A40:  CALL   3594
05A44:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
05A46:  MOVLW  59
05A48:  MOVLB  A
05A4A:  MOVWF  x11
05A4C:  MOVFF  A0B,A15
05A50:  MOVFF  A0A,A14
05A54:  MOVFF  A09,A13
05A58:  MOVFF  A08,A12
05A5C:  MOVLB  0
05A5E:  CALL   3594
05A62:  MOVF   01,F
05A64:  BNZ   5AAA
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
05A66:  MOVFF  A07,A0E
05A6A:  MOVFF  A06,A0D
05A6E:  MOVLW  FC
05A70:  MOVLB  A
05A72:  MOVWF  x0F
05A74:  MOVLB  0
05A76:  RCALL  58D0
05A78:  MOVF   01,F
05A7A:  BNZ   5A7E
....................                break; 
05A7C:  BRA    5A90
....................             Buffer += 512; 
05A7E:  MOVLW  02
05A80:  MOVLB  A
05A82:  ADDWF  x07,F
....................             } while (--SectorCount); 
05A84:  DECF   x0C,F
05A86:  BTFSC  FD8.2
05A88:  BRA    5A8E
05A8A:  MOVLB  0
05A8C:  BRA    5A66
05A8E:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
05A90:  MOVLB  A
05A92:  CLRF   x0E
05A94:  CLRF   x0D
05A96:  MOVLW  FD
05A98:  MOVWF  x0F
05A9A:  MOVLB  0
05A9C:  RCALL  58D0
05A9E:  MOVF   01,F
05AA0:  BNZ   5AAA
....................             SectorCount = 1; 
05AA2:  MOVLW  01
05AA4:  MOVLB  A
05AA6:  MOVWF  x0C
05AA8:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
05AAA:  BSF    F91.1
....................    SD_spi_read(0xFF); 
05AAC:  MOVF   FC9,W
05AAE:  SETF   FC9
05AB0:  RRCF   FC7,W
05AB2:  BNC   5AB0
....................    return SectorCount ? RES_ERROR : RES_OK; 
05AB4:  MOVLB  A
05AB6:  MOVF   x0C,F
05AB8:  BZ    5ABE
05ABA:  MOVLW  01
05ABC:  BRA    5AC0
05ABE:  MOVLW  00
05AC0:  MOVWF  01
05AC2:  MOVLB  4
05AC4:  MOVLB  0
05AC6:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
04520:  MOVLB  4
04522:  BTFSS  xE9.0
04524:  BRA    452C
....................       return (RES_NOTRDY); 
04526:  MOVLW  03
04528:  MOVWF  01
0452A:  BRA    465C
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
0452C:  MOVLB  A
0452E:  MOVF   x0C,W
04530:  SUBLW  01
04532:  BNC   4538
04534:  MOVF   x0C,F
04536:  BNZ   4542
....................       return(RES_PARERR); 
04538:  MOVLW  04
0453A:  MOVWF  01
0453C:  MOVLB  4
0453E:  BRA    465C
04540:  MOVLB  A
....................  
....................    SelectSD; 
04542:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
04544:  CLRF   x10
04546:  CLRF   x0F
04548:  MOVLW  02
0454A:  MOVWF  x0E
0454C:  CLRF   x0D
0454E:  MOVLB  0
04550:  BRA    4428
04552:  MOVF   01,F
04554:  BNZ   4562
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
04556:  BSF    F91.1
....................       return(RES_ERROR); 
04558:  MOVLW  01
0455A:  MOVWF  01
0455C:  MOVLB  4
0455E:  BRA    465C
04560:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
04562:  MOVLB  4
04564:  MOVF   xE3,W
04566:  SUBLW  05
04568:  BZ    4584
....................       SectorNumber *= 512; 
0456A:  BCF    FD8.0
0456C:  MOVFF  A0A,A0B
04570:  MOVFF  A09,A0A
04574:  MOVFF  A08,A09
04578:  MOVLB  A
0457A:  CLRF   x08
0457C:  RLCF   x09,F
0457E:  RLCF   x0A,F
04580:  RLCF   x0B,F
04582:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
04584:  MOVLB  A
04586:  DECFSZ x0C,W
04588:  BRA    45E0
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
0458A:  MOVLW  51
0458C:  MOVWF  x11
0458E:  MOVFF  A0B,A15
04592:  MOVFF  A0A,A14
04596:  MOVFF  A09,A13
0459A:  MOVFF  A08,A12
0459E:  MOVLB  0
045A0:  CALL   3594
045A4:  MOVF   01,F
045A6:  BZ    45B4
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
045A8:  BSF    F91.1
....................          return(RES_PARERR); 
045AA:  MOVLW  04
045AC:  MOVWF  01
045AE:  MOVLB  4
045B0:  BRA    465C
045B2:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
045B4:  MOVFF  A07,A0E
045B8:  MOVFF  A06,A0D
045BC:  MOVLB  A
045BE:  CLRF   x12
045C0:  CLRF   x11
045C2:  MOVLW  02
045C4:  MOVWF  x10
045C6:  CLRF   x0F
045C8:  MOVLB  0
045CA:  RCALL  4472
045CC:  MOVF   01,F
045CE:  BZ    45DC
....................          { 
....................          DeselectSD; 
045D0:  BSF    F91.1
....................          return(RES_ERROR); 
045D2:  MOVLW  01
045D4:  MOVWF  01
045D6:  MOVLB  4
045D8:  BRA    465C
045DA:  MOVLB  0
....................          } 
....................       } 
045DC:  BRA    4654
045DE:  MOVLB  A
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
045E0:  MOVLW  52
045E2:  MOVWF  x11
045E4:  MOVFF  A0B,A15
045E8:  MOVFF  A0A,A14
045EC:  MOVFF  A09,A13
045F0:  MOVFF  A08,A12
045F4:  MOVLB  0
045F6:  CALL   3594
045FA:  MOVF   01,F
045FC:  BZ    460A
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
045FE:  BSF    F91.1
....................          return(RES_PARERR); 
04600:  MOVLW  04
04602:  MOVWF  01
04604:  MOVLB  4
04606:  BRA    465C
04608:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
0460A:  MOVFF  A07,A0E
0460E:  MOVFF  A06,A0D
04612:  MOVLB  A
04614:  CLRF   x12
04616:  CLRF   x11
04618:  MOVLW  02
0461A:  MOVWF  x10
0461C:  CLRF   x0F
0461E:  MOVLB  0
04620:  RCALL  4472
04622:  MOVF   01,F
04624:  BZ    4632
....................             { 
....................             DeselectSD; 
04626:  BSF    F91.1
....................             return(RES_ERROR); 
04628:  MOVLW  01
0462A:  MOVWF  01
0462C:  MOVLB  4
0462E:  BRA    465C
04630:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
04632:  MOVLW  02
04634:  MOVLB  A
04636:  ADDWF  x07,F
....................          } while (--SectorCount); 
04638:  DECF   x0C,F
0463A:  BTFSC  FD8.2
0463C:  BRA    4642
0463E:  MOVLB  0
04640:  BRA    460A
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
04642:  MOVLW  4C
04644:  MOVWF  x11
04646:  CLRF   x15
04648:  CLRF   x14
0464A:  CLRF   x13
0464C:  CLRF   x12
0464E:  MOVLB  0
04650:  CALL   3594
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
04654:  BSF    F91.1
....................    return(RES_OK); 
04656:  MOVLW  00
04658:  MOVWF  01
0465A:  MOVLB  4
0465C:  MOVLB  0
0465E:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
055E4:  MOVLB  4
055E6:  BCF    xE9.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
055E8:  BCF    xE9.2
....................  
....................    return(Media_Status); 
055EA:  MOVFF  4E9,01
055EE:  MOVLB  0
055F0:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
036CA:  MOVLB  9
036CC:  CLRF   xD5
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
036CE:  MOVLB  4
036D0:  CLRF   xE3
....................  
....................    DeselectSD; 
036D2:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
036D4:  MOVLW  0A
036D6:  MOVLB  9
036D8:  MOVWF  xD6
036DA:  MOVLB  0
036DC:  CALL   2964
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
036E0:  BCF    FC6.5
036E2:  MOVLW  22
036E4:  MOVWF  FC6
036E6:  MOVLW  40
036E8:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
036EA:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
036EC:  MOVLB  9
036EE:  CLRF   xCD
036F0:  MOVF   xCD,W
036F2:  SUBLW  09
036F4:  BNC   3702
....................       SD_spi_read(0xFF); 
036F6:  MOVF   FC9,W
036F8:  SETF   FC9
036FA:  RRCF   FC7,W
036FC:  BNC   36FA
036FE:  INCF   xCD,F
03700:  BRA    36F0
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
03702:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
03704:  MOVF   1F,W
03706:  SUBLW  04
03708:  BNZ   372E
0370A:  MOVF   20,F
0370C:  BNZ   372E
0370E:  MOVLW  76
03710:  MOVWF  FF6
03712:  MOVLW  06
03714:  MOVWF  FF7
03716:  MOVLW  00
03718:  MOVWF  FF8
0371A:  CLRF   1B
0371C:  BTFSC  FF2.7
0371E:  BSF    1B.7
03720:  BCF    FF2.7
03722:  MOVLB  0
03724:  CALL   0E3A
03728:  BTFSC  1B.7
0372A:  BSF    FF2.7
0372C:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
0372E:  MOVLW  40
03730:  MOVLB  A
03732:  MOVWF  x11
03734:  CLRF   x15
03736:  CLRF   x14
03738:  CLRF   x13
0373A:  CLRF   x12
0373C:  MOVLB  0
0373E:  RCALL  3594
03740:  MOVFF  01,9CE
....................    if (response > 1 ) 
03744:  MOVLB  9
03746:  MOVF   xCE,W
03748:  SUBLW  01
0374A:  BC    37A0
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
0374C:  MOVF   1F,W
0374E:  SUBLW  04
03750:  BNZ   379A
03752:  MOVF   20,F
03754:  BNZ   379A
03756:  MOVLW  86
03758:  MOVWF  FF6
0375A:  MOVLW  06
0375C:  MOVWF  FF7
0375E:  MOVLW  00
03760:  MOVWF  FF8
03762:  CLRF   1B
03764:  BTFSC  FF2.7
03766:  BSF    1B.7
03768:  BCF    FF2.7
0376A:  MOVLW  31
0376C:  MOVLB  A
0376E:  MOVWF  x25
03770:  MOVLB  0
03772:  CALL   1010
03776:  BTFSC  1B.7
03778:  BSF    FF2.7
0377A:  MOVFF  9CE,9D6
0377E:  MOVLW  57
03780:  MOVLB  9
03782:  MOVWF  xD7
03784:  MOVLB  0
03786:  RCALL  3664
03788:  MOVLW  0D
0378A:  BTFSS  F9E.4
0378C:  BRA    378A
0378E:  MOVWF  FAD
03790:  MOVLW  0A
03792:  BTFSS  F9E.4
03794:  BRA    3792
03796:  MOVWF  FAD
03798:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
0379A:  BSF    xD5.0
....................       goto Exit_disk_initialize; 
0379C:  GOTO   441E
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
037A0:  MOVF   1F,W
037A2:  SUBLW  04
037A4:  BNZ   37EE
037A6:  MOVF   20,F
037A8:  BNZ   37EE
037AA:  MOVLW  BE
037AC:  MOVWF  FF6
037AE:  MOVLW  06
037B0:  MOVWF  FF7
037B2:  MOVLW  00
037B4:  MOVWF  FF8
037B6:  CLRF   1B
037B8:  BTFSC  FF2.7
037BA:  BSF    1B.7
037BC:  BCF    FF2.7
037BE:  MOVLW  1A
037C0:  MOVLB  A
037C2:  MOVWF  x25
037C4:  MOVLB  0
037C6:  CALL   1010
037CA:  BTFSC  1B.7
037CC:  BSF    FF2.7
037CE:  MOVFF  9CE,9D6
037D2:  MOVLW  57
037D4:  MOVLB  9
037D6:  MOVWF  xD7
037D8:  MOVLB  0
037DA:  RCALL  3664
037DC:  MOVLW  0D
037DE:  BTFSS  F9E.4
037E0:  BRA    37DE
037E2:  MOVWF  FAD
037E4:  MOVLW  0A
037E6:  BTFSS  F9E.4
037E8:  BRA    37E6
037EA:  MOVWF  FAD
037EC:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
037EE:  MOVLW  48
037F0:  MOVLB  A
037F2:  MOVWF  x11
037F4:  CLRF   x15
037F6:  CLRF   x14
037F8:  MOVLW  01
037FA:  MOVWF  x13
037FC:  MOVLW  AA
037FE:  MOVWF  x12
03800:  MOVLB  0
03802:  RCALL  3594
03804:  MOVFF  01,9CE
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
03808:  MOVF   1F,W
0380A:  SUBLW  04
0380C:  BNZ   3854
0380E:  MOVF   20,F
03810:  BNZ   3854
03812:  MOVLW  E0
03814:  MOVWF  FF6
03816:  MOVLW  06
03818:  MOVWF  FF7
0381A:  MOVLW  00
0381C:  MOVWF  FF8
0381E:  CLRF   1B
03820:  BTFSC  FF2.7
03822:  BSF    1B.7
03824:  BCF    FF2.7
03826:  MOVLW  25
03828:  MOVLB  A
0382A:  MOVWF  x25
0382C:  MOVLB  0
0382E:  CALL   1010
03832:  BTFSC  1B.7
03834:  BSF    FF2.7
03836:  MOVFF  9CE,9D6
0383A:  MOVLW  57
0383C:  MOVLB  9
0383E:  MOVWF  xD7
03840:  MOVLB  0
03842:  RCALL  3664
03844:  MOVLW  0D
03846:  BTFSS  F9E.4
03848:  BRA    3846
0384A:  MOVWF  FAD
0384C:  MOVLW  0A
0384E:  BTFSS  F9E.4
03850:  BRA    384E
03852:  MOVWF  FAD
....................    if (response == 1)  
03854:  MOVLB  9
03856:  DECFSZ xCE,W
03858:  BRA    3C2A
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
0385A:  MOVF   1F,W
0385C:  SUBLW  04
0385E:  BNZ   3884
03860:  MOVF   20,F
03862:  BNZ   3884
03864:  MOVLW  0A
03866:  MOVWF  FF6
03868:  MOVLW  07
0386A:  MOVWF  FF7
0386C:  MOVLW  00
0386E:  MOVWF  FF8
03870:  CLRF   1B
03872:  BTFSC  FF2.7
03874:  BSF    1B.7
03876:  BCF    FF2.7
03878:  MOVLB  0
0387A:  CALL   0E3A
0387E:  BTFSC  1B.7
03880:  BSF    FF2.7
03882:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
03884:  CLRF   xCD
03886:  MOVF   xCD,W
03888:  SUBLW  03
0388A:  BNC   38AA
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
0388C:  CLRF   03
0388E:  MOVF   xCD,W
03890:  ADDLW  CF
03892:  MOVWF  FE9
03894:  MOVLW  09
03896:  ADDWFC 03,W
03898:  MOVWF  FEA
0389A:  MOVF   FC9,W
0389C:  SETF   FC9
0389E:  RRCF   FC7,W
038A0:  BNC   389E
038A2:  MOVFF  FC9,FEF
038A6:  INCF   xCD,F
038A8:  BRA    3886
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
038AA:  MOVF   1F,W
038AC:  SUBLW  04
038AE:  BNZ   3922
038B0:  MOVF   20,F
038B2:  BNZ   3922
038B4:  MOVLW  2C
038B6:  MOVWF  FF6
038B8:  MOVLW  07
038BA:  MOVWF  FF7
038BC:  MOVLW  00
038BE:  MOVWF  FF8
038C0:  CLRF   1B
038C2:  BTFSC  FF2.7
038C4:  BSF    1B.7
038C6:  BCF    FF2.7
038C8:  MOVLW  1F
038CA:  MOVLB  A
038CC:  MOVWF  x25
038CE:  MOVLB  0
038D0:  CALL   1010
038D4:  BTFSC  1B.7
038D6:  BSF    FF2.7
038D8:  MOVFF  9CF,9D6
038DC:  MOVLW  57
038DE:  MOVLB  9
038E0:  MOVWF  xD7
038E2:  MOVLB  0
038E4:  RCALL  3664
038E6:  MOVFF  9D0,9D6
038EA:  MOVLW  57
038EC:  MOVLB  9
038EE:  MOVWF  xD7
038F0:  MOVLB  0
038F2:  RCALL  3664
038F4:  MOVFF  9D1,9D6
038F8:  MOVLW  57
038FA:  MOVLB  9
038FC:  MOVWF  xD7
038FE:  MOVLB  0
03900:  RCALL  3664
03902:  MOVFF  9D2,9D6
03906:  MOVLW  57
03908:  MOVLB  9
0390A:  MOVWF  xD7
0390C:  MOVLB  0
0390E:  RCALL  3664
03910:  MOVLW  0D
03912:  BTFSS  F9E.4
03914:  BRA    3912
03916:  MOVWF  FAD
03918:  MOVLW  0A
0391A:  BTFSS  F9E.4
0391C:  BRA    391A
0391E:  MOVWF  FAD
03920:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
03922:  DECFSZ xD1,W
03924:  BRA    3C00
03926:  MOVF   xD2,W
03928:  SUBLW  AA
0392A:  BTFSS  FD8.2
0392C:  BRA    3C00
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
0392E:  MOVF   1F,W
03930:  SUBLW  04
03932:  BNZ   3958
03934:  MOVF   20,F
03936:  BNZ   3958
03938:  MOVLW  5E
0393A:  MOVWF  FF6
0393C:  MOVLW  07
0393E:  MOVWF  FF7
03940:  MOVLW  00
03942:  MOVWF  FF8
03944:  CLRF   1B
03946:  BTFSC  FF2.7
03948:  BSF    1B.7
0394A:  BCF    FF2.7
0394C:  MOVLB  0
0394E:  CALL   0E3A
03952:  BTFSC  1B.7
03954:  BSF    FF2.7
03956:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
03958:  MOVF   1F,W
0395A:  SUBLW  04
0395C:  BNZ   3982
0395E:  MOVF   20,F
03960:  BNZ   3982
03962:  MOVLW  84
03964:  MOVWF  FF6
03966:  MOVLW  07
03968:  MOVWF  FF7
0396A:  MOVLW  00
0396C:  MOVWF  FF8
0396E:  CLRF   1B
03970:  BTFSC  FF2.7
03972:  BSF    1B.7
03974:  BCF    FF2.7
03976:  MOVLB  0
03978:  CALL   0E3A
0397C:  BTFSC  1B.7
0397E:  BSF    FF2.7
03980:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
03982:  CLRF   xD4
03984:  CLRF   xD3
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
03986:  MOVLW  77
03988:  MOVLB  A
0398A:  MOVWF  x11
0398C:  CLRF   x15
0398E:  CLRF   x14
03990:  CLRF   x13
03992:  CLRF   x12
03994:  MOVLB  0
03996:  RCALL  3594
03998:  MOVFF  01,9CE
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
0399C:  MOVLW  69
0399E:  MOVLB  A
039A0:  MOVWF  x11
039A2:  MOVLW  40
039A4:  MOVWF  x15
039A6:  CLRF   x14
039A8:  CLRF   x13
039AA:  CLRF   x12
039AC:  MOVLB  0
039AE:  RCALL  3594
039B0:  MOVFF  01,9CE
....................          while (response && (Timer < 50000)) 
039B4:  MOVLB  9
039B6:  MOVF   xCE,F
039B8:  BZ    3A0A
039BA:  MOVF   xD4,W
039BC:  SUBLW  C3
039BE:  BNC   3A0A
039C0:  BNZ   39C8
039C2:  MOVF   xD3,W
039C4:  SUBLW  4F
039C6:  BNC   3A0A
....................          { 
....................             delay_us(20); 
039C8:  MOVLW  6A
039CA:  MOVWF  00
039CC:  DECFSZ 00,F
039CE:  BRA    39CC
039D0:  NOP   
....................             Timer++; 
039D2:  INCF   xD3,F
039D4:  BTFSC  FD8.2
039D6:  INCF   xD4,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
039D8:  MOVLW  77
039DA:  MOVLB  A
039DC:  MOVWF  x11
039DE:  CLRF   x15
039E0:  CLRF   x14
039E2:  CLRF   x13
039E4:  CLRF   x12
039E6:  MOVLB  0
039E8:  RCALL  3594
039EA:  MOVFF  01,9CE
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
039EE:  MOVLW  69
039F0:  MOVLB  A
039F2:  MOVWF  x11
039F4:  MOVLW  40
039F6:  MOVWF  x15
039F8:  CLRF   x14
039FA:  CLRF   x13
039FC:  CLRF   x12
039FE:  MOVLB  0
03A00:  RCALL  3594
03A02:  MOVFF  01,9CE
03A06:  BRA    39B4
03A08:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
03A0A:  MOVF   1F,W
03A0C:  SUBLW  04
03A0E:  BNZ   3A98
03A10:  MOVF   20,F
03A12:  BNZ   3A98
03A14:  MOVLW  B2
03A16:  MOVWF  FF6
03A18:  MOVLW  07
03A1A:  MOVWF  FF7
03A1C:  MOVLW  00
03A1E:  MOVWF  FF8
03A20:  CLRF   1B
03A22:  BTFSC  FF2.7
03A24:  BSF    1B.7
03A26:  BCF    FF2.7
03A28:  MOVLW  23
03A2A:  MOVLB  A
03A2C:  MOVWF  x25
03A2E:  MOVLB  0
03A30:  CALL   1010
03A34:  BTFSC  1B.7
03A36:  BSF    FF2.7
03A38:  MOVFF  9CE,9D6
03A3C:  MOVLW  57
03A3E:  MOVLB  9
03A40:  MOVWF  xD7
03A42:  MOVLB  0
03A44:  RCALL  3664
03A46:  MOVLW  D9
03A48:  MOVWF  FF6
03A4A:  MOVLW  07
03A4C:  MOVWF  FF7
03A4E:  MOVLW  00
03A50:  MOVWF  FF8
03A52:  CLRF   1B
03A54:  BTFSC  FF2.7
03A56:  BSF    1B.7
03A58:  BCF    FF2.7
03A5A:  MOVLW  0A
03A5C:  MOVLB  A
03A5E:  MOVWF  x25
03A60:  MOVLB  0
03A62:  CALL   1010
03A66:  BTFSC  1B.7
03A68:  BSF    FF2.7
03A6A:  MOVLW  10
03A6C:  MOVWF  FE9
03A6E:  CLRF   1B
03A70:  BTFSC  FF2.7
03A72:  BSF    1B.7
03A74:  BCF    FF2.7
03A76:  MOVFF  9D4,A26
03A7A:  MOVFF  9D3,A25
03A7E:  CALL   1192
03A82:  BTFSC  1B.7
03A84:  BSF    FF2.7
03A86:  MOVLW  0D
03A88:  BTFSS  F9E.4
03A8A:  BRA    3A88
03A8C:  MOVWF  FAD
03A8E:  MOVLW  0A
03A90:  BTFSS  F9E.4
03A92:  BRA    3A90
03A94:  MOVWF  FAD
03A96:  MOVLB  9
....................          if (!response) 
03A98:  MOVF   xCE,F
03A9A:  BTFSS  FD8.2
03A9C:  BRA    3BFE
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
03A9E:  MOVLW  7A
03AA0:  MOVLB  A
03AA2:  MOVWF  x11
03AA4:  MOVLW  40
03AA6:  MOVWF  x15
03AA8:  CLRF   x14
03AAA:  CLRF   x13
03AAC:  CLRF   x12
03AAE:  MOVLB  0
03AB0:  RCALL  3594
03AB2:  MOVFF  01,9CE
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
03AB6:  MOVF   1F,W
03AB8:  SUBLW  04
03ABA:  BNZ   3B02
03ABC:  MOVF   20,F
03ABE:  BNZ   3B02
03AC0:  MOVLW  EA
03AC2:  MOVWF  FF6
03AC4:  MOVLW  07
03AC6:  MOVWF  FF7
03AC8:  MOVLW  00
03ACA:  MOVWF  FF8
03ACC:  CLRF   1B
03ACE:  BTFSC  FF2.7
03AD0:  BSF    1B.7
03AD2:  BCF    FF2.7
03AD4:  MOVLW  18
03AD6:  MOVLB  A
03AD8:  MOVWF  x25
03ADA:  MOVLB  0
03ADC:  CALL   1010
03AE0:  BTFSC  1B.7
03AE2:  BSF    FF2.7
03AE4:  MOVFF  9CE,9D6
03AE8:  MOVLW  57
03AEA:  MOVLB  9
03AEC:  MOVWF  xD7
03AEE:  MOVLB  0
03AF0:  RCALL  3664
03AF2:  MOVLW  0D
03AF4:  BTFSS  F9E.4
03AF6:  BRA    3AF4
03AF8:  MOVWF  FAD
03AFA:  MOVLW  0A
03AFC:  BTFSS  F9E.4
03AFE:  BRA    3AFC
03B00:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03B02:  MOVLB  9
03B04:  MOVF   xCE,F
03B06:  BTFSS  FD8.2
03B08:  BRA    3BFE
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03B0A:  CLRF   xCD
03B0C:  MOVF   xCD,W
03B0E:  SUBLW  03
03B10:  BNC   3B30
....................                   ocr[i] = SD_spi_read(0xFF); 
03B12:  CLRF   03
03B14:  MOVF   xCD,W
03B16:  ADDLW  CF
03B18:  MOVWF  FE9
03B1A:  MOVLW  09
03B1C:  ADDWFC 03,W
03B1E:  MOVWF  FEA
03B20:  MOVF   FC9,W
03B22:  SETF   FC9
03B24:  RRCF   FC7,W
03B26:  BNC   3B24
03B28:  MOVFF  FC9,FEF
03B2C:  INCF   xCD,F
03B2E:  BRA    3B0C
....................                if (ocr[0] & 0x40) 
03B30:  BTFSS  xCF.6
03B32:  BRA    3B3E
....................                   Card = SDHC; 
03B34:  MOVLW  05
03B36:  MOVLB  4
03B38:  MOVWF  xE3
03B3A:  BRA    3B44
03B3C:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03B3E:  MOVLW  04
03B40:  MOVLB  4
03B42:  MOVWF  xE3
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03B44:  MOVF   1F,W
03B46:  SUBLW  04
03B48:  BNZ   3BFC
03B4A:  MOVF   20,F
03B4C:  BNZ   3BFC
03B4E:  MOVLW  08
03B50:  MOVWF  FF6
03B52:  MOVLW  08
03B54:  MOVWF  FF7
03B56:  MOVLW  00
03B58:  MOVWF  FF8
03B5A:  CLRF   1B
03B5C:  BTFSC  FF2.7
03B5E:  BSF    1B.7
03B60:  BCF    FF2.7
03B62:  MOVLW  1F
03B64:  MOVLB  A
03B66:  MOVWF  x25
03B68:  MOVLB  0
03B6A:  CALL   1010
03B6E:  BTFSC  1B.7
03B70:  BSF    FF2.7
03B72:  MOVLW  10
03B74:  MOVWF  FE9
03B76:  CLRF   1B
03B78:  BTFSC  FF2.7
03B7A:  BSF    1B.7
03B7C:  BCF    FF2.7
03B7E:  MOVFF  9D4,A26
03B82:  MOVFF  9D3,A25
03B86:  CALL   1192
03B8A:  BTFSC  1B.7
03B8C:  BSF    FF2.7
03B8E:  MOVLW  2A
03B90:  MOVWF  FF6
03B92:  MOVLW  08
03B94:  MOVWF  FF7
03B96:  MOVLW  00
03B98:  MOVWF  FF8
03B9A:  CLRF   1B
03B9C:  BTFSC  FF2.7
03B9E:  BSF    1B.7
03BA0:  BCF    FF2.7
03BA2:  MOVLW  08
03BA4:  MOVLB  A
03BA6:  MOVWF  x25
03BA8:  MOVLB  0
03BAA:  CALL   1010
03BAE:  BTFSC  1B.7
03BB0:  BSF    FF2.7
03BB2:  MOVFF  9CF,9D6
03BB6:  MOVLW  57
03BB8:  MOVLB  9
03BBA:  MOVWF  xD7
03BBC:  MOVLB  0
03BBE:  RCALL  3664
03BC0:  MOVFF  9D0,9D6
03BC4:  MOVLW  57
03BC6:  MOVLB  9
03BC8:  MOVWF  xD7
03BCA:  MOVLB  0
03BCC:  RCALL  3664
03BCE:  MOVFF  9D1,9D6
03BD2:  MOVLW  57
03BD4:  MOVLB  9
03BD6:  MOVWF  xD7
03BD8:  MOVLB  0
03BDA:  RCALL  3664
03BDC:  MOVFF  9D2,9D6
03BE0:  MOVLW  57
03BE2:  MOVLB  9
03BE4:  MOVWF  xD7
03BE6:  MOVLB  0
03BE8:  RCALL  3664
03BEA:  MOVLW  0D
03BEC:  BTFSS  F9E.4
03BEE:  BRA    3BEC
03BF0:  MOVWF  FAD
03BF2:  MOVLW  0A
03BF4:  BTFSS  F9E.4
03BF6:  BRA    3BF4
03BF8:  MOVWF  FAD
03BFA:  MOVLB  4
03BFC:  MOVLB  9
....................             } 
....................          } 
....................       } 
03BFE:  BRA    3C2A
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03C00:  MOVF   1F,W
03C02:  SUBLW  04
03C04:  BNZ   3C2A
03C06:  MOVF   20,F
03C08:  BNZ   3C2A
03C0A:  MOVLW  46
03C0C:  MOVWF  FF6
03C0E:  MOVLW  08
03C10:  MOVWF  FF7
03C12:  MOVLW  00
03C14:  MOVWF  FF8
03C16:  CLRF   1B
03C18:  BTFSC  FF2.7
03C1A:  BSF    1B.7
03C1C:  BCF    FF2.7
03C1E:  MOVLB  0
03C20:  CALL   0E3A
03C24:  BTFSC  1B.7
03C26:  BSF    FF2.7
03C28:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03C2A:  MOVLB  4
03C2C:  MOVF   xE3,F
03C2E:  BTFSS  FD8.2
03C30:  BRA    4100
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03C32:  MOVF   1F,W
03C34:  SUBLW  04
03C36:  BNZ   3C5C
03C38:  MOVF   20,F
03C3A:  BNZ   3C5C
03C3C:  MOVLW  78
03C3E:  MOVWF  FF6
03C40:  MOVLW  08
03C42:  MOVWF  FF7
03C44:  MOVLW  00
03C46:  MOVWF  FF8
03C48:  CLRF   1B
03C4A:  BTFSC  FF2.7
03C4C:  BSF    1B.7
03C4E:  BCF    FF2.7
03C50:  MOVLB  0
03C52:  CALL   0E3A
03C56:  BTFSC  1B.7
03C58:  BSF    FF2.7
03C5A:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03C5C:  MOVLW  40
03C5E:  MOVLB  A
03C60:  MOVWF  x11
03C62:  CLRF   x15
03C64:  CLRF   x14
03C66:  CLRF   x13
03C68:  CLRF   x12
03C6A:  MOVLB  0
03C6C:  RCALL  3594
03C6E:  MOVFF  01,9CE
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03C72:  MOVF   1F,W
03C74:  SUBLW  04
03C76:  BNZ   3CBE
03C78:  MOVF   20,F
03C7A:  BNZ   3CBE
03C7C:  MOVLW  B8
03C7E:  MOVWF  FF6
03C80:  MOVLW  08
03C82:  MOVWF  FF7
03C84:  MOVLW  00
03C86:  MOVWF  FF8
03C88:  CLRF   1B
03C8A:  BTFSC  FF2.7
03C8C:  BSF    1B.7
03C8E:  BCF    FF2.7
03C90:  MOVLW  1C
03C92:  MOVLB  A
03C94:  MOVWF  x25
03C96:  MOVLB  0
03C98:  CALL   1010
03C9C:  BTFSC  1B.7
03C9E:  BSF    FF2.7
03CA0:  MOVFF  9CE,9D6
03CA4:  MOVLW  57
03CA6:  MOVLB  9
03CA8:  MOVWF  xD7
03CAA:  MOVLB  0
03CAC:  RCALL  3664
03CAE:  MOVLW  0D
03CB0:  BTFSS  F9E.4
03CB2:  BRA    3CB0
03CB4:  MOVWF  FAD
03CB6:  MOVLW  0A
03CB8:  BTFSS  F9E.4
03CBA:  BRA    3CB8
03CBC:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03CBE:  MOVLB  9
03CC0:  DECFSZ xCE,W
03CC2:  BRA    3CC6
03CC4:  BRA    3CD0
03CC6:  MOVF   xCE,F
03CC8:  BZ    3CD0
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03CCA:  BSF    xD5.0
....................          goto Exit_disk_initialize; 
03CCC:  GOTO   441E
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03CD0:  CLRF   xD4
03CD2:  CLRF   xD3
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03CD4:  MOVLW  41
03CD6:  MOVLB  A
03CD8:  MOVWF  x11
03CDA:  CLRF   x15
03CDC:  CLRF   x14
03CDE:  CLRF   x13
03CE0:  CLRF   x12
03CE2:  MOVLB  0
03CE4:  RCALL  3594
03CE6:  MOVFF  01,9CE
....................          if (response != 0x00 ) 
03CEA:  MOVLB  9
03CEC:  MOVF   xCE,F
03CEE:  BZ    3CF8
....................             delay_us(10); 
03CF0:  MOVLW  35
03CF2:  MOVWF  00
03CF4:  DECFSZ 00,F
03CF6:  BRA    3CF4
....................          Timer++; 
03CF8:  INCF   xD3,F
03CFA:  BTFSC  FD8.2
03CFC:  INCF   xD4,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03CFE:  MOVF   xCE,F
03D00:  BZ    3D10
03D02:  MOVF   xD4,W
03D04:  SUBLW  C3
03D06:  BNC   3D10
03D08:  BNZ   3CD4
03D0A:  MOVF   xD3,W
03D0C:  SUBLW  4F
03D0E:  BC    3CD4
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03D10:  MOVF   1F,W
03D12:  SUBLW  04
03D14:  BNZ   3D9E
03D16:  MOVF   20,F
03D18:  BNZ   3D9E
03D1A:  MOVLW  DC
03D1C:  MOVWF  FF6
03D1E:  MOVLW  08
03D20:  MOVWF  FF7
03D22:  MOVLW  00
03D24:  MOVWF  FF8
03D26:  CLRF   1B
03D28:  BTFSC  FF2.7
03D2A:  BSF    1B.7
03D2C:  BCF    FF2.7
03D2E:  MOVLW  28
03D30:  MOVLB  A
03D32:  MOVWF  x25
03D34:  MOVLB  0
03D36:  CALL   1010
03D3A:  BTFSC  1B.7
03D3C:  BSF    FF2.7
03D3E:  MOVFF  9CE,9D6
03D42:  MOVLW  57
03D44:  MOVLB  9
03D46:  MOVWF  xD7
03D48:  MOVLB  0
03D4A:  RCALL  3664
03D4C:  MOVLW  08
03D4E:  MOVWF  FF6
03D50:  MOVLW  09
03D52:  MOVWF  FF7
03D54:  MOVLW  00
03D56:  MOVWF  FF8
03D58:  CLRF   1B
03D5A:  BTFSC  FF2.7
03D5C:  BSF    1B.7
03D5E:  BCF    FF2.7
03D60:  MOVLW  0A
03D62:  MOVLB  A
03D64:  MOVWF  x25
03D66:  MOVLB  0
03D68:  CALL   1010
03D6C:  BTFSC  1B.7
03D6E:  BSF    FF2.7
03D70:  MOVLW  10
03D72:  MOVWF  FE9
03D74:  CLRF   1B
03D76:  BTFSC  FF2.7
03D78:  BSF    1B.7
03D7A:  BCF    FF2.7
03D7C:  MOVFF  9D4,A26
03D80:  MOVFF  9D3,A25
03D84:  CALL   1192
03D88:  BTFSC  1B.7
03D8A:  BSF    FF2.7
03D8C:  MOVLW  0D
03D8E:  BTFSS  F9E.4
03D90:  BRA    3D8E
03D92:  MOVWF  FAD
03D94:  MOVLW  0A
03D96:  BTFSS  F9E.4
03D98:  BRA    3D96
03D9A:  MOVWF  FAD
03D9C:  MOVLB  9
....................       if(response) 
03D9E:  MOVF   xCE,F
03DA0:  BZ    3DA6
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03DA2:  BSF    xD5.0
....................          goto Exit_disk_initialize; 
03DA4:  BRA    441E
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03DA6:  MOVLW  77
03DA8:  MOVLB  A
03DAA:  MOVWF  x11
03DAC:  CLRF   x15
03DAE:  CLRF   x14
03DB0:  CLRF   x13
03DB2:  CLRF   x12
03DB4:  MOVLB  0
03DB6:  CALL   3594
03DBA:  MOVFF  01,9CE
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03DBE:  MOVF   1F,W
03DC0:  SUBLW  04
03DC2:  BNZ   3E0A
03DC4:  MOVF   20,F
03DC6:  BNZ   3E0A
03DC8:  MOVLW  18
03DCA:  MOVWF  FF6
03DCC:  MOVLW  09
03DCE:  MOVWF  FF7
03DD0:  MOVLW  00
03DD2:  MOVWF  FF8
03DD4:  CLRF   1B
03DD6:  BTFSC  FF2.7
03DD8:  BSF    1B.7
03DDA:  BCF    FF2.7
03DDC:  MOVLW  43
03DDE:  MOVLB  A
03DE0:  MOVWF  x25
03DE2:  MOVLB  0
03DE4:  CALL   1010
03DE8:  BTFSC  1B.7
03DEA:  BSF    FF2.7
03DEC:  MOVFF  9CE,9D6
03DF0:  MOVLW  57
03DF2:  MOVLB  9
03DF4:  MOVWF  xD7
03DF6:  MOVLB  0
03DF8:  RCALL  3664
03DFA:  MOVLW  0D
03DFC:  BTFSS  F9E.4
03DFE:  BRA    3DFC
03E00:  MOVWF  FAD
03E02:  MOVLW  0A
03E04:  BTFSS  F9E.4
03E06:  BRA    3E04
03E08:  MOVWF  FAD
....................       if (response) 
03E0A:  MOVLB  9
03E0C:  MOVF   xCE,F
03E0E:  BZ    3E1A
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03E10:  MOVLW  02
03E12:  MOVLB  4
03E14:  MOVWF  xE3
....................          } 
03E16:  BRA    4014
03E18:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03E1A:  MOVLW  69
03E1C:  MOVLB  A
03E1E:  MOVWF  x11
03E20:  CLRF   x15
03E22:  CLRF   x14
03E24:  CLRF   x13
03E26:  CLRF   x12
03E28:  MOVLB  0
03E2A:  CALL   3594
03E2E:  MOVFF  01,9CE
....................          if (response <= 1 ) 
03E32:  MOVLB  9
03E34:  MOVF   xCE,W
03E36:  SUBLW  01
03E38:  BNC   3E44
....................             Card = SDv1; 
03E3A:  MOVLW  03
03E3C:  MOVLB  4
03E3E:  MOVWF  xE3
03E40:  BRA    4014
03E42:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03E44:  MOVF   1F,W
03E46:  SUBLW  04
03E48:  BNZ   3EA8
03E4A:  MOVF   20,F
03E4C:  BNZ   3EA8
03E4E:  MOVLW  62
03E50:  MOVWF  FF6
03E52:  MOVLW  09
03E54:  MOVWF  FF7
03E56:  MOVLW  00
03E58:  MOVWF  FF8
03E5A:  CLRF   1B
03E5C:  BTFSC  FF2.7
03E5E:  BSF    1B.7
03E60:  BCF    FF2.7
03E62:  MOVLW  2E
03E64:  MOVLB  A
03E66:  MOVWF  x25
03E68:  MOVLB  0
03E6A:  CALL   1010
03E6E:  BTFSC  1B.7
03E70:  BSF    FF2.7
03E72:  MOVFF  9CE,9D6
03E76:  MOVLW  37
03E78:  MOVLB  9
03E7A:  MOVWF  xD7
03E7C:  MOVLB  0
03E7E:  CALL   3664
03E82:  MOVLW  94
03E84:  MOVWF  FF6
03E86:  MOVLW  09
03E88:  MOVWF  FF7
03E8A:  MOVLW  00
03E8C:  MOVWF  FF8
03E8E:  CLRF   1B
03E90:  BTFSC  FF2.7
03E92:  BSF    1B.7
03E94:  BCF    FF2.7
03E96:  MOVLW  19
03E98:  MOVLB  A
03E9A:  MOVWF  x25
03E9C:  MOVLB  0
03E9E:  CALL   1010
03EA2:  BTFSC  1B.7
03EA4:  BSF    FF2.7
03EA6:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03EA8:  MOVLW  40
03EAA:  MOVLB  A
03EAC:  MOVWF  x11
03EAE:  CLRF   x15
03EB0:  CLRF   x14
03EB2:  CLRF   x13
03EB4:  CLRF   x12
03EB6:  MOVLB  0
03EB8:  CALL   3594
03EBC:  MOVFF  01,9CE
....................             if ((response !=0x01) && (response != 0)) 
03EC0:  MOVLB  9
03EC2:  DECFSZ xCE,W
03EC4:  BRA    3EC8
03EC6:  BRA    3F34
03EC8:  MOVF   xCE,F
03ECA:  BZ    3F34
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03ECC:  MOVF   1F,W
03ECE:  SUBLW  04
03ED0:  BNZ   3F30
03ED2:  MOVF   20,F
03ED4:  BNZ   3F30
03ED6:  MOVLW  AE
03ED8:  MOVWF  FF6
03EDA:  MOVLW  09
03EDC:  MOVWF  FF7
03EDE:  MOVLW  00
03EE0:  MOVWF  FF8
03EE2:  CLRF   1B
03EE4:  BTFSC  FF2.7
03EE6:  BSF    1B.7
03EE8:  BCF    FF2.7
03EEA:  MOVLW  2C
03EEC:  MOVLB  A
03EEE:  MOVWF  x25
03EF0:  MOVLB  0
03EF2:  CALL   1010
03EF6:  BTFSC  1B.7
03EF8:  BSF    FF2.7
03EFA:  MOVFF  9CE,9D6
03EFE:  MOVLW  37
03F00:  MOVLB  9
03F02:  MOVWF  xD7
03F04:  MOVLB  0
03F06:  CALL   3664
03F0A:  MOVLW  DE
03F0C:  MOVWF  FF6
03F0E:  MOVLW  09
03F10:  MOVWF  FF7
03F12:  MOVLW  00
03F14:  MOVWF  FF8
03F16:  CLRF   1B
03F18:  BTFSC  FF2.7
03F1A:  BSF    1B.7
03F1C:  BCF    FF2.7
03F1E:  MOVLW  0B
03F20:  MOVLB  A
03F22:  MOVWF  x25
03F24:  MOVLB  0
03F26:  CALL   1010
03F2A:  BTFSC  1B.7
03F2C:  BSF    FF2.7
03F2E:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03F30:  BSF    xD5.0
....................                goto Exit_disk_initialize; 
03F32:  BRA    441E
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03F34:  CLRF   xD4
03F36:  CLRF   xD3
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03F38:  MOVLW  41
03F3A:  MOVLB  A
03F3C:  MOVWF  x11
03F3E:  CLRF   x15
03F40:  CLRF   x14
03F42:  CLRF   x13
03F44:  CLRF   x12
03F46:  MOVLB  0
03F48:  CALL   3594
03F4C:  MOVFF  01,9CE
....................                if (response != 0x00 ) 
03F50:  MOVLB  9
03F52:  MOVF   xCE,F
03F54:  BZ    3F5E
....................                   delay_us(10); 
03F56:  MOVLW  35
03F58:  MOVWF  00
03F5A:  DECFSZ 00,F
03F5C:  BRA    3F5A
....................                Timer++; 
03F5E:  INCF   xD3,F
03F60:  BTFSC  FD8.2
03F62:  INCF   xD4,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03F64:  MOVF   xCE,F
03F66:  BZ    3F76
03F68:  MOVF   xD4,W
03F6A:  SUBLW  C3
03F6C:  BNC   3F76
03F6E:  BNZ   3F38
03F70:  MOVF   xD3,W
03F72:  SUBLW  4F
03F74:  BC    3F38
....................     
....................             if(response) 
03F76:  MOVF   xCE,F
03F78:  BZ    400E
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03F7A:  MOVF   1F,W
03F7C:  SUBLW  04
03F7E:  BNZ   400A
03F80:  MOVF   20,F
03F82:  BNZ   400A
03F84:  MOVLW  EA
03F86:  MOVWF  FF6
03F88:  MOVLW  09
03F8A:  MOVWF  FF7
03F8C:  MOVLW  00
03F8E:  MOVWF  FF8
03F90:  CLRF   1B
03F92:  BTFSC  FF2.7
03F94:  BSF    1B.7
03F96:  BCF    FF2.7
03F98:  MOVLW  4A
03F9A:  MOVLB  A
03F9C:  MOVWF  x25
03F9E:  MOVLB  0
03FA0:  CALL   1010
03FA4:  BTFSC  1B.7
03FA6:  BSF    FF2.7
03FA8:  MOVFF  9CE,9D6
03FAC:  MOVLW  37
03FAE:  MOVLB  9
03FB0:  MOVWF  xD7
03FB2:  MOVLB  0
03FB4:  CALL   3664
03FB8:  MOVLW  38
03FBA:  MOVWF  FF6
03FBC:  MOVLW  0A
03FBE:  MOVWF  FF7
03FC0:  MOVLW  00
03FC2:  MOVWF  FF8
03FC4:  CLRF   1B
03FC6:  BTFSC  FF2.7
03FC8:  BSF    1B.7
03FCA:  BCF    FF2.7
03FCC:  MOVLW  0A
03FCE:  MOVLB  A
03FD0:  MOVWF  x25
03FD2:  MOVLB  0
03FD4:  CALL   1010
03FD8:  BTFSC  1B.7
03FDA:  BSF    FF2.7
03FDC:  MOVLW  10
03FDE:  MOVWF  FE9
03FE0:  CLRF   1B
03FE2:  BTFSC  FF2.7
03FE4:  BSF    1B.7
03FE6:  BCF    FF2.7
03FE8:  MOVFF  9D4,A26
03FEC:  MOVFF  9D3,A25
03FF0:  CALL   1192
03FF4:  BTFSC  1B.7
03FF6:  BSF    FF2.7
03FF8:  MOVLW  0D
03FFA:  BTFSS  F9E.4
03FFC:  BRA    3FFA
03FFE:  MOVWF  FAD
04000:  MOVLW  0A
04002:  BTFSS  F9E.4
04004:  BRA    4002
04006:  MOVWF  FAD
04008:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
0400A:  BSF    xD5.0
....................                goto Exit_disk_initialize; 
0400C:  BRA    441E
....................                } 
....................  
....................             Card = MMC; 
0400E:  MOVLW  02
04010:  MOVLB  4
04012:  MOVWF  xE3
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
04014:  MOVF   1F,W
04016:  SUBLW  04
04018:  BNZ   403E
0401A:  MOVF   20,F
0401C:  BNZ   403E
0401E:  MOVLW  48
04020:  MOVWF  FF6
04022:  MOVLW  0A
04024:  MOVWF  FF7
04026:  MOVLW  00
04028:  MOVWF  FF8
0402A:  CLRF   1B
0402C:  BTFSC  FF2.7
0402E:  BSF    1B.7
04030:  BCF    FF2.7
04032:  MOVLB  0
04034:  CALL   0E3A
04038:  BTFSC  1B.7
0403A:  BSF    FF2.7
0403C:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
0403E:  MOVLW  50
04040:  MOVLB  A
04042:  MOVWF  x11
04044:  CLRF   x15
04046:  CLRF   x14
04048:  MOVLW  02
0404A:  MOVWF  x13
0404C:  CLRF   x12
0404E:  MOVLB  0
04050:  CALL   3594
04054:  MOVFF  01,9CE
....................       if ((Timer == 50000) || (response > 1))    
04058:  MOVLB  9
0405A:  MOVF   xD3,W
0405C:  SUBLW  50
0405E:  BNZ   4066
04060:  MOVF   xD4,W
04062:  SUBLW  C3
04064:  BZ    406C
04066:  MOVF   xCE,W
04068:  SUBLW  01
0406A:  BC    4102
....................       { 
....................          Card = None; 
0406C:  MOVLB  4
0406E:  CLRF   xE3
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
04070:  MOVF   1F,W
04072:  SUBLW  04
04074:  BNZ   4100
04076:  MOVF   20,F
04078:  BNZ   4100
0407A:  MOVLW  64
0407C:  MOVWF  FF6
0407E:  MOVLW  0A
04080:  MOVWF  FF7
04082:  MOVLW  00
04084:  MOVWF  FF8
04086:  CLRF   1B
04088:  BTFSC  FF2.7
0408A:  BSF    1B.7
0408C:  BCF    FF2.7
0408E:  MOVLW  2B
04090:  MOVLB  A
04092:  MOVWF  x25
04094:  MOVLB  0
04096:  CALL   1010
0409A:  BTFSC  1B.7
0409C:  BSF    FF2.7
0409E:  MOVFF  9CE,9D6
040A2:  MOVLW  57
040A4:  MOVLB  9
040A6:  MOVWF  xD7
040A8:  MOVLB  0
040AA:  CALL   3664
040AE:  MOVLW  93
040B0:  MOVWF  FF6
040B2:  MOVLW  0A
040B4:  MOVWF  FF7
040B6:  MOVLW  00
040B8:  MOVWF  FF8
040BA:  CLRF   1B
040BC:  BTFSC  FF2.7
040BE:  BSF    1B.7
040C0:  BCF    FF2.7
040C2:  MOVLW  0A
040C4:  MOVLB  A
040C6:  MOVWF  x25
040C8:  MOVLB  0
040CA:  CALL   1010
040CE:  BTFSC  1B.7
040D0:  BSF    FF2.7
040D2:  MOVLW  10
040D4:  MOVWF  FE9
040D6:  CLRF   1B
040D8:  BTFSC  FF2.7
040DA:  BSF    1B.7
040DC:  BCF    FF2.7
040DE:  MOVFF  9D4,A26
040E2:  MOVFF  9D3,A25
040E6:  CALL   1192
040EA:  BTFSC  1B.7
040EC:  BSF    FF2.7
040EE:  MOVLW  0D
040F0:  BTFSS  F9E.4
040F2:  BRA    40F0
040F4:  MOVWF  FAD
040F6:  MOVLW  0A
040F8:  BTFSS  F9E.4
040FA:  BRA    40F8
040FC:  MOVWF  FAD
040FE:  MOVLB  4
04100:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
04102:  MOVLB  4
04104:  MOVF   xE3,F
04106:  BNZ   413A
....................    { 
....................       if (nv_report_mode == 4) 
04108:  MOVF   1F,W
0410A:  SUBLW  04
0410C:  BNZ   4132
0410E:  MOVF   20,F
04110:  BNZ   4132
....................          printf("@FS:Card Type Discovery Error\r\n"); 
04112:  MOVLW  A4
04114:  MOVWF  FF6
04116:  MOVLW  0A
04118:  MOVWF  FF7
0411A:  MOVLW  00
0411C:  MOVWF  FF8
0411E:  CLRF   1B
04120:  BTFSC  FF2.7
04122:  BSF    1B.7
04124:  BCF    FF2.7
04126:  MOVLB  0
04128:  CALL   0E3A
0412C:  BTFSC  1B.7
0412E:  BSF    FF2.7
04130:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
04132:  MOVLB  9
04134:  BSF    xD5.0
....................       goto Exit_disk_initialize; 
04136:  BRA    441E
04138:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
0413A:  MOVF   xE3,W
0413C:  XORLW  02
0413E:  MOVLB  0
04140:  BZ    4150
04142:  XORLW  01
04144:  BZ    4178
04146:  XORLW  07
04148:  BZ    41A0
0414A:  XORLW  01
0414C:  BZ    41C8
0414E:  BRA    41F0
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
04150:  MOVF   1F,W
04152:  SUBLW  04
04154:  BNZ   4176
04156:  MOVF   20,F
04158:  BNZ   4176
0415A:  MOVLW  C4
0415C:  MOVWF  FF6
0415E:  MOVLW  0A
04160:  MOVWF  FF7
04162:  MOVLW  00
04164:  MOVWF  FF8
04166:  CLRF   1B
04168:  BTFSC  FF2.7
0416A:  BSF    1B.7
0416C:  BCF    FF2.7
0416E:  CALL   0E3A
04172:  BTFSC  1B.7
04174:  BSF    FF2.7
....................          break; 
04176:  BRA    4246
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
04178:  MOVF   1F,W
0417A:  SUBLW  04
0417C:  BNZ   419E
0417E:  MOVF   20,F
04180:  BNZ   419E
04182:  MOVLW  DA
04184:  MOVWF  FF6
04186:  MOVLW  0A
04188:  MOVWF  FF7
0418A:  MOVLW  00
0418C:  MOVWF  FF8
0418E:  CLRF   1B
04190:  BTFSC  FF2.7
04192:  BSF    1B.7
04194:  BCF    FF2.7
04196:  CALL   0E3A
0419A:  BTFSC  1B.7
0419C:  BSF    FF2.7
....................          break; 
0419E:  BRA    4246
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
041A0:  MOVF   1F,W
041A2:  SUBLW  04
041A4:  BNZ   41C6
041A6:  MOVF   20,F
041A8:  BNZ   41C6
041AA:  MOVLW  F0
041AC:  MOVWF  FF6
041AE:  MOVLW  0A
041B0:  MOVWF  FF7
041B2:  MOVLW  00
041B4:  MOVWF  FF8
041B6:  CLRF   1B
041B8:  BTFSC  FF2.7
041BA:  BSF    1B.7
041BC:  BCF    FF2.7
041BE:  CALL   0E3A
041C2:  BTFSC  1B.7
041C4:  BSF    FF2.7
....................          break; 
041C6:  BRA    4246
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
041C8:  MOVF   1F,W
041CA:  SUBLW  04
041CC:  BNZ   41EE
041CE:  MOVF   20,F
041D0:  BNZ   41EE
041D2:  MOVLW  06
041D4:  MOVWF  FF6
041D6:  MOVLW  0B
041D8:  MOVWF  FF7
041DA:  MOVLW  00
041DC:  MOVWF  FF8
041DE:  CLRF   1B
041E0:  BTFSC  FF2.7
041E2:  BSF    1B.7
041E4:  BCF    FF2.7
041E6:  CALL   0E3A
041EA:  BTFSC  1B.7
041EC:  BSF    FF2.7
....................          break; 
041EE:  BRA    4246
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
041F0:  MOVF   1F,W
041F2:  SUBLW  04
041F4:  BNZ   423E
041F6:  MOVF   20,F
041F8:  BNZ   423E
041FA:  MOVLW  1C
041FC:  MOVWF  FF6
041FE:  MOVLW  0B
04200:  MOVWF  FF7
04202:  MOVLW  00
04204:  MOVWF  FF8
04206:  CLRF   1B
04208:  BTFSC  FF2.7
0420A:  BSF    1B.7
0420C:  BCF    FF2.7
0420E:  MOVLW  26
04210:  MOVLB  A
04212:  MOVWF  x25
04214:  MOVLB  0
04216:  CALL   1010
0421A:  BTFSC  1B.7
0421C:  BSF    FF2.7
0421E:  MOVFF  4E3,9D6
04222:  MOVLW  37
04224:  MOVLB  9
04226:  MOVWF  xD7
04228:  MOVLB  0
0422A:  CALL   3664
0422E:  MOVLW  0D
04230:  BTFSS  F9E.4
04232:  BRA    4230
04234:  MOVWF  FAD
04236:  MOVLW  0A
04238:  BTFSS  F9E.4
0423A:  BRA    4238
0423C:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
0423E:  MOVLB  9
04240:  BSF    xD5.0
....................          goto Exit_disk_initialize; 
04242:  BRA    441E
04244:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
04246:  MOVLB  9
04248:  BCF    xD5.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
0424A:  MOVF   1F,W
0424C:  SUBLW  04
0424E:  BNZ   42A6
04250:  MOVF   20,F
04252:  BNZ   42A6
04254:  MOVLW  4A
04256:  MOVWF  FF6
04258:  MOVLW  0B
0425A:  MOVWF  FF7
0425C:  MOVLW  00
0425E:  MOVWF  FF8
04260:  CLRF   1B
04262:  BTFSC  FF2.7
04264:  BSF    1B.7
04266:  BCF    FF2.7
04268:  MOVLW  2E
0426A:  MOVLB  A
0426C:  MOVWF  x25
0426E:  MOVLB  0
04270:  CALL   1010
04274:  BTFSC  1B.7
04276:  BSF    FF2.7
04278:  MOVLW  10
0427A:  MOVWF  FE9
0427C:  CLRF   1B
0427E:  BTFSC  FF2.7
04280:  BSF    1B.7
04282:  BCF    FF2.7
04284:  MOVFF  9D4,A26
04288:  MOVFF  9D3,A25
0428C:  CALL   1192
04290:  BTFSC  1B.7
04292:  BSF    FF2.7
04294:  MOVLW  0D
04296:  BTFSS  F9E.4
04298:  BRA    4296
0429A:  MOVWF  FAD
0429C:  MOVLW  0A
0429E:  BTFSS  F9E.4
042A0:  BRA    429E
042A2:  MOVWF  FAD
042A4:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
042A6:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
042A8:  BCF    FC6.5
042AA:  MOVLW  20
042AC:  MOVWF  FC6
042AE:  MOVLW  40
042B0:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
042B2:  BCF    F9E.3
....................    SelectSD; 
042B4:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
042B6:  MOVF   1F,W
042B8:  SUBLW  04
042BA:  BNZ   42E0
042BC:  MOVF   20,F
042BE:  BNZ   42E0
042C0:  MOVLW  7E
042C2:  MOVWF  FF6
042C4:  MOVLW  0B
042C6:  MOVWF  FF7
042C8:  MOVLW  00
042CA:  MOVWF  FF8
042CC:  CLRF   1B
042CE:  BTFSC  FF2.7
042D0:  BSF    1B.7
042D2:  BCF    FF2.7
042D4:  MOVLB  0
042D6:  CALL   0E3A
042DA:  BTFSC  1B.7
042DC:  BSF    FF2.7
042DE:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
042E0:  CLRF   xD4
042E2:  CLRF   xD3
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
042E4:  MOVLW  41
042E6:  MOVLB  A
042E8:  MOVWF  x11
042EA:  CLRF   x15
042EC:  CLRF   x14
042EE:  CLRF   x13
042F0:  CLRF   x12
042F2:  MOVLB  0
042F4:  CALL   3594
042F8:  MOVFF  01,9CE
....................       if (response != 0x00 ) 
042FC:  MOVLB  9
042FE:  MOVF   xCE,F
04300:  BZ    430A
....................          delay_us(10); 
04302:  MOVLW  35
04304:  MOVWF  00
04306:  DECFSZ 00,F
04308:  BRA    4306
....................  
....................       Timer++; 
0430A:  INCF   xD3,F
0430C:  BTFSC  FD8.2
0430E:  INCF   xD4,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
04310:  MOVF   xCE,F
04312:  BZ    4322
04314:  MOVF   xD4,W
04316:  SUBLW  C3
04318:  BNC   4322
0431A:  BNZ   42E4
0431C:  MOVF   xD3,W
0431E:  SUBLW  4F
04320:  BC    42E4
....................  
....................    if (response != 0x00) 
04322:  MOVF   xCE,F
04324:  BZ    43BA
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
04326:  MOVF   1F,W
04328:  SUBLW  04
0432A:  BNZ   43B6
0432C:  MOVF   20,F
0432E:  BNZ   43B6
04330:  MOVLW  9E
04332:  MOVWF  FF6
04334:  MOVLW  0B
04336:  MOVWF  FF7
04338:  MOVLW  00
0433A:  MOVWF  FF8
0433C:  CLRF   1B
0433E:  BTFSC  FF2.7
04340:  BSF    1B.7
04342:  BCF    FF2.7
04344:  MOVLW  26
04346:  MOVLB  A
04348:  MOVWF  x25
0434A:  MOVLB  0
0434C:  CALL   1010
04350:  BTFSC  1B.7
04352:  BSF    FF2.7
04354:  MOVFF  9CE,9D6
04358:  MOVLW  37
0435A:  MOVLB  9
0435C:  MOVWF  xD7
0435E:  MOVLB  0
04360:  CALL   3664
04364:  MOVLW  C8
04366:  MOVWF  FF6
04368:  MOVLW  0B
0436A:  MOVWF  FF7
0436C:  MOVLW  00
0436E:  MOVWF  FF8
04370:  CLRF   1B
04372:  BTFSC  FF2.7
04374:  BSF    1B.7
04376:  BCF    FF2.7
04378:  MOVLW  0A
0437A:  MOVLB  A
0437C:  MOVWF  x25
0437E:  MOVLB  0
04380:  CALL   1010
04384:  BTFSC  1B.7
04386:  BSF    FF2.7
04388:  MOVLW  10
0438A:  MOVWF  FE9
0438C:  CLRF   1B
0438E:  BTFSC  FF2.7
04390:  BSF    1B.7
04392:  BCF    FF2.7
04394:  MOVFF  9D4,A26
04398:  MOVFF  9D3,A25
0439C:  CALL   1192
043A0:  BTFSC  1B.7
043A2:  BSF    FF2.7
043A4:  MOVLW  0D
043A6:  BTFSS  F9E.4
043A8:  BRA    43A6
043AA:  MOVWF  FAD
043AC:  MOVLW  0A
043AE:  BTFSS  F9E.4
043B0:  BRA    43AE
043B2:  MOVWF  FAD
043B4:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
043B6:  BSF    xD5.0
....................       goto Exit_disk_initialize; 
043B8:  BRA    441E
....................    } 
....................  
....................    if (nv_report_mode == 4) 
043BA:  MOVF   1F,W
043BC:  SUBLW  04
043BE:  BNZ   4416
043C0:  MOVF   20,F
043C2:  BNZ   4416
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
043C4:  MOVLW  D8
043C6:  MOVWF  FF6
043C8:  MOVLW  0B
043CA:  MOVWF  FF7
043CC:  MOVLW  00
043CE:  MOVWF  FF8
043D0:  CLRF   1B
043D2:  BTFSC  FF2.7
043D4:  BSF    1B.7
043D6:  BCF    FF2.7
043D8:  MOVLW  25
043DA:  MOVLB  A
043DC:  MOVWF  x25
043DE:  MOVLB  0
043E0:  CALL   1010
043E4:  BTFSC  1B.7
043E6:  BSF    FF2.7
043E8:  MOVLW  10
043EA:  MOVWF  FE9
043EC:  CLRF   1B
043EE:  BTFSC  FF2.7
043F0:  BSF    1B.7
043F2:  BCF    FF2.7
043F4:  MOVFF  9D4,A26
043F8:  MOVFF  9D3,A25
043FC:  CALL   1192
04400:  BTFSC  1B.7
04402:  BSF    FF2.7
04404:  MOVLW  0D
04406:  BTFSS  F9E.4
04408:  BRA    4406
0440A:  MOVWF  FAD
0440C:  MOVLW  0A
0440E:  BTFSS  F9E.4
04410:  BRA    440E
04412:  MOVWF  FAD
04414:  MOVLB  9
....................  
....................    msg_card_ok(); 
04416:  MOVLB  0
04418:  GOTO   36AA
0441C:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
0441E:  BSF    F91.1
....................    return(SDCardStatus); 
04420:  MOVFF  9D5,01
04424:  MOVLB  0
04426:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05AC8:  MOVLW  20
05ACA:  MOVLB  7
05ACC:  ADDWF  x0E,W
05ACE:  MOVWF  FE9
05AD0:  MOVLW  00
05AD2:  ADDWFC x0F,W
05AD4:  MOVWF  FEA
05AD6:  MOVFF  FEF,9FE
05ADA:  MOVFF  FEC,9FF
05ADE:  MOVFF  FEC,A00
05AE2:  MOVFF  FEC,A01
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05AE6:  MOVLB  9
05AE8:  MOVF   xFA,W
05AEA:  SUBWF  xFE,W
05AEC:  BNZ   5B10
05AEE:  MOVF   xFB,W
05AF0:  SUBWF  xFF,W
05AF2:  BNZ   5B10
05AF4:  MOVF   xFC,W
05AF6:  MOVLB  A
05AF8:  SUBWF  x00,W
05AFA:  BTFSC  FD8.2
05AFC:  BRA    5B02
05AFE:  MOVLB  9
05B00:  BRA    5B10
05B02:  MOVLB  9
05B04:  MOVF   xFD,W
05B06:  MOVLB  A
05B08:  SUBWF  x01,W
05B0A:  BTFSC  FD8.2
05B0C:  BRA    5CFE
05B0E:  MOVLB  9
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05B10:  MOVLW  06
05B12:  MOVLB  7
05B14:  ADDWF  x0E,W
05B16:  MOVWF  FE9
05B18:  MOVLW  00
05B1A:  ADDWFC x0F,W
05B1C:  MOVWF  FEA
05B1E:  MOVF   FEF,F
05B20:  BTFSC  FD8.2
05B22:  BRA    5C86
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05B24:  MOVLW  24
05B26:  ADDWF  x0E,W
05B28:  MOVWF  01
05B2A:  MOVLW  00
05B2C:  ADDWFC x0F,W
05B2E:  MOVWF  03
05B30:  MOVFF  01,A04
05B34:  MOVLB  A
05B36:  MOVWF  x05
05B38:  MOVWF  x07
05B3A:  MOVFF  01,A06
05B3E:  MOVFF  A01,A0B
05B42:  MOVFF  A00,A0A
05B46:  MOVFF  9FF,A09
05B4A:  MOVFF  9FE,A08
05B4E:  MOVLW  01
05B50:  MOVWF  x0C
05B52:  MOVLB  0
05B54:  RCALL  5984
05B56:  MOVFF  01,A02
....................             if (response != RES_OK) 
05B5A:  MOVLB  A
05B5C:  MOVF   x02,F
05B5E:  BZ    5B66
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05B60:  MOVLW  00
05B62:  MOVWF  01
05B64:  BRA    5D02
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05B66:  MOVLW  06
05B68:  MOVLB  7
05B6A:  ADDWF  x0E,W
05B6C:  MOVWF  FE9
05B6E:  MOVLW  00
05B70:  ADDWFC x0F,W
05B72:  MOVWF  FEA
05B74:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05B76:  MOVLW  10
05B78:  ADDWF  x0E,W
05B7A:  MOVWF  FE9
05B7C:  MOVLW  00
05B7E:  ADDWFC x0F,W
05B80:  MOVWF  FEA
05B82:  MOVFF  FEF,A04
05B86:  MOVFF  FEC,A05
05B8A:  MOVFF  FEC,A06
05B8E:  MOVFF  FEC,A07
05B92:  MOVLW  08
05B94:  ADDWF  x0E,W
05B96:  MOVWF  FE9
05B98:  MOVLW  00
05B9A:  ADDWFC x0F,W
05B9C:  MOVWF  FEA
05B9E:  MOVFF  FEF,00
05BA2:  MOVFF  FEC,01
05BA6:  MOVFF  FEC,02
05BAA:  MOVFF  FEC,03
05BAE:  MOVLB  A
05BB0:  MOVF   x04,W
05BB2:  ADDWF  00,F
05BB4:  MOVF   x05,W
05BB6:  ADDWFC 01,F
05BB8:  MOVF   x06,W
05BBA:  ADDWFC 02,F
05BBC:  MOVF   x07,W
05BBE:  ADDWFC 03,F
05BC0:  MOVF   x01,W
05BC2:  SUBWF  03,W
05BC4:  BNC   5C84
05BC6:  BNZ   5BF4
05BC8:  MOVF   x00,W
05BCA:  SUBWF  02,W
05BCC:  BNC   5C84
05BCE:  BNZ   5BF4
05BD0:  MOVLB  9
05BD2:  MOVF   xFF,W
05BD4:  SUBWF  01,W
05BD6:  BTFSC  FD8.0
05BD8:  BRA    5BDE
05BDA:  MOVLB  A
05BDC:  BRA    5C84
05BDE:  BTFSC  FD8.2
05BE0:  BRA    5BE6
05BE2:  MOVLB  A
05BE4:  BRA    5BF4
05BE6:  MOVF   00,W
05BE8:  SUBWF  xFE,W
05BEA:  BTFSS  FD8.0
05BEC:  BRA    5BF2
05BEE:  MOVLB  A
05BF0:  BRA    5C84
05BF2:  MOVLB  A
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05BF4:  MOVLW  03
05BF6:  MOVLB  7
05BF8:  ADDWF  x0E,W
05BFA:  MOVWF  FE9
05BFC:  MOVLW  00
05BFE:  ADDWFC x0F,W
05C00:  MOVWF  FEA
05C02:  MOVFF  FEF,A03
05C06:  MOVLB  A
05C08:  MOVF   x03,W
05C0A:  SUBLW  01
05C0C:  BC    5C84
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05C0E:  MOVLW  08
05C10:  MOVLB  7
05C12:  ADDWF  x0E,W
05C14:  MOVWF  FE9
05C16:  MOVLW  00
05C18:  ADDWFC x0F,W
05C1A:  MOVWF  FEA
05C1C:  MOVFF  FEF,00
05C20:  MOVFF  FEC,01
05C24:  MOVFF  FEC,02
05C28:  MOVFF  FEC,03
05C2C:  MOVF   00,W
05C2E:  MOVLB  9
05C30:  ADDWF  xFE,F
05C32:  MOVF   01,W
05C34:  ADDWFC xFF,F
05C36:  MOVF   02,W
05C38:  MOVLB  A
05C3A:  ADDWFC x00,F
05C3C:  MOVF   03,W
05C3E:  ADDWFC x01,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05C40:  MOVLW  24
05C42:  MOVLB  7
05C44:  ADDWF  x0E,W
05C46:  MOVWF  01
05C48:  MOVLW  00
05C4A:  ADDWFC x0F,W
05C4C:  MOVWF  03
05C4E:  MOVFF  01,A04
05C52:  MOVLB  A
05C54:  MOVWF  x05
05C56:  MOVWF  x07
05C58:  MOVFF  01,A06
05C5C:  MOVFF  A01,A0B
05C60:  MOVFF  A00,A0A
05C64:  MOVFF  9FF,A09
05C68:  MOVFF  9FE,A08
05C6C:  MOVLW  01
05C6E:  MOVWF  x0C
05C70:  MOVLB  0
05C72:  RCALL  5984
05C74:  MOVF   01,F
05C76:  BZ    5C7E
....................                      break; 
05C78:  MOVLB  A
05C7A:  BRA    5C84
05C7C:  MOVLB  0
05C7E:  MOVLB  A
05C80:  DECF   x03,F
05C82:  BRA    5C08
05C84:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05C86:  MOVLB  9
05C88:  MOVF   xFA,F
05C8A:  BNZ   5C98
05C8C:  MOVF   xFB,F
05C8E:  BNZ   5C98
05C90:  MOVF   xFC,F
05C92:  BNZ   5C98
05C94:  MOVF   xFD,F
05C96:  BZ    5CFC
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05C98:  MOVLW  24
05C9A:  MOVLB  7
05C9C:  ADDWF  x0E,W
05C9E:  MOVWF  01
05CA0:  MOVLW  00
05CA2:  ADDWFC x0F,W
05CA4:  MOVWF  03
05CA6:  MOVFF  01,A04
05CAA:  MOVLB  A
05CAC:  MOVWF  x05
05CAE:  MOVWF  x07
05CB0:  MOVFF  01,A06
05CB4:  MOVFF  9FD,A0B
05CB8:  MOVFF  9FC,A0A
05CBC:  MOVFF  9FB,A09
05CC0:  MOVFF  9FA,A08
05CC4:  MOVLW  01
05CC6:  MOVWF  x0C
05CC8:  MOVLB  0
05CCA:  CALL   4520
05CCE:  MOVF   01,F
05CD0:  BZ    5CDC
....................             return FALSE; 
05CD2:  MOVLW  00
05CD4:  MOVWF  01
05CD6:  MOVLB  A
05CD8:  BRA    5D02
05CDA:  MOVLB  0
....................          fs->winsect = sector; 
05CDC:  MOVLW  20
05CDE:  MOVLB  7
05CE0:  ADDWF  x0E,W
05CE2:  MOVWF  FE9
05CE4:  MOVLW  00
05CE6:  ADDWFC x0F,W
05CE8:  MOVWF  FEA
05CEA:  MOVFF  9FA,FEF
05CEE:  MOVFF  9FB,FEC
05CF2:  MOVFF  9FC,FEC
05CF6:  MOVFF  9FD,FEC
05CFA:  MOVLB  9
05CFC:  MOVLB  A
....................          } 
....................       } 
....................    return (TRUE); 
05CFE:  MOVLW  01
05D00:  MOVWF  01
05D02:  MOVLB  0
05D04:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05D28:  MOVLB  9
05D2A:  MOVF   xE9,F
05D2C:  BNZ   5D3E
05D2E:  MOVF   xE8,F
05D30:  BNZ   5D3E
05D32:  MOVF   xE7,F
05D34:  BNZ   5D3E
05D36:  MOVF   xE6,W
05D38:  SUBLW  01
05D3A:  BTFSC  FD8.0
05D3C:  BRA    604E
05D3E:  MOVLW  0C
05D40:  MOVLB  7
05D42:  ADDWF  x0E,W
05D44:  MOVWF  FE9
05D46:  MOVLW  00
05D48:  ADDWFC x0F,W
05D4A:  MOVWF  FEA
05D4C:  MOVFF  FEF,00
05D50:  MOVFF  FEC,01
05D54:  MOVFF  FEC,02
05D58:  MOVFF  FEC,03
05D5C:  MOVLB  9
05D5E:  MOVF   xE9,W
05D60:  SUBWF  03,W
05D62:  BTFSS  FD8.0
05D64:  BRA    604E
05D66:  BNZ   5D84
05D68:  MOVF   xE8,W
05D6A:  SUBWF  02,W
05D6C:  BTFSS  FD8.0
05D6E:  BRA    604E
05D70:  BNZ   5D84
05D72:  MOVF   xE7,W
05D74:  SUBWF  01,W
05D76:  BTFSS  FD8.0
05D78:  BRA    604E
05D7A:  BNZ   5D84
05D7C:  MOVF   00,W
05D7E:  SUBWF  xE6,W
05D80:  BTFSC  FD8.0
05D82:  BRA    604E
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05D84:  MOVLW  10
05D86:  MOVLB  7
05D88:  ADDWF  x0E,W
05D8A:  MOVWF  FE9
05D8C:  MOVLW  00
05D8E:  ADDWFC x0F,W
05D90:  MOVWF  FEA
05D92:  MOVFF  FEF,9EE
05D96:  MOVFF  FEC,9EF
05D9A:  MOVFF  FEC,9F0
05D9E:  MOVFF  FEC,9F1
....................       switch (fs->fs_type)  
05DA2:  MOVF   x0E,W
05DA4:  MOVWF  FE9
05DA6:  MOVF   x0F,W
05DA8:  MOVWF  FEA
05DAA:  MOVF   FEF,W
05DAC:  XORLW  01
05DAE:  MOVLB  0
05DB0:  BZ    5DC0
05DB2:  XORLW  03
05DB4:  BTFSC  FD8.2
05DB6:  BRA    5F06
05DB8:  XORLW  01
05DBA:  BTFSC  FD8.2
05DBC:  BRA    5F88
05DBE:  BRA    6050
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05DC0:  MOVFF  9E7,9F7
05DC4:  MOVFF  9E6,9F6
05DC8:  MOVLB  9
05DCA:  CLRF   xF9
05DCC:  MOVLW  03
05DCE:  MOVWF  xF8
05DD0:  MOVLB  0
05DD2:  RCALL  5D06
05DD4:  BCF    FD8.0
05DD6:  MOVLB  9
05DD8:  RRCF   02,W
05DDA:  MOVWF  xED
05DDC:  RRCF   01,W
05DDE:  MOVWF  xEC
....................             if (!move_window(fatsect + bc / 512))  
05DE0:  BCF    FD8.0
05DE2:  CLRF   03
05DE4:  RRCF   xED,W
05DE6:  MOVWF  02
05DE8:  ADDWF  xEE,W
05DEA:  MOVWF  xF2
05DEC:  MOVF   03,W
05DEE:  ADDWFC xEF,W
05DF0:  MOVWF  xF3
05DF2:  MOVLW  00
05DF4:  ADDWFC xF0,W
05DF6:  MOVWF  xF4
05DF8:  MOVLW  00
05DFA:  ADDWFC xF1,W
05DFC:  MOVWF  xF5
05DFE:  MOVWF  xFD
05E00:  MOVFF  9F4,9FC
05E04:  MOVFF  9F3,9FB
05E08:  MOVFF  9F2,9FA
05E0C:  MOVLB  0
05E0E:  RCALL  5AC8
05E10:  MOVF   01,F
05E12:  BNZ   5E16
....................                break; 
05E14:  BRA    6050
....................             wc = fs->win[bc % 512]; 
05E16:  MOVLB  9
05E18:  MOVF   xED,W
05E1A:  ANDLW  01
05E1C:  MOVWF  xF3
05E1E:  MOVLW  24
05E20:  ADDWF  xEC,W
05E22:  MOVWF  01
05E24:  MOVLW  00
05E26:  ADDWFC xF3,W
05E28:  MOVWF  03
05E2A:  MOVF   01,W
05E2C:  MOVLB  7
05E2E:  ADDWF  x0E,W
05E30:  MOVWF  FE9
05E32:  MOVF   x0F,W
05E34:  ADDWFC 03,W
05E36:  MOVWF  FEA
05E38:  MOVLB  9
05E3A:  CLRF   xEB
05E3C:  MOVFF  FEF,9EA
....................             bc++; 
05E40:  INCF   xEC,F
05E42:  BTFSC  FD8.2
05E44:  INCF   xED,F
....................             if (!move_window(fatsect + bc / 512))  
05E46:  BCF    FD8.0
05E48:  CLRF   03
05E4A:  RRCF   xED,W
05E4C:  MOVWF  02
05E4E:  ADDWF  xEE,W
05E50:  MOVWF  xF2
05E52:  MOVF   03,W
05E54:  ADDWFC xEF,W
05E56:  MOVWF  xF3
05E58:  MOVLW  00
05E5A:  ADDWFC xF0,W
05E5C:  MOVWF  xF4
05E5E:  MOVLW  00
05E60:  ADDWFC xF1,W
05E62:  MOVWF  xF5
05E64:  MOVWF  xFD
05E66:  MOVFF  9F4,9FC
05E6A:  MOVFF  9F3,9FB
05E6E:  MOVFF  9F2,9FA
05E72:  MOVLB  0
05E74:  RCALL  5AC8
05E76:  MOVF   01,F
05E78:  BNZ   5E7C
....................                break; 
05E7A:  BRA    6050
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05E7C:  MOVLB  9
05E7E:  MOVF   xED,W
05E80:  ANDLW  01
05E82:  MOVWF  xF3
05E84:  MOVLW  24
05E86:  ADDWF  xEC,W
05E88:  MOVWF  01
05E8A:  MOVLW  00
05E8C:  ADDWFC xF3,W
05E8E:  MOVWF  03
05E90:  MOVF   01,W
05E92:  MOVLB  7
05E94:  ADDWF  x0E,W
05E96:  MOVWF  FE9
05E98:  MOVF   x0F,W
05E9A:  ADDWFC 03,W
05E9C:  MOVWF  FEA
05E9E:  MOVF   FEF,W
05EA0:  MOVLB  9
05EA2:  MOVWF  xF4
05EA4:  MOVLW  00
05EA6:  IORWF  xEA,F
05EA8:  MOVF   xF4,W
05EAA:  IORWF  xEB,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05EAC:  MOVF   xE6,W
05EAE:  ANDLW  01
05EB0:  MOVWF  00
05EB2:  CLRF   01
05EB4:  CLRF   02
05EB6:  CLRF   03
05EB8:  MOVF   00,F
05EBA:  BNZ   5EC8
05EBC:  MOVF   01,F
05EBE:  BNZ   5EC8
05EC0:  MOVF   02,F
05EC2:  BNZ   5EC8
05EC4:  MOVF   03,F
05EC6:  BZ    5EEE
05EC8:  RRCF   xEB,W
05ECA:  MOVWF  03
05ECC:  RRCF   xEA,W
05ECE:  MOVWF  02
05ED0:  RRCF   03,F
05ED2:  RRCF   02,F
05ED4:  RRCF   03,F
05ED6:  RRCF   02,F
05ED8:  RRCF   03,F
05EDA:  RRCF   02,F
05EDC:  MOVLW  0F
05EDE:  ANDWF  03,F
05EE0:  MOVFF  02,00
05EE4:  MOVFF  03,01
05EE8:  CLRF   02
05EEA:  CLRF   03
05EEC:  BRA    5F02
05EEE:  MOVFF  9EA,00
05EF2:  MOVF   xEB,W
05EF4:  ANDLW  0F
05EF6:  MOVWF  03
05EF8:  MOVF   xEA,W
05EFA:  MOVFF  03,01
05EFE:  CLRF   02
05F00:  CLRF   03
05F02:  BRA    605C
05F04:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05F06:  MOVFF  9E7,00
05F0A:  MOVFF  9E8,01
05F0E:  MOVFF  9E9,02
05F12:  CLRF   03
05F14:  MOVF   00,W
05F16:  MOVLB  9
05F18:  ADDWF  xEE,W
05F1A:  MOVWF  xF2
05F1C:  MOVF   xE8,W
05F1E:  ADDWFC xEF,W
05F20:  MOVWF  xF3
05F22:  MOVF   xE9,W
05F24:  ADDWFC xF0,W
05F26:  MOVWF  xF4
05F28:  MOVF   03,W
05F2A:  ADDWFC xF1,W
05F2C:  MOVWF  xF5
05F2E:  MOVWF  xFD
05F30:  MOVFF  9F4,9FC
05F34:  MOVFF  9F3,9FB
05F38:  MOVFF  9F2,9FA
05F3C:  MOVLB  0
05F3E:  RCALL  5AC8
05F40:  MOVF   01,F
05F42:  BNZ   5F46
....................                break; 
05F44:  BRA    6050
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05F46:  BCF    FD8.0
05F48:  MOVLB  9
05F4A:  RLCF   xE6,W
05F4C:  MOVWF  xF2
05F4E:  RLCF   xE7,W
05F50:  MOVWF  xF3
05F52:  MOVLW  01
05F54:  ANDWF  xF3,F
05F56:  MOVLW  24
05F58:  ADDWF  xF2,W
05F5A:  MOVWF  01
05F5C:  MOVLW  00
05F5E:  ADDWFC xF3,W
05F60:  MOVWF  03
05F62:  MOVF   01,W
05F64:  MOVLB  7
05F66:  ADDWF  x0E,W
05F68:  MOVWF  01
05F6A:  MOVF   x0F,W
05F6C:  ADDWFC 03,F
05F6E:  MOVFF  01,FE9
05F72:  MOVFF  03,FEA
05F76:  MOVFF  FEF,00
05F7A:  MOVFF  FEC,01
05F7E:  CLRF   02
05F80:  CLRF   03
05F82:  MOVLB  9
05F84:  BRA    605C
05F86:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05F88:  MOVLB  9
05F8A:  RRCF   xE9,W
05F8C:  MOVWF  03
05F8E:  RRCF   xE8,W
05F90:  MOVWF  02
05F92:  RRCF   xE7,W
05F94:  MOVWF  01
05F96:  RRCF   xE6,W
05F98:  MOVWF  00
05F9A:  RRCF   03,F
05F9C:  RRCF   02,F
05F9E:  RRCF   01,F
05FA0:  RRCF   00,F
05FA2:  RRCF   03,F
05FA4:  RRCF   02,F
05FA6:  RRCF   01,F
05FA8:  RRCF   00,F
05FAA:  RRCF   03,F
05FAC:  RRCF   02,F
05FAE:  RRCF   01,F
05FB0:  RRCF   00,F
05FB2:  RRCF   03,F
05FB4:  RRCF   02,F
05FB6:  RRCF   01,F
05FB8:  RRCF   00,F
05FBA:  RRCF   03,F
05FBC:  RRCF   02,F
05FBE:  RRCF   01,F
05FC0:  RRCF   00,F
05FC2:  RRCF   03,F
05FC4:  RRCF   02,F
05FC6:  RRCF   01,F
05FC8:  RRCF   00,F
05FCA:  MOVLW  01
05FCC:  ANDWF  03,F
05FCE:  MOVF   00,W
05FD0:  ADDWF  xEE,W
05FD2:  MOVWF  xF2
05FD4:  MOVF   01,W
05FD6:  ADDWFC xEF,W
05FD8:  MOVWF  xF3
05FDA:  MOVF   02,W
05FDC:  ADDWFC xF0,W
05FDE:  MOVWF  xF4
05FE0:  MOVF   03,W
05FE2:  ADDWFC xF1,W
05FE4:  MOVWF  xF5
05FE6:  MOVWF  xFD
05FE8:  MOVFF  9F4,9FC
05FEC:  MOVFF  9F3,9FB
05FF0:  MOVFF  9F2,9FA
05FF4:  MOVLB  0
05FF6:  RCALL  5AC8
05FF8:  MOVF   01,F
05FFA:  BNZ   5FFE
....................                break; 
05FFC:  BRA    6050
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05FFE:  MOVLB  9
06000:  RLCF   xE6,W
06002:  MOVWF  xF2
06004:  RLCF   xE7,W
06006:  MOVWF  xF3
06008:  RLCF   xF2,F
0600A:  RLCF   xF3,F
0600C:  MOVLW  FC
0600E:  ANDWF  xF2,F
06010:  MOVLW  01
06012:  ANDWF  xF3,F
06014:  MOVLW  24
06016:  ADDWF  xF2,W
06018:  MOVWF  01
0601A:  MOVLW  00
0601C:  ADDWFC xF3,W
0601E:  MOVWF  03
06020:  MOVF   01,W
06022:  MOVLB  7
06024:  ADDWF  x0E,W
06026:  MOVWF  01
06028:  MOVF   x0F,W
0602A:  ADDWFC 03,F
0602C:  MOVFF  01,FE9
06030:  MOVFF  03,FEA
06034:  MOVFF  FEF,00
06038:  MOVFF  FEC,01
0603C:  MOVFF  FEC,02
06040:  MOVFF  FEC,9F7
06044:  MOVLB  9
06046:  MOVF   xF7,W
06048:  ANDLW  0F
0604A:  MOVWF  03
0604C:  BRA    605C
0604E:  MOVLB  0
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
06050:  MOVLW  01
06052:  MOVWF  00
06054:  CLRF   01
06056:  CLRF   02
06058:  CLRF   03
0605A:  MOVLB  9
0605C:  MOVLB  0
0605E:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
06622:  MOVLW  10
06624:  MOVLB  7
06626:  ADDWF  x0E,W
06628:  MOVWF  FE9
0662A:  MOVLW  00
0662C:  ADDWFC x0F,W
0662E:  MOVWF  FEA
06630:  MOVFF  FEF,9F2
06634:  MOVFF  FEC,9F3
06638:  MOVFF  FEC,9F4
0663C:  MOVFF  FEC,9F5
....................    switch (fs->fs_type)  
06640:  MOVF   x0E,W
06642:  MOVWF  FE9
06644:  MOVF   x0F,W
06646:  MOVWF  FEA
06648:  MOVF   FEF,W
0664A:  XORLW  01
0664C:  MOVLB  0
0664E:  BZ    665E
06650:  XORLW  03
06652:  BTFSC  FD8.2
06654:  BRA    6836
06656:  XORLW  01
06658:  BTFSC  FD8.2
0665A:  BRA    68BA
0665C:  BRA    6982
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
0665E:  MOVFF  9E7,9F7
06662:  MOVFF  9E6,9F6
06666:  MOVLB  9
06668:  CLRF   xF9
0666A:  MOVLW  03
0666C:  MOVWF  xF8
0666E:  MOVLB  0
06670:  CALL   5D06
06674:  BCF    FD8.0
06676:  MOVLB  9
06678:  RRCF   02,W
0667A:  MOVWF  xEF
0667C:  RRCF   01,W
0667E:  MOVWF  xEE
....................          if (!move_window(fatsect + bc / 512)) 
06680:  BCF    FD8.0
06682:  CLRF   03
06684:  RRCF   xEF,W
06686:  MOVWF  02
06688:  ADDWF  xF2,W
0668A:  MOVWF  xF6
0668C:  MOVF   03,W
0668E:  ADDWFC xF3,W
06690:  MOVWF  xF7
06692:  MOVLW  00
06694:  ADDWFC xF4,W
06696:  MOVWF  xF8
06698:  MOVLW  00
0669A:  ADDWFC xF5,W
0669C:  MOVWF  xF9
0669E:  MOVWF  xFD
066A0:  MOVFF  9F8,9FC
066A4:  MOVFF  9F7,9FB
066A8:  MOVFF  9F6,9FA
066AC:  MOVLB  0
066AE:  CALL   5AC8
066B2:  MOVF   01,F
066B4:  BNZ   66BC
....................             return (FALSE); 
066B6:  MOVLW  00
066B8:  MOVWF  01
066BA:  BRA    69A0
....................          p = &fs->win[bc % 512]; 
066BC:  MOVLB  9
066BE:  MOVF   xEF,W
066C0:  ANDLW  01
066C2:  MOVWF  xF7
066C4:  MOVLW  24
066C6:  ADDWF  xEE,W
066C8:  MOVWF  01
066CA:  MOVLW  00
066CC:  ADDWFC xF7,W
066CE:  MOVWF  03
066D0:  MOVF   01,W
066D2:  MOVLB  7
066D4:  ADDWF  x0E,W
066D6:  MOVWF  01
066D8:  MOVF   x0F,W
066DA:  ADDWFC 03,F
066DC:  MOVFF  01,9F0
066E0:  MOVLB  9
066E2:  MOVFF  03,9F1
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
066E6:  MOVFF  9F0,9F6
066EA:  MOVFF  9F1,9F7
066EE:  MOVF   xE6,W
066F0:  ANDLW  01
066F2:  MOVWF  00
066F4:  CLRF   01
066F6:  CLRF   02
066F8:  CLRF   03
066FA:  MOVF   00,F
066FC:  BNZ   670A
066FE:  MOVF   01,F
06700:  BNZ   670A
06702:  MOVF   02,F
06704:  BNZ   670A
06706:  MOVF   03,F
06708:  BZ    672A
0670A:  MOVFF  9F1,03
0670E:  MOVFF  9F0,FE9
06712:  MOVFF  9F1,FEA
06716:  MOVF   FEF,W
06718:  ANDLW  0F
0671A:  MOVWF  xF8
0671C:  SWAPF  xEA,W
0671E:  MOVWF  00
06720:  MOVLW  F0
06722:  ANDWF  00,F
06724:  MOVF   00,W
06726:  IORWF  xF8,W
06728:  BRA    672C
0672A:  MOVF   xEA,W
0672C:  MOVFF  9F7,FEA
06730:  MOVFF  9F6,FE9
06734:  MOVWF  FEF
....................          fs->winflag = 1; 
06736:  MOVLW  06
06738:  MOVLB  7
0673A:  ADDWF  x0E,W
0673C:  MOVWF  FE9
0673E:  MOVLW  00
06740:  ADDWFC x0F,W
06742:  MOVWF  FEA
06744:  MOVLW  01
06746:  MOVWF  FEF
....................          bc++; 
06748:  MOVLB  9
0674A:  INCF   xEE,F
0674C:  BTFSC  FD8.2
0674E:  INCF   xEF,F
....................          if (!move_window(fatsect + bc / 512)) 
06750:  BCF    FD8.0
06752:  CLRF   03
06754:  RRCF   xEF,W
06756:  MOVWF  02
06758:  ADDWF  xF2,W
0675A:  MOVWF  xF6
0675C:  MOVF   03,W
0675E:  ADDWFC xF3,W
06760:  MOVWF  xF7
06762:  MOVLW  00
06764:  ADDWFC xF4,W
06766:  MOVWF  xF8
06768:  MOVLW  00
0676A:  ADDWFC xF5,W
0676C:  MOVWF  xF9
0676E:  MOVWF  xFD
06770:  MOVFF  9F8,9FC
06774:  MOVFF  9F7,9FB
06778:  MOVFF  9F6,9FA
0677C:  MOVLB  0
0677E:  CALL   5AC8
06782:  MOVF   01,F
06784:  BNZ   678C
....................             return (FALSE); 
06786:  MOVLW  00
06788:  MOVWF  01
0678A:  BRA    69A0
....................          p = &fs->win[bc % 512]; 
0678C:  MOVLB  9
0678E:  MOVF   xEF,W
06790:  ANDLW  01
06792:  MOVWF  xF7
06794:  MOVLW  24
06796:  ADDWF  xEE,W
06798:  MOVWF  01
0679A:  MOVLW  00
0679C:  ADDWFC xF7,W
0679E:  MOVWF  03
067A0:  MOVF   01,W
067A2:  MOVLB  7
067A4:  ADDWF  x0E,W
067A6:  MOVWF  01
067A8:  MOVF   x0F,W
067AA:  ADDWFC 03,F
067AC:  MOVFF  01,9F0
067B0:  MOVLB  9
067B2:  MOVFF  03,9F1
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
067B6:  MOVFF  9F0,9F6
067BA:  MOVFF  9F1,9F7
067BE:  MOVF   xE6,W
067C0:  ANDLW  01
067C2:  MOVWF  00
067C4:  CLRF   01
067C6:  CLRF   02
067C8:  CLRF   03
067CA:  MOVF   00,F
067CC:  BNZ   67DA
067CE:  MOVF   01,F
067D0:  BNZ   67DA
067D2:  MOVF   02,F
067D4:  BNZ   67DA
067D6:  MOVF   03,F
067D8:  BZ    680A
067DA:  RRCF   xED,W
067DC:  MOVWF  03
067DE:  RRCF   xEC,W
067E0:  MOVWF  02
067E2:  RRCF   xEB,W
067E4:  MOVWF  01
067E6:  RRCF   xEA,W
067E8:  MOVWF  00
067EA:  RRCF   03,F
067EC:  RRCF   02,F
067EE:  RRCF   01,F
067F0:  RRCF   00,F
067F2:  RRCF   03,F
067F4:  RRCF   02,F
067F6:  RRCF   01,F
067F8:  RRCF   00,F
067FA:  RRCF   03,F
067FC:  RRCF   02,F
067FE:  RRCF   01,F
06800:  RRCF   00,F
06802:  MOVLW  0F
06804:  ANDWF  03,F
06806:  MOVF   00,W
06808:  BRA    682A
0680A:  MOVFF  9F0,FE9
0680E:  MOVFF  9F1,FEA
06812:  MOVF   FEF,W
06814:  ANDLW  F0
06816:  MOVWF  xF9
06818:  MOVFF  9EB,00
0681C:  MOVFF  9EC,01
06820:  MOVFF  9ED,02
06824:  MOVF   xEB,W
06826:  ANDLW  0F
06828:  IORWF  xF9,W
0682A:  MOVFF  9F7,FEA
0682E:  MOVFF  9F6,FE9
06832:  MOVWF  FEF
....................          break; 
06834:  BRA    698A
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
06836:  MOVFF  9E7,00
0683A:  MOVFF  9E8,01
0683E:  MOVFF  9E9,02
06842:  CLRF   03
06844:  MOVF   00,W
06846:  MOVLB  9
06848:  ADDWF  xF2,W
0684A:  MOVWF  xF6
0684C:  MOVF   xE8,W
0684E:  ADDWFC xF3,W
06850:  MOVWF  xF7
06852:  MOVF   xE9,W
06854:  ADDWFC xF4,W
06856:  MOVWF  xF8
06858:  MOVF   03,W
0685A:  ADDWFC xF5,W
0685C:  MOVWF  xF9
0685E:  MOVWF  xFD
06860:  MOVFF  9F8,9FC
06864:  MOVFF  9F7,9FB
06868:  MOVFF  9F6,9FA
0686C:  MOVLB  0
0686E:  CALL   5AC8
06872:  MOVF   01,F
06874:  BNZ   687C
....................             return (FALSE); 
06876:  MOVLW  00
06878:  MOVWF  01
0687A:  BRA    69A0
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
0687C:  BCF    FD8.0
0687E:  MOVLB  9
06880:  RLCF   xE6,W
06882:  MOVWF  xF6
06884:  RLCF   xE7,W
06886:  MOVWF  xF7
06888:  MOVLW  01
0688A:  ANDWF  xF7,F
0688C:  MOVLW  24
0688E:  ADDWF  xF6,W
06890:  MOVWF  01
06892:  MOVLW  00
06894:  ADDWFC xF7,W
06896:  MOVWF  03
06898:  MOVF   01,W
0689A:  MOVLB  7
0689C:  ADDWF  x0E,W
0689E:  MOVWF  01
068A0:  MOVF   x0F,W
068A2:  ADDWFC 03,F
068A4:  MOVFF  01,FE9
068A8:  MOVFF  03,FEA
068AC:  MOVFF  9EB,FEC
068B0:  MOVF   FED,F
068B2:  MOVFF  9EA,FEF
....................          break; 
068B6:  MOVLB  9
068B8:  BRA    698A
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
068BA:  MOVLB  9
068BC:  RRCF   xE9,W
068BE:  MOVWF  03
068C0:  RRCF   xE8,W
068C2:  MOVWF  02
068C4:  RRCF   xE7,W
068C6:  MOVWF  01
068C8:  RRCF   xE6,W
068CA:  MOVWF  00
068CC:  RRCF   03,F
068CE:  RRCF   02,F
068D0:  RRCF   01,F
068D2:  RRCF   00,F
068D4:  RRCF   03,F
068D6:  RRCF   02,F
068D8:  RRCF   01,F
068DA:  RRCF   00,F
068DC:  RRCF   03,F
068DE:  RRCF   02,F
068E0:  RRCF   01,F
068E2:  RRCF   00,F
068E4:  RRCF   03,F
068E6:  RRCF   02,F
068E8:  RRCF   01,F
068EA:  RRCF   00,F
068EC:  RRCF   03,F
068EE:  RRCF   02,F
068F0:  RRCF   01,F
068F2:  RRCF   00,F
068F4:  RRCF   03,F
068F6:  RRCF   02,F
068F8:  RRCF   01,F
068FA:  RRCF   00,F
068FC:  MOVLW  01
068FE:  ANDWF  03,F
06900:  MOVF   00,W
06902:  ADDWF  xF2,W
06904:  MOVWF  xF6
06906:  MOVF   01,W
06908:  ADDWFC xF3,W
0690A:  MOVWF  xF7
0690C:  MOVF   02,W
0690E:  ADDWFC xF4,W
06910:  MOVWF  xF8
06912:  MOVF   03,W
06914:  ADDWFC xF5,W
06916:  MOVWF  xF9
06918:  MOVWF  xFD
0691A:  MOVFF  9F8,9FC
0691E:  MOVFF  9F7,9FB
06922:  MOVFF  9F6,9FA
06926:  MOVLB  0
06928:  CALL   5AC8
0692C:  MOVF   01,F
0692E:  BNZ   6936
....................             return (FALSE); 
06930:  MOVLW  00
06932:  MOVWF  01
06934:  BRA    69A0
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
06936:  MOVLB  9
06938:  RLCF   xE6,W
0693A:  MOVWF  xF6
0693C:  RLCF   xE7,W
0693E:  MOVWF  xF7
06940:  RLCF   xF6,F
06942:  RLCF   xF7,F
06944:  MOVLW  FC
06946:  ANDWF  xF6,F
06948:  MOVLW  01
0694A:  ANDWF  xF7,F
0694C:  MOVLW  24
0694E:  ADDWF  xF6,W
06950:  MOVWF  01
06952:  MOVLW  00
06954:  ADDWFC xF7,W
06956:  MOVWF  03
06958:  MOVF   01,W
0695A:  MOVLB  7
0695C:  ADDWF  x0E,W
0695E:  MOVWF  01
06960:  MOVF   x0F,W
06962:  ADDWFC 03,F
06964:  MOVFF  01,FE9
06968:  MOVFF  03,FEA
0696C:  MOVFF  9EA,FEF
06970:  MOVFF  9EB,FEC
06974:  MOVFF  9EC,FEC
06978:  MOVFF  9ED,FEC
....................          break; 
0697C:  MOVLB  9
0697E:  BRA    698A
06980:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
06982:  MOVLW  00
06984:  MOVWF  01
06986:  BRA    69A0
06988:  MOVLB  9
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
0698A:  MOVLW  06
0698C:  MOVLB  7
0698E:  ADDWF  x0E,W
06990:  MOVWF  FE9
06992:  MOVLW  00
06994:  ADDWFC x0F,W
06996:  MOVWF  FEA
06998:  MOVLW  01
0699A:  MOVWF  FEF
....................    return (TRUE); 
0699C:  MOVWF  01
0699E:  MOVLB  0
069A0:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06F80:  MOVFF  9C8,9E9
06F84:  MOVFF  9C7,9E8
06F88:  MOVFF  9C6,9E7
06F8C:  MOVFF  9C5,9E6
06F90:  CALL   5D28
06F94:  MOVFF  03,9CC
06F98:  MOVFF  02,9CB
06F9C:  MOVFF  01,9CA
06FA0:  MOVFF  00,9C9
06FA4:  MOVLB  9
06FA6:  MOVF   xCC,F
06FA8:  BNZ   6FB8
06FAA:  MOVF   xCB,F
06FAC:  BNZ   6FB8
06FAE:  MOVF   xCA,F
06FB0:  BNZ   6FB8
06FB2:  MOVF   xC9,W
06FB4:  SUBLW  01
06FB6:  BC    7018
....................       { 
....................       if (!put_cluster(clust, 0)) 
06FB8:  MOVFF  9C8,9E9
06FBC:  MOVFF  9C7,9E8
06FC0:  MOVFF  9C6,9E7
06FC4:  MOVFF  9C5,9E6
06FC8:  CLRF   xED
06FCA:  CLRF   xEC
06FCC:  CLRF   xEB
06FCE:  CLRF   xEA
06FD0:  MOVLB  0
06FD2:  CALL   6622
06FD6:  MOVF   01,F
06FD8:  BNZ   6FE0
....................          return FALSE; 
06FDA:  MOVLW  00
06FDC:  MOVWF  01
06FDE:  BRA    701E
....................       clust = nxt; 
06FE0:  MOVFF  9CC,9C8
06FE4:  MOVFF  9CB,9C7
06FE8:  MOVFF  9CA,9C6
06FEC:  MOVFF  9C9,9C5
06FF0:  MOVFF  9C8,9E9
06FF4:  MOVFF  9C7,9E8
06FF8:  MOVFF  9C6,9E7
06FFC:  MOVFF  9C5,9E6
07000:  CALL   5D28
07004:  MOVFF  03,9CC
07008:  MOVFF  02,9CB
0700C:  MOVFF  01,9CA
07010:  MOVFF  00,9C9
07014:  BRA    6FA4
07016:  MOVLB  9
....................       } 
....................    return TRUE; 
07018:  MOVLW  01
0701A:  MOVWF  01
0701C:  MOVLB  0
0701E:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
069A2:  MOVLW  0C
069A4:  MOVLB  7
069A6:  ADDWF  x0E,W
069A8:  MOVWF  FE9
069AA:  MOVLW  00
069AC:  ADDWFC x0F,W
069AE:  MOVWF  FEA
069B0:  MOVFF  FEF,9E2
069B4:  MOVFF  FEC,9E3
069B8:  MOVFF  FEC,9E4
069BC:  MOVFF  FEC,9E5
....................    if (clust == 0)  
069C0:  MOVLB  9
069C2:  MOVF   xD2,F
069C4:  BNZ   6A2E
069C6:  MOVF   xD3,F
069C8:  BNZ   6A2E
069CA:  MOVF   xD4,F
069CC:  BNZ   6A2E
069CE:  MOVF   xD5,F
069D0:  BNZ   6A2E
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
069D2:  MOVLW  1C
069D4:  MOVLB  7
069D6:  ADDWF  x0E,W
069D8:  MOVWF  FE9
069DA:  MOVLW  00
069DC:  ADDWFC x0F,W
069DE:  MOVWF  FEA
069E0:  MOVFF  FEF,9DE
069E4:  MOVFF  FEC,9DF
069E8:  MOVFF  FEC,9E0
069EC:  MOVFF  FEC,9E1
....................       if (scl < 2 || scl >= mcl) scl = 1; 
069F0:  MOVLB  9
069F2:  MOVF   xE1,F
069F4:  BNZ   6A04
069F6:  MOVF   xE0,F
069F8:  BNZ   6A04
069FA:  MOVF   xDF,F
069FC:  BNZ   6A04
069FE:  MOVF   xDE,W
06A00:  SUBLW  01
06A02:  BC    6A22
06A04:  MOVF   xE5,W
06A06:  SUBWF  xE1,W
06A08:  BNC   6A2C
06A0A:  BNZ   6A22
06A0C:  MOVF   xE4,W
06A0E:  SUBWF  xE0,W
06A10:  BNC   6A2C
06A12:  BNZ   6A22
06A14:  MOVF   xE3,W
06A16:  SUBWF  xDF,W
06A18:  BNC   6A2C
06A1A:  BNZ   6A22
06A1C:  MOVF   xE2,W
06A1E:  SUBWF  xDE,W
06A20:  BNC   6A2C
06A22:  CLRF   xE1
06A24:  CLRF   xE0
06A26:  CLRF   xDF
06A28:  MOVLW  01
06A2A:  MOVWF  xDE
....................       } 
06A2C:  BRA    6AB2
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
06A2E:  MOVFF  9D5,9E9
06A32:  MOVFF  9D4,9E8
06A36:  MOVFF  9D3,9E7
06A3A:  MOVFF  9D2,9E6
06A3E:  MOVLB  0
06A40:  CALL   5D28
06A44:  MOVFF  03,9D9
06A48:  MOVFF  02,9D8
06A4C:  MOVFF  01,9D7
06A50:  MOVFF  00,9D6
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
06A54:  MOVLB  9
06A56:  MOVF   xD9,F
06A58:  BNZ   6A72
06A5A:  MOVF   xD8,F
06A5C:  BNZ   6A72
06A5E:  MOVF   xD7,F
06A60:  BNZ   6A72
06A62:  MOVF   xD6,W
06A64:  SUBLW  01
06A66:  BNC   6A72
06A68:  CLRF   00
06A6A:  CLRF   01
06A6C:  CLRF   02
06A6E:  CLRF   03
06A70:  BRA    6C34
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
06A72:  MOVF   xD9,W
06A74:  SUBWF  xE5,W
06A76:  BNC   6AA2
06A78:  BNZ   6A90
06A7A:  MOVF   xD8,W
06A7C:  SUBWF  xE4,W
06A7E:  BNC   6AA2
06A80:  BNZ   6A90
06A82:  MOVF   xD7,W
06A84:  SUBWF  xE3,W
06A86:  BNC   6AA2
06A88:  BNZ   6A90
06A8A:  MOVF   xE2,W
06A8C:  SUBWF  xD6,W
06A8E:  BC    6AA2
06A90:  MOVFF  9D6,00
06A94:  MOVFF  9D7,01
06A98:  MOVFF  9D8,02
06A9C:  MOVFF  9D9,03
06AA0:  BRA    6C34
....................       scl = clust; 
06AA2:  MOVFF  9D5,9E1
06AA6:  MOVFF  9D4,9E0
06AAA:  MOVFF  9D3,9DF
06AAE:  MOVFF  9D2,9DE
....................       } 
....................       ncl = scl;                  // Scan start cluster 
06AB2:  MOVFF  9E1,9DD
06AB6:  MOVFF  9E0,9DC
06ABA:  MOVFF  9DF,9DB
06ABE:  MOVFF  9DE,9DA
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
06AC2:  MOVLW  01
06AC4:  ADDWF  xDA,F
06AC6:  BTFSC  FD8.0
06AC8:  INCF   xDB,F
06ACA:  BTFSC  FD8.2
06ACC:  INCF   xDC,F
06ACE:  BTFSC  FD8.2
06AD0:  INCF   xDD,F
....................       if (ncl >= mcl)  
06AD2:  MOVF   xE5,W
06AD4:  SUBWF  xDD,W
06AD6:  BNC   6B14
06AD8:  BNZ   6AF0
06ADA:  MOVF   xE4,W
06ADC:  SUBWF  xDC,W
06ADE:  BNC   6B14
06AE0:  BNZ   6AF0
06AE2:  MOVF   xE3,W
06AE4:  SUBWF  xDB,W
06AE6:  BNC   6B14
06AE8:  BNZ   6AF0
06AEA:  MOVF   xE2,W
06AEC:  SUBWF  xDA,W
06AEE:  BNC   6B14
....................          {         // Wrap around 
....................          ncl = 2; 
06AF0:  CLRF   xDD
06AF2:  CLRF   xDC
06AF4:  CLRF   xDB
06AF6:  MOVLW  02
06AF8:  MOVWF  xDA
....................          if (scl == 1) return 0;      // No free custer was found 
06AFA:  DECFSZ xDE,W
06AFC:  BRA    6B14
06AFE:  MOVF   xDF,F
06B00:  BNZ   6B14
06B02:  MOVF   xE0,F
06B04:  BNZ   6B14
06B06:  MOVF   xE1,F
06B08:  BNZ   6B14
06B0A:  CLRF   00
06B0C:  CLRF   01
06B0E:  CLRF   02
06B10:  CLRF   03
06B12:  BRA    6C34
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06B14:  MOVF   xDE,W
06B16:  SUBWF  xDA,W
06B18:  BNZ   6B36
06B1A:  MOVF   xDF,W
06B1C:  SUBWF  xDB,W
06B1E:  BNZ   6B36
06B20:  MOVF   xE0,W
06B22:  SUBWF  xDC,W
06B24:  BNZ   6B36
06B26:  MOVF   xE1,W
06B28:  SUBWF  xDD,W
06B2A:  BNZ   6B36
06B2C:  CLRF   00
06B2E:  CLRF   01
06B30:  CLRF   02
06B32:  CLRF   03
06B34:  BRA    6C34
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06B36:  MOVFF  9DD,9E9
06B3A:  MOVFF  9DC,9E8
06B3E:  MOVFF  9DB,9E7
06B42:  MOVFF  9DA,9E6
06B46:  MOVLB  0
06B48:  CALL   5D28
06B4C:  MOVFF  03,9D9
06B50:  MOVFF  02,9D8
06B54:  MOVFF  01,9D7
06B58:  MOVFF  00,9D6
....................       if (cstat == 1) return 0;      // Any error occured 
06B5C:  MOVLB  9
06B5E:  DECFSZ xD6,W
06B60:  BRA    6B78
06B62:  MOVF   xD7,F
06B64:  BNZ   6B78
06B66:  MOVF   xD8,F
06B68:  BNZ   6B78
06B6A:  MOVF   xD9,F
06B6C:  BNZ   6B78
06B6E:  CLRF   00
06B70:  CLRF   01
06B72:  CLRF   02
06B74:  CLRF   03
06B76:  BRA    6C34
....................       } while (cstat);            // Repeat until find a free cluster 
06B78:  MOVF   xD6,F
06B7A:  BNZ   6AC2
06B7C:  MOVF   xD7,F
06B7E:  BNZ   6AC2
06B80:  MOVF   xD8,F
06B82:  BNZ   6AC2
06B84:  MOVF   xD9,F
06B86:  BNZ   6AC2
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06B88:  MOVFF  9DD,9E9
06B8C:  MOVFF  9DC,9E8
06B90:  MOVFF  9DB,9E7
06B94:  MOVFF  9DA,9E6
06B98:  MOVLW  0F
06B9A:  MOVWF  xED
06B9C:  SETF   xEC
06B9E:  SETF   xEB
06BA0:  SETF   xEA
06BA2:  MOVLB  0
06BA4:  RCALL  6622
06BA6:  MOVF   01,F
06BA8:  BNZ   6BB8
06BAA:  CLRF   00
06BAC:  CLRF   01
06BAE:  CLRF   02
06BB0:  CLRF   03
06BB2:  MOVLB  9
06BB4:  BRA    6C34
06BB6:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06BB8:  MOVLB  9
06BBA:  MOVF   xD2,F
06BBC:  BNZ   6BCA
06BBE:  MOVF   xD3,F
06BC0:  BNZ   6BCA
06BC2:  MOVF   xD4,F
06BC4:  BNZ   6BCA
06BC6:  MOVF   xD5,F
06BC8:  BZ    6C04
06BCA:  MOVFF  9D5,9E9
06BCE:  MOVFF  9D4,9E8
06BD2:  MOVFF  9D3,9E7
06BD6:  MOVFF  9D2,9E6
06BDA:  MOVFF  9DD,9ED
06BDE:  MOVFF  9DC,9EC
06BE2:  MOVFF  9DB,9EB
06BE6:  MOVFF  9DA,9EA
06BEA:  MOVLB  0
06BEC:  RCALL  6622
06BEE:  MOVF   01,F
06BF0:  BTFSC  FD8.2
06BF2:  BRA    6BF8
06BF4:  MOVLB  9
06BF6:  BRA    6C04
06BF8:  CLRF   00
06BFA:  CLRF   01
06BFC:  CLRF   02
06BFE:  CLRF   03
06C00:  MOVLB  9
06C02:  BRA    6C34
....................    fs->last_clust = ncl; 
06C04:  MOVLW  1C
06C06:  MOVLB  7
06C08:  ADDWF  x0E,W
06C0A:  MOVWF  FE9
06C0C:  MOVLW  00
06C0E:  ADDWFC x0F,W
06C10:  MOVWF  FEA
06C12:  MOVFF  9DA,FEF
06C16:  MOVFF  9DB,FEC
06C1A:  MOVFF  9DC,FEC
06C1E:  MOVFF  9DD,FEC
....................  
....................    return ncl;      // Return new cluster number 
06C22:  MOVFF  9DA,00
06C26:  MOVFF  9DB,01
06C2A:  MOVFF  9DC,02
06C2E:  MOVFF  9DD,03
06C32:  MOVLB  9
06C34:  MOVLB  0
06C36:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
05654:  MOVLW  02
05656:  MOVLB  9
05658:  SUBWF  xD9,F
0565A:  MOVLW  00
0565C:  SUBWFB xDA,F
0565E:  SUBWFB xDB,F
05660:  SUBWFB xDC,F
....................    if (clust >= fs->max_clust)  
05662:  MOVLW  0C
05664:  MOVLB  7
05666:  ADDWF  x0E,W
05668:  MOVWF  FE9
0566A:  MOVLW  00
0566C:  ADDWFC x0F,W
0566E:  MOVWF  FEA
05670:  MOVFF  FEF,00
05674:  MOVFF  FEC,01
05678:  MOVFF  FEC,02
0567C:  MOVFF  FEC,03
05680:  MOVF   03,W
05682:  MOVLB  9
05684:  SUBWF  xDC,W
05686:  BNC   56AA
05688:  BNZ   56A0
0568A:  MOVF   02,W
0568C:  SUBWF  xDB,W
0568E:  BNC   56AA
05690:  BNZ   56A0
05692:  MOVF   01,W
05694:  SUBWF  xDA,W
05696:  BNC   56AA
05698:  BNZ   56A0
0569A:  MOVF   00,W
0569C:  SUBWF  xD9,W
0569E:  BNC   56AA
....................       return 0;      // Invalid cluster#  
056A0:  CLRF   00
056A2:  CLRF   01
056A4:  CLRF   02
056A6:  CLRF   03
056A8:  BRA    572A
....................    return (clust * fs->sects_clust + fs->database); 
056AA:  MOVLW  02
056AC:  MOVLB  7
056AE:  ADDWF  x0E,W
056B0:  MOVWF  FE9
056B2:  MOVLW  00
056B4:  ADDWFC x0F,W
056B6:  MOVWF  FEA
056B8:  MOVFF  FEF,9E4
056BC:  MOVLB  9
056BE:  MOVFF  FEA,9DF
056C2:  MOVFF  FE9,9DE
056C6:  MOVFF  9DC,9E3
056CA:  MOVFF  9DB,9E2
056CE:  MOVFF  9DA,9E1
056D2:  MOVFF  9D9,9E0
056D6:  CLRF   xE7
056D8:  CLRF   xE6
056DA:  CLRF   xE5
056DC:  MOVLB  0
056DE:  CALL   4844
056E2:  MOVFF  9DF,FEA
056E6:  MOVFF  9DE,FE9
056EA:  MOVFF  03,9E0
056EE:  MOVFF  02,9DF
056F2:  MOVFF  01,9DE
056F6:  MOVFF  00,9DD
056FA:  MOVLW  18
056FC:  MOVLB  7
056FE:  ADDWF  x0E,W
05700:  MOVWF  FE9
05702:  MOVLW  00
05704:  ADDWFC x0F,W
05706:  MOVWF  FEA
05708:  MOVFF  FEF,00
0570C:  MOVFF  FEC,01
05710:  MOVFF  FEC,02
05714:  MOVFF  FEC,03
05718:  MOVLB  9
0571A:  MOVF   xDD,W
0571C:  ADDWF  00,F
0571E:  MOVF   xDE,W
05720:  ADDWFC 01,F
05722:  MOVF   xDF,W
05724:  ADDWFC 02,F
05726:  MOVF   xE0,W
05728:  ADDWFC 03,F
0572A:  MOVLB  0
0572C:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
046E4:  MOVLW  24
046E6:  MOVLB  7
046E8:  ADDWF  x0E,W
046EA:  MOVWF  01
046EC:  MOVLW  00
046EE:  ADDWFC x0F,W
046F0:  MOVWF  03
046F2:  MOVFF  01,9D1
046F6:  MOVLB  9
046F8:  MOVWF  xD2
046FA:  MOVWF  FEA
046FC:  MOVFF  01,FE9
04700:  CLRF   00
04702:  MOVLW  02
04704:  MOVWF  02
04706:  CLRF   01
04708:  MOVLB  0
0470A:  CALL   357A
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
0470E:  MOVLW  24
04710:  MOVLB  7
04712:  ADDWF  x0E,W
04714:  MOVWF  01
04716:  MOVLW  00
04718:  ADDWFC x0F,W
0471A:  MOVWF  03
0471C:  MOVFF  01,9D1
04720:  MOVLB  9
04722:  MOVWF  xD2
04724:  MOVFF  FE8,A07
04728:  MOVFF  01,A06
0472C:  MOVFF  9D0,A0B
04730:  MOVFF  9CF,A0A
04734:  MOVFF  9CE,A09
04738:  MOVFF  9CD,A08
0473C:  MOVLW  01
0473E:  MOVLB  A
04740:  MOVWF  x0C
04742:  MOVLB  0
04744:  RCALL  4520
04746:  MOVF   01,F
04748:  BTFSS  FD8.2
0474A:  BRA    483A
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
0474C:  MOVLW  22
0474E:  MOVLB  7
04750:  ADDWF  x0E,W
04752:  MOVWF  01
04754:  MOVLW  02
04756:  ADDWFC x0F,W
04758:  MOVWF  03
0475A:  MOVFF  01,FE9
0475E:  MOVWF  FEA
04760:  MOVFF  FEC,9D2
04764:  MOVF   FED,F
04766:  MOVFF  FEF,9D1
0476A:  MOVLB  9
0476C:  MOVF   xD1,W
0476E:  SUBLW  55
04770:  BNZ   483C
04772:  MOVF   xD2,W
04774:  SUBLW  AA
04776:  BNZ   483C
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
04778:  MOVLW  5A
0477A:  MOVLB  7
0477C:  ADDWF  x0E,W
0477E:  MOVWF  01
04780:  MOVLW  00
04782:  ADDWFC x0F,W
04784:  MOVWF  03
04786:  MOVFF  01,9D1
0478A:  MOVLB  9
0478C:  MOVWF  xD2
0478E:  MOVWF  xD4
04790:  MOVFF  01,9D3
04794:  MOVLW  07
04796:  MOVWF  xD6
04798:  MOVLW  10
0479A:  MOVWF  xD5
0479C:  CLRF   xD8
0479E:  MOVLW  05
047A0:  MOVWF  xD7
047A2:  MOVLB  0
047A4:  RCALL  4660
047A6:  MOVF   01,F
047A8:  BNZ   47B0
....................             return (FS_FAT12); 
047AA:  MOVLW  01
047AC:  MOVWF  01
047AE:  BRA    4842
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
047B0:  MOVLW  5A
047B2:  MOVLB  7
047B4:  ADDWF  x0E,W
047B6:  MOVWF  01
047B8:  MOVLW  00
047BA:  ADDWFC x0F,W
047BC:  MOVWF  03
047BE:  MOVFF  01,9D1
047C2:  MOVLB  9
047C4:  MOVWF  xD2
047C6:  MOVWF  xD4
047C8:  MOVFF  01,9D3
047CC:  MOVLW  07
047CE:  MOVWF  xD6
047D0:  MOVLW  15
047D2:  MOVWF  xD5
047D4:  CLRF   xD8
047D6:  MOVLW  05
047D8:  MOVWF  xD7
047DA:  MOVLB  0
047DC:  RCALL  4660
047DE:  MOVF   01,F
047E0:  BNZ   47E8
....................             return (FS_FAT16); 
047E2:  MOVLW  02
047E4:  MOVWF  01
047E6:  BRA    4842
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
047E8:  MOVLW  76
047EA:  MOVLB  7
047EC:  ADDWF  x0E,W
047EE:  MOVWF  01
047F0:  MOVLW  00
047F2:  ADDWFC x0F,W
047F4:  MOVWF  03
047F6:  MOVFF  01,9D1
047FA:  MOVLB  9
047FC:  MOVWF  xD2
047FE:  MOVWF  xD4
04800:  MOVFF  01,9D3
04804:  MOVLW  07
04806:  MOVWF  xD6
04808:  MOVLW  1A
0480A:  MOVWF  xD5
0480C:  CLRF   xD8
0480E:  MOVLW  05
04810:  MOVWF  xD7
04812:  MOVLB  0
04814:  RCALL  4660
04816:  MOVF   01,F
04818:  BNZ   483A
0481A:  MOVLW  4C
0481C:  MOVLB  7
0481E:  ADDWF  x0E,W
04820:  MOVWF  FE9
04822:  MOVLW  00
04824:  ADDWFC x0F,W
04826:  MOVWF  FEA
04828:  MOVF   FEF,F
0482A:  BTFSC  FD8.2
0482C:  BRA    4832
0482E:  MOVLB  0
04830:  BRA    483A
....................             return (FS_FAT32); 
04832:  MOVLW  03
04834:  MOVWF  01
04836:  MOVLB  0
04838:  BRA    4842
0483A:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
0483C:  MOVLW  00
0483E:  MOVWF  01
04840:  MOVLB  0
04842:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
06060:  MOVLW  0C
06062:  MOVLB  9
06064:  ADDWF  xCF,W
06066:  MOVWF  FE9
06068:  MOVLW  00
0606A:  ADDWFC xD0,W
0606C:  MOVWF  FEA
0606E:  MOVFF  FEC,9D8
06072:  MOVF   FED,F
06074:  MOVFF  FEF,9D7
06078:  MOVLW  01
0607A:  ADDWF  xD7,W
0607C:  MOVWF  xD5
0607E:  MOVLW  00
06080:  ADDWFC xD8,W
06082:  MOVWF  xD6
....................    if ((idx & 15) == 0)  
06084:  MOVF   xD5,W
06086:  ANDLW  0F
06088:  MOVWF  xD7
0608A:  CLRF   xD8
0608C:  MOVF   xD7,F
0608E:  BTFSS  FD8.2
06090:  BRA    621C
06092:  MOVF   xD8,F
06094:  BTFSS  FD8.2
06096:  BRA    621C
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
06098:  MOVLW  08
0609A:  ADDWF  xCF,W
0609C:  MOVWF  FE9
0609E:  MOVLW  00
060A0:  ADDWFC xD0,W
060A2:  MOVWF  FEA
060A4:  MOVLW  01
060A6:  ADDWF  FEE,F
060A8:  MOVLW  00
060AA:  ADDWFC FEE,F
060AC:  ADDWFC FEE,F
060AE:  ADDWFC FED,F
....................       if (!scan->clust)  
060B0:  MOVLW  04
060B2:  ADDWF  xCF,W
060B4:  MOVWF  FE9
060B6:  MOVLW  00
060B8:  ADDWFC xD0,W
060BA:  MOVWF  FEA
060BC:  MOVF   FEF,F
060BE:  BNZ   60FC
060C0:  MOVF   FEC,F
060C2:  BNZ   60FC
060C4:  MOVF   FEC,F
060C6:  BNZ   60FC
060C8:  MOVF   FEC,F
060CA:  BNZ   60FC
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
060CC:  MOVLW  04
060CE:  MOVLB  7
060D0:  ADDWF  x0E,W
060D2:  MOVWF  FE9
060D4:  MOVLW  00
060D6:  ADDWFC x0F,W
060D8:  MOVWF  FEA
060DA:  MOVFF  FEC,03
060DE:  MOVF   FED,F
060E0:  MOVFF  FEF,01
060E4:  MOVF   03,W
060E6:  MOVLB  9
060E8:  SUBWF  xD6,W
060EA:  BNC   60FA
060EC:  BNZ   60F4
060EE:  MOVF   01,W
060F0:  SUBWF  xD5,W
060F2:  BNC   60FA
....................             return (FALSE);   // Reached to end of table  
060F4:  MOVLW  00
060F6:  MOVWF  01
060F8:  BRA    6236
....................          }  
060FA:  BRA    621C
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
060FC:  RRCF   xD6,W
060FE:  MOVWF  xD8
06100:  RRCF   xD5,W
06102:  MOVWF  xD7
06104:  RRCF   xD8,F
06106:  RRCF   xD7,F
06108:  RRCF   xD8,F
0610A:  RRCF   xD7,F
0610C:  RRCF   xD8,F
0610E:  RRCF   xD7,F
06110:  MOVLW  0F
06112:  ANDWF  xD8,F
06114:  MOVLW  02
06116:  MOVLB  7
06118:  ADDWF  x0E,W
0611A:  MOVWF  FE9
0611C:  MOVLW  00
0611E:  ADDWFC x0F,W
06120:  MOVWF  FEA
06122:  MOVLW  01
06124:  SUBWF  FEF,W
06126:  MOVLB  9
06128:  ANDWF  xD7,F
0612A:  CLRF   xD8
0612C:  MOVF   xD7,F
0612E:  BTFSS  FD8.2
06130:  BRA    621C
06132:  MOVF   xD8,F
06134:  BTFSS  FD8.2
06136:  BRA    621C
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
06138:  MOVLW  04
0613A:  ADDWF  xCF,W
0613C:  MOVWF  FE9
0613E:  MOVLW  00
06140:  ADDWFC xD0,W
06142:  MOVWF  FEA
06144:  MOVFF  FEF,9E6
06148:  MOVFF  FEC,9E7
0614C:  MOVFF  FEC,9E8
06150:  MOVFF  FEC,9E9
06154:  MOVLB  0
06156:  RCALL  5D28
06158:  MOVFF  03,9D4
0615C:  MOVFF  02,9D3
06160:  MOVFF  01,9D2
06164:  MOVFF  00,9D1
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
06168:  MOVLW  0C
0616A:  MOVLB  7
0616C:  ADDWF  x0E,W
0616E:  MOVWF  FE9
06170:  MOVLW  00
06172:  ADDWFC x0F,W
06174:  MOVWF  FEA
06176:  MOVFF  FEF,00
0617A:  MOVFF  FEC,01
0617E:  MOVFF  FEC,02
06182:  MOVFF  FEC,03
06186:  MOVF   03,W
06188:  MOVLB  9
0618A:  SUBWF  xD4,W
0618C:  BNC   61A6
0618E:  BNZ   61B8
06190:  MOVF   02,W
06192:  SUBWF  xD3,W
06194:  BNC   61A6
06196:  BNZ   61B8
06198:  MOVF   01,W
0619A:  SUBWF  xD2,W
0619C:  BNC   61A6
0619E:  BNZ   61B8
061A0:  MOVF   00,W
061A2:  SUBWF  xD1,W
061A4:  BC    61B8
061A6:  MOVF   xD4,F
061A8:  BNZ   61BE
061AA:  MOVF   xD3,F
061AC:  BNZ   61BE
061AE:  MOVF   xD2,F
061B0:  BNZ   61BE
061B2:  MOVF   xD1,W
061B4:  SUBLW  01
061B6:  BNC   61BE
....................                return (FALSE); 
061B8:  MOVLW  00
061BA:  MOVWF  01
061BC:  BRA    6236
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
061BE:  MOVLW  04
061C0:  ADDWF  xCF,W
061C2:  MOVWF  FE9
061C4:  MOVLW  00
061C6:  ADDWFC xD0,W
061C8:  MOVWF  FEA
061CA:  MOVFF  9D1,FEF
061CE:  MOVFF  9D2,FEC
061D2:  MOVFF  9D3,FEC
061D6:  MOVFF  9D4,FEC
....................             scan->sect = clust2sect(clust); 
061DA:  MOVLW  08
061DC:  ADDWF  xCF,W
061DE:  MOVWF  01
061E0:  MOVLW  00
061E2:  ADDWFC xD0,W
061E4:  MOVWF  03
061E6:  MOVFF  01,9D7
061EA:  MOVWF  xD8
061EC:  MOVFF  9D4,9DC
061F0:  MOVFF  9D3,9DB
061F4:  MOVFF  9D2,9DA
061F8:  MOVFF  9D1,9D9
061FC:  MOVLB  0
061FE:  CALL   5654
06202:  MOVFF  9D8,FEA
06206:  MOVFF  9D7,FE9
0620A:  MOVFF  00,FEF
0620E:  MOVFF  01,FEC
06212:  MOVFF  02,FEC
06216:  MOVFF  03,FEC
0621A:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
0621C:  MOVLW  0C
0621E:  ADDWF  xCF,W
06220:  MOVWF  FE9
06222:  MOVLW  00
06224:  ADDWFC xD0,W
06226:  MOVWF  FEA
06228:  MOVFF  9D6,FEC
0622C:  MOVF   FED,F
0622E:  MOVFF  9D5,FEF
....................    return (TRUE); 
06232:  MOVLW  01
06234:  MOVWF  01
06236:  MOVLB  0
06238:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
0572E:  MOVFF  9D2,FEA
05732:  MOVFF  9D1,FE9
05736:  MOVLW  20
05738:  MOVWF  00
0573A:  CLRF   02
0573C:  MOVLW  0B
0573E:  MOVWF  01
05740:  CALL   357A
....................    a = 0; b = 0x18;            // NT flag 
05744:  MOVLB  9
05746:  CLRF   xD6
05748:  MOVLW  18
0574A:  MOVWF  xD7
....................    n = 0; t = 8; 
0574C:  CLRF   xD3
0574E:  MOVLW  08
05750:  MOVWF  xD4
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
05752:  MOVFF  9CF,FE9
05756:  MOVFF  9D0,FEA
0575A:  MOVFF  FEC,9D9
0575E:  MOVF   FED,F
05760:  MOVFF  FEF,9D8
....................       c = *ptr; 
05764:  MOVFF  9D8,FE9
05768:  MOVFF  9D9,FEA
0576C:  MOVFF  FEF,9D5
....................       (*path)++; 
05770:  MOVFF  9D0,03
05774:  MOVFF  9CF,FE9
05778:  MOVFF  9D0,FEA
0577C:  MOVLW  01
0577E:  ADDWF  FEE,F
05780:  BNC   5784
05782:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
05784:  MOVF   xD5,W
05786:  SUBLW  20
05788:  BNC   578C
....................          c = 0; 
0578A:  CLRF   xD5
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
0578C:  MOVF   xD5,F
0578E:  BZ    579C
05790:  MOVF   xD5,W
05792:  SUBLW  2F
05794:  BZ    579C
05796:  MOVF   xD5,W
05798:  SUBLW  5C
0579A:  BNZ   57BA
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
0579C:  MOVF   xD3,F
0579E:  BNZ   57A2
....................             break; 
057A0:  BRA    5882
....................          dirname[11] = a & b;  
057A2:  MOVLW  0B
057A4:  ADDWF  xD1,W
057A6:  MOVWF  FE9
057A8:  MOVLW  00
057AA:  ADDWFC xD2,W
057AC:  MOVWF  FEA
057AE:  MOVF   xD6,W
057B0:  ANDWF  xD7,W
057B2:  MOVWF  FEF
....................             return (c); 
057B4:  MOVFF  9D5,01
057B8:  BRA    5886
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
057BA:  MOVF   xD5,W
057BC:  SUBLW  20
057BE:  BC    57C6
057C0:  MOVF   xD5,W
057C2:  SUBLW  7F
057C4:  BNZ   57C8
....................          break;   // reject invisible characters 
057C6:  BRA    5882
....................       if (c == '.')  
057C8:  MOVF   xD5,W
057CA:  SUBLW  2E
057CC:  BNZ   57EA
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
057CE:  BTFSC  xD6.0
057D0:  BRA    57E8
057D2:  MOVF   xD3,W
057D4:  SUBLW  00
057D6:  BC    57E8
057D8:  MOVF   xD3,W
057DA:  SUBLW  08
057DC:  BNC   57E8
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
057DE:  MOVLW  08
057E0:  MOVWF  xD3
057E2:  MOVLW  0B
057E4:  MOVWF  xD4
....................             continue; 
057E6:  BRA    5880
....................             } 
....................          break; 
057E8:  BRA    5882
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
057EA:  MOVF   xD5,W
057EC:  SUBLW  22
057EE:  BNZ   57F2
....................          break;               // Reject "  
057F0:  BRA    5882
....................  
....................       if (c <= ')')  
057F2:  MOVF   xD5,W
057F4:  SUBLW  29
057F6:  BNC   57FA
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
057F8:  BRA    5864
....................  
....................       if (c <= ',') 
057FA:  MOVF   xD5,W
057FC:  SUBLW  2C
057FE:  BNC   5802
....................          break;               // Reject * + ,  
05800:  BRA    5882
....................  
....................       if (c <= '9')  
05802:  MOVF   xD5,W
05804:  SUBLW  39
05806:  BNC   580A
....................          goto md_l1;            // Accept - 0-9  
05808:  BRA    5864
....................  
....................       if (c <= '?')  
0580A:  MOVF   xD5,W
0580C:  SUBLW  3F
0580E:  BNC   5812
....................          break;               // Reject : ; < = > ?  
05810:  BRA    5882
....................  
....................       if (!(a & 1))  
05812:  BTFSC  xD6.0
05814:  BRA    5864
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
05816:  MOVF   xD5,W
05818:  SUBLW  7C
0581A:  BNZ   581E
....................             break;            // Reject |  
0581C:  BRA    5882
....................  
....................          if ((c >= '[') && (c <= ']')) 
0581E:  MOVF   xD5,W
05820:  SUBLW  5A
05822:  BC    582C
05824:  MOVF   xD5,W
05826:  SUBLW  5D
05828:  BNC   582C
....................             break;// Reject [ \ ]  
0582A:  BRA    5882
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
0582C:  MOVF   xD5,W
0582E:  SUBLW  40
05830:  BC    5846
05832:  MOVF   xD5,W
05834:  SUBLW  5A
05836:  BNC   5846
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
05838:  MOVF   xD4,W
0583A:  SUBLW  08
0583C:  BNZ   5844
0583E:  BCF    xD7.3
05840:  MOVF   xD7,W
05842:  BRA    5846
05844:  BCF    xD7.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
05846:  MOVF   xD5,W
05848:  SUBLW  60
0584A:  BC    5864
0584C:  MOVF   xD5,W
0584E:  SUBLW  7A
05850:  BNC   5864
....................             {      // Convert to upper case  
....................             c -= 0x20; 
05852:  MOVLW  20
05854:  SUBWF  xD5,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
05856:  MOVF   xD4,W
05858:  SUBLW  08
0585A:  BNZ   5862
0585C:  BSF    xD6.3
0585E:  MOVF   xD6,W
05860:  BRA    5864
05862:  BSF    xD6.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
05864:  BCF    xD6.0
....................    md_l2: 
....................       if (n >= t)  
05866:  MOVF   xD4,W
05868:  SUBWF  xD3,W
0586A:  BNC   586E
....................          break; 
0586C:  BRA    5882
....................       dirname[n++] = c; 
0586E:  MOVF   xD3,W
05870:  INCF   xD3,F
05872:  ADDWF  xD1,W
05874:  MOVWF  FE9
05876:  MOVLW  00
05878:  ADDWFC xD2,W
0587A:  MOVWF  FEA
0587C:  MOVFF  9D5,FEF
05880:  BRA    5752
....................       } 
....................    return 1; 
05882:  MOVLW  01
05884:  MOVWF  01
05886:  MOVLB  0
05888:  GOTO   63DC (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
0623A:  MOVLB  9
0623C:  CLRF   xCE
0623E:  CLRF   xCD
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
06240:  MOVLW  14
06242:  MOVLB  7
06244:  ADDWF  x0E,W
06246:  MOVWF  FE9
06248:  MOVLW  00
0624A:  ADDWFC x0F,W
0624C:  MOVWF  FEA
0624E:  MOVFF  FEF,9C8
06252:  MOVFF  FEC,9C9
06256:  MOVFF  FEC,9CA
0625A:  MOVFF  FEC,9CB
....................    if (fs->fs_type == FS_FAT32)  
0625E:  MOVFF  70E,FE9
06262:  MOVFF  70F,FEA
06266:  MOVF   FEF,W
06268:  SUBLW  03
0626A:  BNZ   62EE
....................       { 
....................       scan->clust = scan->sclust = clust; 
0626C:  MOVLW  04
0626E:  MOVLB  9
06270:  ADDWF  xC0,W
06272:  MOVWF  01
06274:  MOVLW  00
06276:  ADDWFC xC1,W
06278:  MOVFF  01,9CF
0627C:  MOVFF  9C0,FE9
06280:  MOVFF  9C1,FEA
06284:  MOVFF  9C8,FEF
06288:  MOVFF  9C9,FEC
0628C:  MOVFF  9CA,FEC
06290:  MOVFF  9CB,FEC
06294:  MOVWF  FEA
06296:  MOVFF  9CF,FE9
0629A:  MOVFF  9C8,FEF
0629E:  MOVFF  9C9,FEC
062A2:  MOVFF  9CA,FEC
062A6:  MOVFF  9CB,FEC
....................       scan->sect = clust2sect(clust); 
062AA:  MOVLW  08
062AC:  ADDWF  xC0,W
062AE:  MOVWF  01
062B0:  MOVLW  00
062B2:  ADDWFC xC1,W
062B4:  MOVWF  03
062B6:  MOVFF  01,9CF
062BA:  MOVWF  xD0
062BC:  MOVFF  9CB,9DC
062C0:  MOVFF  9CA,9DB
062C4:  MOVFF  9C9,9DA
062C8:  MOVFF  9C8,9D9
062CC:  MOVLB  0
062CE:  CALL   5654
062D2:  MOVFF  9D0,FEA
062D6:  MOVFF  9CF,FE9
062DA:  MOVFF  00,FEF
062DE:  MOVFF  01,FEC
062E2:  MOVFF  02,FEC
062E6:  MOVFF  03,FEC
....................       } 
062EA:  BRA    634E
062EC:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
062EE:  MOVLW  04
062F0:  MOVLB  9
062F2:  ADDWF  xC0,W
062F4:  MOVWF  01
062F6:  MOVLW  00
062F8:  ADDWFC xC1,W
062FA:  MOVWF  03
062FC:  MOVFF  9C0,FE9
06300:  MOVFF  9C1,FEA
06304:  MOVF   FEE,F
06306:  MOVF   FEE,F
06308:  CLRF   FEC
0630A:  MOVF   FED,F
0630C:  CLRF   FEF
0630E:  MOVF   FED,F
06310:  CLRF   FEF
06312:  MOVF   FED,F
06314:  CLRF   FEF
06316:  MOVLW  00
06318:  MOVFF  03,FEA
0631C:  MOVFF  01,FE9
06320:  MOVFF  00,FEF
06324:  MOVFF  01,FEC
06328:  MOVFF  02,FEC
0632C:  MOVFF  03,FEC
....................       scan->sect = clust; 
06330:  MOVLW  08
06332:  ADDWF  xC0,W
06334:  MOVWF  FE9
06336:  MOVLW  00
06338:  ADDWFC xC1,W
0633A:  MOVWF  FEA
0633C:  MOVFF  9C8,FEF
06340:  MOVFF  9C9,FEC
06344:  MOVFF  9CA,FEC
06348:  MOVFF  9CB,FEC
0634C:  MOVLB  0
....................       } 
....................    scan->index = 0; 
0634E:  MOVLW  0C
06350:  MOVLB  9
06352:  ADDWF  xC0,W
06354:  MOVWF  FE9
06356:  MOVLW  00
06358:  ADDWFC xC1,W
0635A:  MOVWF  FEA
0635C:  CLRF   FEC
0635E:  MOVF   FED,F
06360:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
06362:  MOVFF  9C5,03
06366:  MOVFF  9C4,FE9
0636A:  MOVFF  9C5,FEA
0636E:  MOVF   FEF,W
06370:  SUBLW  20
06372:  BZ    6398
06374:  MOVFF  9C5,03
06378:  MOVFF  9C4,FE9
0637C:  MOVFF  9C5,FEA
06380:  MOVF   FEF,W
06382:  SUBLW  2F
06384:  BZ    6398
06386:  MOVFF  9C5,03
0638A:  MOVFF  9C4,FE9
0638E:  MOVFF  9C5,FEA
06392:  MOVF   FEF,W
06394:  SUBLW  5C
06396:  BNZ   63A0
....................        path++; 
06398:  INCF   xC4,F
0639A:  BTFSC  FD8.2
0639C:  INCF   xC5,F
0639E:  BRA    6362
....................  
....................    if ((BYTE)*path < ' ')  
063A0:  MOVFF  9C5,03
063A4:  MOVFF  9C4,FE9
063A8:  MOVFF  9C5,FEA
063AC:  MOVF   FEF,W
063AE:  SUBLW  1F
063B0:  BNC   63C6
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
063B2:  MOVFF  9C6,FE9
063B6:  MOVFF  9C7,FEA
063BA:  CLRF   FEC
063BC:  MOVF   FED,F
063BE:  CLRF   FEF
....................       return (FR_OK); 
063C0:  MOVLW  00
063C2:  MOVWF  01
063C4:  BRA    661E
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
063C6:  MOVLW  09
063C8:  MOVWF  xD0
063CA:  MOVLW  C4
063CC:  MOVWF  xCF
063CE:  MOVFF  9C3,9D2
063D2:  MOVFF  9C2,9D1
063D6:  MOVLB  0
063D8:  GOTO   572E
063DC:  MOVFF  01,9CC
....................       if (ds == 1)  
063E0:  MOVLB  9
063E2:  DECFSZ xCC,W
063E4:  BRA    63EC
....................          return (FR_INVALID_NAME); 
063E6:  MOVLW  04
063E8:  MOVWF  01
063EA:  BRA    661E
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
063EC:  MOVLW  08
063EE:  ADDWF  xC0,W
063F0:  MOVWF  FE9
063F2:  MOVLW  00
063F4:  ADDWFC xC1,W
063F6:  MOVWF  FEA
063F8:  MOVFF  FEF,9FA
063FC:  MOVFF  FEC,9FB
06400:  MOVFF  FEC,9FC
06404:  MOVFF  FEC,9FD
06408:  MOVLB  0
0640A:  CALL   5AC8
0640E:  MOVF   01,F
06410:  BNZ   641C
....................             return (FR_RW_ERROR); 
06412:  MOVLW  07
06414:  MOVWF  01
06416:  MOVLB  9
06418:  BRA    661E
0641A:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
0641C:  MOVLW  0C
0641E:  MOVLB  9
06420:  ADDWF  xC0,W
06422:  MOVWF  FE9
06424:  MOVLW  00
06426:  ADDWFC xC1,W
06428:  MOVWF  FEA
0642A:  MOVFF  FEC,9D0
0642E:  MOVF   FED,F
06430:  MOVFF  FEF,9CF
06434:  MOVLW  0F
06436:  ANDWF  xCF,F
06438:  CLRF   xD0
0643A:  RLCF   xCF,F
0643C:  RLCF   xD0,F
0643E:  RLCF   xCF,F
06440:  RLCF   xD0,F
06442:  RLCF   xCF,F
06444:  RLCF   xD0,F
06446:  RLCF   xCF,F
06448:  RLCF   xD0,F
0644A:  RLCF   xCF,F
0644C:  RLCF   xD0,F
0644E:  MOVLW  E0
06450:  ANDWF  xCF,F
06452:  MOVLW  24
06454:  ADDWF  xCF,W
06456:  MOVWF  01
06458:  MOVLW  00
0645A:  ADDWFC xD0,W
0645C:  MOVWF  03
0645E:  MOVF   01,W
06460:  MOVLB  7
06462:  ADDWF  x0E,W
06464:  MOVWF  01
06466:  MOVF   x0F,W
06468:  ADDWFC 03,F
0646A:  MOVFF  01,9CD
0646E:  MOVLB  9
06470:  MOVFF  03,9CE
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
06474:  MOVFF  9CE,03
06478:  MOVFF  9CD,FE9
0647C:  MOVFF  9CE,FEA
06480:  MOVF   FEF,F
06482:  BNZ   6492
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06484:  MOVF   xCC,F
06486:  BNZ   648C
06488:  MOVLW  02
0648A:  BRA    648E
0648C:  MOVLW  03
0648E:  MOVWF  01
06490:  BRA    661E
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
06492:  MOVFF  9CE,03
06496:  MOVFF  9CD,FE9
0649A:  MOVFF  9CE,FEA
0649E:  MOVF   FEF,W
064A0:  SUBLW  E5
064A2:  BZ    64E4
064A4:  MOVLW  0B
064A6:  ADDWF  xCD,W
064A8:  MOVWF  01
064AA:  MOVLW  00
064AC:  ADDWFC xCE,W
064AE:  MOVWF  03
064B0:  MOVFF  01,FE9
064B4:  MOVWF  FEA
064B6:  BTFSC  FEF.3
064B8:  BRA    64E4
064BA:  MOVFF  9CE,9D4
064BE:  MOVFF  9CD,9D3
064C2:  MOVFF  9C3,9D6
064C6:  MOVFF  9C2,9D5
064CA:  CLRF   xD8
064CC:  MOVLW  0B
064CE:  MOVWF  xD7
064D0:  MOVLB  0
064D2:  CALL   4660
064D6:  MOVF   01,F
064D8:  BTFSC  FD8.2
064DA:  BRA    64E0
064DC:  MOVLB  9
064DE:  BRA    64E4
....................              break; 
064E0:  BRA    650C
064E2:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
064E4:  MOVFF  9C1,9D0
064E8:  MOVFF  9C0,9CF
064EC:  MOVLB  0
064EE:  RCALL  6060
064F0:  MOVF   01,F
064F2:  BNZ   6506
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
064F4:  MOVLB  9
064F6:  MOVF   xCC,F
064F8:  BNZ   64FE
064FA:  MOVLW  02
064FC:  BRA    6500
064FE:  MOVLW  03
06500:  MOVWF  01
06502:  BRA    661E
06504:  MOVLB  0
06506:  MOVLB  9
06508:  BRA    63EC
0650A:  MOVLB  0
....................          } 
....................       if (!ds)  
0650C:  MOVLB  9
0650E:  MOVF   xCC,F
06510:  BNZ   652A
....................          {  
....................          *win_dir = dptr;  
06512:  MOVFF  9C6,FE9
06516:  MOVFF  9C7,FEA
0651A:  MOVFF  9CE,FEC
0651E:  MOVF   FED,F
06520:  MOVFF  9CD,FEF
....................          return (FR_OK); 
06524:  MOVLW  00
06526:  MOVWF  01
06528:  BRA    661E
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
0652A:  MOVLW  0B
0652C:  ADDWF  xCD,W
0652E:  MOVWF  01
06530:  MOVLW  00
06532:  ADDWFC xCE,W
06534:  MOVWF  03
06536:  MOVFF  01,FE9
0653A:  MOVWF  FEA
0653C:  BTFSC  FEF.4
0653E:  BRA    6546
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
06540:  MOVLW  03
06542:  MOVWF  01
06544:  BRA    661E
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
06546:  MOVLW  14
06548:  ADDWF  xCD,W
0654A:  MOVWF  01
0654C:  MOVLW  00
0654E:  ADDWFC xCE,W
06550:  MOVWF  03
06552:  MOVFF  01,FE9
06556:  MOVWF  FEA
06558:  MOVFF  FEC,9CB
0655C:  MOVF   FED,F
0655E:  MOVFF  FEF,9CF
06562:  MOVFF  9CF,9CA
06566:  CLRF   xCF
06568:  CLRF   xD0
0656A:  MOVLW  1A
0656C:  ADDWF  xCD,W
0656E:  MOVWF  01
06570:  MOVLW  00
06572:  ADDWFC xCE,W
06574:  MOVFF  01,FE9
06578:  MOVWF  FEA
0657A:  MOVFF  FEC,03
0657E:  MOVF   FED,F
06580:  MOVF   FEF,W
06582:  IORWF  xCF,W
06584:  MOVWF  xC8
06586:  MOVF   03,W
06588:  IORWF  xD0,W
0658A:  MOVWF  xC9
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
0658C:  MOVLW  04
0658E:  ADDWF  xC0,W
06590:  MOVWF  01
06592:  MOVLW  00
06594:  ADDWFC xC1,W
06596:  MOVFF  01,9CF
0659A:  MOVFF  9C0,FE9
0659E:  MOVFF  9C1,FEA
065A2:  MOVFF  9C8,FEF
065A6:  MOVFF  9C9,FEC
065AA:  MOVFF  9CA,FEC
065AE:  MOVFF  9CB,FEC
065B2:  MOVWF  FEA
065B4:  MOVFF  9CF,FE9
065B8:  MOVFF  9C8,FEF
065BC:  MOVFF  9C9,FEC
065C0:  MOVFF  9CA,FEC
065C4:  MOVFF  9CB,FEC
....................       scan->sect = clust2sect(clust); 
065C8:  MOVLW  08
065CA:  ADDWF  xC0,W
065CC:  MOVWF  01
065CE:  MOVLW  00
065D0:  ADDWFC xC1,W
065D2:  MOVWF  03
065D4:  MOVFF  01,9CF
065D8:  MOVWF  xD0
065DA:  MOVFF  9CB,9DC
065DE:  MOVFF  9CA,9DB
065E2:  MOVFF  9C9,9DA
065E6:  MOVFF  9C8,9D9
065EA:  MOVLB  0
065EC:  CALL   5654
065F0:  MOVFF  9D0,FEA
065F4:  MOVFF  9CF,FE9
065F8:  MOVFF  00,FEF
065FC:  MOVFF  01,FEC
06600:  MOVFF  02,FEC
06604:  MOVFF  03,FEC
....................       scan->index = 0; 
06608:  MOVLW  0C
0660A:  MOVLB  9
0660C:  ADDWF  xC0,W
0660E:  MOVWF  FE9
06610:  MOVLW  00
06612:  ADDWFC xC1,W
06614:  MOVWF  FEA
06616:  CLRF   FEC
06618:  MOVF   FED,F
0661A:  CLRF   FEF
0661C:  BRA    63C6
....................       } 
0661E:  MOVLB  0
06620:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06C38:  MOVLB  9
06C3A:  MOVFF  9C0,FE9
06C3E:  MOVFF  9C1,FEA
06C42:  MOVFF  FEF,9C2
06C46:  MOVFF  FEC,9C3
06C4A:  MOVFF  FEC,9C4
06C4E:  MOVFF  FEC,9C5
....................    if (clust) {   // Dyanmic directory table  
06C52:  MOVF   xC2,F
06C54:  BNZ   6C62
06C56:  MOVF   xC3,F
06C58:  BNZ   6C62
06C5A:  MOVF   xC4,F
06C5C:  BNZ   6C62
06C5E:  MOVF   xC5,F
06C60:  BZ    6CC2
....................       scan->clust = clust; 
06C62:  MOVLW  04
06C64:  ADDWF  xC0,W
06C66:  MOVWF  FE9
06C68:  MOVLW  00
06C6A:  ADDWFC xC1,W
06C6C:  MOVWF  FEA
06C6E:  MOVFF  9C2,FEF
06C72:  MOVFF  9C3,FEC
06C76:  MOVFF  9C4,FEC
06C7A:  MOVFF  9C5,FEC
....................       scan->sect = clust2sect(clust); 
06C7E:  MOVLW  08
06C80:  ADDWF  xC0,W
06C82:  MOVWF  01
06C84:  MOVLW  00
06C86:  ADDWFC xC1,W
06C88:  MOVWF  03
06C8A:  MOVFF  01,9CE
06C8E:  MOVWF  xCF
06C90:  MOVFF  9C5,9DC
06C94:  MOVFF  9C4,9DB
06C98:  MOVFF  9C3,9DA
06C9C:  MOVFF  9C2,9D9
06CA0:  MOVLB  0
06CA2:  CALL   5654
06CA6:  MOVFF  9CF,FEA
06CAA:  MOVFF  9CE,FE9
06CAE:  MOVFF  00,FEF
06CB2:  MOVFF  01,FEC
06CB6:  MOVFF  02,FEC
06CBA:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06CBE:  BRA    6D0C
06CC0:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06CC2:  MOVLW  08
06CC4:  ADDWF  xC0,W
06CC6:  MOVWF  01
06CC8:  MOVLW  00
06CCA:  ADDWFC xC1,W
06CCC:  MOVWF  03
06CCE:  MOVFF  01,9CE
06CD2:  MOVWF  xCF
06CD4:  MOVLW  14
06CD6:  MOVLB  7
06CD8:  ADDWF  x0E,W
06CDA:  MOVWF  FE9
06CDC:  MOVLW  00
06CDE:  ADDWFC x0F,W
06CE0:  MOVWF  FEA
06CE2:  MOVFF  FEF,00
06CE6:  MOVFF  FEC,01
06CEA:  MOVFF  FEC,02
06CEE:  MOVFF  FEC,03
06CF2:  MOVFF  9CF,FEA
06CF6:  MOVFF  9CE,FE9
06CFA:  MOVFF  00,FEF
06CFE:  MOVFF  01,FEC
06D02:  MOVFF  02,FEC
06D06:  MOVFF  03,FEC
06D0A:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06D0C:  MOVLW  0C
06D0E:  MOVLB  9
06D10:  ADDWF  xC0,W
06D12:  MOVWF  FE9
06D14:  MOVLW  00
06D16:  ADDWFC xC1,W
06D18:  MOVWF  FEA
06D1A:  CLRF   FEC
06D1C:  MOVF   FED,F
06D1E:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06D20:  MOVLW  08
06D22:  ADDWF  xC0,W
06D24:  MOVWF  FE9
06D26:  MOVLW  00
06D28:  ADDWFC xC1,W
06D2A:  MOVWF  FEA
06D2C:  MOVFF  FEF,9FA
06D30:  MOVFF  FEC,9FB
06D34:  MOVFF  FEC,9FC
06D38:  MOVFF  FEC,9FD
06D3C:  MOVLB  0
06D3E:  CALL   5AC8
06D42:  MOVF   01,F
06D44:  BNZ   6D4E
....................          return (NULL); 
06D46:  MOVLW  00
06D48:  MOVWF  01
06D4A:  MOVWF  02
06D4C:  BRA    6F7A
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06D4E:  MOVLW  0C
06D50:  MOVLB  9
06D52:  ADDWF  xC0,W
06D54:  MOVWF  FE9
06D56:  MOVLW  00
06D58:  ADDWFC xC1,W
06D5A:  MOVWF  FEA
06D5C:  MOVFF  FEC,9CF
06D60:  MOVF   FED,F
06D62:  MOVFF  FEF,9CE
06D66:  MOVLW  0F
06D68:  ANDWF  xCE,F
06D6A:  CLRF   xCF
06D6C:  RLCF   xCE,F
06D6E:  RLCF   xCF,F
06D70:  RLCF   xCE,F
06D72:  RLCF   xCF,F
06D74:  RLCF   xCE,F
06D76:  RLCF   xCF,F
06D78:  RLCF   xCE,F
06D7A:  RLCF   xCF,F
06D7C:  RLCF   xCE,F
06D7E:  RLCF   xCF,F
06D80:  MOVLW  E0
06D82:  ANDWF  xCE,F
06D84:  MOVLW  24
06D86:  ADDWF  xCE,W
06D88:  MOVWF  01
06D8A:  MOVLW  00
06D8C:  ADDWFC xCF,W
06D8E:  MOVWF  03
06D90:  MOVF   01,W
06D92:  MOVLB  7
06D94:  ADDWF  x0E,W
06D96:  MOVWF  01
06D98:  MOVF   x0F,W
06D9A:  ADDWFC 03,F
06D9C:  MOVFF  01,9CC
06DA0:  MOVLB  9
06DA2:  MOVFF  03,9CD
....................       c = *dptr; 
06DA6:  MOVFF  9CC,FE9
06DAA:  MOVFF  9CD,FEA
06DAE:  MOVFF  FEF,9CA
....................       if ((c == 0) || (c == 0xE5))  
06DB2:  MOVF   xCA,F
06DB4:  BZ    6DBC
06DB6:  MOVF   xCA,W
06DB8:  SUBLW  E5
06DBA:  BNZ   6DCA
....................          return (dptr);      // Found an empty entry!  
06DBC:  MOVFF  9CC,01
06DC0:  MOVFF  9CD,02
06DC4:  MOVLB  0
06DC6:  BRA    6F7A
06DC8:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06DCA:  MOVFF  9C1,9D0
06DCE:  MOVFF  9C0,9CF
06DD2:  MOVLB  0
06DD4:  CALL   6060
06DD8:  MOVF   01,F
06DDA:  BTFSC  FD8.2
06DDC:  BRA    6DE2
06DDE:  MOVLB  9
06DE0:  BRA    6D20
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06DE2:  MOVLB  9
06DE4:  MOVF   xC2,F
06DE6:  BNZ   6E00
06DE8:  MOVF   xC3,F
06DEA:  BNZ   6E00
06DEC:  MOVF   xC4,F
06DEE:  BNZ   6E00
06DF0:  MOVF   xC5,F
06DF2:  BNZ   6E00
....................        return (NULL); 
06DF4:  MOVLW  00
06DF6:  MOVWF  01
06DF8:  MOVWF  02
06DFA:  MOVLB  0
06DFC:  BRA    6F7A
06DFE:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06E00:  MOVLW  04
06E02:  ADDWF  xC0,W
06E04:  MOVWF  FE9
06E06:  MOVLW  00
06E08:  ADDWFC xC1,W
06E0A:  MOVWF  FEA
06E0C:  MOVFF  FEF,9D2
06E10:  MOVFF  FEC,9D3
06E14:  MOVFF  FEC,9D4
06E18:  MOVFF  FEC,9D5
06E1C:  MOVLB  0
06E1E:  RCALL  69A2
06E20:  MOVFF  03,9C5
06E24:  MOVFF  02,9C4
06E28:  MOVFF  01,9C3
06E2C:  MOVFF  00,9C2
....................    if (!(clust))  
06E30:  MOVLB  9
06E32:  MOVF   xC2,F
06E34:  BNZ   6E4E
06E36:  MOVF   xC3,F
06E38:  BNZ   6E4E
06E3A:  MOVF   xC4,F
06E3C:  BNZ   6E4E
06E3E:  MOVF   xC5,F
06E40:  BNZ   6E4E
....................       return (NULL); 
06E42:  MOVLW  00
06E44:  MOVWF  01
06E46:  MOVWF  02
06E48:  MOVLB  0
06E4A:  BRA    6F7A
06E4C:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06E4E:  CLRF   xFD
06E50:  CLRF   xFC
06E52:  CLRF   xFB
06E54:  CLRF   xFA
06E56:  MOVLB  0
06E58:  CALL   5AC8
06E5C:  MOVF   01,F
06E5E:  BNZ   6E68
....................       return (0); 
06E60:  MOVLW  00
06E62:  MOVWF  01
06E64:  MOVWF  02
06E66:  BRA    6F7A
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06E68:  MOVLW  20
06E6A:  MOVLB  7
06E6C:  ADDWF  x0E,W
06E6E:  MOVWF  01
06E70:  MOVLW  00
06E72:  ADDWFC x0F,W
06E74:  MOVWF  03
06E76:  MOVFF  01,9CE
06E7A:  MOVLB  9
06E7C:  MOVWF  xCF
06E7E:  MOVFF  9C5,9DC
06E82:  MOVFF  9C4,9DB
06E86:  MOVFF  9C3,9DA
06E8A:  MOVFF  9C2,9D9
06E8E:  MOVLB  0
06E90:  CALL   5654
06E94:  MOVFF  03,9C9
06E98:  MOVFF  02,9C8
06E9C:  MOVFF  01,9C7
06EA0:  MOVFF  00,9C6
06EA4:  MOVFF  9CF,FEA
06EA8:  MOVFF  9CE,FE9
06EAC:  MOVFF  9C6,FEF
06EB0:  MOVFF  9C7,FEC
06EB4:  MOVFF  9C8,FEC
06EB8:  MOVFF  9C9,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06EBC:  MOVLW  24
06EBE:  MOVLB  7
06EC0:  ADDWF  x0E,W
06EC2:  MOVWF  01
06EC4:  MOVLW  00
06EC6:  ADDWFC x0F,W
06EC8:  MOVWF  03
06ECA:  MOVFF  01,9CE
06ECE:  MOVLB  9
06ED0:  MOVWF  xCF
06ED2:  MOVWF  FEA
06ED4:  MOVFF  01,FE9
06ED8:  CLRF   00
06EDA:  MOVLW  02
06EDC:  MOVWF  02
06EDE:  CLRF   01
06EE0:  MOVLB  0
06EE2:  CALL   357A
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06EE6:  MOVLW  02
06EE8:  MOVLB  7
06EEA:  ADDWF  x0E,W
06EEC:  MOVWF  FE9
06EEE:  MOVLW  00
06EF0:  ADDWFC x0F,W
06EF2:  MOVWF  FEA
06EF4:  MOVFF  FEF,9CB
06EF8:  MOVLB  9
06EFA:  MOVF   xCB,F
06EFC:  BZ    6F5A
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06EFE:  MOVLW  24
06F00:  MOVLB  7
06F02:  ADDWF  x0E,W
06F04:  MOVWF  01
06F06:  MOVLW  00
06F08:  ADDWFC x0F,W
06F0A:  MOVWF  03
06F0C:  MOVFF  01,9CE
06F10:  MOVLB  9
06F12:  MOVWF  xCF
06F14:  MOVFF  FE8,A07
06F18:  MOVFF  01,A06
06F1C:  MOVFF  9C9,A0B
06F20:  MOVFF  9C8,A0A
06F24:  MOVFF  9C7,A09
06F28:  MOVFF  9C6,A08
06F2C:  MOVLW  01
06F2E:  MOVLB  A
06F30:  MOVWF  x0C
06F32:  MOVLB  0
06F34:  CALL   5984
06F38:  MOVF   01,F
06F3A:  BZ    6F44
....................          return (NULL); 
06F3C:  MOVLW  00
06F3E:  MOVWF  01
06F40:  MOVWF  02
06F42:  BRA    6F7A
....................       sector++; 
06F44:  MOVLW  01
06F46:  MOVLB  9
06F48:  ADDWF  xC6,F
06F4A:  BTFSC  FD8.0
06F4C:  INCF   xC7,F
06F4E:  BTFSC  FD8.2
06F50:  INCF   xC8,F
06F52:  BTFSC  FD8.2
06F54:  INCF   xC9,F
06F56:  DECF   xCB,F
06F58:  BRA    6EFA
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06F5A:  MOVLW  06
06F5C:  MOVLB  7
06F5E:  ADDWF  x0E,W
06F60:  MOVWF  FE9
06F62:  MOVLW  00
06F64:  ADDWFC x0F,W
06F66:  MOVWF  FEA
06F68:  MOVLW  01
06F6A:  MOVWF  FEF
....................    return (fs->win); 
06F6C:  MOVLW  24
06F6E:  ADDWF  x0E,W
06F70:  MOVWF  01
06F72:  MOVLW  00
06F74:  ADDWFC x0F,W
06F76:  MOVWF  03
06F78:  MOVWF  02
06F7A:  MOVLB  0
06F7C:  GOTO   7212 (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
055F2:  MOVLB  7
055F4:  MOVF   x0E,W
055F6:  IORWF  x0F,W
055F8:  BNZ   5600
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
055FA:  MOVLW  0B
055FC:  MOVWF  01
055FE:  BRA    5650
....................  
....................    if (disk_status() & STA_NOINIT)  
05600:  MOVLB  0
05602:  RCALL  55E4
05604:  BTFSS  01.0
05606:  BRA    5632
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
05608:  MOVLW  01
0560A:  MOVLB  7
0560C:  ADDWF  x0E,W
0560E:  MOVWF  FE9
05610:  MOVLW  00
05612:  ADDWFC x0F,W
05614:  MOVWF  FEA
05616:  MOVF   FEF,F
05618:  BZ    5622
....................          return (FR_INCORRECT_DISK_CHANGE); 
0561A:  MOVLW  09
0561C:  MOVWF  01
0561E:  BRA    5650
05620:  BRA    562E
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
05622:  MOVLB  0
05624:  CALL   48A0
05628:  MOVF   01,W
0562A:  MOVLB  7
0562C:  BRA    5650
....................       }  
0562E:  BRA    564C
05630:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
05632:  MOVLB  7
05634:  MOVFF  70E,FE9
05638:  MOVFF  70F,FEA
0563C:  MOVF   FEF,F
0563E:  BNZ   564C
....................          return (f_mountdrv());      // Initialize file system and return resulut  
05640:  MOVLB  0
05642:  CALL   48A0
05646:  MOVF   01,W
05648:  MOVLB  7
0564A:  BRA    5650
....................       } 
....................    return FR_OK;                  // File system is valid  
0564C:  MOVLW  00
0564E:  MOVWF  01
05650:  MOVLB  0
05652:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B6DA:  MOVLB  8
0B6DC:  MOVF   xB6,W
0B6DE:  XORLW  00
0B6E0:  MOVLB  0
0B6E2:  BZ    B71C
0B6E4:  XORLW  04
0B6E6:  BZ    B738
0B6E8:  XORLW  05
0B6EA:  BZ    B754
0B6EC:  XORLW  03
0B6EE:  BZ    B770
0B6F0:  XORLW  01
0B6F2:  BZ    B78C
0B6F4:  XORLW  06
0B6F6:  BZ    B7A8
0B6F8:  XORLW  03
0B6FA:  BZ    B7C4
0B6FC:  XORLW  01
0B6FE:  BTFSC  FD8.2
0B700:  BRA    B7E0
0B702:  XORLW  0E
0B704:  BTFSC  FD8.2
0B706:  BRA    B7FC
0B708:  XORLW  03
0B70A:  BTFSC  FD8.2
0B70C:  BRA    B818
0B70E:  XORLW  01
0B710:  BTFSC  FD8.2
0B712:  BRA    B834
0B714:  XORLW  07
0B716:  BTFSC  FD8.2
0B718:  BRA    B850
0B71A:  BRA    B86C
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B71C:  MOVFF  8B8,FEA
0B720:  MOVFF  8B7,FE9
0B724:  MOVLW  00
0B726:  CALL   0106
0B72A:  TBLRD*-
0B72C:  TBLRD*+
0B72E:  MOVF   FF5,W
0B730:  MOVWF  FEE
0B732:  IORLW  00
0B734:  BNZ   B72C
....................          break; 
0B736:  BRA    B886
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B738:  MOVFF  8B8,FEA
0B73C:  MOVFF  8B7,FE9
0B740:  MOVLW  00
0B742:  CALL   0124
0B746:  TBLRD*-
0B748:  TBLRD*+
0B74A:  MOVF   FF5,W
0B74C:  MOVWF  FEE
0B74E:  IORLW  00
0B750:  BNZ   B748
....................          break; 
0B752:  BRA    B886
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0B754:  MOVFF  8B8,FEA
0B758:  MOVFF  8B7,FE9
0B75C:  MOVLW  00
0B75E:  CALL   014A
0B762:  TBLRD*-
0B764:  TBLRD*+
0B766:  MOVF   FF5,W
0B768:  MOVWF  FEE
0B76A:  IORLW  00
0B76C:  BNZ   B764
....................          break; 
0B76E:  BRA    B886
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0B770:  MOVFF  8B8,FEA
0B774:  MOVFF  8B7,FE9
0B778:  MOVLW  00
0B77A:  CALL   016E
0B77E:  TBLRD*-
0B780:  TBLRD*+
0B782:  MOVF   FF5,W
0B784:  MOVWF  FEE
0B786:  IORLW  00
0B788:  BNZ   B780
....................          break; 
0B78A:  BRA    B886
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0B78C:  MOVFF  8B8,FEA
0B790:  MOVFF  8B7,FE9
0B794:  MOVLW  00
0B796:  CALL   0192
0B79A:  TBLRD*-
0B79C:  TBLRD*+
0B79E:  MOVF   FF5,W
0B7A0:  MOVWF  FEE
0B7A2:  IORLW  00
0B7A4:  BNZ   B79C
....................          break; 
0B7A6:  BRA    B886
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0B7A8:  MOVFF  8B8,FEA
0B7AC:  MOVFF  8B7,FE9
0B7B0:  MOVLW  00
0B7B2:  CALL   01B6
0B7B6:  TBLRD*-
0B7B8:  TBLRD*+
0B7BA:  MOVF   FF5,W
0B7BC:  MOVWF  FEE
0B7BE:  IORLW  00
0B7C0:  BNZ   B7B8
....................          break; 
0B7C2:  BRA    B886
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0B7C4:  MOVFF  8B8,FEA
0B7C8:  MOVFF  8B7,FE9
0B7CC:  MOVLW  00
0B7CE:  CALL   01D8
0B7D2:  TBLRD*-
0B7D4:  TBLRD*+
0B7D6:  MOVF   FF5,W
0B7D8:  MOVWF  FEE
0B7DA:  IORLW  00
0B7DC:  BNZ   B7D4
....................          break; 
0B7DE:  BRA    B886
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0B7E0:  MOVFF  8B8,FEA
0B7E4:  MOVFF  8B7,FE9
0B7E8:  MOVLW  00
0B7EA:  CALL   01F8
0B7EE:  TBLRD*-
0B7F0:  TBLRD*+
0B7F2:  MOVF   FF5,W
0B7F4:  MOVWF  FEE
0B7F6:  IORLW  00
0B7F8:  BNZ   B7F0
....................          break; 
0B7FA:  BRA    B886
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0B7FC:  MOVFF  8B8,FEA
0B800:  MOVFF  8B7,FE9
0B804:  MOVLW  00
0B806:  CALL   0216
0B80A:  TBLRD*-
0B80C:  TBLRD*+
0B80E:  MOVF   FF5,W
0B810:  MOVWF  FEE
0B812:  IORLW  00
0B814:  BNZ   B80C
....................          break; 
0B816:  BRA    B886
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0B818:  MOVFF  8B8,FEA
0B81C:  MOVFF  8B7,FE9
0B820:  MOVLW  00
0B822:  CALL   0242
0B826:  TBLRD*-
0B828:  TBLRD*+
0B82A:  MOVF   FF5,W
0B82C:  MOVWF  FEE
0B82E:  IORLW  00
0B830:  BNZ   B828
....................          break; 
0B832:  BRA    B886
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0B834:  MOVFF  8B8,FEA
0B838:  MOVFF  8B7,FE9
0B83C:  MOVLW  00
0B83E:  CALL   0266
0B842:  TBLRD*-
0B844:  TBLRD*+
0B846:  MOVF   FF5,W
0B848:  MOVWF  FEE
0B84A:  IORLW  00
0B84C:  BNZ   B844
....................          break; 
0B84E:  BRA    B886
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0B850:  MOVFF  8B8,FEA
0B854:  MOVFF  8B7,FE9
0B858:  MOVLW  00
0B85A:  CALL   028A
0B85E:  TBLRD*-
0B860:  TBLRD*+
0B862:  MOVF   FF5,W
0B864:  MOVWF  FEE
0B866:  IORLW  00
0B868:  BNZ   B860
....................          break; 
0B86A:  BRA    B886
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0B86C:  MOVFF  8B8,FEA
0B870:  MOVFF  8B7,FE9
0B874:  MOVLW  00
0B876:  CALL   02AC
0B87A:  TBLRD*-
0B87C:  TBLRD*+
0B87E:  MOVF   FF5,W
0B880:  MOVWF  FEE
0B882:  IORLW  00
0B884:  BNZ   B87C
....................       } 
0B886:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
048A0:  MOVLB  7
048A2:  MOVF   x0E,W
048A4:  IORWF  x0F,W
048A6:  BNZ   48AE
....................       return (FR_NOT_ENABLED); 
048A8:  MOVLW  0B
048AA:  MOVWF  01
048AC:  BRA    4E3A
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
048AE:  MOVFF  70F,FEA
048B2:  MOVFF  70E,FE9
048B6:  CLRF   00
048B8:  MOVLW  02
048BA:  MOVWF  02
048BC:  MOVLW  24
048BE:  MOVWF  01
048C0:  MOVLB  0
048C2:  CALL   357A
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
048C6:  CALL   36CA
048CA:  MOVFF  01,4E9
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
048CE:  MOVLB  4
048D0:  BTFSS  xE9.0
048D2:  BRA    48E0
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
048D4:  MOVLB  0
048D6:  CALL   36CA
048DA:  MOVFF  01,4E9
048DE:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
048E0:  BTFSS  xE9.0
048E2:  BRA    48EE
048E4:  MOVLW  01
048E6:  MOVWF  01
048E8:  MOVLB  7
048EA:  BRA    4E3A
048EC:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
048EE:  MOVLB  9
048F0:  CLRF   xC4
048F2:  CLRF   xC3
048F4:  CLRF   xC2
048F6:  CLRF   xC1
048F8:  MOVFF  9C4,9D0
048FC:  MOVFF  9C3,9CF
04900:  MOVFF  9C2,9CE
04904:  MOVFF  9C1,9CD
04908:  MOVLB  0
0490A:  RCALL  46E4
0490C:  MOVFF  01,9C0
....................    if (!fat)  
04910:  MOVLB  9
04912:  MOVF   xC0,F
04914:  BNZ   4984
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
04916:  MOVLW  E6
04918:  MOVLB  7
0491A:  ADDWF  x0E,W
0491C:  MOVWF  FE9
0491E:  MOVLW  01
04920:  ADDWFC x0F,W
04922:  MOVWF  FEA
04924:  MOVF   FEF,F
04926:  BZ    4964
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
04928:  MOVLW  EA
0492A:  ADDWF  x0E,W
0492C:  MOVWF  01
0492E:  MOVLW  01
04930:  ADDWFC x0F,W
04932:  MOVFF  01,FE9
04936:  MOVWF  FEA
04938:  MOVFF  FEF,9C1
0493C:  MOVFF  FEC,9C2
04940:  MOVFF  FEC,9C3
04944:  MOVFF  FEC,9C4
....................          fat = check_fs(sect);            // Check the partition  
04948:  MOVFF  9C4,9D0
0494C:  MOVFF  9C3,9CF
04950:  MOVFF  9C2,9CE
04954:  MOVFF  9C1,9CD
04958:  MOVLB  0
0495A:  RCALL  46E4
0495C:  MOVFF  01,9C0
....................          } 
04960:  BRA    4982
04962:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
04964:  MOVLW  04
04966:  MOVWF  FF6
04968:  MOVLW  0C
0496A:  MOVWF  FF7
0496C:  MOVLW  00
0496E:  MOVWF  FF8
04970:  CLRF   1B
04972:  BTFSC  FF2.7
04974:  BSF    1B.7
04976:  BCF    FF2.7
04978:  MOVLB  0
0497A:  CALL   0E3A
0497E:  BTFSC  1B.7
04980:  BSF    FF2.7
04982:  MOVLB  9
....................       } 
....................    if (!fat)  
04984:  MOVF   xC0,F
04986:  BNZ   4992
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
04988:  MOVLW  0C
0498A:  MOVWF  01
0498C:  MOVLB  7
0498E:  BRA    4E3A
04990:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
04992:  MOVLB  7
04994:  MOVFF  70E,FE9
04998:  MOVFF  70F,FEA
0499C:  MOVFF  9C0,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
049A0:  MOVLB  9
049A2:  MOVF   xC0,W
049A4:  SUBLW  03
049A6:  BNZ   4A0C
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
049A8:  MOVLW  08
049AA:  MOVLB  7
049AC:  ADDWF  x0E,W
049AE:  MOVWF  01
049B0:  MOVLW  00
049B2:  ADDWFC x0F,W
049B4:  MOVWF  03
049B6:  MOVFF  01,9CD
049BA:  MOVLB  9
049BC:  MOVWF  xCE
049BE:  MOVLW  48
049C0:  MOVLB  7
049C2:  ADDWF  x0E,W
049C4:  MOVWF  01
049C6:  MOVLW  00
049C8:  ADDWFC x0F,W
049CA:  MOVFF  01,FE9
049CE:  MOVWF  FEA
049D0:  MOVFF  FEF,00
049D4:  MOVFF  FEC,01
049D8:  MOVFF  FEC,02
049DC:  MOVFF  FEC,03
049E0:  MOVFF  03,9D2
049E4:  MOVFF  02,9D1
049E8:  MOVFF  01,9D0
049EC:  MOVFF  00,9CF
049F0:  MOVFF  9CE,FEA
049F4:  MOVFF  9CD,FE9
049F8:  MOVFF  00,FEF
049FC:  MOVFF  01,FEC
04A00:  MOVFF  02,FEC
04A04:  MOVFF  03,FEC
04A08:  BRA    4A64
04A0A:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
04A0C:  MOVLW  08
04A0E:  MOVLB  7
04A10:  ADDWF  x0E,W
04A12:  MOVWF  01
04A14:  MOVLW  00
04A16:  ADDWFC x0F,W
04A18:  MOVWF  03
04A1A:  MOVFF  01,9CD
04A1E:  MOVLB  9
04A20:  MOVWF  xCE
04A22:  MOVLW  3A
04A24:  MOVLB  7
04A26:  ADDWF  x0E,W
04A28:  MOVWF  01
04A2A:  MOVLW  00
04A2C:  ADDWFC x0F,W
04A2E:  MOVFF  01,FE9
04A32:  MOVWF  FEA
04A34:  MOVFF  FEC,03
04A38:  MOVF   FED,F
04A3A:  MOVFF  FEF,9CF
04A3E:  MOVLB  9
04A40:  MOVFF  03,9D0
04A44:  MOVFF  9CE,FEA
04A48:  MOVFF  9CD,FE9
04A4C:  MOVF   FEE,F
04A4E:  MOVF   FEE,F
04A50:  CLRF   FEC
04A52:  MOVF   FED,F
04A54:  CLRF   FEF
04A56:  MOVF   FED,F
04A58:  MOVFF  03,FEF
04A5C:  MOVF   FED,F
04A5E:  MOVFF  9CF,FEF
04A62:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
04A64:  MOVLW  02
04A66:  ADDWF  x0E,W
04A68:  MOVWF  01
04A6A:  MOVLW  00
04A6C:  ADDWFC x0F,W
04A6E:  MOVWF  03
04A70:  MOVLW  31
04A72:  MOVLB  7
04A74:  ADDWF  x0E,W
04A76:  MOVWF  FE9
04A78:  MOVLW  00
04A7A:  ADDWFC x0F,W
04A7C:  MOVWF  FEA
04A7E:  MOVFF  FEF,9CF
04A82:  MOVLB  9
04A84:  MOVFF  03,FEA
04A88:  MOVFF  01,FE9
04A8C:  MOVFF  9CF,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
04A90:  MOVLW  03
04A92:  MOVLB  7
04A94:  ADDWF  x0E,W
04A96:  MOVWF  01
04A98:  MOVLW  00
04A9A:  ADDWFC x0F,W
04A9C:  MOVWF  03
04A9E:  MOVLW  34
04AA0:  MOVLB  7
04AA2:  ADDWF  x0E,W
04AA4:  MOVWF  FE9
04AA6:  MOVLW  00
04AA8:  ADDWFC x0F,W
04AAA:  MOVWF  FEA
04AAC:  MOVFF  FEF,9CF
04AB0:  MOVLB  9
04AB2:  MOVFF  03,FEA
04AB6:  MOVFF  01,FE9
04ABA:  MOVFF  9CF,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
04ABE:  MOVLW  10
04AC0:  MOVLB  7
04AC2:  ADDWF  x0E,W
04AC4:  MOVWF  01
04AC6:  MOVLW  00
04AC8:  ADDWFC x0F,W
04ACA:  MOVWF  03
04ACC:  MOVFF  01,9CD
04AD0:  MOVLB  9
04AD2:  MOVWF  xCE
04AD4:  MOVLW  32
04AD6:  MOVLB  7
04AD8:  ADDWF  x0E,W
04ADA:  MOVWF  01
04ADC:  MOVLW  00
04ADE:  ADDWFC x0F,W
04AE0:  MOVFF  01,FE9
04AE4:  MOVWF  FEA
04AE6:  MOVFF  FEC,03
04AEA:  MOVF   FED,F
04AEC:  MOVF   FEF,W
04AEE:  MOVLB  9
04AF0:  ADDWF  xC1,W
04AF2:  MOVWF  00
04AF4:  MOVF   03,W
04AF6:  ADDWFC xC2,W
04AF8:  MOVWF  01
04AFA:  MOVLW  00
04AFC:  ADDWFC xC3,W
04AFE:  MOVWF  02
04B00:  MOVLW  00
04B02:  ADDWFC xC4,W
04B04:  MOVFF  9CE,FEA
04B08:  MOVFF  9CD,FE9
04B0C:  MOVFF  00,FEF
04B10:  MOVFF  01,FEC
04B14:  MOVFF  02,FEC
04B18:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04B1A:  MOVLW  04
04B1C:  MOVLB  7
04B1E:  ADDWF  x0E,W
04B20:  MOVWF  01
04B22:  MOVLW  00
04B24:  ADDWFC x0F,W
04B26:  MOVWF  03
04B28:  MOVFF  01,9CD
04B2C:  MOVLB  9
04B2E:  MOVWF  xCE
04B30:  MOVLW  35
04B32:  MOVLB  7
04B34:  ADDWF  x0E,W
04B36:  MOVWF  01
04B38:  MOVLW  00
04B3A:  ADDWFC x0F,W
04B3C:  MOVFF  01,FE9
04B40:  MOVWF  FEA
04B42:  MOVFF  FEC,03
04B46:  MOVF   FED,F
04B48:  MOVFF  FEF,9CF
04B4C:  MOVLB  9
04B4E:  MOVFF  9CE,FEA
04B52:  MOVFF  9CD,FE9
04B56:  MOVFF  03,FEC
04B5A:  MOVF   FED,F
04B5C:  MOVFF  9CF,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04B60:  MOVLW  08
04B62:  MOVLB  7
04B64:  ADDWF  x0E,W
04B66:  MOVWF  FE9
04B68:  MOVLW  00
04B6A:  ADDWFC x0F,W
04B6C:  MOVWF  FEA
04B6E:  MOVFF  FEF,9E0
04B72:  MOVFF  FEC,9E1
04B76:  MOVFF  FEC,9E2
04B7A:  MOVFF  FEC,9E3
04B7E:  MOVLW  03
04B80:  ADDWF  x0E,W
04B82:  MOVWF  FE9
04B84:  MOVLW  00
04B86:  ADDWFC x0F,W
04B88:  MOVWF  FEA
04B8A:  MOVFF  FEF,9E4
04B8E:  MOVLB  9
04B90:  MOVFF  FEA,9D3
04B94:  MOVFF  FE9,9D2
04B98:  CLRF   xE7
04B9A:  CLRF   xE6
04B9C:  CLRF   xE5
04B9E:  MOVLB  0
04BA0:  RCALL  4844
04BA2:  MOVFF  9D3,FEA
04BA6:  MOVFF  9D2,FE9
04BAA:  MOVFF  03,9D0
04BAE:  MOVFF  02,9CF
04BB2:  MOVFF  01,9CE
04BB6:  MOVFF  00,9CD
04BBA:  MOVLW  10
04BBC:  MOVLB  7
04BBE:  ADDWF  x0E,W
04BC0:  MOVWF  FE9
04BC2:  MOVLW  00
04BC4:  ADDWFC x0F,W
04BC6:  MOVWF  FEA
04BC8:  MOVFF  FEF,00
04BCC:  MOVFF  FEC,01
04BD0:  MOVFF  FEC,02
04BD4:  MOVFF  FEC,03
04BD8:  MOVF   00,W
04BDA:  MOVLB  9
04BDC:  ADDWF  xCD,W
04BDE:  MOVWF  xC5
04BE0:  MOVF   01,W
04BE2:  ADDWFC xCE,W
04BE4:  MOVWF  xC6
04BE6:  MOVF   02,W
04BE8:  ADDWFC xCF,W
04BEA:  MOVWF  xC7
04BEC:  MOVF   03,W
04BEE:  ADDWFC xD0,W
04BF0:  MOVWF  xC8
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04BF2:  MOVF   xC0,W
04BF4:  SUBLW  03
04BF6:  BNZ   4C68
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04BF8:  MOVLW  14
04BFA:  MOVLB  7
04BFC:  ADDWF  x0E,W
04BFE:  MOVWF  01
04C00:  MOVLW  00
04C02:  ADDWFC x0F,W
04C04:  MOVWF  03
04C06:  MOVFF  01,9CD
04C0A:  MOVLB  9
04C0C:  MOVWF  xCE
04C0E:  MOVLW  50
04C10:  MOVLB  7
04C12:  ADDWF  x0E,W
04C14:  MOVWF  01
04C16:  MOVLW  00
04C18:  ADDWFC x0F,W
04C1A:  MOVFF  01,FE9
04C1E:  MOVWF  FEA
04C20:  MOVFF  FEF,00
04C24:  MOVFF  FEC,01
04C28:  MOVFF  FEC,02
04C2C:  MOVFF  FEC,03
04C30:  MOVFF  9CE,FEA
04C34:  MOVFF  9CD,FE9
04C38:  MOVFF  00,FEF
04C3C:  MOVFF  01,FEC
04C40:  MOVFF  02,FEC
04C44:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04C48:  MOVLW  18
04C4A:  ADDWF  x0E,W
04C4C:  MOVWF  FE9
04C4E:  MOVLW  00
04C50:  ADDWFC x0F,W
04C52:  MOVWF  FEA
04C54:  MOVFF  9C5,FEF
04C58:  MOVFF  9C6,FEC
04C5C:  MOVFF  9C7,FEC
04C60:  MOVFF  9C8,FEC
....................       }  
04C64:  BRA    4CF4
04C66:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04C68:  MOVLW  14
04C6A:  MOVLB  7
04C6C:  ADDWF  x0E,W
04C6E:  MOVWF  FE9
04C70:  MOVLW  00
04C72:  ADDWFC x0F,W
04C74:  MOVWF  FEA
04C76:  MOVFF  9C5,FEF
04C7A:  MOVFF  9C6,FEC
04C7E:  MOVFF  9C7,FEC
04C82:  MOVFF  9C8,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04C86:  MOVLW  18
04C88:  ADDWF  x0E,W
04C8A:  MOVWF  01
04C8C:  MOVLW  00
04C8E:  ADDWFC x0F,W
04C90:  MOVFF  01,9CD
04C94:  MOVLB  9
04C96:  MOVWF  xCE
04C98:  MOVLW  04
04C9A:  MOVLB  7
04C9C:  ADDWF  x0E,W
04C9E:  MOVWF  FE9
04CA0:  MOVLW  00
04CA2:  ADDWFC x0F,W
04CA4:  MOVWF  FEA
04CA6:  MOVFF  FEC,9D0
04CAA:  MOVF   FED,F
04CAC:  MOVFF  FEF,9CF
04CB0:  MOVLB  9
04CB2:  RRCF   xD0,F
04CB4:  RRCF   xCF,F
04CB6:  RRCF   xD0,F
04CB8:  RRCF   xCF,F
04CBA:  RRCF   xD0,F
04CBC:  RRCF   xCF,F
04CBE:  RRCF   xD0,F
04CC0:  RRCF   xCF,F
04CC2:  MOVLW  0F
04CC4:  ANDWF  xD0,F
04CC6:  MOVF   xCF,W
04CC8:  ADDWF  xC5,W
04CCA:  MOVWF  00
04CCC:  MOVF   xD0,W
04CCE:  ADDWFC xC6,W
04CD0:  MOVWF  01
04CD2:  MOVLW  00
04CD4:  ADDWFC xC7,W
04CD6:  MOVWF  02
04CD8:  MOVLW  00
04CDA:  ADDWFC xC8,W
04CDC:  MOVFF  9CE,FEA
04CE0:  MOVFF  9CD,FE9
04CE4:  MOVFF  00,FEF
04CE8:  MOVFF  01,FEC
04CEC:  MOVFF  02,FEC
04CF0:  MOVWF  FEC
04CF2:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04CF4:  MOVLW  44
04CF6:  ADDWF  x0E,W
04CF8:  MOVWF  01
04CFA:  MOVLW  00
04CFC:  ADDWFC x0F,W
04CFE:  MOVFF  01,FE9
04D02:  MOVWF  FEA
04D04:  MOVFF  FEF,9C9
04D08:  MOVFF  FEC,9CA
04D0C:  MOVFF  FEC,9CB
04D10:  MOVFF  FEC,9CC
....................    if (!maxsect)  
04D14:  MOVLB  9
04D16:  MOVF   xC9,F
04D18:  BNZ   4D48
04D1A:  MOVF   xCA,F
04D1C:  BNZ   4D48
04D1E:  MOVF   xCB,F
04D20:  BNZ   4D48
04D22:  MOVF   xCC,F
04D24:  BNZ   4D48
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04D26:  MOVLW  37
04D28:  MOVLB  7
04D2A:  ADDWF  x0E,W
04D2C:  MOVWF  01
04D2E:  MOVLW  00
04D30:  ADDWFC x0F,W
04D32:  MOVFF  01,FE9
04D36:  MOVWF  FEA
04D38:  MOVLB  9
04D3A:  CLRF   xCC
04D3C:  CLRF   xCB
04D3E:  MOVFF  FEC,9CA
04D42:  MOVF   FED,F
04D44:  MOVFF  FEF,9C9
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04D48:  MOVLW  0C
04D4A:  MOVLB  7
04D4C:  ADDWF  x0E,W
04D4E:  MOVWF  01
04D50:  MOVLW  00
04D52:  ADDWFC x0F,W
04D54:  MOVWF  03
04D56:  MOVFF  01,9CD
04D5A:  MOVLB  9
04D5C:  MOVWF  xCE
04D5E:  MOVLW  18
04D60:  MOVLB  7
04D62:  ADDWF  x0E,W
04D64:  MOVWF  FE9
04D66:  MOVLW  00
04D68:  ADDWFC x0F,W
04D6A:  MOVWF  FEA
04D6C:  MOVFF  FEF,00
04D70:  MOVFF  FEC,01
04D74:  MOVFF  FEC,02
04D78:  MOVFF  FEC,03
04D7C:  MOVF   00,W
04D7E:  MOVLB  9
04D80:  SUBWF  xC9,W
04D82:  MOVWF  xCF
04D84:  MOVF   01,W
04D86:  SUBWFB xCA,W
04D88:  MOVWF  xD0
04D8A:  MOVF   02,W
04D8C:  SUBWFB xCB,W
04D8E:  MOVWF  xD1
04D90:  MOVF   03,W
04D92:  SUBWFB xCC,W
04D94:  MOVWF  xD2
04D96:  MOVF   xC1,W
04D98:  ADDWF  xCF,F
04D9A:  MOVF   xC2,W
04D9C:  ADDWFC xD0,F
04D9E:  MOVF   xC3,W
04DA0:  ADDWFC xD1,F
04DA2:  MOVF   xC4,W
04DA4:  ADDWFC xD2,F
04DA6:  MOVLW  02
04DA8:  MOVLB  7
04DAA:  ADDWF  x0E,W
04DAC:  MOVWF  FE9
04DAE:  MOVLW  00
04DB0:  ADDWFC x0F,W
04DB2:  MOVWF  FEA
04DB4:  MOVFF  FEF,A35
04DB8:  MOVLB  9
04DBA:  MOVFF  FEA,9D5
04DBE:  MOVFF  FE9,9D4
04DC2:  BCF    FD8.1
04DC4:  CLRF   1B
04DC6:  BTFSC  FF2.7
04DC8:  BSF    1B.7
04DCA:  BCF    FF2.7
04DCC:  MOVFF  9D2,A34
04DD0:  MOVFF  9D1,A33
04DD4:  MOVFF  9D0,A32
04DD8:  MOVFF  9CF,A31
04DDC:  MOVLB  A
04DDE:  CLRF   x38
04DE0:  CLRF   x37
04DE2:  CLRF   x36
04DE4:  MOVLB  0
04DE6:  CALL   1042
04DEA:  BTFSC  1B.7
04DEC:  BSF    FF2.7
04DEE:  MOVFF  9D5,FEA
04DF2:  MOVFF  9D4,FE9
04DF6:  MOVFF  03,9D2
04DFA:  MOVFF  02,9D1
04DFE:  MOVFF  01,9D0
04E02:  MOVFF  00,9CF
04E06:  MOVLW  02
04E08:  MOVLB  9
04E0A:  ADDWF  00,W
04E0C:  MOVWF  00
04E0E:  MOVLW  00
04E10:  ADDWFC 01,W
04E12:  MOVWF  01
04E14:  MOVLW  00
04E16:  ADDWFC 02,W
04E18:  MOVWF  02
04E1A:  MOVLW  00
04E1C:  ADDWFC 03,W
04E1E:  MOVFF  9CE,FEA
04E22:  MOVFF  9CD,FE9
04E26:  MOVFF  00,FEF
04E2A:  MOVFF  01,FEC
04E2E:  MOVFF  02,FEC
04E32:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04E34:  MOVLW  00
04E36:  MOVWF  01
04E38:  MOVLB  7
04E3A:  MOVLB  0
04E3C:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
07190:  CALL   55F2
07194:  MOVFF  01,9AD
....................    if (result != FR_OK)  
07198:  MOVLB  9
0719A:  MOVF   xAD,F
0719C:  BZ    71A4
....................       return (result); 
0719E:  MOVFF  9AD,01
071A2:  BRA    75D4
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
071A4:  MOVF   x9E,W
071A6:  ANDLW  0A
071A8:  BZ    71C0
071AA:  MOVLB  0
071AC:  CALL   55E4
071B0:  BTFSC  01.2
071B2:  BRA    71B8
071B4:  MOVLB  9
071B6:  BRA    71C0
....................          return (FR_WRITE_PROTECTED); 
071B8:  MOVLW  0A
071BA:  MOVWF  01
071BC:  MOVLB  9
071BE:  BRA    75D4
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
071C0:  MOVLW  09
071C2:  MOVWF  xC1
071C4:  MOVLW  9F
071C6:  MOVWF  xC0
071C8:  MOVLW  09
071CA:  MOVWF  xC3
071CC:  MOVLW  B0
071CE:  MOVWF  xC2
071D0:  MOVFF  99D,9C5
071D4:  MOVFF  99C,9C4
071D8:  MOVLW  09
071DA:  MOVWF  xC7
071DC:  MOVLW  AE
071DE:  MOVWF  xC6
071E0:  MOVLB  0
071E2:  CALL   623A
071E6:  MOVFF  01,9AD
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
071EA:  MOVLB  9
071EC:  MOVF   x9E,W
071EE:  ANDLW  18
071F0:  BTFSC  FD8.2
071F2:  BRA    7416
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
071F4:  MOVF   xAD,F
071F6:  BZ    727E
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
071F8:  BSF    x9E.3
....................          if (result != FR_NO_FILE) 
071FA:  MOVF   xAD,W
071FC:  SUBLW  02
071FE:  BZ    7206
....................             return (result); 
07200:  MOVFF  9AD,01
07204:  BRA    75D4
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
07206:  MOVLW  09
07208:  MOVWF  xC1
0720A:  MOVLW  9F
0720C:  MOVWF  xC0
0720E:  MOVLB  0
07210:  BRA    6C38
07212:  MOVFF  02,9AF
07216:  MOVFF  01,9AE
....................          if (dir_ptr == NULL) 
0721A:  MOVLB  9
0721C:  MOVF   xAE,F
0721E:  BNZ   722A
07220:  MOVF   xAF,F
07222:  BNZ   722A
....................             return (FR_DENIED); 
07224:  MOVLW  05
07226:  MOVWF  01
07228:  BRA    75D4
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
0722A:  MOVFF  9AF,FEA
0722E:  MOVFF  9AE,FE9
07232:  MOVLW  09
07234:  MOVWF  FE2
07236:  MOVLW  B0
07238:  MOVWF  FE1
0723A:  MOVLW  0B
0723C:  MOVWF  01
0723E:  MOVFF  FE6,FEE
07242:  DECFSZ 01,F
07244:  BRA    723E
....................          *(dir_ptr+12) = fn[11]; 
07246:  MOVLW  0C
07248:  ADDWF  xAE,W
0724A:  MOVWF  01
0724C:  MOVLW  00
0724E:  ADDWFC xAF,W
07250:  MOVFF  01,FE9
07254:  MOVWF  FEA
07256:  MOVFF  9BB,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
0725A:  MOVLW  0D
0725C:  ADDWF  xAE,W
0725E:  MOVWF  xC0
07260:  MOVLW  00
07262:  ADDWFC xAF,W
07264:  MOVWF  xC1
07266:  MOVWF  FEA
07268:  MOVFF  9C0,FE9
0726C:  CLRF   00
0726E:  CLRF   02
07270:  MOVLW  13
07272:  MOVWF  01
07274:  MOVLB  0
07276:  CALL   357A
....................       }  
0727A:  BRA    7390
0727C:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
0727E:  MOVF   xAE,F
07280:  BNZ   7286
07282:  MOVF   xAF,F
07284:  BZ    729E
07286:  MOVLW  0B
07288:  ADDWF  xAE,W
0728A:  MOVWF  01
0728C:  MOVLW  00
0728E:  ADDWFC xAF,W
07290:  MOVWF  03
07292:  MOVFF  01,FE9
07296:  MOVWF  FEA
07298:  MOVF   FEF,W
0729A:  ANDLW  11
0729C:  BZ    72A4
....................             return (FR_DENIED); 
0729E:  MOVLW  05
072A0:  MOVWF  01
072A2:  BRA    75D4
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
072A4:  BTFSS  x9E.3
072A6:  BRA    738E
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
072A8:  MOVLW  20
072AA:  MOVLB  7
072AC:  ADDWF  x0E,W
072AE:  MOVWF  FE9
072B0:  MOVLW  00
072B2:  ADDWFC x0F,W
072B4:  MOVWF  FEA
072B6:  MOVFF  FEF,9BC
072BA:  MOVFF  FEC,9BD
072BE:  MOVFF  FEC,9BE
072C2:  MOVFF  FEC,9BF
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
072C6:  MOVLW  14
072C8:  MOVLB  9
072CA:  ADDWF  xAE,W
072CC:  MOVWF  01
072CE:  MOVLW  00
072D0:  ADDWFC xAF,W
072D2:  MOVWF  03
072D4:  MOVFF  01,FE9
072D8:  MOVWF  FEA
072DA:  MOVFF  FEC,9C8
072DE:  MOVF   FED,F
072E0:  MOVFF  FEF,9C0
072E4:  CLRF   xC2
072E6:  MOVFF  9C0,9C7
072EA:  CLRF   xC0
072EC:  CLRF   xC1
072EE:  MOVLW  1A
072F0:  ADDWF  xAE,W
072F2:  MOVWF  01
072F4:  MOVLW  00
072F6:  ADDWFC xAF,W
072F8:  MOVFF  01,FE9
072FC:  MOVWF  FEA
072FE:  MOVFF  FEC,03
07302:  MOVF   FED,F
07304:  MOVF   FEF,W
07306:  IORWF  xC0,F
07308:  MOVF   03,W
0730A:  IORWF  xC1,F
0730C:  MOVFF  9C1,9C6
07310:  MOVFF  9C0,9C5
07314:  MOVLB  0
07316:  RCALL  6F80
07318:  MOVF   01,F
0731A:  BZ    7334
0731C:  MOVFF  9BF,9FD
07320:  MOVFF  9BE,9FC
07324:  MOVFF  9BD,9FB
07328:  MOVFF  9BC,9FA
0732C:  CALL   5AC8
07330:  MOVF   01,F
07332:  BNZ   733E
....................                return (FR_RW_ERROR); 
07334:  MOVLW  07
07336:  MOVWF  01
07338:  MOVLB  9
0733A:  BRA    75D4
0733C:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
0733E:  MOVLW  14
07340:  MOVLB  9
07342:  ADDWF  xAE,W
07344:  MOVWF  01
07346:  MOVLW  00
07348:  ADDWFC xAF,W
0734A:  MOVFF  01,FE9
0734E:  MOVWF  FEA
07350:  CLRF   FEC
07352:  MOVF   FED,F
07354:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
07356:  MOVLW  1A
07358:  ADDWF  xAE,W
0735A:  MOVWF  01
0735C:  MOVLW  00
0735E:  ADDWFC xAF,W
07360:  MOVFF  01,FE9
07364:  MOVWF  FEA
07366:  CLRF   FEC
07368:  MOVF   FED,F
0736A:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
0736C:  MOVLW  1C
0736E:  ADDWF  xAE,W
07370:  MOVWF  01
07372:  MOVLW  00
07374:  ADDWFC xAF,W
07376:  MOVFF  01,FE9
0737A:  MOVWF  FEA
0737C:  MOVF   FEE,F
0737E:  MOVF   FEE,F
07380:  CLRF   FEC
07382:  MOVF   FED,F
07384:  CLRF   FEF
07386:  MOVF   FED,F
07388:  CLRF   FEF
0738A:  MOVF   FED,F
0738C:  CLRF   FEF
0738E:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
07390:  MOVLB  9
07392:  BTFSS  x9E.3
07394:  BRA    7414
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
07396:  MOVLW  0B
07398:  ADDWF  xAE,W
0739A:  MOVWF  01
0739C:  MOVLW  00
0739E:  ADDWFC xAF,W
073A0:  MOVFF  01,FE9
073A4:  MOVWF  FEA
073A6:  MOVLW  20
073A8:  MOVWF  FEF
....................          dw = get_fattime(); 
073AA:  MOVLB  0
073AC:  RCALL  7020
073AE:  MOVFF  03,9BF
073B2:  MOVFF  02,9BE
073B6:  MOVFF  01,9BD
073BA:  MOVFF  00,9BC
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
073BE:  MOVLW  0E
073C0:  MOVLB  9
073C2:  ADDWF  xAE,W
073C4:  MOVWF  01
073C6:  MOVLW  00
073C8:  ADDWFC xAF,W
073CA:  MOVFF  01,FE9
073CE:  MOVWF  FEA
073D0:  MOVFF  9BC,FEF
073D4:  MOVFF  9BD,FEC
073D8:  MOVFF  9BE,FEC
073DC:  MOVFF  9BF,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
073E0:  MOVLW  16
073E2:  ADDWF  xAE,W
073E4:  MOVWF  01
073E6:  MOVLW  00
073E8:  ADDWFC xAF,W
073EA:  MOVFF  01,FE9
073EE:  MOVWF  FEA
073F0:  MOVFF  9BC,FEF
073F4:  MOVFF  9BD,FEC
073F8:  MOVFF  9BE,FEC
073FC:  MOVFF  9BF,FEC
....................          fs->winflag = 1; 
07400:  MOVLW  06
07402:  MOVLB  7
07404:  ADDWF  x0E,W
07406:  MOVWF  FE9
07408:  MOVLW  00
0740A:  ADDWFC x0F,W
0740C:  MOVWF  FEA
0740E:  MOVLW  01
07410:  MOVWF  FEF
07412:  MOVLB  9
....................       } 
....................    } 
07414:  BRA    7464
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
07416:  MOVF   xAD,F
07418:  BZ    7420
....................          return (result);      // Trace failed  
0741A:  MOVFF  9AD,01
0741E:  BRA    75D4
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
07420:  MOVF   xAE,F
07422:  BNZ   7428
07424:  MOVF   xAF,F
07426:  BZ    743E
07428:  MOVLW  0B
0742A:  ADDWF  xAE,W
0742C:  MOVWF  01
0742E:  MOVLW  00
07430:  ADDWFC xAF,W
07432:  MOVWF  03
07434:  MOVFF  01,FE9
07438:  MOVWF  FEA
0743A:  BTFSS  FEF.4
0743C:  BRA    7444
....................          return (FR_NO_FILE); 
0743E:  MOVLW  02
07440:  MOVWF  01
07442:  BRA    75D4
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
07444:  BTFSS  x9E.1
07446:  BRA    7464
07448:  MOVLW  0B
0744A:  ADDWF  xAE,W
0744C:  MOVWF  01
0744E:  MOVLW  00
07450:  ADDWFC xAF,W
07452:  MOVWF  03
07454:  MOVFF  01,FE9
07458:  MOVWF  FEA
0745A:  BTFSS  FEF.0
0745C:  BRA    7464
....................          return (FR_DENIED); 
0745E:  MOVLW  05
07460:  MOVWF  01
07462:  BRA    75D4
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
07464:  MOVLW  1A
07466:  ADDWF  x9A,W
07468:  MOVWF  FE9
0746A:  MOVLW  00
0746C:  ADDWFC x9B,W
0746E:  MOVWF  FEA
07470:  MOVF   x9E,W
07472:  ANDLW  03
07474:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
07476:  MOVLW  14
07478:  ADDWF  x9A,W
0747A:  MOVWF  01
0747C:  MOVLW  00
0747E:  ADDWFC x9B,W
07480:  MOVWF  03
07482:  MOVFF  01,9C0
07486:  MOVWF  xC1
07488:  MOVLW  20
0748A:  MOVLB  7
0748C:  ADDWF  x0E,W
0748E:  MOVWF  FE9
07490:  MOVLW  00
07492:  ADDWFC x0F,W
07494:  MOVWF  FEA
07496:  MOVFF  FEF,00
0749A:  MOVFF  FEC,01
0749E:  MOVFF  FEC,02
074A2:  MOVFF  FEC,03
074A6:  MOVFF  9C1,FEA
074AA:  MOVFF  9C0,FE9
074AE:  MOVFF  00,FEF
074B2:  MOVFF  01,FEC
074B6:  MOVFF  02,FEC
074BA:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
074BE:  MOVLW  18
074C0:  MOVLB  9
074C2:  ADDWF  x9A,W
074C4:  MOVWF  FE9
074C6:  MOVLW  00
074C8:  ADDWFC x9B,W
074CA:  MOVWF  FEA
074CC:  MOVFF  9AF,FEC
074D0:  MOVF   FED,F
074D2:  MOVFF  9AE,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
074D6:  MOVLW  08
074D8:  ADDWF  x9A,W
074DA:  MOVWF  01
074DC:  MOVLW  00
074DE:  ADDWFC x9B,W
074E0:  MOVWF  03
074E2:  MOVFF  01,9C0
074E6:  MOVWF  xC1
074E8:  MOVLW  14
074EA:  ADDWF  xAE,W
074EC:  MOVWF  01
074EE:  MOVLW  00
074F0:  ADDWFC xAF,W
074F2:  MOVWF  03
074F4:  MOVFF  01,FE9
074F8:  MOVWF  FEA
074FA:  MOVFF  FEC,9C5
074FE:  MOVF   FED,F
07500:  MOVFF  FEF,9C2
07504:  CLRF   xC4
07506:  MOVFF  9C2,9C4
0750A:  CLRF   xC2
0750C:  CLRF   xC3
0750E:  MOVLW  1A
07510:  ADDWF  xAE,W
07512:  MOVWF  01
07514:  MOVLW  00
07516:  ADDWFC xAF,W
07518:  MOVFF  01,FE9
0751C:  MOVWF  FEA
0751E:  MOVFF  FEC,03
07522:  MOVF   FED,F
07524:  MOVF   FEF,W
07526:  IORWF  xC2,W
07528:  MOVWF  00
0752A:  MOVF   03,W
0752C:  IORWF  xC3,W
0752E:  MOVFF  9C4,02
07532:  MOVFF  9C5,03
07536:  MOVFF  9C1,FEA
0753A:  MOVFF  9C0,FE9
0753E:  MOVFF  00,FEF
07542:  MOVWF  FEC
07544:  MOVFF  9C4,FEC
07548:  MOVFF  9C5,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
0754C:  MOVLW  04
0754E:  ADDWF  x9A,W
07550:  MOVWF  01
07552:  MOVLW  00
07554:  ADDWFC x9B,W
07556:  MOVWF  03
07558:  MOVFF  01,9C0
0755C:  MOVWF  xC1
0755E:  MOVLW  1C
07560:  ADDWF  xAE,W
07562:  MOVWF  01
07564:  MOVLW  00
07566:  ADDWFC xAF,W
07568:  MOVFF  01,FE9
0756C:  MOVWF  FEA
0756E:  MOVFF  FEF,00
07572:  MOVFF  FEC,01
07576:  MOVFF  FEC,02
0757A:  MOVFF  FEC,03
0757E:  MOVFF  9C1,FEA
07582:  MOVFF  9C0,FE9
07586:  MOVFF  00,FEF
0758A:  MOVFF  01,FEC
0758E:  MOVFF  02,FEC
07592:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
07596:  MOVFF  99A,FE9
0759A:  MOVFF  99B,FEA
0759E:  MOVF   FEE,F
075A0:  MOVF   FEE,F
075A2:  CLRF   FEC
075A4:  MOVF   FED,F
075A6:  CLRF   FEF
075A8:  MOVF   FED,F
075AA:  CLRF   FEF
075AC:  MOVF   FED,F
075AE:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
075B0:  MOVLW  1B
075B2:  ADDWF  x9A,W
075B4:  MOVWF  FE9
075B6:  MOVLW  00
075B8:  ADDWFC x9B,W
075BA:  MOVWF  FEA
075BC:  MOVLW  01
075BE:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
075C0:  MOVLB  7
075C2:  ADDWF  x0E,W
075C4:  MOVWF  FE9
075C6:  MOVLW  00
075C8:  ADDWFC x0F,W
075CA:  MOVWF  FEA
075CC:  INCF   FEF,F
....................    return (FR_OK); 
075CE:  MOVLW  00
075D0:  MOVWF  01
075D2:  MOVLB  9
075D4:  MOVLB  0
075D6:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B1CC:  MOVFF  8B9,8CE
0B1D0:  MOVFF  8B8,8CD
....................       *br = 0; 
0B1D4:  MOVLB  8
0B1D6:  MOVFF  8BC,FE9
0B1DA:  MOVFF  8BD,FEA
0B1DE:  CLRF   FEC
0B1E0:  MOVF   FED,F
0B1E2:  CLRF   FEF
....................       if (!fs)  
0B1E4:  MOVLB  7
0B1E6:  MOVF   x0E,W
0B1E8:  IORWF  x0F,W
0B1EA:  BNZ   B1F2
....................          return (FR_NOT_ENABLED); 
0B1EC:  MOVLW  0B
0B1EE:  MOVWF  01
0B1F0:  BRA    B6D4
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B1F2:  MOVLB  0
0B1F4:  CALL   55E4
0B1F8:  BTFSC  01.0
0B1FA:  BRA    B20C
0B1FC:  MOVLB  7
0B1FE:  MOVFF  70E,FE9
0B202:  MOVFF  70F,FEA
0B206:  MOVF   FEF,F
0B208:  BNZ   B214
0B20A:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B20C:  MOVLW  01
0B20E:  MOVWF  01
0B210:  MOVLB  7
0B212:  BRA    B6D4
....................     
....................       if (fp->flag & FA__ERROR) 
0B214:  MOVLW  1A
0B216:  MOVLB  8
0B218:  ADDWF  xB6,W
0B21A:  MOVWF  FE9
0B21C:  MOVLW  00
0B21E:  ADDWFC xB7,W
0B220:  MOVWF  FEA
0B222:  BTFSS  FEF.7
0B224:  BRA    B230
....................          return (FR_RW_ERROR);   // Check error flag  
0B226:  MOVLW  07
0B228:  MOVWF  01
0B22A:  MOVLB  7
0B22C:  BRA    B6D4
0B22E:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B230:  MOVLW  1A
0B232:  ADDWF  xB6,W
0B234:  MOVWF  FE9
0B236:  MOVLW  00
0B238:  ADDWFC xB7,W
0B23A:  MOVWF  FEA
0B23C:  BTFSC  FEF.0
0B23E:  BRA    B24A
....................          return (FR_DENIED);      // Check access mode  
0B240:  MOVLW  05
0B242:  MOVWF  01
0B244:  MOVLB  7
0B246:  BRA    B6D4
0B248:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B24A:  MOVLW  04
0B24C:  ADDWF  xB6,W
0B24E:  MOVWF  FE9
0B250:  MOVLW  00
0B252:  ADDWFC xB7,W
0B254:  MOVWF  FEA
0B256:  MOVFF  FEF,8CF
0B25A:  MOVFF  FEC,8D0
0B25E:  MOVFF  FEC,8D1
0B262:  MOVFF  FEC,8D2
0B266:  MOVFF  8B6,FE9
0B26A:  MOVFF  8B7,FEA
0B26E:  MOVFF  FEF,00
0B272:  MOVFF  FEC,01
0B276:  MOVFF  FEC,02
0B27A:  MOVFF  FEC,03
0B27E:  MOVF   00,W
0B280:  SUBWF  xCF,W
0B282:  MOVWF  xC6
0B284:  MOVF   01,W
0B286:  SUBWFB xD0,W
0B288:  MOVWF  xC7
0B28A:  MOVF   02,W
0B28C:  SUBWFB xD1,W
0B28E:  MOVWF  xC8
0B290:  MOVF   03,W
0B292:  SUBWFB xD2,W
0B294:  MOVWF  xC9
....................       if (btr > ln) 
0B296:  MOVF   xC9,F
0B298:  BNZ   B2B4
0B29A:  MOVF   xC8,F
0B29C:  BNZ   B2B4
0B29E:  MOVF   xC7,W
0B2A0:  SUBWF  xBB,W
0B2A2:  BNC   B2B4
0B2A4:  BNZ   B2AC
0B2A6:  MOVF   xBA,W
0B2A8:  SUBWF  xC6,W
0B2AA:  BC    B2B4
....................          btr = ln;            // Truncate read count by number of bytes left  
0B2AC:  MOVFF  8C7,8BB
0B2B0:  MOVFF  8C6,8BA
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B2B4:  MOVF   xBA,W
0B2B6:  IORWF  xBB,W
0B2B8:  BTFSC  FD8.2
0B2BA:  BRA    B6B2
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B2BC:  MOVFF  8B6,FE9
0B2C0:  MOVFF  8B7,FEA
0B2C4:  MOVFF  FEF,8CF
0B2C8:  MOVFF  FEC,8D0
0B2CC:  MOVFF  FEC,8D1
0B2D0:  MOVFF  FEC,8D2
0B2D4:  MOVLW  01
0B2D6:  ANDWF  xD0,F
0B2D8:  CLRF   xD1
0B2DA:  CLRF   xD2
0B2DC:  MOVF   xCF,F
0B2DE:  BTFSS  FD8.2
0B2E0:  BRA    B55A
0B2E2:  MOVF   xD0,F
0B2E4:  BTFSS  FD8.2
0B2E6:  BRA    B55A
0B2E8:  MOVF   xD1,F
0B2EA:  BTFSS  FD8.2
0B2EC:  BRA    B55A
0B2EE:  MOVF   xD2,F
0B2F0:  BTFSS  FD8.2
0B2F2:  BRA    B55A
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B2F4:  MOVLW  1B
0B2F6:  ADDWF  xB6,W
0B2F8:  MOVWF  FE9
0B2FA:  MOVLW  00
0B2FC:  ADDWFC xB7,W
0B2FE:  MOVWF  FEA
0B300:  DECF   FEF,F
0B302:  BZ    B33A
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B304:  MOVLW  10
0B306:  ADDWF  xB6,W
0B308:  MOVWF  FE9
0B30A:  MOVLW  00
0B30C:  ADDWFC xB7,W
0B30E:  MOVWF  FEA
0B310:  MOVFF  FEF,8CF
0B314:  MOVFF  FEC,8D0
0B318:  MOVFF  FEC,8D1
0B31C:  MOVFF  FEC,8D2
0B320:  MOVLW  01
0B322:  ADDWF  xCF,W
0B324:  MOVWF  xC2
0B326:  MOVLW  00
0B328:  ADDWFC xD0,W
0B32A:  MOVWF  xC3
0B32C:  MOVLW  00
0B32E:  ADDWFC xD1,W
0B330:  MOVWF  xC4
0B332:  MOVLW  00
0B334:  ADDWFC xD2,W
0B336:  MOVWF  xC5
....................                }  
0B338:  BRA    B476
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B33A:  MOVFF  8B6,FE9
0B33E:  MOVFF  8B7,FEA
0B342:  MOVFF  FEF,8CF
0B346:  MOVFF  FEC,8D0
0B34A:  MOVFF  FEC,8D1
0B34E:  MOVFF  FEC,8D2
0B352:  MOVF   xCF,F
0B354:  BNZ   B380
0B356:  MOVF   xD0,F
0B358:  BNZ   B380
0B35A:  MOVF   xD1,F
0B35C:  BNZ   B380
0B35E:  MOVF   xD2,F
0B360:  BNZ   B380
0B362:  MOVLW  08
0B364:  ADDWF  xB6,W
0B366:  MOVWF  FE9
0B368:  MOVLW  00
0B36A:  ADDWFC xB7,W
0B36C:  MOVWF  FEA
0B36E:  MOVFF  FEF,00
0B372:  MOVFF  FEC,01
0B376:  MOVFF  FEC,02
0B37A:  MOVFF  FEC,03
0B37E:  BRA    B3A4
0B380:  MOVLW  0C
0B382:  ADDWF  xB6,W
0B384:  MOVWF  FE9
0B386:  MOVLW  00
0B388:  ADDWFC xB7,W
0B38A:  MOVWF  FEA
0B38C:  MOVFF  FEF,9E6
0B390:  MOVFF  FEC,9E7
0B394:  MOVFF  FEC,9E8
0B398:  MOVFF  FEC,9E9
0B39C:  MOVLB  0
0B39E:  CALL   5D28
0B3A2:  MOVLB  8
0B3A4:  MOVFF  03,8C1
0B3A8:  MOVFF  02,8C0
0B3AC:  MOVFF  01,8BF
0B3B0:  MOVFF  00,8BE
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B3B4:  MOVF   xC1,F
0B3B6:  BNZ   B3C6
0B3B8:  MOVF   xC0,F
0B3BA:  BNZ   B3C6
0B3BC:  MOVF   xBF,F
0B3BE:  BNZ   B3C6
0B3C0:  MOVF   xBE,W
0B3C2:  SUBLW  01
0B3C4:  BC    B404
0B3C6:  MOVLW  0C
0B3C8:  MOVLB  7
0B3CA:  ADDWF  x0E,W
0B3CC:  MOVWF  FE9
0B3CE:  MOVLW  00
0B3D0:  ADDWFC x0F,W
0B3D2:  MOVWF  FEA
0B3D4:  MOVFF  FEF,00
0B3D8:  MOVFF  FEC,01
0B3DC:  MOVFF  FEC,02
0B3E0:  MOVFF  FEC,03
0B3E4:  MOVF   03,W
0B3E6:  MOVLB  8
0B3E8:  SUBWF  xC1,W
0B3EA:  BNC   B406
0B3EC:  BNZ   B404
0B3EE:  MOVF   02,W
0B3F0:  SUBWF  xC0,W
0B3F2:  BNC   B406
0B3F4:  BNZ   B404
0B3F6:  MOVF   01,W
0B3F8:  SUBWF  xBF,W
0B3FA:  BNC   B406
0B3FC:  BNZ   B404
0B3FE:  MOVF   00,W
0B400:  SUBWF  xBE,W
0B402:  BNC   B406
....................                   goto fr_error; 
0B404:  BRA    B6BC
....................                fp->curr_clust = clust;            // Current cluster  
0B406:  MOVLW  0C
0B408:  ADDWF  xB6,W
0B40A:  MOVWF  FE9
0B40C:  MOVLW  00
0B40E:  ADDWFC xB7,W
0B410:  MOVWF  FEA
0B412:  MOVFF  8BE,FEF
0B416:  MOVFF  8BF,FEC
0B41A:  MOVFF  8C0,FEC
0B41E:  MOVFF  8C1,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B422:  MOVFF  8C1,9DC
0B426:  MOVFF  8C0,9DB
0B42A:  MOVFF  8BF,9DA
0B42E:  MOVFF  8BE,9D9
0B432:  MOVLB  0
0B434:  CALL   5654
0B438:  MOVFF  03,8C5
0B43C:  MOVFF  02,8C4
0B440:  MOVFF  01,8C3
0B444:  MOVFF  00,8C2
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B448:  MOVLW  1B
0B44A:  MOVLB  8
0B44C:  ADDWF  xB6,W
0B44E:  MOVWF  01
0B450:  MOVLW  00
0B452:  ADDWFC xB7,W
0B454:  MOVWF  03
0B456:  MOVLW  02
0B458:  MOVLB  7
0B45A:  ADDWF  x0E,W
0B45C:  MOVWF  FE9
0B45E:  MOVLW  00
0B460:  ADDWFC x0F,W
0B462:  MOVWF  FEA
0B464:  MOVFF  FEF,8D1
0B468:  MOVLB  8
0B46A:  MOVFF  03,FEA
0B46E:  MOVFF  01,FE9
0B472:  MOVFF  8D1,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B476:  MOVLW  10
0B478:  ADDWF  xB6,W
0B47A:  MOVWF  FE9
0B47C:  MOVLW  00
0B47E:  ADDWFC xB7,W
0B480:  MOVWF  FEA
0B482:  MOVFF  8C2,FEF
0B486:  MOVFF  8C3,FEC
0B48A:  MOVFF  8C4,FEC
0B48E:  MOVFF  8C5,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B492:  BCF    FD8.0
0B494:  RRCF   xBB,W
0B496:  MOVWF  xCC
....................             if (cc)  
0B498:  MOVF   xCC,F
0B49A:  BZ    B55A
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B49C:  MOVLW  1B
0B49E:  ADDWF  xB6,W
0B4A0:  MOVWF  FE9
0B4A2:  MOVLW  00
0B4A4:  ADDWFC xB7,W
0B4A6:  MOVWF  FEA
0B4A8:  MOVF   FEF,W
0B4AA:  SUBWF  xCC,W
0B4AC:  BZ    B4C0
0B4AE:  BNC   B4C0
....................                   cc = fp->sect_clust; 
0B4B0:  MOVLW  1B
0B4B2:  ADDWF  xB6,W
0B4B4:  MOVWF  FE9
0B4B6:  MOVLW  00
0B4B8:  ADDWFC xB7,W
0B4BA:  MOVWF  FEA
0B4BC:  MOVFF  FEF,8CC
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B4C0:  MOVFF  8CE,A07
0B4C4:  MOVFF  8CD,A06
0B4C8:  MOVFF  8C5,A0B
0B4CC:  MOVFF  8C4,A0A
0B4D0:  MOVFF  8C3,A09
0B4D4:  MOVFF  8C2,A08
0B4D8:  MOVFF  8CC,A0C
0B4DC:  MOVLB  0
0B4DE:  CALL   4520
0B4E2:  MOVF   01,F
0B4E4:  BZ    B4EC
....................                   goto fr_error; 
0B4E6:  MOVLB  8
0B4E8:  BRA    B6BC
0B4EA:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B4EC:  MOVLW  1B
0B4EE:  MOVLB  8
0B4F0:  ADDWF  xB6,W
0B4F2:  MOVWF  FE9
0B4F4:  MOVLW  00
0B4F6:  ADDWFC xB7,W
0B4F8:  MOVWF  FEA
0B4FA:  MOVLW  01
0B4FC:  SUBWF  xCC,W
0B4FE:  SUBWF  FEF,W
0B500:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B502:  MOVLW  10
0B504:  ADDWF  xB6,W
0B506:  MOVWF  FE9
0B508:  MOVLW  00
0B50A:  ADDWFC xB7,W
0B50C:  MOVWF  FEA
0B50E:  MOVLW  01
0B510:  SUBWF  xCC,W
0B512:  ADDWF  FEF,W
0B514:  MOVWF  00
0B516:  MOVLW  00
0B518:  ADDWFC FEC,W
0B51A:  MOVWF  01
0B51C:  MOVLW  00
0B51E:  ADDWFC FEC,W
0B520:  MOVWF  02
0B522:  MOVLW  00
0B524:  ADDWFC FEC,W
0B526:  MOVF   FED,F
0B528:  MOVF   FED,F
0B52A:  MOVF   FED,F
0B52C:  MOVFF  00,FEF
0B530:  MOVFF  01,FEC
0B534:  MOVFF  02,FEC
0B538:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B53A:  MOVLB  9
0B53C:  CLRF   xF7
0B53E:  MOVFF  8CC,9F6
0B542:  MOVLW  02
0B544:  MOVWF  xF9
0B546:  CLRF   xF8
0B548:  MOVLB  0
0B54A:  CALL   5D06
0B54E:  MOVFF  02,8CB
0B552:  MOVFF  01,8CA
....................                continue; 
0B556:  BRA    B64E
0B558:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B55A:  MOVLW  10
0B55C:  ADDWF  xB6,W
0B55E:  MOVWF  FE9
0B560:  MOVLW  00
0B562:  ADDWFC xB7,W
0B564:  MOVWF  FEA
0B566:  MOVFF  FEF,9FA
0B56A:  MOVFF  FEC,9FB
0B56E:  MOVFF  FEC,9FC
0B572:  MOVFF  FEC,9FD
0B576:  MOVLB  0
0B578:  CALL   5AC8
0B57C:  MOVF   01,F
0B57E:  BNZ   B586
....................                goto fr_error; 
0B580:  MOVLB  8
0B582:  BRA    B6BC
0B584:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B586:  MOVLB  8
0B588:  MOVFF  8B6,FE9
0B58C:  MOVFF  8B7,FEA
0B590:  MOVFF  FEF,8CF
0B594:  MOVFF  FEC,8D0
0B598:  MOVFF  FEC,8D1
0B59C:  MOVFF  FEC,8D2
0B5A0:  MOVF   xD0,W
0B5A2:  ANDLW  01
0B5A4:  MOVWF  01
0B5A6:  MOVLW  00
0B5A8:  BSF    FD8.0
0B5AA:  SUBFWB xCF,W
0B5AC:  MOVWF  xCA
0B5AE:  MOVLW  02
0B5B0:  SUBFWB 01,W
0B5B2:  MOVWF  xCB
....................          if (rcnt > btr) 
0B5B4:  MOVF   xBB,W
0B5B6:  SUBWF  xCB,W
0B5B8:  BNC   B5CA
0B5BA:  BNZ   B5C2
0B5BC:  MOVF   xCA,W
0B5BE:  SUBWF  xBA,W
0B5C0:  BC    B5CA
....................             rcnt = btr; 
0B5C2:  MOVFF  8BB,8CB
0B5C6:  MOVFF  8BA,8CA
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B5CA:  MOVFF  8B6,FE9
0B5CE:  MOVFF  8B7,FEA
0B5D2:  MOVFF  FEF,8CF
0B5D6:  MOVFF  FEC,8D0
0B5DA:  MOVFF  FEC,8D1
0B5DE:  MOVFF  FEC,8D2
0B5E2:  MOVLW  01
0B5E4:  ANDWF  xD0,F
0B5E6:  CLRF   xD1
0B5E8:  CLRF   xD2
0B5EA:  MOVLW  24
0B5EC:  ADDWF  xCF,W
0B5EE:  MOVWF  00
0B5F0:  MOVLW  00
0B5F2:  ADDWFC xD0,W
0B5F4:  MOVWF  01
0B5F6:  MOVLW  00
0B5F8:  ADDWFC xD1,W
0B5FA:  MOVWF  02
0B5FC:  MOVLW  00
0B5FE:  ADDWFC xD2,W
0B600:  MOVWF  03
0B602:  MOVFF  01,03
0B606:  MOVF   00,W
0B608:  MOVLB  7
0B60A:  ADDWF  x0E,W
0B60C:  MOVWF  01
0B60E:  MOVF   x0F,W
0B610:  ADDWFC 03,F
0B612:  MOVFF  01,8D3
0B616:  MOVLB  8
0B618:  MOVFF  03,8D4
0B61C:  MOVFF  8CE,FEA
0B620:  MOVFF  8CD,FE9
0B624:  MOVFF  03,FE2
0B628:  MOVFF  01,FE1
0B62C:  MOVFF  8CB,02
0B630:  MOVFF  8CA,01
0B634:  MOVF   01,F
0B636:  BZ    B63C
0B638:  INCF   02,F
0B63A:  BRA    B640
0B63C:  MOVF   02,F
0B63E:  BZ    B64C
0B640:  MOVFF  FE6,FEE
0B644:  DECFSZ 01,F
0B646:  BRA    B640
0B648:  DECFSZ 02,F
0B64A:  BRA    B640
0B64C:  MOVLB  0
0B64E:  MOVLB  8
0B650:  MOVF   xCA,W
0B652:  ADDWF  xCD,F
0B654:  MOVF   xCB,W
0B656:  ADDWFC xCE,F
0B658:  MOVFF  8B6,FE9
0B65C:  MOVFF  8B7,FEA
0B660:  MOVF   xCA,W
0B662:  ADDWF  FEF,W
0B664:  MOVWF  00
0B666:  MOVF   xCB,W
0B668:  ADDWFC FEC,W
0B66A:  MOVWF  01
0B66C:  MOVLW  00
0B66E:  ADDWFC FEC,W
0B670:  MOVWF  02
0B672:  MOVLW  00
0B674:  ADDWFC FEC,W
0B676:  MOVWF  03
0B678:  MOVF   FED,F
0B67A:  MOVF   FED,F
0B67C:  MOVF   FED,F
0B67E:  MOVFF  00,FEF
0B682:  MOVFF  01,FEC
0B686:  MOVFF  02,FEC
0B68A:  MOVWF  FEC
0B68C:  MOVFF  8BC,FE9
0B690:  MOVFF  8BD,FEA
0B694:  MOVF   xCA,W
0B696:  ADDWF  FEF,W
0B698:  MOVWF  01
0B69A:  MOVF   xCB,W
0B69C:  ADDWFC FEC,W
0B69E:  MOVWF  03
0B6A0:  MOVF   FED,F
0B6A2:  MOVFF  01,FEF
0B6A6:  MOVWF  FEC
0B6A8:  MOVF   xCA,W
0B6AA:  SUBWF  xBA,F
0B6AC:  MOVF   xCB,W
0B6AE:  SUBWFB xBB,F
0B6B0:  BRA    B2B4
....................          } 
....................       return (FR_OK); 
0B6B2:  MOVLW  00
0B6B4:  MOVWF  01
0B6B6:  MOVLB  7
0B6B8:  BRA    B6D4
0B6BA:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B6BC:  MOVLW  1A
0B6BE:  ADDWF  xB6,W
0B6C0:  MOVWF  FE9
0B6C2:  MOVLW  00
0B6C4:  ADDWFC xB7,W
0B6C6:  MOVWF  FEA
0B6C8:  MOVF   FEF,W
0B6CA:  IORLW  80
0B6CC:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B6CE:  MOVLW  07
0B6D0:  MOVWF  01
0B6D2:  MOVLB  7
0B6D4:  MOVLB  0
0B6D6:  GOTO   B8D2 (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
07A32:  MOVFF  99D,9AE
07A36:  MOVFF  99C,9AD
....................       *bw = 0; 
07A3A:  MOVLB  9
07A3C:  MOVFF  9A0,FE9
07A40:  MOVFF  9A1,FEA
07A44:  CLRF   FEC
07A46:  MOVF   FED,F
07A48:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
07A4A:  CLRF   xAB
07A4C:  CLRF   xAA
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
07A4E:  MOVLB  7
07A50:  MOVF   x0E,W
07A52:  IORWF  x0F,W
07A54:  BNZ   7A5C
....................          return (FR_NOT_ENABLED); 
07A56:  MOVLW  0B
07A58:  MOVWF  01
07A5A:  BRA    80F8
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
07A5C:  MOVLB  0
07A5E:  CALL   55E4
07A62:  BTFSC  01.0
07A64:  BRA    7A76
07A66:  MOVLB  7
07A68:  MOVFF  70E,FE9
07A6C:  MOVFF  70F,FEA
07A70:  MOVF   FEF,F
07A72:  BNZ   7A7E
07A74:  MOVLB  0
....................          return (FR_NOT_READY); 
07A76:  MOVLW  01
07A78:  MOVWF  01
07A7A:  MOVLB  7
07A7C:  BRA    80F8
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
07A7E:  MOVLW  1A
07A80:  MOVLB  9
07A82:  ADDWF  x9A,W
07A84:  MOVWF  FE9
07A86:  MOVLW  00
07A88:  ADDWFC x9B,W
07A8A:  MOVWF  FEA
07A8C:  BTFSS  FEF.7
07A8E:  BRA    7A9A
....................          return (FR_RW_ERROR);         // Check error flag  
07A90:  MOVLW  07
07A92:  MOVWF  01
07A94:  MOVLB  7
07A96:  BRA    80F8
07A98:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
07A9A:  MOVLW  1A
07A9C:  ADDWF  x9A,W
07A9E:  MOVWF  FE9
07AA0:  MOVLW  00
07AA2:  ADDWFC x9B,W
07AA4:  MOVWF  FEA
07AA6:  BTFSC  FEF.1
07AA8:  BRA    7AB4
....................          return (FR_DENIED);            // Check access mode  
07AAA:  MOVLW  05
07AAC:  MOVWF  01
07AAE:  MOVLB  7
07AB0:  BRA    80F8
07AB2:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
07AB4:  MOVLW  04
07AB6:  ADDWF  x9A,W
07AB8:  MOVWF  FE9
07ABA:  MOVLW  00
07ABC:  ADDWFC x9B,W
07ABE:  MOVWF  FEA
07AC0:  MOVFF  FEF,9AF
07AC4:  MOVFF  FEC,9B0
07AC8:  MOVFF  FEC,9B1
07ACC:  MOVFF  FEC,9B2
07AD0:  MOVF   x9E,W
07AD2:  ADDWF  xAF,F
07AD4:  MOVF   x9F,W
07AD6:  ADDWFC xB0,F
07AD8:  MOVLW  00
07ADA:  ADDWFC xB1,F
07ADC:  ADDWFC xB2,F
07ADE:  MOVLW  04
07AE0:  ADDWF  x9A,W
07AE2:  MOVWF  FE9
07AE4:  MOVLW  00
07AE6:  ADDWFC x9B,W
07AE8:  MOVWF  FEA
07AEA:  MOVFF  FEF,00
07AEE:  MOVFF  FEC,01
07AF2:  MOVFF  FEC,02
07AF6:  MOVFF  FEC,03
07AFA:  MOVF   xB2,W
07AFC:  SUBWF  03,W
07AFE:  BNC   7B1C
07B00:  BNZ   7B18
07B02:  MOVF   xB1,W
07B04:  SUBWF  02,W
07B06:  BNC   7B1C
07B08:  BNZ   7B18
07B0A:  MOVF   xB0,W
07B0C:  SUBWF  01,W
07B0E:  BNC   7B1C
07B10:  BNZ   7B18
07B12:  MOVF   00,W
07B14:  SUBWF  xAF,W
07B16:  BC    7B1C
....................          btw = 0;                  // File size cannot reach 4GB  
07B18:  CLRF   x9F
07B1A:  CLRF   x9E
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07B1C:  MOVF   x9E,W
07B1E:  IORWF  x9F,W
07B20:  BTFSC  FD8.2
07B22:  BRA    802C
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07B24:  MOVFF  99A,FE9
07B28:  MOVFF  99B,FEA
07B2C:  MOVFF  FEF,9AF
07B30:  MOVFF  FEC,9B0
07B34:  MOVFF  FEC,9B1
07B38:  MOVFF  FEC,9B2
07B3C:  MOVLW  01
07B3E:  ANDWF  xB0,F
07B40:  CLRF   xB1
07B42:  CLRF   xB2
07B44:  MOVF   xAF,F
07B46:  BTFSS  FD8.2
07B48:  BRA    7EC6
07B4A:  MOVF   xB0,F
07B4C:  BTFSS  FD8.2
07B4E:  BRA    7EC6
07B50:  MOVF   xB1,F
07B52:  BTFSS  FD8.2
07B54:  BRA    7EC6
07B56:  MOVF   xB2,F
07B58:  BTFSS  FD8.2
07B5A:  BRA    7EC6
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07B5C:  MOVLW  1B
07B5E:  ADDWF  x9A,W
07B60:  MOVWF  FE9
07B62:  MOVLW  00
07B64:  ADDWFC x9B,W
07B66:  MOVWF  FEA
07B68:  DECF   FEF,F
07B6A:  BZ    7BA2
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07B6C:  MOVLW  10
07B6E:  ADDWF  x9A,W
07B70:  MOVWF  FE9
07B72:  MOVLW  00
07B74:  ADDWFC x9B,W
07B76:  MOVWF  FEA
07B78:  MOVFF  FEF,9AF
07B7C:  MOVFF  FEC,9B0
07B80:  MOVFF  FEC,9B1
07B84:  MOVFF  FEC,9B2
07B88:  MOVLW  01
07B8A:  ADDWF  xAF,W
07B8C:  MOVWF  xA6
07B8E:  MOVLW  00
07B90:  ADDWFC xB0,W
07B92:  MOVWF  xA7
07B94:  MOVLW  00
07B96:  ADDWFC xB1,W
07B98:  MOVWF  xA8
07B9A:  MOVLW  00
07B9C:  ADDWFC xB2,W
07B9E:  MOVWF  xA9
....................                }  
07BA0:  BRA    7D38
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07BA2:  MOVFF  99A,FE9
07BA6:  MOVFF  99B,FEA
07BAA:  MOVFF  FEF,9AF
07BAE:  MOVFF  FEC,9B0
07BB2:  MOVFF  FEC,9B1
07BB6:  MOVFF  FEC,9B2
07BBA:  MOVF   xAF,F
07BBC:  BNZ   7C42
07BBE:  MOVF   xB0,F
07BC0:  BNZ   7C42
07BC2:  MOVF   xB1,F
07BC4:  BNZ   7C42
07BC6:  MOVF   xB2,F
07BC8:  BNZ   7C42
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07BCA:  MOVLW  08
07BCC:  ADDWF  x9A,W
07BCE:  MOVWF  FE9
07BD0:  MOVLW  00
07BD2:  ADDWFC x9B,W
07BD4:  MOVWF  FEA
07BD6:  MOVFF  FEF,9A2
07BDA:  MOVFF  FEC,9A3
07BDE:  MOVFF  FEC,9A4
07BE2:  MOVFF  FEC,9A5
....................                   if (clust == 0)            // No cluster is created  
07BE6:  MOVF   xA2,F
07BE8:  BNZ   7C40
07BEA:  MOVF   xA3,F
07BEC:  BNZ   7C40
07BEE:  MOVF   xA4,F
07BF0:  BNZ   7C40
07BF2:  MOVF   xA5,F
07BF4:  BNZ   7C40
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07BF6:  MOVLW  08
07BF8:  ADDWF  x9A,W
07BFA:  MOVWF  01
07BFC:  MOVLW  00
07BFE:  ADDWFC x9B,W
07C00:  MOVWF  03
07C02:  MOVFF  01,9AF
07C06:  MOVWF  xB0
07C08:  CLRF   xD5
07C0A:  CLRF   xD4
07C0C:  CLRF   xD3
07C0E:  CLRF   xD2
07C10:  MOVLB  0
07C12:  CALL   69A2
07C16:  MOVFF  03,9A5
07C1A:  MOVFF  02,9A4
07C1E:  MOVFF  01,9A3
07C22:  MOVFF  00,9A2
07C26:  MOVFF  9B0,FEA
07C2A:  MOVFF  9AF,FE9
07C2E:  MOVFF  9A2,FEF
07C32:  MOVFF  9A3,FEC
07C36:  MOVFF  9A4,FEC
07C3A:  MOVFF  9A5,FEC
07C3E:  MOVLB  9
....................                   } 
07C40:  BRA    7C76
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07C42:  MOVLW  0C
07C44:  ADDWF  x9A,W
07C46:  MOVWF  FE9
07C48:  MOVLW  00
07C4A:  ADDWFC x9B,W
07C4C:  MOVWF  FEA
07C4E:  MOVFF  FEF,9D2
07C52:  MOVFF  FEC,9D3
07C56:  MOVFF  FEC,9D4
07C5A:  MOVFF  FEC,9D5
07C5E:  MOVLB  0
07C60:  CALL   69A2
07C64:  MOVFF  03,9A5
07C68:  MOVFF  02,9A4
07C6C:  MOVFF  01,9A3
07C70:  MOVFF  00,9A2
07C74:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07C76:  MOVF   xA5,F
07C78:  BNZ   7C88
07C7A:  MOVF   xA4,F
07C7C:  BNZ   7C88
07C7E:  MOVF   xA3,F
07C80:  BNZ   7C88
07C82:  MOVF   xA2,W
07C84:  SUBLW  01
07C86:  BC    7CC6
07C88:  MOVLW  0C
07C8A:  MOVLB  7
07C8C:  ADDWF  x0E,W
07C8E:  MOVWF  FE9
07C90:  MOVLW  00
07C92:  ADDWFC x0F,W
07C94:  MOVWF  FEA
07C96:  MOVFF  FEF,00
07C9A:  MOVFF  FEC,01
07C9E:  MOVFF  FEC,02
07CA2:  MOVFF  FEC,03
07CA6:  MOVF   03,W
07CA8:  MOVLB  9
07CAA:  SUBWF  xA5,W
07CAC:  BNC   7CC8
07CAE:  BNZ   7CC6
07CB0:  MOVF   02,W
07CB2:  SUBWF  xA4,W
07CB4:  BNC   7CC8
07CB6:  BNZ   7CC6
07CB8:  MOVF   01,W
07CBA:  SUBWF  xA3,W
07CBC:  BNC   7CC8
07CBE:  BNZ   7CC6
07CC0:  MOVF   00,W
07CC2:  SUBWF  xA2,W
07CC4:  BNC   7CC8
....................                   break; 
07CC6:  BRA    802C
....................                fp->curr_clust = clust;            // Current cluster  
07CC8:  MOVLW  0C
07CCA:  ADDWF  x9A,W
07CCC:  MOVWF  FE9
07CCE:  MOVLW  00
07CD0:  ADDWFC x9B,W
07CD2:  MOVWF  FEA
07CD4:  MOVFF  9A2,FEF
07CD8:  MOVFF  9A3,FEC
07CDC:  MOVFF  9A4,FEC
07CE0:  MOVFF  9A5,FEC
....................                sect = clust2sect(clust);         // Current sector  
07CE4:  MOVFF  9A5,9DC
07CE8:  MOVFF  9A4,9DB
07CEC:  MOVFF  9A3,9DA
07CF0:  MOVFF  9A2,9D9
07CF4:  MOVLB  0
07CF6:  CALL   5654
07CFA:  MOVFF  03,9A9
07CFE:  MOVFF  02,9A8
07D02:  MOVFF  01,9A7
07D06:  MOVFF  00,9A6
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07D0A:  MOVLW  1B
07D0C:  MOVLB  9
07D0E:  ADDWF  x9A,W
07D10:  MOVWF  01
07D12:  MOVLW  00
07D14:  ADDWFC x9B,W
07D16:  MOVWF  03
07D18:  MOVLW  02
07D1A:  MOVLB  7
07D1C:  ADDWF  x0E,W
07D1E:  MOVWF  FE9
07D20:  MOVLW  00
07D22:  ADDWFC x0F,W
07D24:  MOVWF  FEA
07D26:  MOVFF  FEF,9B1
07D2A:  MOVLB  9
07D2C:  MOVFF  03,FEA
07D30:  MOVFF  01,FE9
07D34:  MOVFF  9B1,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07D38:  MOVLW  10
07D3A:  ADDWF  x9A,W
07D3C:  MOVWF  FE9
07D3E:  MOVLW  00
07D40:  ADDWFC x9B,W
07D42:  MOVWF  FEA
07D44:  MOVFF  9A6,FEF
07D48:  MOVFF  9A7,FEC
07D4C:  MOVFF  9A8,FEC
07D50:  MOVFF  9A9,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07D54:  BCF    FD8.0
07D56:  RRCF   x9F,W
07D58:  MOVWF  xAC
....................             if (cc)  
07D5A:  MOVF   xAC,F
07D5C:  BZ    7E16
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07D5E:  MOVLW  1B
07D60:  ADDWF  x9A,W
07D62:  MOVWF  FE9
07D64:  MOVLW  00
07D66:  ADDWFC x9B,W
07D68:  MOVWF  FEA
07D6A:  MOVF   FEF,W
07D6C:  SUBWF  xAC,W
07D6E:  BZ    7D82
07D70:  BNC   7D82
....................                   cc = fp->sect_clust; 
07D72:  MOVLW  1B
07D74:  ADDWF  x9A,W
07D76:  MOVWF  FE9
07D78:  MOVLW  00
07D7A:  ADDWFC x9B,W
07D7C:  MOVWF  FEA
07D7E:  MOVFF  FEF,9AC
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07D82:  MOVFF  9AE,A07
07D86:  MOVFF  9AD,A06
07D8A:  MOVFF  9A9,A0B
07D8E:  MOVFF  9A8,A0A
07D92:  MOVFF  9A7,A09
07D96:  MOVFF  9A6,A08
07D9A:  MOVFF  9AC,A0C
07D9E:  MOVLB  0
07DA0:  CALL   5984
07DA4:  MOVF   01,F
07DA6:  BZ    7DAA
....................                   goto fw_error; 
07DA8:  BRA    80DE
....................                fp->sect_clust -= cc - 1; 
07DAA:  MOVLW  1B
07DAC:  MOVLB  9
07DAE:  ADDWF  x9A,W
07DB0:  MOVWF  FE9
07DB2:  MOVLW  00
07DB4:  ADDWFC x9B,W
07DB6:  MOVWF  FEA
07DB8:  MOVLW  01
07DBA:  SUBWF  xAC,W
07DBC:  SUBWF  FEF,W
07DBE:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07DC0:  MOVLW  10
07DC2:  ADDWF  x9A,W
07DC4:  MOVWF  FE9
07DC6:  MOVLW  00
07DC8:  ADDWFC x9B,W
07DCA:  MOVWF  FEA
07DCC:  MOVLW  01
07DCE:  SUBWF  xAC,W
07DD0:  ADDWF  FEF,W
07DD2:  MOVWF  00
07DD4:  MOVLW  00
07DD6:  ADDWFC FEC,W
07DD8:  MOVWF  01
07DDA:  MOVLW  00
07DDC:  ADDWFC FEC,W
07DDE:  MOVWF  02
07DE0:  MOVLW  00
07DE2:  ADDWFC FEC,W
07DE4:  MOVF   FED,F
07DE6:  MOVF   FED,F
07DE8:  MOVF   FED,F
07DEA:  MOVFF  00,FEF
07DEE:  MOVFF  01,FEC
07DF2:  MOVFF  02,FEC
07DF6:  MOVWF  FEC
....................                wcnt = cc * 512; 
07DF8:  CLRF   xF7
07DFA:  MOVFF  9AC,9F6
07DFE:  MOVLW  02
07E00:  MOVWF  xF9
07E02:  CLRF   xF8
07E04:  MOVLB  0
07E06:  CALL   5D06
07E0A:  MOVFF  02,9AB
07E0E:  MOVFF  01,9AA
....................                continue; 
07E12:  BRA    7FC8
07E14:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07E16:  MOVFF  99A,FE9
07E1A:  MOVFF  99B,FEA
07E1E:  MOVFF  FEF,9AF
07E22:  MOVFF  FEC,9B0
07E26:  MOVFF  FEC,9B1
07E2A:  MOVFF  FEC,9B2
07E2E:  MOVLW  04
07E30:  ADDWF  x9A,W
07E32:  MOVWF  FE9
07E34:  MOVLW  00
07E36:  ADDWFC x9B,W
07E38:  MOVWF  FEA
07E3A:  MOVFF  FEF,00
07E3E:  MOVFF  FEC,01
07E42:  MOVFF  FEC,02
07E46:  MOVFF  FEC,03
07E4A:  MOVF   03,W
07E4C:  SUBWF  xB2,W
07E4E:  BNC   7EC6
07E50:  BNZ   7E68
07E52:  MOVF   02,W
07E54:  SUBWF  xB1,W
07E56:  BNC   7EC6
07E58:  BNZ   7E68
07E5A:  MOVF   01,W
07E5C:  SUBWF  xB0,W
07E5E:  BNC   7EC6
07E60:  BNZ   7E68
07E62:  MOVF   00,W
07E64:  SUBWF  xAF,W
07E66:  BNC   7EC6
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07E68:  CLRF   xFD
07E6A:  CLRF   xFC
07E6C:  CLRF   xFB
07E6E:  CLRF   xFA
07E70:  MOVLB  0
07E72:  CALL   5AC8
07E76:  MOVF   01,F
07E78:  BNZ   7E7C
....................                   goto fw_error; 
07E7A:  BRA    80DE
....................                fs->winsect = fp->curr_sect; 
07E7C:  MOVLW  20
07E7E:  MOVLB  7
07E80:  ADDWF  x0E,W
07E82:  MOVWF  01
07E84:  MOVLW  00
07E86:  ADDWFC x0F,W
07E88:  MOVWF  03
07E8A:  MOVFF  01,9AF
07E8E:  MOVLB  9
07E90:  MOVWF  xB0
07E92:  MOVLW  10
07E94:  ADDWF  x9A,W
07E96:  MOVWF  FE9
07E98:  MOVLW  00
07E9A:  ADDWFC x9B,W
07E9C:  MOVWF  FEA
07E9E:  MOVFF  FEF,00
07EA2:  MOVFF  FEC,01
07EA6:  MOVFF  FEC,02
07EAA:  MOVFF  FEC,03
07EAE:  MOVFF  9B0,FEA
07EB2:  MOVFF  9AF,FE9
07EB6:  MOVFF  00,FEF
07EBA:  MOVFF  01,FEC
07EBE:  MOVFF  02,FEC
07EC2:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07EC6:  MOVLW  10
07EC8:  ADDWF  x9A,W
07ECA:  MOVWF  FE9
07ECC:  MOVLW  00
07ECE:  ADDWFC x9B,W
07ED0:  MOVWF  FEA
07ED2:  MOVFF  FEF,9FA
07ED6:  MOVFF  FEC,9FB
07EDA:  MOVFF  FEC,9FC
07EDE:  MOVFF  FEC,9FD
07EE2:  MOVLB  0
07EE4:  CALL   5AC8
07EE8:  MOVF   01,F
07EEA:  BNZ   7EEE
....................             goto fw_error;               // Move sector window 
07EEC:  BRA    80DE
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07EEE:  MOVLB  9
07EF0:  MOVFF  99A,FE9
07EF4:  MOVFF  99B,FEA
07EF8:  MOVFF  FEF,9AF
07EFC:  MOVFF  FEC,9B0
07F00:  MOVFF  FEC,9B1
07F04:  MOVFF  FEC,9B2
07F08:  MOVF   xB0,W
07F0A:  ANDLW  01
07F0C:  MOVWF  01
07F0E:  MOVLW  00
07F10:  BSF    FD8.0
07F12:  SUBFWB xAF,W
07F14:  MOVWF  xAA
07F16:  MOVLW  02
07F18:  SUBFWB 01,W
07F1A:  MOVWF  xAB
....................          if (wcnt > btw) 
07F1C:  MOVF   x9F,W
07F1E:  SUBWF  xAB,W
07F20:  BNC   7F32
07F22:  BNZ   7F2A
07F24:  MOVF   xAA,W
07F26:  SUBWF  x9E,W
07F28:  BC    7F32
....................             wcnt = btw; 
07F2A:  MOVFF  99F,9AB
07F2E:  MOVFF  99E,9AA
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07F32:  MOVFF  99A,FE9
07F36:  MOVFF  99B,FEA
07F3A:  MOVFF  FEF,9AF
07F3E:  MOVFF  FEC,9B0
07F42:  MOVFF  FEC,9B1
07F46:  MOVFF  FEC,9B2
07F4A:  MOVLW  01
07F4C:  ANDWF  xB0,F
07F4E:  CLRF   xB1
07F50:  CLRF   xB2
07F52:  MOVLW  24
07F54:  ADDWF  xAF,W
07F56:  MOVWF  00
07F58:  MOVLW  00
07F5A:  ADDWFC xB0,W
07F5C:  MOVWF  01
07F5E:  MOVLW  00
07F60:  ADDWFC xB1,W
07F62:  MOVWF  02
07F64:  MOVLW  00
07F66:  ADDWFC xB2,W
07F68:  MOVWF  03
07F6A:  MOVFF  01,03
07F6E:  MOVF   00,W
07F70:  MOVLB  7
07F72:  ADDWF  x0E,W
07F74:  MOVWF  01
07F76:  MOVF   x0F,W
07F78:  ADDWFC 03,F
07F7A:  MOVFF  01,9B3
07F7E:  MOVLB  9
07F80:  MOVFF  03,9B4
07F84:  MOVFF  03,FEA
07F88:  MOVFF  01,FE9
07F8C:  MOVFF  9AE,FE2
07F90:  MOVFF  9AD,FE1
07F94:  MOVFF  9AB,02
07F98:  MOVFF  9AA,01
07F9C:  MOVF   01,F
07F9E:  BZ    7FA4
07FA0:  INCF   02,F
07FA2:  BRA    7FA8
07FA4:  MOVF   02,F
07FA6:  BZ    7FB4
07FA8:  MOVFF  FE6,FEE
07FAC:  DECFSZ 01,F
07FAE:  BRA    7FA8
07FB0:  DECFSZ 02,F
07FB2:  BRA    7FA8
....................          fs->winflag = 1; 
07FB4:  MOVLW  06
07FB6:  MOVLB  7
07FB8:  ADDWF  x0E,W
07FBA:  MOVWF  FE9
07FBC:  MOVLW  00
07FBE:  ADDWFC x0F,W
07FC0:  MOVWF  FEA
07FC2:  MOVLW  01
07FC4:  MOVWF  FEF
07FC6:  MOVLB  0
07FC8:  MOVLB  9
07FCA:  MOVF   xAA,W
07FCC:  ADDWF  xAD,F
07FCE:  MOVF   xAB,W
07FD0:  ADDWFC xAE,F
07FD2:  MOVFF  99A,FE9
07FD6:  MOVFF  99B,FEA
07FDA:  MOVF   xAA,W
07FDC:  ADDWF  FEF,W
07FDE:  MOVWF  00
07FE0:  MOVF   xAB,W
07FE2:  ADDWFC FEC,W
07FE4:  MOVWF  01
07FE6:  MOVLW  00
07FE8:  ADDWFC FEC,W
07FEA:  MOVWF  02
07FEC:  MOVLW  00
07FEE:  ADDWFC FEC,W
07FF0:  MOVWF  03
07FF2:  MOVF   FED,F
07FF4:  MOVF   FED,F
07FF6:  MOVF   FED,F
07FF8:  MOVFF  00,FEF
07FFC:  MOVFF  01,FEC
08000:  MOVFF  02,FEC
08004:  MOVWF  FEC
08006:  MOVFF  9A0,FE9
0800A:  MOVFF  9A1,FEA
0800E:  MOVF   xAA,W
08010:  ADDWF  FEF,W
08012:  MOVWF  01
08014:  MOVF   xAB,W
08016:  ADDWFC FEC,W
08018:  MOVWF  03
0801A:  MOVF   FED,F
0801C:  MOVFF  01,FEF
08020:  MOVWF  FEC
08022:  MOVF   xAA,W
08024:  SUBWF  x9E,F
08026:  MOVF   xAB,W
08028:  SUBWFB x9F,F
0802A:  BRA    7B1C
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
0802C:  MOVFF  99A,FE9
08030:  MOVFF  99B,FEA
08034:  MOVFF  FEF,9AF
08038:  MOVFF  FEC,9B0
0803C:  MOVFF  FEC,9B1
08040:  MOVFF  FEC,9B2
08044:  MOVLW  04
08046:  ADDWF  x9A,W
08048:  MOVWF  FE9
0804A:  MOVLW  00
0804C:  ADDWFC x9B,W
0804E:  MOVWF  FEA
08050:  MOVFF  FEF,00
08054:  MOVFF  FEC,01
08058:  MOVFF  FEC,02
0805C:  MOVFF  FEC,03
08060:  MOVF   03,W
08062:  SUBWF  xB2,W
08064:  BNC   80C2
08066:  BNZ   807E
08068:  MOVF   02,W
0806A:  SUBWF  xB1,W
0806C:  BNC   80C2
0806E:  BNZ   807E
08070:  MOVF   01,W
08072:  SUBWF  xB0,W
08074:  BNC   80C2
08076:  BNZ   807E
08078:  MOVF   xAF,W
0807A:  SUBWF  00,W
0807C:  BC    80C2
....................          fp->fsize = fp->fptr;      // Update file size if needed  
0807E:  MOVLW  04
08080:  ADDWF  x9A,W
08082:  MOVWF  01
08084:  MOVLW  00
08086:  ADDWFC x9B,W
08088:  MOVWF  03
0808A:  MOVFF  01,9AF
0808E:  MOVFF  03,9B0
08092:  MOVFF  99A,FE9
08096:  MOVFF  99B,FEA
0809A:  MOVFF  FEF,00
0809E:  MOVFF  FEC,01
080A2:  MOVFF  FEC,02
080A6:  MOVFF  FEC,03
080AA:  MOVFF  9B0,FEA
080AE:  MOVFF  9AF,FE9
080B2:  MOVFF  00,FEF
080B6:  MOVFF  01,FEC
080BA:  MOVFF  02,FEC
080BE:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
080C2:  MOVLW  1A
080C4:  ADDWF  x9A,W
080C6:  MOVWF  FE9
080C8:  MOVLW  00
080CA:  ADDWFC x9B,W
080CC:  MOVWF  FEA
080CE:  MOVF   FEF,W
080D0:  IORLW  20
080D2:  MOVWF  FEF
....................       return (FR_OK); 
080D4:  MOVLW  00
080D6:  MOVWF  01
080D8:  MOVLB  7
080DA:  BRA    80F8
080DC:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
080DE:  MOVLW  1A
080E0:  MOVLB  9
080E2:  ADDWF  x9A,W
080E4:  MOVWF  FE9
080E6:  MOVLW  00
080E8:  ADDWFC x9B,W
080EA:  MOVWF  FEA
080EC:  MOVF   FEF,W
080EE:  IORLW  80
080F0:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
080F2:  MOVLW  07
080F4:  MOVWF  01
080F6:  MOVLB  7
080F8:  MOVLB  0
080FA:  GOTO   849E (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
075D8:  MOVLB  7
075DA:  MOVF   x0E,W
075DC:  IORWF  x0F,W
075DE:  BNZ   75E6
....................          return (FR_NOT_ENABLED); 
075E0:  MOVLW  0B
075E2:  MOVWF  01
075E4:  BRA    793A
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
075E6:  MOVLB  0
075E8:  CALL   55E4
075EC:  BTFSC  01.0
075EE:  BRA    7600
075F0:  MOVLB  7
075F2:  MOVFF  70E,FE9
075F6:  MOVFF  70F,FEA
075FA:  MOVF   FEF,F
075FC:  BNZ   7608
075FE:  MOVLB  0
....................          return (FR_NOT_READY); 
07600:  MOVLW  01
07602:  MOVWF  01
07604:  MOVLB  7
07606:  BRA    793A
....................     
....................       if (fp->flag & FA__ERROR) 
07608:  MOVLW  1A
0760A:  MOVLB  9
0760C:  ADDWF  x9A,W
0760E:  MOVWF  FE9
07610:  MOVLW  00
07612:  ADDWFC x9B,W
07614:  MOVWF  FEA
07616:  BTFSS  FEF.7
07618:  BRA    7624
....................          return (FR_RW_ERROR); 
0761A:  MOVLW  07
0761C:  MOVWF  01
0761E:  MOVLB  7
07620:  BRA    793A
07622:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
07624:  MOVLW  04
07626:  ADDWF  x9A,W
07628:  MOVWF  FE9
0762A:  MOVLW  00
0762C:  ADDWFC x9B,W
0762E:  MOVWF  FEA
07630:  MOVFF  FEF,00
07634:  MOVFF  FEC,01
07638:  MOVFF  FEC,02
0763C:  MOVFF  FEC,03
07640:  MOVF   03,W
07642:  SUBWF  x9F,W
07644:  BNC   767A
07646:  BNZ   765E
07648:  MOVF   02,W
0764A:  SUBWF  x9E,W
0764C:  BNC   767A
0764E:  BNZ   765E
07650:  MOVF   01,W
07652:  SUBWF  x9D,W
07654:  BNC   767A
07656:  BNZ   765E
07658:  MOVF   x9C,W
0765A:  SUBWF  00,W
0765C:  BC    767A
....................          ofs = fp->fsize;               // Clip offset by file size  
0765E:  MOVLW  04
07660:  ADDWF  x9A,W
07662:  MOVWF  FE9
07664:  MOVLW  00
07666:  ADDWFC x9B,W
07668:  MOVWF  FEA
0766A:  MOVFF  FEF,99C
0766E:  MOVFF  FEC,99D
07672:  MOVFF  FEC,99E
07676:  MOVFF  FEC,99F
....................       fp->fptr = ofs;  
0767A:  MOVFF  99A,FE9
0767E:  MOVF   x9B,W
07680:  MOVWF  FEA
07682:  MOVFF  99C,FEF
07686:  MOVFF  99D,FEC
0768A:  MOVFF  99E,FEC
0768E:  MOVFF  99F,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
07692:  MOVLW  1B
07694:  ADDWF  x9A,W
07696:  MOVWF  FE9
07698:  MOVLW  00
0769A:  ADDWFC x9B,W
0769C:  MOVWF  FEA
0769E:  MOVLW  01
076A0:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
076A2:  MOVF   x9C,F
076A4:  BNZ   76B4
076A6:  MOVF   x9D,F
076A8:  BNZ   76B4
076AA:  MOVF   x9E,F
076AC:  BNZ   76B4
076AE:  MOVF   x9F,F
076B0:  BTFSC  FD8.2
076B2:  BRA    7918
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
076B4:  MOVLW  01
076B6:  SUBWF  x9C,W
076B8:  MOVLW  00
076BA:  SUBWFB x9D,W
076BC:  MOVWF  xA6
076BE:  MOVLW  00
076C0:  SUBWFB x9E,W
076C2:  MOVWF  xA7
076C4:  MOVLW  00
076C6:  SUBWFB x9F,W
076C8:  MOVWF  xA8
076CA:  BCF    FD8.0
076CC:  CLRF   x9F
076CE:  RRCF   xA8,W
076D0:  MOVWF  x9E
076D2:  RRCF   xA7,W
076D4:  MOVWF  x9D
076D6:  RRCF   xA6,W
076D8:  MOVWF  x9C
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
076DA:  MOVLW  02
076DC:  MOVLB  7
076DE:  ADDWF  x0E,W
076E0:  MOVWF  FE9
076E2:  MOVLW  00
076E4:  ADDWFC x0F,W
076E6:  MOVWF  FEA
076E8:  MOVFF  FEF,9A4
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
076EC:  MOVLW  1B
076EE:  MOVLB  9
076F0:  ADDWF  x9A,W
076F2:  MOVWF  01
076F4:  MOVLW  00
076F6:  ADDWFC x9B,W
076F8:  MOVWF  03
076FA:  MOVFF  01,9A5
076FE:  MOVWF  xA6
07700:  MOVFF  FEA,9A8
07704:  MOVFF  FE9,9A7
07708:  BSF    FD8.1
0770A:  MOVLW  09
0770C:  MOVWF  FEA
0770E:  MOVLW  A9
07710:  MOVWF  FE9
07712:  CLRF   1B
07714:  BTFSC  FF2.7
07716:  BSF    1B.7
07718:  BCF    FF2.7
0771A:  MOVFF  99F,A34
0771E:  MOVFF  99E,A33
07722:  MOVFF  99D,A32
07726:  MOVFF  99C,A31
0772A:  MOVLB  A
0772C:  CLRF   x38
0772E:  CLRF   x37
07730:  CLRF   x36
07732:  MOVFF  9A4,A35
07736:  MOVLB  0
07738:  CALL   1042
0773C:  BTFSC  1B.7
0773E:  BSF    FF2.7
07740:  MOVFF  9A9,00
07744:  MOVFF  9AA,01
07748:  MOVFF  9AB,02
0774C:  MOVFF  9AC,03
07750:  MOVFF  9A8,FEA
07754:  MOVFF  9A7,FE9
07758:  MOVF   00,W
0775A:  MOVLB  9
0775C:  SUBWF  xA4,W
0775E:  MOVWF  00
07760:  MOVLW  00
07762:  SUBFWB 01,F
07764:  SUBFWB 02,F
07766:  SUBFWB 03,F
07768:  MOVFF  9A6,FEA
0776C:  MOVFF  9A5,FE9
07770:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
07774:  BCF    FD8.1
07776:  CLRF   1B
07778:  BTFSC  FF2.7
0777A:  BSF    1B.7
0777C:  BCF    FF2.7
0777E:  MOVFF  99F,A34
07782:  MOVFF  99E,A33
07786:  MOVFF  99D,A32
0778A:  MOVFF  99C,A31
0778E:  MOVLB  A
07790:  CLRF   x38
07792:  CLRF   x37
07794:  CLRF   x36
07796:  MOVFF  9A4,A35
0779A:  MOVLB  0
0779C:  CALL   1042
077A0:  BTFSC  1B.7
077A2:  BSF    FF2.7
077A4:  MOVFF  03,99F
077A8:  MOVFF  02,99E
077AC:  MOVFF  01,99D
077B0:  MOVFF  00,99C
....................          clust = fp->org_clust;            // Seek to current cluster  
077B4:  MOVLW  08
077B6:  MOVLB  9
077B8:  ADDWF  x9A,W
077BA:  MOVWF  FE9
077BC:  MOVLW  00
077BE:  ADDWFC x9B,W
077C0:  MOVWF  FEA
077C2:  MOVFF  FEF,9A0
077C6:  MOVFF  FEC,9A1
077CA:  MOVFF  FEC,9A2
077CE:  MOVFF  FEC,9A3
....................     
....................          while (ofs--) 
077D2:  MOVFF  99F,03
077D6:  MOVFF  99E,02
077DA:  MOVFF  99D,01
077DE:  MOVFF  99C,00
077E2:  MOVLW  FF
077E4:  ADDWF  x9C,F
077E6:  BTFSS  FD8.0
077E8:  ADDWF  x9D,F
077EA:  BTFSS  FD8.0
077EC:  ADDWF  x9E,F
077EE:  BTFSS  FD8.0
077F0:  ADDWF  x9F,F
077F2:  MOVF   00,F
077F4:  BNZ   7802
077F6:  MOVF   01,F
077F8:  BNZ   7802
077FA:  MOVF   02,F
077FC:  BNZ   7802
077FE:  MOVF   03,F
07800:  BZ    782C
....................             clust = get_cluster(clust); 
07802:  MOVFF  9A3,9E9
07806:  MOVFF  9A2,9E8
0780A:  MOVFF  9A1,9E7
0780E:  MOVFF  9A0,9E6
07812:  MOVLB  0
07814:  CALL   5D28
07818:  MOVFF  03,9A3
0781C:  MOVFF  02,9A2
07820:  MOVFF  01,9A1
07824:  MOVFF  00,9A0
07828:  MOVLB  9
0782A:  BRA    77D2
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
0782C:  MOVF   xA3,F
0782E:  BNZ   783E
07830:  MOVF   xA2,F
07832:  BNZ   783E
07834:  MOVF   xA1,F
07836:  BNZ   783E
07838:  MOVF   xA0,W
0783A:  SUBLW  01
0783C:  BC    787C
0783E:  MOVLW  0C
07840:  MOVLB  7
07842:  ADDWF  x0E,W
07844:  MOVWF  FE9
07846:  MOVLW  00
07848:  ADDWFC x0F,W
0784A:  MOVWF  FEA
0784C:  MOVFF  FEF,00
07850:  MOVFF  FEC,01
07854:  MOVFF  FEC,02
07858:  MOVFF  FEC,03
0785C:  MOVF   03,W
0785E:  MOVLB  9
07860:  SUBWF  xA3,W
07862:  BNC   787E
07864:  BNZ   787C
07866:  MOVF   02,W
07868:  SUBWF  xA2,W
0786A:  BNC   787E
0786C:  BNZ   787C
0786E:  MOVF   01,W
07870:  SUBWF  xA1,W
07872:  BNC   787E
07874:  BNZ   787C
07876:  MOVF   00,W
07878:  SUBWF  xA0,W
0787A:  BNC   787E
....................             goto fk_error; 
0787C:  BRA    7922
....................     
....................          fp->curr_clust = clust; 
0787E:  MOVLW  0C
07880:  ADDWF  x9A,W
07882:  MOVWF  FE9
07884:  MOVLW  00
07886:  ADDWFC x9B,W
07888:  MOVWF  FEA
0788A:  MOVFF  9A0,FEF
0788E:  MOVFF  9A1,FEC
07892:  MOVFF  9A2,FEC
07896:  MOVFF  9A3,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
0789A:  MOVLW  10
0789C:  ADDWF  x9A,W
0789E:  MOVWF  01
078A0:  MOVLW  00
078A2:  ADDWFC x9B,W
078A4:  MOVWF  03
078A6:  MOVFF  01,9A5
078AA:  MOVWF  xA6
078AC:  MOVFF  9A3,9DC
078B0:  MOVFF  9A2,9DB
078B4:  MOVFF  9A1,9DA
078B8:  MOVFF  9A0,9D9
078BC:  MOVLB  0
078BE:  CALL   5654
078C2:  MOVFF  03,9AA
078C6:  MOVFF  02,9A9
078CA:  MOVFF  01,9A8
078CE:  MOVFF  00,9A7
078D2:  MOVLB  9
078D4:  MOVF   xA4,W
078D6:  ADDWF  xA7,F
078D8:  MOVLW  00
078DA:  ADDWFC xA8,F
078DC:  ADDWFC xA9,F
078DE:  ADDWFC xAA,F
078E0:  MOVLW  1B
078E2:  ADDWF  x9A,W
078E4:  MOVWF  FE9
078E6:  MOVLW  00
078E8:  ADDWFC x9B,W
078EA:  MOVWF  FEA
078EC:  MOVF   FEF,W
078EE:  SUBWF  xA7,W
078F0:  MOVWF  00
078F2:  MOVLW  00
078F4:  SUBWFB xA8,W
078F6:  MOVWF  01
078F8:  MOVLW  00
078FA:  SUBWFB xA9,W
078FC:  MOVWF  02
078FE:  MOVLW  00
07900:  SUBWFB xAA,W
07902:  MOVFF  9A6,FEA
07906:  MOVFF  9A5,FE9
0790A:  MOVFF  00,FEF
0790E:  MOVFF  01,FEC
07912:  MOVFF  02,FEC
07916:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
07918:  MOVLW  00
0791A:  MOVWF  01
0791C:  MOVLB  7
0791E:  BRA    793A
07920:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
07922:  MOVLW  1A
07924:  ADDWF  x9A,W
07926:  MOVWF  FE9
07928:  MOVLW  00
0792A:  ADDWFC x9B,W
0792C:  MOVWF  FEA
0792E:  MOVF   FEF,W
07930:  IORLW  80
07932:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
07934:  MOVLW  07
07936:  MOVWF  01
07938:  MOVLB  7
0793A:  MOVLB  0
0793C:  GOTO   83B6 (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
080FE:  MOVLB  7
08100:  MOVF   x0E,W
08102:  IORWF  x0F,W
08104:  BNZ   810C
....................       return (FR_NOT_ENABLED); 
08106:  MOVLW  0B
08108:  MOVWF  01
0810A:  BRA    82D8
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
0810C:  MOVLB  0
0810E:  CALL   55E4
08112:  BTFSC  01.0
08114:  BRA    8126
08116:  MOVLB  7
08118:  MOVFF  70E,FE9
0811C:  MOVFF  70F,FEA
08120:  MOVF   FEF,F
08122:  BNZ   812E
08124:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
08126:  MOVLW  09
08128:  MOVWF  01
0812A:  MOVLB  7
0812C:  BRA    82D8
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
0812E:  MOVLW  1A
08130:  MOVLB  9
08132:  ADDWF  x9D,W
08134:  MOVWF  FE9
08136:  MOVLW  00
08138:  ADDWFC x9E,W
0813A:  MOVWF  FEA
0813C:  BTFSS  FEF.5
0813E:  BRA    82B6
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
08140:  MOVLW  14
08142:  ADDWF  x9D,W
08144:  MOVWF  FE9
08146:  MOVLW  00
08148:  ADDWFC x9E,W
0814A:  MOVWF  FEA
0814C:  MOVFF  FEF,9FA
08150:  MOVFF  FEC,9FB
08154:  MOVFF  FEC,9FC
08158:  MOVFF  FEC,9FD
0815C:  MOVLB  0
0815E:  CALL   5AC8
08162:  MOVF   01,F
08164:  BNZ   8170
....................          return (FR_RW_ERROR); 
08166:  MOVLW  07
08168:  MOVWF  01
0816A:  MOVLB  7
0816C:  BRA    82D8
0816E:  MOVLB  0
....................       ptr = fp->dir_ptr; 
08170:  MOVLW  18
08172:  MOVLB  9
08174:  ADDWF  x9D,W
08176:  MOVWF  FE9
08178:  MOVLW  00
0817A:  ADDWFC x9E,W
0817C:  MOVWF  FEA
0817E:  MOVFF  FEC,9A0
08182:  MOVF   FED,F
08184:  MOVFF  FEF,99F
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
08188:  MOVLW  0B
0818A:  ADDWF  x9F,W
0818C:  MOVWF  01
0818E:  MOVLW  00
08190:  ADDWFC xA0,W
08192:  MOVFF  01,FE9
08196:  MOVWF  FEA
08198:  MOVF   FEF,W
0819A:  IORLW  20
0819C:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
0819E:  MOVLW  1C
081A0:  ADDWF  x9F,W
081A2:  MOVWF  01
081A4:  MOVLW  00
081A6:  ADDWFC xA0,W
081A8:  MOVWF  03
081AA:  MOVFF  01,9A1
081AE:  MOVWF  xA2
081B0:  MOVLW  04
081B2:  ADDWF  x9D,W
081B4:  MOVWF  FE9
081B6:  MOVLW  00
081B8:  ADDWFC x9E,W
081BA:  MOVWF  FEA
081BC:  MOVFF  FEF,00
081C0:  MOVFF  FEC,01
081C4:  MOVFF  FEC,02
081C8:  MOVFF  FEC,03
081CC:  MOVFF  9A2,FEA
081D0:  MOVFF  9A1,FE9
081D4:  MOVFF  00,FEF
081D8:  MOVFF  01,FEC
081DC:  MOVFF  02,FEC
081E0:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
081E4:  MOVLW  1A
081E6:  ADDWF  x9F,W
081E8:  MOVWF  01
081EA:  MOVLW  00
081EC:  ADDWFC xA0,W
081EE:  MOVWF  03
081F0:  MOVFF  01,9A1
081F4:  MOVWF  xA2
081F6:  MOVLW  08
081F8:  ADDWF  x9D,W
081FA:  MOVWF  FE9
081FC:  MOVLW  00
081FE:  ADDWFC x9E,W
08200:  MOVWF  FEA
08202:  MOVFF  FEF,00
08206:  MOVFF  FEC,01
0820A:  MOVFF  FEC,02
0820E:  MOVFF  FEC,03
08212:  MOVFF  9A2,FEA
08216:  MOVFF  9A1,FE9
0821A:  MOVFF  00,FEF
0821E:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
08222:  MOVLW  14
08224:  ADDWF  x9F,W
08226:  MOVWF  01
08228:  MOVLW  00
0822A:  ADDWFC xA0,W
0822C:  MOVWF  03
0822E:  MOVFF  01,9A1
08232:  MOVWF  xA2
08234:  MOVLW  08
08236:  ADDWF  x9D,W
08238:  MOVWF  FE9
0823A:  MOVLW  00
0823C:  ADDWFC x9E,W
0823E:  MOVWF  FEA
08240:  MOVFF  FEF,9A3
08244:  MOVFF  FEC,9A4
08248:  MOVFF  FEC,00
0824C:  MOVFF  FEC,01
08250:  MOVFF  9A2,FEA
08254:  MOVFF  9A1,FE9
08258:  MOVFF  00,FEF
0825C:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
08260:  MOVLW  16
08262:  ADDWF  x9F,W
08264:  MOVWF  01
08266:  MOVLW  00
08268:  ADDWFC xA0,W
0826A:  MOVWF  03
0826C:  MOVFF  01,9A1
08270:  MOVWF  xA2
08272:  MOVLB  0
08274:  CALL   7020
08278:  MOVFF  9A2,FEA
0827C:  MOVFF  9A1,FE9
08280:  MOVFF  00,FEF
08284:  MOVFF  01,FEC
08288:  MOVFF  02,FEC
0828C:  MOVFF  03,FEC
....................       fs->winflag = 1; 
08290:  MOVLW  06
08292:  MOVLB  7
08294:  ADDWF  x0E,W
08296:  MOVWF  FE9
08298:  MOVLW  00
0829A:  ADDWFC x0F,W
0829C:  MOVWF  FEA
0829E:  MOVLW  01
082A0:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
082A2:  MOVLW  1A
082A4:  MOVLB  9
082A6:  ADDWF  x9D,W
082A8:  MOVWF  FE9
082AA:  MOVLW  00
082AC:  ADDWFC x9E,W
082AE:  MOVWF  FEA
082B0:  MOVF   FEF,W
082B2:  ANDLW  DF
082B4:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
082B6:  CLRF   xFD
082B8:  CLRF   xFC
082BA:  CLRF   xFB
082BC:  CLRF   xFA
082BE:  MOVLB  0
082C0:  CALL   5AC8
082C4:  MOVF   01,F
082C6:  BNZ   82D2
....................       return (FR_RW_ERROR); 
082C8:  MOVLW  07
082CA:  MOVWF  01
082CC:  MOVLB  7
082CE:  BRA    82D8
082D0:  MOVLB  0
....................  
....................    return (FR_OK); 
082D2:  MOVLW  00
082D4:  MOVWF  01
082D6:  MOVLB  7
082D8:  MOVLB  0
082DA:  GOTO   82E8 (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
082DE:  MOVFF  99B,99E
082E2:  MOVFF  99A,99D
082E6:  BRA    80FE
082E8:  MOVFF  01,99C
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
082EC:  MOVLB  9
082EE:  MOVF   x9C,F
082F0:  BNZ   8322
....................       { 
....................       fp->flag = 0; 
082F2:  MOVLW  1A
082F4:  ADDWF  x9A,W
082F6:  MOVWF  FE9
082F8:  MOVLW  00
082FA:  ADDWFC x9B,W
082FC:  MOVWF  FEA
082FE:  CLRF   FEF
....................       if (fs->files) 
08300:  MOVLW  01
08302:  MOVLB  7
08304:  ADDWF  x0E,W
08306:  MOVWF  FE9
08308:  MOVLW  00
0830A:  ADDWFC x0F,W
0830C:  MOVWF  FEA
0830E:  MOVF   FEF,F
08310:  BZ    8320
....................          fs->files--; 
08312:  MOVLW  01
08314:  ADDWF  x0E,W
08316:  MOVWF  FE9
08318:  MOVLW  00
0831A:  ADDWFC x0F,W
0831C:  MOVWF  FEA
0831E:  DECF   FEF,F
08320:  MOVLB  9
....................       } 
....................    return (res); 
08322:  MOVFF  99C,01
08326:  MOVLB  0
08328:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0BA02:  CALL   55F2
0BA06:  MOVFF  01,875
....................    if (res != FR_OK)  
0BA0A:  MOVLB  8
0BA0C:  MOVF   x75,F
0BA0E:  BZ    BA16
....................       return (res); 
0BA10:  MOVFF  875,01
0BA14:  BRA    BCA6
....................  
....................    if (disk_status() & STA_PROTECT) 
0BA16:  MOVLB  0
0BA18:  CALL   55E4
0BA1C:  BTFSS  01.2
0BA1E:  BRA    BA2A
....................       return (FR_WRITE_PROTECTED); 
0BA20:  MOVLW  0A
0BA22:  MOVWF  01
0BA24:  MOVLB  8
0BA26:  BRA    BCA6
0BA28:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0BA2A:  MOVLW  08
0BA2C:  MOVLB  9
0BA2E:  MOVWF  xC1
0BA30:  MOVLW  82
0BA32:  MOVWF  xC0
0BA34:  MOVLW  08
0BA36:  MOVWF  xC3
0BA38:  MOVLW  90
0BA3A:  MOVWF  xC2
0BA3C:  MOVFF  874,9C5
0BA40:  MOVFF  873,9C4
0BA44:  MOVLW  08
0BA46:  MOVWF  xC7
0BA48:  MOVLW  76
0BA4A:  MOVWF  xC6
0BA4C:  MOVLB  0
0BA4E:  CALL   623A
0BA52:  MOVFF  01,875
....................  
....................    if (res != FR_OK)  
0BA56:  MOVLB  8
0BA58:  MOVF   x75,F
0BA5A:  BZ    BA62
....................       return (res);            // Trace failed  
0BA5C:  MOVFF  875,01
0BA60:  BRA    BCA6
....................  
....................    if (dir_ptr == NULL)  
0BA62:  MOVF   x76,F
0BA64:  BNZ   BA70
0BA66:  MOVF   x77,F
0BA68:  BNZ   BA70
....................       return (FR_NO_FILE);      // It is a root directory  
0BA6A:  MOVLW  02
0BA6C:  MOVWF  01
0BA6E:  BRA    BCA6
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0BA70:  MOVLW  0B
0BA72:  ADDWF  x76,W
0BA74:  MOVWF  01
0BA76:  MOVLW  00
0BA78:  ADDWFC x77,W
0BA7A:  MOVWF  03
0BA7C:  MOVFF  01,FE9
0BA80:  MOVWF  FEA
0BA82:  BTFSS  FEF.0
0BA84:  BRA    BA8C
....................       return (FR_DENIED);         // It is a R/O item  
0BA86:  MOVLW  05
0BA88:  MOVWF  01
0BA8A:  BRA    BCA6
....................  
....................    dsect = fs->winsect; 
0BA8C:  MOVLW  20
0BA8E:  MOVLB  7
0BA90:  ADDWF  x0E,W
0BA92:  MOVWF  FE9
0BA94:  MOVLW  00
0BA96:  ADDWFC x0F,W
0BA98:  MOVWF  FEA
0BA9A:  MOVFF  FEF,87E
0BA9E:  MOVFF  FEC,87F
0BAA2:  MOVFF  FEC,880
0BAA6:  MOVFF  FEC,881
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0BAAA:  MOVLW  14
0BAAC:  MOVLB  8
0BAAE:  ADDWF  x76,W
0BAB0:  MOVWF  01
0BAB2:  MOVLW  00
0BAB4:  ADDWFC x77,W
0BAB6:  MOVWF  03
0BAB8:  MOVFF  01,FE9
0BABC:  MOVWF  FEA
0BABE:  MOVFF  FEC,87D
0BAC2:  MOVF   FED,F
0BAC4:  MOVFF  FEF,89C
0BAC8:  MOVFF  89C,87C
0BACC:  CLRF   x9C
0BACE:  CLRF   x9D
0BAD0:  MOVLW  1A
0BAD2:  ADDWF  x76,W
0BAD4:  MOVWF  01
0BAD6:  MOVLW  00
0BAD8:  ADDWFC x77,W
0BADA:  MOVFF  01,FE9
0BADE:  MOVWF  FEA
0BAE0:  MOVFF  FEC,03
0BAE4:  MOVF   FED,F
0BAE6:  MOVF   FEF,W
0BAE8:  IORWF  x9C,W
0BAEA:  MOVWF  x7A
0BAEC:  MOVF   03,W
0BAEE:  IORWF  x9D,W
0BAF0:  MOVWF  x7B
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BAF2:  MOVLW  0B
0BAF4:  ADDWF  x76,W
0BAF6:  MOVWF  01
0BAF8:  MOVLW  00
0BAFA:  ADDWFC x77,W
0BAFC:  MOVWF  03
0BAFE:  MOVFF  01,FE9
0BB02:  MOVWF  FEA
0BB04:  BTFSS  FEF.4
0BB06:  BRA    BC1A
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BB08:  MOVFF  87D,889
0BB0C:  MOVFF  87C,888
0BB10:  MOVFF  87B,887
0BB14:  MOVFF  87A,886
....................       dirscan.sect = clust2sect(dclust); 
0BB18:  MOVFF  87D,9DC
0BB1C:  MOVFF  87C,9DB
0BB20:  MOVFF  87B,9DA
0BB24:  MOVFF  87A,9D9
0BB28:  MOVLB  0
0BB2A:  CALL   5654
0BB2E:  MOVFF  03,88D
0BB32:  MOVFF  02,88C
0BB36:  MOVFF  01,88B
0BB3A:  MOVFF  00,88A
....................       dirscan.index = 0; 
0BB3E:  MOVLB  8
0BB40:  CLRF   x8F
0BB42:  CLRF   x8E
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BB44:  MOVFF  88D,9FD
0BB48:  MOVFF  88C,9FC
0BB4C:  MOVFF  88B,9FB
0BB50:  MOVFF  88A,9FA
0BB54:  MOVLB  0
0BB56:  CALL   5AC8
0BB5A:  MOVF   01,F
0BB5C:  BNZ   BB68
....................             return (FR_RW_ERROR); 
0BB5E:  MOVLW  07
0BB60:  MOVWF  01
0BB62:  MOVLB  8
0BB64:  BRA    BCA6
0BB66:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BB68:  MOVLB  8
0BB6A:  MOVF   x8E,W
0BB6C:  ANDLW  0F
0BB6E:  MOVWF  x9C
0BB70:  CLRF   x9D
0BB72:  RLCF   x9C,F
0BB74:  RLCF   x9D,F
0BB76:  RLCF   x9C,F
0BB78:  RLCF   x9D,F
0BB7A:  RLCF   x9C,F
0BB7C:  RLCF   x9D,F
0BB7E:  RLCF   x9C,F
0BB80:  RLCF   x9D,F
0BB82:  RLCF   x9C,F
0BB84:  RLCF   x9D,F
0BB86:  MOVLW  E0
0BB88:  ANDWF  x9C,F
0BB8A:  MOVLW  24
0BB8C:  ADDWF  x9C,W
0BB8E:  MOVWF  01
0BB90:  MOVLW  00
0BB92:  ADDWFC x9D,W
0BB94:  MOVWF  03
0BB96:  MOVF   01,W
0BB98:  MOVLB  7
0BB9A:  ADDWF  x0E,W
0BB9C:  MOVWF  01
0BB9E:  MOVF   x0F,W
0BBA0:  ADDWFC 03,F
0BBA2:  MOVFF  01,878
0BBA6:  MOVLB  8
0BBA8:  MOVFF  03,879
....................          if (*sdir == 0) 
0BBAC:  MOVFF  879,03
0BBB0:  MOVFF  878,FE9
0BBB4:  MOVFF  879,FEA
0BBB8:  MOVF   FEF,F
0BBBA:  BNZ   BBBE
....................             break; 
0BBBC:  BRA    BC1A
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BBBE:  MOVFF  879,03
0BBC2:  MOVFF  878,FE9
0BBC6:  MOVFF  879,FEA
0BBCA:  MOVF   FEF,W
0BBCC:  SUBLW  E5
0BBCE:  BZ    BBFE
0BBD0:  MOVFF  879,03
0BBD4:  MOVFF  878,FE9
0BBD8:  MOVFF  879,FEA
0BBDC:  MOVF   FEF,W
0BBDE:  SUBLW  2E
0BBE0:  BZ    BBFE
0BBE2:  MOVLW  0B
0BBE4:  ADDWF  x78,W
0BBE6:  MOVWF  01
0BBE8:  MOVLW  00
0BBEA:  ADDWFC x79,W
0BBEC:  MOVWF  03
0BBEE:  MOVFF  01,FE9
0BBF2:  MOVWF  FEA
0BBF4:  BTFSC  FEF.3
0BBF6:  BRA    BBFE
....................             return (FR_DENIED);   // The directory is not empty  
0BBF8:  MOVLW  05
0BBFA:  MOVWF  01
0BBFC:  BRA    BCA6
....................          } while (next_dir_ptr(&dirscan)); 
0BBFE:  MOVLW  08
0BC00:  MOVLB  9
0BC02:  MOVWF  xD0
0BC04:  MOVLW  82
0BC06:  MOVWF  xCF
0BC08:  MOVLB  0
0BC0A:  CALL   6060
0BC0E:  MOVF   01,F
0BC10:  BTFSC  FD8.2
0BC12:  BRA    BC18
0BC14:  MOVLB  8
0BC16:  BRA    BB44
0BC18:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BC1A:  MOVFF  881,9FD
0BC1E:  MOVFF  880,9FC
0BC22:  MOVFF  87F,9FB
0BC26:  MOVFF  87E,9FA
0BC2A:  MOVLB  0
0BC2C:  CALL   5AC8
0BC30:  MOVF   01,F
0BC32:  BNZ   BC3E
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BC34:  MOVLW  07
0BC36:  MOVWF  01
0BC38:  MOVLB  8
0BC3A:  BRA    BCA6
0BC3C:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BC3E:  MOVLB  8
0BC40:  MOVFF  876,FE9
0BC44:  MOVFF  877,FEA
0BC48:  MOVLW  E5
0BC4A:  MOVWF  FEF
....................    fs->winflag = 1; 
0BC4C:  MOVLW  06
0BC4E:  MOVLB  7
0BC50:  ADDWF  x0E,W
0BC52:  MOVWF  FE9
0BC54:  MOVLW  00
0BC56:  ADDWFC x0F,W
0BC58:  MOVWF  FEA
0BC5A:  MOVLW  01
0BC5C:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BC5E:  MOVFF  87D,9C8
0BC62:  MOVFF  87C,9C7
0BC66:  MOVFF  87B,9C6
0BC6A:  MOVFF  87A,9C5
0BC6E:  MOVLB  0
0BC70:  CALL   6F80
0BC74:  MOVF   01,F
0BC76:  BNZ   BC82
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BC78:  MOVLW  07
0BC7A:  MOVWF  01
0BC7C:  MOVLB  8
0BC7E:  BRA    BCA6
0BC80:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BC82:  MOVLB  9
0BC84:  CLRF   xFD
0BC86:  CLRF   xFC
0BC88:  CLRF   xFB
0BC8A:  CLRF   xFA
0BC8C:  MOVLB  0
0BC8E:  CALL   5AC8
0BC92:  MOVF   01,F
0BC94:  BNZ   BCA0
....................       return (FR_RW_ERROR); 
0BC96:  MOVLW  07
0BC98:  MOVWF  01
0BC9A:  MOVLB  8
0BC9C:  BRA    BCA6
0BC9E:  MOVLB  0
....................  
....................    return (FR_OK); 
0BCA0:  MOVLW  00
0BCA2:  MOVWF  01
0BCA4:  MOVLB  8
0BCA6:  MOVLB  0
0BCA8:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
079F4:  MOVFF  99B,99D
079F8:  MOVFF  99A,99C
079FC:  MOVFF  99D,03
07A00:  MOVLB  9
07A02:  MOVFF  99C,FE9
07A06:  MOVFF  99D,FEA
07A0A:  MOVF   FEF,F
07A0C:  BZ    7A1A
07A0E:  INCF   x9C,F
07A10:  BTFSC  FD8.2
07A12:  INCF   x9D,F
07A14:  MOVLB  0
07A16:  BRA    79FC
07A18:  MOVLB  9
....................    return(sc - s); 
07A1A:  MOVF   x9A,W
07A1C:  SUBWF  x9C,W
07A1E:  MOVWF  00
07A20:  MOVF   x9B,W
07A22:  SUBWFB x9D,W
07A24:  MOVWF  03
07A26:  MOVFF  00,01
07A2A:  MOVWF  02
07A2C:  MOVLB  0
07A2E:  GOTO   846E (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
0355C:  MOVLB  4
0355E:  CLRF   xE2
03560:  MOVLW  01
03562:  MOVWF  xE1
....................    rtc.year=10; 
03564:  MOVLW  0A
03566:  MOVWF  xE0
....................    rtc.month=1; 
03568:  MOVLW  01
0356A:  MOVWF  xDF
....................    rtc.day=1; 
0356C:  MOVWF  xDE
....................    rtc.hour=0; 
0356E:  CLRF   xDD
....................    rtc.min=0; 
03570:  CLRF   xDC
....................    rtc.sec=0; 
03572:  CLRF   xDB
....................    rtc.ms100=0; 
03574:  CLRF   xDA
03576:  MOVLB  0
03578:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
07020:  MOVLB  9
07022:  CLRF   xC7
07024:  CLRF   xC6
07026:  CLRF   xC5
07028:  MOVFF  4E0,9C4
0702C:  MOVLW  14
0702E:  ADDWF  xC4,F
07030:  MOVLW  00
07032:  ADDWFC xC5,F
07034:  ADDWFC xC6,F
07036:  ADDWFC xC7,F
07038:  BCF    FD8.0
0703A:  CLRF   xC0
0703C:  CLRF   xC1
0703E:  CLRF   xC2
07040:  RLCF   xC4,W
07042:  MOVWF  xC3
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
07044:  CLRF   xC7
07046:  CLRF   xC6
07048:  CLRF   xC5
0704A:  MOVFF  4DF,9C4
0704E:  MOVLW  0F
07050:  ANDWF  xC4,F
07052:  CLRF   xC5
07054:  CLRF   xC6
07056:  CLRF   xC7
07058:  CLRF   00
0705A:  CLRF   01
0705C:  RLCF   xC4,W
0705E:  MOVWF  02
07060:  RLCF   xC5,W
07062:  MOVWF  03
07064:  RLCF   02,F
07066:  RLCF   03,F
07068:  RLCF   02,F
0706A:  RLCF   03,F
0706C:  RLCF   02,F
0706E:  RLCF   03,F
07070:  RLCF   02,F
07072:  RLCF   03,F
07074:  MOVLW  E0
07076:  ANDWF  02,F
07078:  MOVF   00,W
0707A:  IORWF  xC0,F
0707C:  MOVF   01,W
0707E:  IORWF  xC1,F
07080:  MOVF   02,W
07082:  IORWF  xC2,F
07084:  MOVF   03,W
07086:  IORWF  xC3,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
07088:  CLRF   xC7
0708A:  CLRF   xC6
0708C:  CLRF   xC5
0708E:  MOVFF  4DE,9C4
07092:  MOVLW  1F
07094:  ANDWF  xC4,F
07096:  CLRF   xC5
07098:  CLRF   xC6
0709A:  CLRF   xC7
0709C:  CLRF   00
0709E:  CLRF   01
070A0:  MOVF   00,W
070A2:  IORWF  xC0,F
070A4:  MOVF   01,W
070A6:  IORWF  xC1,F
070A8:  MOVF   xC4,W
070AA:  IORWF  xC2,F
070AC:  MOVF   xC5,W
070AE:  IORWF  xC3,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
070B0:  CLRF   xC7
070B2:  CLRF   xC6
070B4:  CLRF   xC5
070B6:  MOVFF  4DD,9C4
070BA:  MOVLW  1F
070BC:  ANDWF  xC4,F
070BE:  CLRF   xC5
070C0:  CLRF   xC6
070C2:  CLRF   xC7
070C4:  CLRF   00
070C6:  RLCF   xC4,W
070C8:  MOVWF  01
070CA:  RLCF   xC5,W
070CC:  MOVWF  02
070CE:  RLCF   xC6,W
070D0:  MOVWF  03
070D2:  RLCF   01,F
070D4:  RLCF   02,F
070D6:  RLCF   03,F
070D8:  RLCF   01,F
070DA:  RLCF   02,F
070DC:  RLCF   03,F
070DE:  MOVLW  F8
070E0:  ANDWF  01,F
070E2:  MOVF   00,W
070E4:  IORWF  xC0,F
070E6:  MOVF   01,W
070E8:  IORWF  xC1,F
070EA:  MOVF   02,W
070EC:  IORWF  xC2,F
070EE:  MOVF   03,W
070F0:  IORWF  xC3,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
070F2:  CLRF   xC7
070F4:  CLRF   xC6
070F6:  CLRF   xC5
070F8:  MOVFF  4DC,9C4
070FC:  MOVLW  3F
070FE:  ANDWF  xC4,F
07100:  CLRF   xC5
07102:  CLRF   xC6
07104:  CLRF   xC7
07106:  RLCF   xC4,W
07108:  MOVWF  00
0710A:  RLCF   xC5,W
0710C:  MOVWF  01
0710E:  RLCF   xC6,W
07110:  MOVWF  02
07112:  RLCF   xC7,W
07114:  MOVWF  03
07116:  RLCF   00,F
07118:  RLCF   01,F
0711A:  RLCF   02,F
0711C:  RLCF   03,F
0711E:  RLCF   00,F
07120:  RLCF   01,F
07122:  RLCF   02,F
07124:  RLCF   03,F
07126:  RLCF   00,F
07128:  RLCF   01,F
0712A:  RLCF   02,F
0712C:  RLCF   03,F
0712E:  RLCF   00,F
07130:  RLCF   01,F
07132:  RLCF   02,F
07134:  RLCF   03,F
07136:  MOVLW  E0
07138:  ANDWF  00,F
0713A:  MOVF   00,W
0713C:  IORWF  xC0,F
0713E:  MOVF   01,W
07140:  IORWF  xC1,F
07142:  MOVF   02,W
07144:  IORWF  xC2,F
07146:  MOVF   03,W
07148:  IORWF  xC3,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
0714A:  CLRF   xC7
0714C:  CLRF   xC6
0714E:  CLRF   xC5
07150:  MOVFF  4DB,9C4
07154:  MOVLW  3F
07156:  ANDWF  xC4,F
07158:  CLRF   xC5
0715A:  CLRF   xC6
0715C:  CLRF   xC7
0715E:  BCF    FD8.0
07160:  RRCF   xC7,W
07162:  MOVWF  03
07164:  RRCF   xC6,W
07166:  MOVWF  02
07168:  RRCF   xC5,W
0716A:  MOVWF  01
0716C:  RRCF   xC4,W
0716E:  IORWF  xC0,F
07170:  MOVF   01,W
07172:  IORWF  xC1,F
07174:  MOVF   02,W
07176:  IORWF  xC2,F
07178:  MOVF   03,W
0717A:  IORWF  xC3,F
....................    return (work); 
0717C:  MOVFF  9C0,00
07180:  MOVFF  9C1,01
07184:  MOVFF  9C2,02
07188:  MOVFF  9C3,03
0718C:  MOVLB  0
0718E:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0B888:  MOVLW  08
0B88A:  MOVLB  9
0B88C:  MOVWF  x9B
0B88E:  MOVLW  75
0B890:  MOVWF  x9A
0B892:  MOVFF  874,99D
0B896:  MOVFF  873,99C
0B89A:  MOVLW  01
0B89C:  MOVWF  x9E
0B89E:  MOVLB  0
0B8A0:  CALL   7190
0B8A4:  MOVFF  01,891
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0B8A8:  MOVLB  8
0B8AA:  MOVF   x91,F
0B8AC:  BTFSS  FD8.2
0B8AE:  BRA    B9B0
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0B8B0:  MOVLW  08
0B8B2:  MOVWF  xB7
0B8B4:  MOVLW  75
0B8B6:  MOVWF  xB6
0B8B8:  MOVLW  08
0B8BA:  MOVWF  xB9
0B8BC:  MOVLW  92
0B8BE:  MOVWF  xB8
0B8C0:  CLRF   xBB
0B8C2:  MOVLW  20
0B8C4:  MOVWF  xBA
0B8C6:  MOVLW  08
0B8C8:  MOVWF  xBD
0B8CA:  MOVLW  B4
0B8CC:  MOVWF  xBC
0B8CE:  MOVLB  0
0B8D0:  BRA    B1CC
0B8D2:  MOVFF  01,891
....................          for (i = 0; i < br; i++) 
0B8D6:  MOVLB  8
0B8D8:  CLRF   xB3
0B8DA:  CLRF   xB2
0B8DC:  MOVF   xB3,W
0B8DE:  SUBWF  xB5,W
0B8E0:  BNC   B90C
0B8E2:  BNZ   B8EA
0B8E4:  MOVF   xB4,W
0B8E6:  SUBWF  xB2,W
0B8E8:  BC    B90C
....................          { 
....................             putc(mesg[i]); 
0B8EA:  MOVLW  92
0B8EC:  ADDWF  xB2,W
0B8EE:  MOVWF  FE9
0B8F0:  MOVLW  08
0B8F2:  ADDWFC xB3,W
0B8F4:  MOVWF  FEA
0B8F6:  MOVFF  FEF,8B6
0B8FA:  MOVF   xB6,W
0B8FC:  MOVLB  0
0B8FE:  CALL   AEA6
0B902:  MOVLB  8
0B904:  INCF   xB2,F
0B906:  BTFSC  FD8.2
0B908:  INCF   xB3,F
0B90A:  BRA    B8DC
....................          } 
....................       } while ((result == FR_OK) && br); 
0B90C:  MOVF   x91,F
0B90E:  BNZ   B916
0B910:  MOVF   xB4,W
0B912:  IORWF  xB5,W
0B914:  BNZ   B8B0
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0B916:  MOVF   x91,F
0B918:  BZ    B98C
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0B91A:  MOVLW  16
0B91C:  MOVWF  FF6
0B91E:  MOVLW  0C
0B920:  MOVWF  FF7
0B922:  MOVLW  00
0B924:  MOVWF  FF8
0B926:  CLRF   1B
0B928:  BTFSC  FF2.7
0B92A:  BSF    1B.7
0B92C:  BCF    FF2.7
0B92E:  MOVLB  0
0B930:  CALL   0E3A
0B934:  BTFSC  1B.7
0B936:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0B938:  MOVFF  891,8B6
0B93C:  MOVLW  08
0B93E:  MOVLB  8
0B940:  MOVWF  xB8
0B942:  MOVLW  92
0B944:  MOVWF  xB7
0B946:  MOVLB  0
0B948:  RCALL  B6DA
....................          printf("@FS: %s\r\n",mesg); 
0B94A:  MOVLW  2C
0B94C:  MOVWF  FF6
0B94E:  MOVLW  0C
0B950:  MOVWF  FF7
0B952:  MOVLW  00
0B954:  MOVWF  FF8
0B956:  CLRF   1B
0B958:  BTFSC  FF2.7
0B95A:  BSF    1B.7
0B95C:  BCF    FF2.7
0B95E:  MOVLW  05
0B960:  MOVLB  A
0B962:  MOVWF  x25
0B964:  MOVLB  0
0B966:  CALL   1010
0B96A:  BTFSC  1B.7
0B96C:  BSF    FF2.7
0B96E:  MOVLW  08
0B970:  MOVWF  FEA
0B972:  MOVLW  92
0B974:  MOVWF  FE9
0B976:  CALL   79CE
0B97A:  MOVLW  0D
0B97C:  BTFSS  F9E.4
0B97E:  BRA    B97C
0B980:  MOVWF  FAD
0B982:  MOVLW  0A
0B984:  BTFSS  F9E.4
0B986:  BRA    B984
0B988:  MOVWF  FAD
0B98A:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0B98C:  MOVLW  08
0B98E:  MOVLB  9
0B990:  MOVWF  x9B
0B992:  MOVLW  75
0B994:  MOVWF  x9A
0B996:  MOVLB  0
0B998:  CALL   82DE
....................       printf("\r\n");       
0B99C:  MOVLW  0D
0B99E:  BTFSS  F9E.4
0B9A0:  BRA    B99E
0B9A2:  MOVWF  FAD
0B9A4:  MOVLW  0A
0B9A6:  BTFSS  F9E.4
0B9A8:  BRA    B9A6
0B9AA:  MOVWF  FAD
....................    } 
0B9AC:  BRA    BA00
0B9AE:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0B9B0:  MOVFF  891,8B6
0B9B4:  MOVLW  08
0B9B6:  MOVWF  xB8
0B9B8:  MOVLW  92
0B9BA:  MOVWF  xB7
0B9BC:  MOVLB  0
0B9BE:  RCALL  B6DA
....................       printf("@FS: %s\r\n",mesg); 
0B9C0:  MOVLW  36
0B9C2:  MOVWF  FF6
0B9C4:  MOVLW  0C
0B9C6:  MOVWF  FF7
0B9C8:  MOVLW  00
0B9CA:  MOVWF  FF8
0B9CC:  CLRF   1B
0B9CE:  BTFSC  FF2.7
0B9D0:  BSF    1B.7
0B9D2:  BCF    FF2.7
0B9D4:  MOVLW  05
0B9D6:  MOVLB  A
0B9D8:  MOVWF  x25
0B9DA:  MOVLB  0
0B9DC:  CALL   1010
0B9E0:  BTFSC  1B.7
0B9E2:  BSF    FF2.7
0B9E4:  MOVLW  08
0B9E6:  MOVWF  FEA
0B9E8:  MOVLW  92
0B9EA:  MOVWF  FE9
0B9EC:  CALL   79CE
0B9F0:  MOVLW  0D
0B9F2:  BTFSS  F9E.4
0B9F4:  BRA    B9F2
0B9F6:  MOVWF  FAD
0B9F8:  MOVLW  0A
0B9FA:  BTFSS  F9E.4
0B9FC:  BRA    B9FA
0B9FE:  MOVWF  FAD
....................    } 
0BA00:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04E3E:  MOVLW  40
04E40:  MOVWF  FF6
04E42:  MOVLW  0C
04E44:  MOVWF  FF7
04E46:  MOVLW  00
04E48:  MOVWF  FF8
04E4A:  CLRF   1B
04E4C:  BTFSC  FF2.7
04E4E:  BSF    1B.7
04E50:  BCF    FF2.7
04E52:  CALL   0E3A
04E56:  BTFSC  1B.7
04E58:  BSF    FF2.7
....................    if (status & FR_OK) 
04E5A:  ANDLW  00
04E5C:  BZ    4E7A
....................       printf("   NoError\r\n"); 
04E5E:  MOVLW  50
04E60:  MOVWF  FF6
04E62:  MOVLW  0C
04E64:  MOVWF  FF7
04E66:  MOVLW  00
04E68:  MOVWF  FF8
04E6A:  CLRF   1B
04E6C:  BTFSC  FF2.7
04E6E:  BSF    1B.7
04E70:  BCF    FF2.7
04E72:  CALL   0E3A
04E76:  BTFSC  1B.7
04E78:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04E7A:  MOVLB  8
04E7C:  BTFSS  x74.0
04E7E:  BRA    4EA0
....................       printf("   Media Not Ready\r\n"); 
04E80:  MOVLW  5E
04E82:  MOVWF  FF6
04E84:  MOVLW  0C
04E86:  MOVWF  FF7
04E88:  MOVLW  00
04E8A:  MOVWF  FF8
04E8C:  CLRF   1B
04E8E:  BTFSC  FF2.7
04E90:  BSF    1B.7
04E92:  BCF    FF2.7
04E94:  MOVLB  0
04E96:  CALL   0E3A
04E9A:  BTFSC  1B.7
04E9C:  BSF    FF2.7
04E9E:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04EA0:  BTFSS  x74.1
04EA2:  BRA    4EC4
....................       printf("   File Not Found\r\n"); 
04EA4:  MOVLW  74
04EA6:  MOVWF  FF6
04EA8:  MOVLW  0C
04EAA:  MOVWF  FF7
04EAC:  MOVLW  00
04EAE:  MOVWF  FF8
04EB0:  CLRF   1B
04EB2:  BTFSC  FF2.7
04EB4:  BSF    1B.7
04EB6:  BCF    FF2.7
04EB8:  MOVLB  0
04EBA:  CALL   0E3A
04EBE:  BTFSC  1B.7
04EC0:  BSF    FF2.7
04EC2:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04EC4:  MOVF   x74,W
04EC6:  ANDLW  03
04EC8:  BZ    4EEA
....................       printf("   Invalid Path\r\n"); 
04ECA:  MOVLW  88
04ECC:  MOVWF  FF6
04ECE:  MOVLW  0C
04ED0:  MOVWF  FF7
04ED2:  MOVLW  00
04ED4:  MOVWF  FF8
04ED6:  CLRF   1B
04ED8:  BTFSC  FF2.7
04EDA:  BSF    1B.7
04EDC:  BCF    FF2.7
04EDE:  MOVLB  0
04EE0:  CALL   0E3A
04EE4:  BTFSC  1B.7
04EE6:  BSF    FF2.7
04EE8:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04EEA:  BTFSS  x74.2
04EEC:  BRA    4F0E
....................       printf("   Invalid Name\r\n"); 
04EEE:  MOVLW  9A
04EF0:  MOVWF  FF6
04EF2:  MOVLW  0C
04EF4:  MOVWF  FF7
04EF6:  MOVLW  00
04EF8:  MOVWF  FF8
04EFA:  CLRF   1B
04EFC:  BTFSC  FF2.7
04EFE:  BSF    1B.7
04F00:  BCF    FF2.7
04F02:  MOVLB  0
04F04:  CALL   0E3A
04F08:  BTFSC  1B.7
04F0A:  BSF    FF2.7
04F0C:  MOVLB  8
....................    if (status & FR_DENIED) 
04F0E:  MOVF   x74,W
04F10:  ANDLW  05
04F12:  BZ    4F34
....................       printf("   Access Denied\r\n"); 
04F14:  MOVLW  AC
04F16:  MOVWF  FF6
04F18:  MOVLW  0C
04F1A:  MOVWF  FF7
04F1C:  MOVLW  00
04F1E:  MOVWF  FF8
04F20:  CLRF   1B
04F22:  BTFSC  FF2.7
04F24:  BSF    1B.7
04F26:  BCF    FF2.7
04F28:  MOVLB  0
04F2A:  CALL   0E3A
04F2E:  BTFSC  1B.7
04F30:  BSF    FF2.7
04F32:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04F34:  MOVF   x74,W
04F36:  ANDLW  06
04F38:  BZ    4F5A
....................       printf("   Disk Full\r\n"); 
04F3A:  MOVLW  C0
04F3C:  MOVWF  FF6
04F3E:  MOVLW  0C
04F40:  MOVWF  FF7
04F42:  MOVLW  00
04F44:  MOVWF  FF8
04F46:  CLRF   1B
04F48:  BTFSC  FF2.7
04F4A:  BSF    1B.7
04F4C:  BCF    FF2.7
04F4E:  MOVLB  0
04F50:  CALL   0E3A
04F54:  BTFSC  1B.7
04F56:  BSF    FF2.7
04F58:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04F5A:  MOVF   x74,W
04F5C:  ANDLW  07
04F5E:  BZ    4F80
....................       printf("   Read/Write Error\r\n"); 
04F60:  MOVLW  D0
04F62:  MOVWF  FF6
04F64:  MOVLW  0C
04F66:  MOVWF  FF7
04F68:  MOVLW  00
04F6A:  MOVWF  FF8
04F6C:  CLRF   1B
04F6E:  BTFSC  FF2.7
04F70:  BSF    1B.7
04F72:  BCF    FF2.7
04F74:  MOVLB  0
04F76:  CALL   0E3A
04F7A:  BTFSC  1B.7
04F7C:  BSF    FF2.7
04F7E:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04F80:  MOVF   x74,W
04F82:  ANDLW  09
04F84:  BZ    4FA6
....................       printf("   Incorrect Media Change\r\n"); 
04F86:  MOVLW  E6
04F88:  MOVWF  FF6
04F8A:  MOVLW  0C
04F8C:  MOVWF  FF7
04F8E:  MOVLW  00
04F90:  MOVWF  FF8
04F92:  CLRF   1B
04F94:  BTFSC  FF2.7
04F96:  BSF    1B.7
04F98:  BCF    FF2.7
04F9A:  MOVLB  0
04F9C:  CALL   0E3A
04FA0:  BTFSC  1B.7
04FA2:  BSF    FF2.7
04FA4:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04FA6:  MOVF   x74,W
04FA8:  ANDLW  0A
04FAA:  BZ    4FCC
....................       printf("   Write Protected\r\n"); 
04FAC:  MOVLW  02
04FAE:  MOVWF  FF6
04FB0:  MOVLW  0D
04FB2:  MOVWF  FF7
04FB4:  MOVLW  00
04FB6:  MOVWF  FF8
04FB8:  CLRF   1B
04FBA:  BTFSC  FF2.7
04FBC:  BSF    1B.7
04FBE:  BCF    FF2.7
04FC0:  MOVLB  0
04FC2:  CALL   0E3A
04FC6:  BTFSC  1B.7
04FC8:  BSF    FF2.7
04FCA:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04FCC:  MOVF   x74,W
04FCE:  ANDLW  0B
04FD0:  BZ    4FF2
....................       printf("   Not Enabled\r\n"); 
04FD2:  MOVLW  18
04FD4:  MOVWF  FF6
04FD6:  MOVLW  0D
04FD8:  MOVWF  FF7
04FDA:  MOVLW  00
04FDC:  MOVWF  FF8
04FDE:  CLRF   1B
04FE0:  BTFSC  FF2.7
04FE2:  BSF    1B.7
04FE4:  BCF    FF2.7
04FE6:  MOVLB  0
04FE8:  CALL   0E3A
04FEC:  BTFSC  1B.7
04FEE:  BSF    FF2.7
04FF0:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04FF2:  MOVF   x74,W
04FF4:  ANDLW  0C
04FF6:  BZ    5018
....................       printf("   No File System\r\n"); 
04FF8:  MOVLW  2A
04FFA:  MOVWF  FF6
04FFC:  MOVLW  0D
04FFE:  MOVWF  FF7
05000:  MOVLW  00
05002:  MOVWF  FF8
05004:  CLRF   1B
05006:  BTFSC  FF2.7
05008:  BSF    1B.7
0500A:  BCF    FF2.7
0500C:  MOVLB  0
0500E:  CALL   0E3A
05012:  BTFSC  1B.7
05014:  BSF    FF2.7
05016:  MOVLB  8
05018:  MOVLB  0
0501A:  GOTO   50A4 (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
0832A:  MOVLW  08
0832C:  MOVWF  FEA
0832E:  MOVLW  FA
08330:  MOVWF  FE9
08332:  CLRF   00
08334:  CLRF   02
08336:  MOVLW  A0
08338:  MOVWF  01
0833A:  CALL   357A
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
0833E:  MOVLW  08
08340:  MOVLB  9
08342:  MOVWF  x9B
08344:  MOVLW  D9
08346:  MOVWF  x9A
08348:  MOVFF  8D8,99D
0834C:  MOVFF  8D7,99C
08350:  MOVLW  12
08352:  MOVWF  x9E
08354:  MOVLB  0
08356:  CALL   7190
0835A:  MOVFF  01,8F5
....................    if (result) 
0835E:  MOVLB  8
08360:  MOVF   xF5,F
08362:  BZ    8386
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
08364:  MOVLW  3E
08366:  MOVWF  FF6
08368:  MOVLW  0D
0836A:  MOVWF  FF7
0836C:  MOVLW  00
0836E:  MOVWF  FF8
08370:  CLRF   1B
08372:  BTFSC  FF2.7
08374:  BSF    1B.7
08376:  BCF    FF2.7
08378:  MOVLB  0
0837A:  CALL   0E3A
0837E:  BTFSC  1B.7
08380:  BSF    FF2.7
....................    } 
08382:  BRA    8502
08384:  MOVLB  8
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
08386:  MOVF   xDD,F
08388:  BNZ   8396
0838A:  MOVF   xDE,F
0838C:  BNZ   8396
0838E:  MOVF   xDF,F
08390:  BNZ   8396
08392:  MOVF   xE0,F
08394:  BZ    83BC
....................          result = f_lseek(&fdst, fdst.fsize);  
08396:  MOVLW  08
08398:  MOVLB  9
0839A:  MOVWF  x9B
0839C:  MOVLW  D9
0839E:  MOVWF  x9A
083A0:  MOVFF  8E0,99F
083A4:  MOVFF  8DF,99E
083A8:  MOVFF  8DE,99D
083AC:  MOVFF  8DD,99C
083B0:  MOVLB  0
083B2:  GOTO   75D8
083B6:  MOVFF  01,8F5
083BA:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
083BC:  MOVLB  0
083BE:  MOVF   x62,F
083C0:  BNZ   83DE
083C2:  MOVLW  08
083C4:  MOVLB  9
083C6:  MOVWF  x9B
083C8:  MOVLW  FA
083CA:  MOVWF  x9A
083CC:  CLRF   x9D
083CE:  MOVLW  63
083D0:  MOVWF  x9C
083D2:  CLRF   x9F
083D4:  MOVLW  9F
083D6:  MOVWF  x9E
083D8:  MOVLB  0
083DA:  CALL   7940
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
083DE:  DECFSZ x62,W
083E0:  BRA    8400
083E2:  MOVLW  08
083E4:  MOVLB  9
083E6:  MOVWF  x9B
083E8:  MOVLW  FA
083EA:  MOVWF  x9A
083EC:  MOVLW  01
083EE:  MOVWF  x9D
083F0:  MOVLW  03
083F2:  MOVWF  x9C
083F4:  CLRF   x9F
083F6:  MOVLW  9F
083F8:  MOVWF  x9E
083FA:  MOVLB  0
083FC:  CALL   7940
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
08400:  MOVF   20,F
08402:  BNZ   840A
08404:  MOVF   1F,W
08406:  SUBLW  04
08408:  BC    845E
0840A:  MOVLW  5E
0840C:  MOVWF  FF6
0840E:  MOVLW  0D
08410:  MOVWF  FF7
08412:  MOVLW  00
08414:  MOVWF  FF8
08416:  CLRF   1B
08418:  BTFSC  FF2.7
0841A:  BSF    1B.7
0841C:  BCF    FF2.7
0841E:  MOVLW  0E
08420:  MOVLB  A
08422:  MOVWF  x25
08424:  MOVLB  0
08426:  CALL   1010
0842A:  BTFSC  1B.7
0842C:  BSF    FF2.7
0842E:  MOVLW  08
08430:  MOVWF  FEA
08432:  MOVLW  FA
08434:  MOVWF  FE9
08436:  CALL   79CE
0843A:  MOVLW  6E
0843C:  MOVWF  FF6
0843E:  MOVLW  0D
08440:  MOVWF  FF7
08442:  MOVLW  00
08444:  MOVWF  FF8
08446:  CLRF   1B
08448:  BTFSC  FF2.7
0844A:  BSF    1B.7
0844C:  BCF    FF2.7
0844E:  MOVLW  03
08450:  MOVLB  A
08452:  MOVWF  x25
08454:  MOVLB  0
08456:  CALL   1010
0845A:  BTFSC  1B.7
0845C:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
0845E:  MOVLW  08
08460:  MOVLB  9
08462:  MOVWF  x9B
08464:  MOVLW  FA
08466:  MOVWF  x9A
08468:  MOVLB  0
0846A:  GOTO   79F4
0846E:  MOVFF  02,8F7
08472:  MOVFF  01,8F6
....................       result = f_write(&fdst, mesg, btw, &bw); 
08476:  MOVLW  08
08478:  MOVLB  9
0847A:  MOVWF  x9B
0847C:  MOVLW  D9
0847E:  MOVWF  x9A
08480:  MOVLW  08
08482:  MOVWF  x9D
08484:  MOVLW  FA
08486:  MOVWF  x9C
08488:  MOVFF  8F7,99F
0848C:  MOVFF  8F6,99E
08490:  MOVLW  08
08492:  MOVWF  xA1
08494:  MOVLW  F8
08496:  MOVWF  xA0
08498:  MOVLB  0
0849A:  GOTO   7A32
0849E:  MOVFF  01,8F5
....................       if (result) 
084A2:  MOVLB  8
084A4:  MOVF   xF5,F
084A6:  BZ    84CA
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
084A8:  MOVLW  72
084AA:  MOVWF  FF6
084AC:  MOVLW  0D
084AE:  MOVWF  FF7
084B0:  MOVLW  00
084B2:  MOVWF  FF8
084B4:  CLRF   1B
084B6:  BTFSC  FF2.7
084B8:  BSF    1B.7
084BA:  BCF    FF2.7
084BC:  MOVLB  0
084BE:  CALL   0E3A
084C2:  BTFSC  1B.7
084C4:  BSF    FF2.7
....................       } 
084C6:  BRA    84F2
084C8:  MOVLB  8
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
084CA:  MOVF   20,F
084CC:  BNZ   84D4
084CE:  MOVF   1F,W
084D0:  SUBLW  04
084D2:  BC    84F4
084D4:  MOVLW  86
084D6:  MOVWF  FF6
084D8:  MOVLW  0D
084DA:  MOVWF  FF7
084DC:  MOVLW  00
084DE:  MOVWF  FF8
084E0:  CLRF   1B
084E2:  BTFSC  FF2.7
084E4:  BSF    1B.7
084E6:  BCF    FF2.7
084E8:  MOVLB  0
084EA:  CALL   0E3A
084EE:  BTFSC  1B.7
084F0:  BSF    FF2.7
084F2:  MOVLB  8
....................       } 
....................  
....................       f_close(&fdst); 
084F4:  MOVLW  08
084F6:  MOVLB  9
084F8:  MOVWF  x9B
084FA:  MOVLW  D9
084FC:  MOVWF  x9A
084FE:  MOVLB  0
08500:  RCALL  82DE
....................    } 
....................  
....................    return (result); 
08502:  MOVLB  8
08504:  MOVFF  8F5,01
08508:  MOVLB  0
0850A:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
176E4:  CLRF   1B
176E6:  BTFSC  FF2.7
176E8:  BSF    1B.7
176EA:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
176EC:  MOVFF  871,A27
176F0:  MOVLW  0A
176F2:  MOVLB  A
176F4:  MOVWF  x28
176F6:  MOVLB  0
176F8:  CALL   0F66
176FC:  BTFSC  1B.7
176FE:  BSF    FF2.7
17700:  MOVFF  01,872
....................    nibl=data-(nibh*10); 
17704:  MOVLB  8
17706:  MOVF   x72,W
17708:  MULLW  0A
1770A:  MOVF   FF3,W
1770C:  SUBWF  x71,W
1770E:  MOVWF  x73
....................  
....................    return((nibh<<4)|nibl); 
17710:  SWAPF  x72,W
17712:  MOVWF  00
17714:  MOVLW  F0
17716:  ANDWF  00,F
17718:  MOVF   00,W
1771A:  IORWF  x73,W
1771C:  MOVWF  01
1771E:  MOVLB  0
17720:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
03366:  MOVFF  8D8,8D9
....................    data=(i>>4)*10; 
0336A:  MOVLB  8
0336C:  SWAPF  xD9,W
0336E:  MOVWF  00
03370:  MOVLW  0F
03372:  ANDWF  00,F
03374:  MOVF   00,W
03376:  MULLW  0A
03378:  MOVFF  FF3,8D8
....................    data=data+(i<<4>>4); 
0337C:  SWAPF  xD9,W
0337E:  MOVWF  00
03380:  MOVLW  F0
03382:  ANDWF  00,F
03384:  MOVF   00,W
03386:  SWAPF  00,F
03388:  MOVLW  0F
0338A:  ANDWF  00,F
0338C:  MOVF   00,W
0338E:  ADDWF  xD8,F
....................  
....................    return data; 
03390:  MOVFF  8D8,01
03394:  MOVLB  0
03396:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
03506:  MOVLB  8
03508:  CLRF   xB5
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0350A:  BCF    FC6.5
0350C:  MOVLW  21
0350E:  MOVWF  FC6
03510:  MOVLW  40
03512:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
03514:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
03516:  MOVF   FC9,W
03518:  MOVLW  0C
0351A:  MOVWF  FC9
0351C:  RRCF   FC7,W
0351E:  BNC   351C
03520:  MOVFF  FC9,8B5
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
03524:  MOVF   FC9,W
03526:  MOVFF  8B5,FC9
0352A:  RRCF   FC7,W
0352C:  BNC   352A
0352E:  MOVFF  FC9,72C
....................    output_bit(RTC_CS, DISABLE); 
03532:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
03534:  MOVLB  7
03536:  BCF    x2C.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
03538:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
0353A:  MOVF   FC9,W
0353C:  MOVLW  8C
0353E:  MOVWF  FC9
03540:  RRCF   FC7,W
03542:  BNC   3540
03544:  MOVFF  FC9,8B5
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
03548:  MOVF   FC9,W
0354A:  MOVFF  72C,FC9
0354E:  RRCF   FC7,W
03550:  BNC   354E
03552:  MOVFF  FC9,8B5
....................    output_bit(RTC_CS, DISABLE); 
03556:  BSF    F91.0
03558:  MOVLB  0
0355A:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0DFFE:  MOVLW  1A
0E000:  MOVLB  8
0E002:  MOVWF  x81
0E004:  MOVLB  0
0E006:  CALL   2A1E
0E00A:  MOVFF  01,4B
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0E00E:  MOVF   4B,F
0E010:  BNZ   E07E
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0E012:  MOVLW  94
0E014:  MOVWF  FF6
0E016:  MOVLW  0D
0E018:  MOVWF  FF7
0E01A:  MOVLW  00
0E01C:  MOVWF  FF8
0E01E:  CLRF   1B
0E020:  BTFSC  FF2.7
0E022:  BSF    1B.7
0E024:  BCF    FF2.7
0E026:  MOVLW  05
0E028:  MOVLB  A
0E02A:  MOVWF  x25
0E02C:  MOVLB  0
0E02E:  CALL   1010
0E032:  BTFSC  1B.7
0E034:  BSF    FF2.7
0E036:  CLRF   1B
0E038:  BTFSC  FF2.7
0E03A:  BSF    1B.7
0E03C:  BCF    FF2.7
0E03E:  MOVFF  726,A25
0E042:  MOVLW  01
0E044:  MOVLB  A
0E046:  MOVWF  x26
0E048:  MOVLB  0
0E04A:  CALL   0F92
0E04E:  BTFSC  1B.7
0E050:  BSF    FF2.7
0E052:  MOVLW  2F
0E054:  BTFSS  F9E.4
0E056:  BRA    E054
0E058:  MOVWF  FAD
0E05A:  CLRF   1B
0E05C:  BTFSC  FF2.7
0E05E:  BSF    1B.7
0E060:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0E062:  MOVFF  725,A25
0E066:  MOVLW  01
0E068:  MOVLB  A
0E06A:  MOVWF  x26
0E06C:  MOVLB  0
0E06E:  CALL   0F92
0E072:  BTFSC  1B.7
0E074:  BSF    FF2.7
0E076:  MOVLW  2F
0E078:  BTFSS  F9E.4
0E07A:  BRA    E078
0E07C:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0E07E:  DECFSZ 4B,W
0E080:  BRA    E0EE
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0E082:  MOVLW  A0
0E084:  MOVWF  FF6
0E086:  MOVLW  0D
0E088:  MOVWF  FF7
0E08A:  MOVLW  00
0E08C:  MOVWF  FF8
0E08E:  CLRF   1B
0E090:  BTFSC  FF2.7
0E092:  BSF    1B.7
0E094:  BCF    FF2.7
0E096:  MOVLW  05
0E098:  MOVLB  A
0E09A:  MOVWF  x25
0E09C:  MOVLB  0
0E09E:  CALL   1010
0E0A2:  BTFSC  1B.7
0E0A4:  BSF    FF2.7
0E0A6:  CLRF   1B
0E0A8:  BTFSC  FF2.7
0E0AA:  BSF    1B.7
0E0AC:  BCF    FF2.7
0E0AE:  MOVFF  725,A25
0E0B2:  MOVLW  01
0E0B4:  MOVLB  A
0E0B6:  MOVWF  x26
0E0B8:  MOVLB  0
0E0BA:  CALL   0F92
0E0BE:  BTFSC  1B.7
0E0C0:  BSF    FF2.7
0E0C2:  MOVLW  2F
0E0C4:  BTFSS  F9E.4
0E0C6:  BRA    E0C4
0E0C8:  MOVWF  FAD
0E0CA:  CLRF   1B
0E0CC:  BTFSC  FF2.7
0E0CE:  BSF    1B.7
0E0D0:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0E0D2:  MOVFF  726,A25
0E0D6:  MOVLW  01
0E0D8:  MOVLB  A
0E0DA:  MOVWF  x26
0E0DC:  MOVLB  0
0E0DE:  CALL   0F92
0E0E2:  BTFSC  1B.7
0E0E4:  BSF    FF2.7
0E0E6:  MOVLW  2F
0E0E8:  BTFSS  F9E.4
0E0EA:  BRA    E0E8
0E0EC:  MOVWF  FAD
0E0EE:  CLRF   1B
0E0F0:  BTFSC  FF2.7
0E0F2:  BSF    1B.7
0E0F4:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0E0F6:  MOVFF  727,A25
0E0FA:  MOVLW  01
0E0FC:  MOVLB  A
0E0FE:  MOVWF  x26
0E100:  MOVLB  0
0E102:  CALL   0F92
0E106:  BTFSC  1B.7
0E108:  BSF    FF2.7
0E10A:  MOVLW  20
0E10C:  BTFSS  F9E.4
0E10E:  BRA    E10C
0E110:  MOVWF  FAD
0E112:  CLRF   1B
0E114:  BTFSC  FF2.7
0E116:  BSF    1B.7
0E118:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E11A:  MOVFF  723,A25
0E11E:  MOVLW  01
0E120:  MOVLB  A
0E122:  MOVWF  x26
0E124:  MOVLB  0
0E126:  CALL   0F92
0E12A:  BTFSC  1B.7
0E12C:  BSF    FF2.7
0E12E:  MOVLW  3A
0E130:  BTFSS  F9E.4
0E132:  BRA    E130
0E134:  MOVWF  FAD
0E136:  CLRF   1B
0E138:  BTFSC  FF2.7
0E13A:  BSF    1B.7
0E13C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E13E:  MOVFF  722,A25
0E142:  MOVLW  01
0E144:  MOVLB  A
0E146:  MOVWF  x26
0E148:  MOVLB  0
0E14A:  CALL   0F92
0E14E:  BTFSC  1B.7
0E150:  BSF    FF2.7
0E152:  MOVLW  3A
0E154:  BTFSS  F9E.4
0E156:  BRA    E154
0E158:  MOVWF  FAD
0E15A:  CLRF   1B
0E15C:  BTFSC  FF2.7
0E15E:  BSF    1B.7
0E160:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E162:  MOVFF  721,A25
0E166:  MOVLW  01
0E168:  MOVLB  A
0E16A:  MOVWF  x26
0E16C:  MOVLB  0
0E16E:  CALL   0F92
0E172:  BTFSC  1B.7
0E174:  BSF    FF2.7
0E176:  MOVLW  0A
0E178:  BTFSS  F9E.4
0E17A:  BRA    E178
0E17C:  MOVWF  FAD
0E17E:  MOVLW  0D
0E180:  BTFSS  F9E.4
0E182:  BRA    E180
0E184:  MOVWF  FAD
0E186:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
03398:  MOVLB  8
0339A:  CLRF   xD7
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0339C:  BCF    FC6.5
0339E:  MOVLW  21
033A0:  MOVWF  FC6
033A2:  MOVLW  40
033A4:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
033A6:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
033A8:  MOVF   FC9,W
033AA:  CLRF   FC9
033AC:  RRCF   FC7,W
033AE:  BNC   33AC
033B0:  MOVFF  FC9,8D7
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
033B4:  MOVF   FC9,W
033B6:  MOVFF  8D7,FC9
033BA:  RRCF   FC7,W
033BC:  BNC   33BA
033BE:  MOVFF  FC9,728
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
033C2:  MOVF   FC9,W
033C4:  MOVFF  8D7,FC9
033C8:  RRCF   FC7,W
033CA:  BNC   33C8
033CC:  MOVFF  FC9,721
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
033D0:  MOVF   FC9,W
033D2:  MOVFF  8D7,FC9
033D6:  RRCF   FC7,W
033D8:  BNC   33D6
033DA:  MOVFF  FC9,722
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
033DE:  MOVF   FC9,W
033E0:  MOVFF  8D7,FC9
033E4:  RRCF   FC7,W
033E6:  BNC   33E4
033E8:  MOVFF  FC9,723
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
033EC:  MOVF   FC9,W
033EE:  MOVFF  8D7,FC9
033F2:  RRCF   FC7,W
033F4:  BNC   33F2
033F6:  MOVFF  FC9,724
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
033FA:  MOVF   FC9,W
033FC:  MOVFF  8D7,FC9
03400:  RRCF   FC7,W
03402:  BNC   3400
03404:  MOVFF  FC9,725
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
03408:  MOVF   FC9,W
0340A:  MOVFF  8D7,FC9
0340E:  RRCF   FC7,W
03410:  BNC   340E
03412:  MOVFF  FC9,726
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
03416:  MOVF   FC9,W
03418:  MOVFF  8D7,FC9
0341C:  RRCF   FC7,W
0341E:  BNC   341C
03420:  MOVFF  FC9,727
....................    output_bit(RTC_CS, DISABLE); 
03424:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
03426:  MOVFF  721,8D8
0342A:  MOVLB  0
0342C:  RCALL  3366
0342E:  MOVFF  01,721
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
03432:  MOVFF  722,8D8
03436:  RCALL  3366
03438:  MOVFF  01,722
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
0343C:  MOVFF  723,8D8
03440:  RCALL  3366
03442:  MOVFF  01,723
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
03446:  MOVFF  725,8D8
0344A:  RCALL  3366
0344C:  MOVFF  01,725
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
03450:  MOVFF  726,8D8
03454:  RCALL  3366
03456:  MOVFF  01,726
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
0345A:  MOVFF  727,8D8
0345E:  RCALL  3366
03460:  MOVFF  01,727
03464:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DCC:  MOVLB  A
00DCE:  CLRF   x1C
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DD0:  BCF    FC6.5
00DD2:  MOVLW  21
00DD4:  MOVWF  FC6
00DD6:  MOVLW  40
00DD8:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00DDA:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00DDC:  MOVF   FC9,W
00DDE:  MOVLW  0F
00DE0:  MOVWF  FC9
00DE2:  RRCF   FC7,W
00DE4:  BNC   0DE2
00DE6:  MOVFF  FC9,A1C
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00DEA:  MOVF   FC9,W
00DEC:  MOVFF  A1C,FC9
00DF0:  RRCF   FC7,W
00DF2:  BNC   0DF0
00DF4:  MOVFF  FC9,72F
....................    output_bit(RTC_CS, DISABLE); 
00DF8:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00DFA:  BCF    49.2
00DFC:  MOVLB  0
00DFE:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E25E:  MOVF   4B,F
0E260:  BNZ   E2CE
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E262:  MOVLW  AC
0E264:  MOVWF  FF6
0E266:  MOVLW  0D
0E268:  MOVWF  FF7
0E26A:  MOVLW  00
0E26C:  MOVWF  FF8
0E26E:  CLRF   1B
0E270:  BTFSC  FF2.7
0E272:  BSF    1B.7
0E274:  BCF    FF2.7
0E276:  MOVLW  05
0E278:  MOVLB  A
0E27A:  MOVWF  x25
0E27C:  MOVLB  0
0E27E:  CALL   1010
0E282:  BTFSC  1B.7
0E284:  BSF    FF2.7
0E286:  CLRF   1B
0E288:  BTFSC  FF2.7
0E28A:  BSF    1B.7
0E28C:  BCF    FF2.7
0E28E:  MOVFF  72A,A25
0E292:  MOVLW  01
0E294:  MOVLB  A
0E296:  MOVWF  x26
0E298:  MOVLB  0
0E29A:  CALL   0F92
0E29E:  BTFSC  1B.7
0E2A0:  BSF    FF2.7
0E2A2:  MOVLW  2F
0E2A4:  BTFSS  F9E.4
0E2A6:  BRA    E2A4
0E2A8:  MOVWF  FAD
0E2AA:  CLRF   1B
0E2AC:  BTFSC  FF2.7
0E2AE:  BSF    1B.7
0E2B0:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E2B2:  MOVFF  72B,A25
0E2B6:  MOVLW  01
0E2B8:  MOVLB  A
0E2BA:  MOVWF  x26
0E2BC:  MOVLB  0
0E2BE:  CALL   0F92
0E2C2:  BTFSC  1B.7
0E2C4:  BSF    FF2.7
0E2C6:  MOVLW  2F
0E2C8:  BTFSS  F9E.4
0E2CA:  BRA    E2C8
0E2CC:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E2CE:  DECFSZ 4B,W
0E2D0:  BRA    E33E
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E2D2:  MOVLW  B8
0E2D4:  MOVWF  FF6
0E2D6:  MOVLW  0D
0E2D8:  MOVWF  FF7
0E2DA:  MOVLW  00
0E2DC:  MOVWF  FF8
0E2DE:  CLRF   1B
0E2E0:  BTFSC  FF2.7
0E2E2:  BSF    1B.7
0E2E4:  BCF    FF2.7
0E2E6:  MOVLW  05
0E2E8:  MOVLB  A
0E2EA:  MOVWF  x25
0E2EC:  MOVLB  0
0E2EE:  CALL   1010
0E2F2:  BTFSC  1B.7
0E2F4:  BSF    FF2.7
0E2F6:  CLRF   1B
0E2F8:  BTFSC  FF2.7
0E2FA:  BSF    1B.7
0E2FC:  BCF    FF2.7
0E2FE:  MOVFF  72B,A25
0E302:  MOVLW  01
0E304:  MOVLB  A
0E306:  MOVWF  x26
0E308:  MOVLB  0
0E30A:  CALL   0F92
0E30E:  BTFSC  1B.7
0E310:  BSF    FF2.7
0E312:  MOVLW  2F
0E314:  BTFSS  F9E.4
0E316:  BRA    E314
0E318:  MOVWF  FAD
0E31A:  CLRF   1B
0E31C:  BTFSC  FF2.7
0E31E:  BSF    1B.7
0E320:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E322:  MOVFF  72A,A25
0E326:  MOVLW  01
0E328:  MOVLB  A
0E32A:  MOVWF  x26
0E32C:  MOVLB  0
0E32E:  CALL   0F92
0E332:  BTFSC  1B.7
0E334:  BSF    FF2.7
0E336:  MOVLW  2F
0E338:  BTFSS  F9E.4
0E33A:  BRA    E338
0E33C:  MOVWF  FAD
0E33E:  CLRF   1B
0E340:  BTFSC  FF2.7
0E342:  BSF    1B.7
0E344:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E346:  MOVFF  729,A25
0E34A:  MOVLW  01
0E34C:  MOVLB  A
0E34E:  MOVWF  x26
0E350:  MOVLB  0
0E352:  CALL   0F92
0E356:  BTFSC  1B.7
0E358:  BSF    FF2.7
0E35A:  MOVLW  20
0E35C:  BTFSS  F9E.4
0E35E:  BRA    E35C
0E360:  MOVWF  FAD
0E362:  CLRF   1B
0E364:  BTFSC  FF2.7
0E366:  BSF    1B.7
0E368:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E36A:  MOVFF  72C,A25
0E36E:  MOVLW  01
0E370:  MOVLB  A
0E372:  MOVWF  x26
0E374:  MOVLB  0
0E376:  CALL   0F92
0E37A:  BTFSC  1B.7
0E37C:  BSF    FF2.7
0E37E:  MOVLW  3A
0E380:  BTFSS  F9E.4
0E382:  BRA    E380
0E384:  MOVWF  FAD
0E386:  CLRF   1B
0E388:  BTFSC  FF2.7
0E38A:  BSF    1B.7
0E38C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E38E:  MOVFF  72D,A25
0E392:  MOVLW  01
0E394:  MOVLB  A
0E396:  MOVWF  x26
0E398:  MOVLB  0
0E39A:  CALL   0F92
0E39E:  BTFSC  1B.7
0E3A0:  BSF    FF2.7
0E3A2:  MOVLW  3A
0E3A4:  BTFSS  F9E.4
0E3A6:  BRA    E3A4
0E3A8:  MOVWF  FAD
0E3AA:  CLRF   1B
0E3AC:  BTFSC  FF2.7
0E3AE:  BSF    1B.7
0E3B0:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E3B2:  MOVFF  72E,A25
0E3B6:  MOVLW  01
0E3B8:  MOVLB  A
0E3BA:  MOVWF  x26
0E3BC:  MOVLB  0
0E3BE:  CALL   0F92
0E3C2:  BTFSC  1B.7
0E3C4:  BSF    FF2.7
0E3C6:  MOVLW  0A
0E3C8:  BTFSS  F9E.4
0E3CA:  BRA    E3C8
0E3CC:  MOVWF  FAD
0E3CE:  MOVLW  0D
0E3D0:  BTFSS  F9E.4
0E3D2:  BRA    E3D0
0E3D4:  MOVWF  FAD
0E3D6:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E188:  MOVLB  8
0E18A:  CLRF   xA1
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E18C:  BCF    FC6.5
0E18E:  MOVLW  21
0E190:  MOVWF  FC6
0E192:  MOVLW  40
0E194:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E196:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E198:  MOVF   FC9,W
0E19A:  MOVLW  0A
0E19C:  MOVWF  FC9
0E19E:  RRCF   FC7,W
0E1A0:  BNC   E19E
0E1A2:  MOVFF  FC9,8A1
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E1A6:  MOVF   FC9,W
0E1A8:  MOVFF  8A1,FC9
0E1AC:  RRCF   FC7,W
0E1AE:  BNC   E1AC
0E1B0:  MOVFF  FC9,72A
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E1B4:  MOVF   FC9,W
0E1B6:  MOVFF  8A1,FC9
0E1BA:  RRCF   FC7,W
0E1BC:  BNC   E1BA
0E1BE:  MOVFF  FC9,72B
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E1C2:  MOVF   FC9,W
0E1C4:  MOVFF  8A1,FC9
0E1C8:  RRCF   FC7,W
0E1CA:  BNC   E1C8
0E1CC:  MOVFF  FC9,72C
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E1D0:  MOVF   FC9,W
0E1D2:  MOVFF  8A1,FC9
0E1D6:  RRCF   FC7,W
0E1D8:  BNC   E1D6
0E1DA:  MOVFF  FC9,72D
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E1DE:  MOVF   FC9,W
0E1E0:  MOVFF  8A1,FC9
0E1E4:  RRCF   FC7,W
0E1E6:  BNC   E1E4
0E1E8:  MOVFF  FC9,72E
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E1EC:  MOVF   FC9,W
0E1EE:  MOVFF  8A1,FC9
0E1F2:  RRCF   FC7,W
0E1F4:  BNC   E1F2
0E1F6:  MOVFF  FC9,72F
....................    output_bit(RTC_CS, DISABLE); 
0E1FA:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E1FC:  MOVLW  1F
0E1FE:  MOVLB  7
0E200:  ANDWF  x2A,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E202:  MOVFF  72A,8D8
0E206:  MOVLB  0
0E208:  CALL   3366
0E20C:  MOVFF  01,72A
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E210:  MOVLW  3F
0E212:  MOVLB  7
0E214:  ANDWF  x2B,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E216:  MOVFF  72B,8D8
0E21A:  MOVLB  0
0E21C:  CALL   3366
0E220:  MOVFF  01,72B
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E224:  MOVLW  3F
0E226:  MOVLB  7
0E228:  ANDWF  x2C,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E22A:  MOVFF  72C,8D8
0E22E:  MOVLB  0
0E230:  CALL   3366
0E234:  MOVFF  01,72C
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E238:  MOVLB  7
0E23A:  BCF    x2D.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E23C:  MOVFF  72D,8D8
0E240:  MOVLB  0
0E242:  CALL   3366
0E246:  MOVFF  01,72D
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E24A:  MOVLB  7
0E24C:  BCF    x2E.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E24E:  MOVFF  72E,8D8
0E252:  MOVLB  0
0E254:  CALL   3366
0E258:  MOVFF  01,72E
0E25C:  RETURN 0
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
1732A:  MOVLW  08
1732C:  MOVWF  FEA
1732E:  MOVLW  73
17330:  MOVWF  FE9
17332:  CLRF   00
17334:  CLRF   02
17336:  MOVLW  0C
17338:  MOVWF  01
1733A:  CALL   357A
....................  
....................    time_error = 0; 
1733E:  MOVLB  8
17340:  CLRF   x7F
....................     
....................    fputc('[', COM_A); 
17342:  MOVLW  5B
17344:  MOVLB  0
17346:  CALL   AEA6
....................     
....................    for (n=0; n<12; ++n){ 
1734A:  MOVLB  8
1734C:  CLRF   x72
1734E:  MOVF   x72,W
17350:  SUBLW  0B
17352:  BNC   17398
....................       c = fgetc(COM_A); 
17354:  MOVLB  0
17356:  CALL   0E24
1735A:  MOVFF  01,871
....................       if (com_echo == TRUE) 
1735E:  DECFSZ 48,W
17360:  BRA    1736C
....................       { 
....................          fputc(c, COM_A); 
17362:  MOVLB  8
17364:  MOVF   x71,W
17366:  MOVLB  0
17368:  CALL   AEA6
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
1736C:  MOVLB  8
1736E:  MOVF   x71,W
17370:  SUBLW  2F
17372:  BC    1738E
17374:  MOVF   x71,W
17376:  SUBLW  39
17378:  BNC   1738E
1737A:  CLRF   03
1737C:  MOVF   x72,W
1737E:  ADDLW  73
17380:  MOVWF  FE9
17382:  MOVLW  08
17384:  ADDWFC 03,W
17386:  MOVWF  FEA
17388:  MOVFF  871,FEF
1738C:  BRA    17394
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
1738E:  MOVLW  01
17390:  MOVWF  x7F
....................          break; 
17392:  BRA    17398
....................       } 
17394:  INCF   x72,F
17396:  BRA    1734E
....................    } 
....................     
....................    if (time_error == 0){ 
17398:  MOVF   x7F,F
1739A:  BTFSS  FD8.2
1739C:  BRA    176D4
....................     
....................       fputc(']', COM_A); 
1739E:  MOVLW  5D
173A0:  MOVLB  0
173A2:  CALL   AEA6
....................        
....................       for (n=0; n<12; ++n){ 
173A6:  MOVLB  8
173A8:  CLRF   x72
173AA:  MOVF   x72,W
173AC:  SUBLW  0B
173AE:  BNC   173E0
....................          t_entry[n] = (t_entry[n] - 48); 
173B0:  CLRF   03
173B2:  MOVF   x72,W
173B4:  ADDLW  73
173B6:  MOVWF  01
173B8:  MOVLW  08
173BA:  ADDWFC 03,F
173BC:  MOVFF  03,881
173C0:  CLRF   03
173C2:  MOVF   x72,W
173C4:  ADDLW  73
173C6:  MOVWF  FE9
173C8:  MOVLW  08
173CA:  ADDWFC 03,W
173CC:  MOVWF  FEA
173CE:  MOVLW  30
173D0:  SUBWF  FEF,W
173D2:  MOVFF  881,FEA
173D6:  MOVFF  01,FE9
173DA:  MOVWF  FEF
173DC:  INCF   x72,F
173DE:  BRA    173AA
....................       } 
....................        
....................       if (RTCfmt == 0) 
173E0:  MOVF   4B,F
173E2:  BNZ   17420
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
173E4:  MOVF   x73,W
173E6:  MULLW  0A
173E8:  MOVF   FF3,W
173EA:  ADDWF  x74,W
173EC:  MOVLB  7
173EE:  MOVWF  x34
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
173F0:  MOVF   x34,F
173F2:  BZ    173FA
173F4:  MOVF   x34,W
173F6:  SUBLW  0C
173F8:  BC    17402
173FA:  MOVLW  02
173FC:  MOVLB  8
173FE:  MOVWF  x7F
17400:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
17402:  MOVLB  8
17404:  MOVF   x75,W
17406:  MULLW  0A
17408:  MOVF   FF3,W
1740A:  ADDWF  x76,W
1740C:  MOVLB  7
1740E:  MOVWF  x33
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17410:  MOVF   x33,F
17412:  BZ    1741A
17414:  MOVF   x33,W
17416:  SUBLW  1F
17418:  BC    17422
1741A:  MOVLW  02
1741C:  MOVLB  8
1741E:  MOVWF  x7F
17420:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17422:  DECFSZ 4B,W
17424:  BRA    17466
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
17426:  MOVLB  8
17428:  MOVF   x73,W
1742A:  MULLW  0A
1742C:  MOVF   FF3,W
1742E:  ADDWF  x74,W
17430:  MOVLB  7
17432:  MOVWF  x33
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17434:  MOVF   x33,F
17436:  BZ    1743E
17438:  MOVF   x33,W
1743A:  SUBLW  1F
1743C:  BC    17446
1743E:  MOVLW  02
17440:  MOVLB  8
17442:  MOVWF  x7F
17444:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
17446:  MOVLB  8
17448:  MOVF   x75,W
1744A:  MULLW  0A
1744C:  MOVF   FF3,W
1744E:  ADDWF  x76,W
17450:  MOVLB  7
17452:  MOVWF  x34
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17454:  MOVF   x34,F
17456:  BZ    1745E
17458:  MOVF   x34,W
1745A:  SUBLW  0C
1745C:  BC    17466
1745E:  MOVLW  02
17460:  MOVLB  8
17462:  MOVWF  x7F
17464:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
17466:  MOVLB  8
17468:  MOVF   x77,W
1746A:  MULLW  0A
1746C:  MOVF   FF3,W
1746E:  ADDWF  x78,W
17470:  MOVLB  7
17472:  MOVWF  x35
....................       if (RTC_Yr_Data > 99) time_error = 2;  
17474:  MOVF   x35,W
17476:  SUBLW  63
17478:  BC    17482
1747A:  MOVLW  02
1747C:  MOVLB  8
1747E:  MOVWF  x7F
17480:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
17482:  MOVLB  8
17484:  MOVF   x79,W
17486:  MULLW  0A
17488:  MOVF   FF3,W
1748A:  ADDWF  x7A,W
1748C:  MOVLB  7
1748E:  MOVWF  x32
....................       if (RTC_Hr_Data > 24) time_error = 2;  
17490:  MOVF   x32,W
17492:  SUBLW  18
17494:  BC    1749E
17496:  MOVLW  02
17498:  MOVLB  8
1749A:  MOVWF  x7F
1749C:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
1749E:  MOVLB  8
174A0:  MOVF   x7B,W
174A2:  MULLW  0A
174A4:  MOVF   FF3,W
174A6:  ADDWF  x7C,W
174A8:  MOVLB  7
174AA:  MOVWF  x31
....................       if (RTC_Min_Data > 60) time_error = 2;  
174AC:  MOVF   x31,W
174AE:  SUBLW  3C
174B0:  BC    174BA
174B2:  MOVLW  02
174B4:  MOVLB  8
174B6:  MOVWF  x7F
174B8:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
174BA:  MOVLB  8
174BC:  MOVF   x7D,W
174BE:  MULLW  0A
174C0:  MOVF   FF3,W
174C2:  ADDWF  x7E,W
174C4:  MOVLB  7
174C6:  MOVWF  x30
....................       if (RTC_Sec_Data > 60) time_error = 2; 
174C8:  MOVF   x30,W
174CA:  SUBLW  3C
174CC:  BC    174D6
174CE:  MOVLW  02
174D0:  MOVLB  8
174D2:  MOVWF  x7F
174D4:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
174D6:  MOVF   4B,F
174D8:  BTFSS  FD8.2
174DA:  BRA    175CE
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
174DC:  MOVLW  0A
174DE:  BTFSS  F9E.4
174E0:  BRA    174DE
174E2:  MOVWF  FAD
174E4:  MOVLW  0D
174E6:  BTFSS  F9E.4
174E8:  BRA    174E6
174EA:  MOVWF  FAD
174EC:  CLRF   1B
174EE:  BTFSC  FF2.7
174F0:  BSF    1B.7
174F2:  BCF    FF2.7
174F4:  MOVFF  734,A25
174F8:  MOVLW  01
174FA:  MOVLB  A
174FC:  MOVWF  x26
174FE:  MOVLB  0
17500:  CALL   0F92
17504:  BTFSC  1B.7
17506:  BSF    FF2.7
17508:  MOVLW  2F
1750A:  BTFSS  F9E.4
1750C:  BRA    1750A
1750E:  MOVWF  FAD
17510:  CLRF   1B
17512:  BTFSC  FF2.7
17514:  BSF    1B.7
17516:  BCF    FF2.7
17518:  MOVFF  733,A25
1751C:  MOVLW  01
1751E:  MOVLB  A
17520:  MOVWF  x26
17522:  MOVLB  0
17524:  CALL   0F92
17528:  BTFSC  1B.7
1752A:  BSF    FF2.7
1752C:  MOVLW  2F
1752E:  BTFSS  F9E.4
17530:  BRA    1752E
17532:  MOVWF  FAD
17534:  CLRF   1B
17536:  BTFSC  FF2.7
17538:  BSF    1B.7
1753A:  BCF    FF2.7
1753C:  MOVFF  735,A25
17540:  MOVLW  01
17542:  MOVLB  A
17544:  MOVWF  x26
17546:  MOVLB  0
17548:  CALL   0F92
1754C:  BTFSC  1B.7
1754E:  BSF    FF2.7
17550:  MOVLW  20
17552:  BTFSS  F9E.4
17554:  BRA    17552
17556:  MOVWF  FAD
17558:  CLRF   1B
1755A:  BTFSC  FF2.7
1755C:  BSF    1B.7
1755E:  BCF    FF2.7
17560:  MOVFF  732,A25
17564:  MOVLW  01
17566:  MOVLB  A
17568:  MOVWF  x26
1756A:  MOVLB  0
1756C:  CALL   0F92
17570:  BTFSC  1B.7
17572:  BSF    FF2.7
17574:  MOVLW  3A
17576:  BTFSS  F9E.4
17578:  BRA    17576
1757A:  MOVWF  FAD
1757C:  CLRF   1B
1757E:  BTFSC  FF2.7
17580:  BSF    1B.7
17582:  BCF    FF2.7
17584:  MOVFF  731,A25
17588:  MOVLW  01
1758A:  MOVLB  A
1758C:  MOVWF  x26
1758E:  MOVLB  0
17590:  CALL   0F92
17594:  BTFSC  1B.7
17596:  BSF    FF2.7
17598:  MOVLW  3A
1759A:  BTFSS  F9E.4
1759C:  BRA    1759A
1759E:  MOVWF  FAD
175A0:  CLRF   1B
175A2:  BTFSC  FF2.7
175A4:  BSF    1B.7
175A6:  BCF    FF2.7
175A8:  MOVFF  730,A25
175AC:  MOVLW  01
175AE:  MOVLB  A
175B0:  MOVWF  x26
175B2:  MOVLB  0
175B4:  CALL   0F92
175B8:  BTFSC  1B.7
175BA:  BSF    FF2.7
175BC:  MOVLW  0A
175BE:  BTFSS  F9E.4
175C0:  BRA    175BE
175C2:  MOVWF  FAD
175C4:  MOVLW  0D
175C6:  BTFSS  F9E.4
175C8:  BRA    175C6
175CA:  MOVWF  FAD
175CC:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
175CE:  DECFSZ 4B,W
175D0:  BRA    176C4
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
175D2:  MOVLW  0A
175D4:  BTFSS  F9E.4
175D6:  BRA    175D4
175D8:  MOVWF  FAD
175DA:  MOVLW  0D
175DC:  BTFSS  F9E.4
175DE:  BRA    175DC
175E0:  MOVWF  FAD
175E2:  CLRF   1B
175E4:  BTFSC  FF2.7
175E6:  BSF    1B.7
175E8:  BCF    FF2.7
175EA:  MOVFF  733,A25
175EE:  MOVLW  01
175F0:  MOVLB  A
175F2:  MOVWF  x26
175F4:  MOVLB  0
175F6:  CALL   0F92
175FA:  BTFSC  1B.7
175FC:  BSF    FF2.7
175FE:  MOVLW  2F
17600:  BTFSS  F9E.4
17602:  BRA    17600
17604:  MOVWF  FAD
17606:  CLRF   1B
17608:  BTFSC  FF2.7
1760A:  BSF    1B.7
1760C:  BCF    FF2.7
1760E:  MOVFF  734,A25
17612:  MOVLW  01
17614:  MOVLB  A
17616:  MOVWF  x26
17618:  MOVLB  0
1761A:  CALL   0F92
1761E:  BTFSC  1B.7
17620:  BSF    FF2.7
17622:  MOVLW  2F
17624:  BTFSS  F9E.4
17626:  BRA    17624
17628:  MOVWF  FAD
1762A:  CLRF   1B
1762C:  BTFSC  FF2.7
1762E:  BSF    1B.7
17630:  BCF    FF2.7
17632:  MOVFF  735,A25
17636:  MOVLW  01
17638:  MOVLB  A
1763A:  MOVWF  x26
1763C:  MOVLB  0
1763E:  CALL   0F92
17642:  BTFSC  1B.7
17644:  BSF    FF2.7
17646:  MOVLW  20
17648:  BTFSS  F9E.4
1764A:  BRA    17648
1764C:  MOVWF  FAD
1764E:  CLRF   1B
17650:  BTFSC  FF2.7
17652:  BSF    1B.7
17654:  BCF    FF2.7
17656:  MOVFF  732,A25
1765A:  MOVLW  01
1765C:  MOVLB  A
1765E:  MOVWF  x26
17660:  MOVLB  0
17662:  CALL   0F92
17666:  BTFSC  1B.7
17668:  BSF    FF2.7
1766A:  MOVLW  3A
1766C:  BTFSS  F9E.4
1766E:  BRA    1766C
17670:  MOVWF  FAD
17672:  CLRF   1B
17674:  BTFSC  FF2.7
17676:  BSF    1B.7
17678:  BCF    FF2.7
1767A:  MOVFF  731,A25
1767E:  MOVLW  01
17680:  MOVLB  A
17682:  MOVWF  x26
17684:  MOVLB  0
17686:  CALL   0F92
1768A:  BTFSC  1B.7
1768C:  BSF    FF2.7
1768E:  MOVLW  3A
17690:  BTFSS  F9E.4
17692:  BRA    17690
17694:  MOVWF  FAD
17696:  CLRF   1B
17698:  BTFSC  FF2.7
1769A:  BSF    1B.7
1769C:  BCF    FF2.7
1769E:  MOVFF  730,A25
176A2:  MOVLW  01
176A4:  MOVLB  A
176A6:  MOVWF  x26
176A8:  MOVLB  0
176AA:  CALL   0F92
176AE:  BTFSC  1B.7
176B0:  BSF    FF2.7
176B2:  MOVLW  0A
176B4:  BTFSS  F9E.4
176B6:  BRA    176B4
176B8:  MOVWF  FAD
176BA:  MOVLW  0D
176BC:  BTFSS  F9E.4
176BE:  BRA    176BC
176C0:  MOVWF  FAD
176C2:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
176C4:  MOVLB  8
176C6:  MOVF   x7F,W
176C8:  SUBLW  02
176CA:  BNZ   176D2
176CC:  MOVLB  0
176CE:  BRA    1730A
176D0:  MOVLB  8
....................  
....................    } 
176D2:  BRA    176DC
....................    else cmd_arg(); 
176D4:  MOVLB  0
176D6:  CALL   B062
176DA:  MOVLB  8
....................     
....................    return time_error; 
176DC:  MOVFF  87F,01
176E0:  MOVLB  0
176E2:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
17722:  RCALL  1732A
17724:  MOVFF  01,86F
....................     
....................    if (time_error ==0 ){ 
17728:  MOVLB  8
1772A:  MOVF   x6F,F
1772C:  BTFSS  FD8.2
1772E:  BRA    17866
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
17730:  BCF    FC6.5
17732:  MOVLW  21
17734:  MOVWF  FC6
17736:  MOVLW  40
17738:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
1773A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
1773C:  MOVF   FC9,W
1773E:  MOVLW  86
17740:  MOVWF  FC9
17742:  RRCF   FC7,W
17744:  BNC   17742
17746:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
1774A:  MOVFF  734,871
1774E:  MOVLB  0
17750:  RCALL  176E4
17752:  MOVFF  01,871
17756:  MOVF   FC9,W
17758:  MOVFF  01,FC9
1775C:  RRCF   FC7,W
1775E:  BNC   1775C
17760:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
17764:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17766:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
17768:  MOVF   FC9,W
1776A:  MOVLW  85
1776C:  MOVWF  FC9
1776E:  RRCF   FC7,W
17770:  BNC   1776E
17772:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
17776:  MOVFF  733,871
1777A:  RCALL  176E4
1777C:  MOVFF  01,871
17780:  MOVF   FC9,W
17782:  MOVFF  01,FC9
17786:  RRCF   FC7,W
17788:  BNC   17786
1778A:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
1778E:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17790:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
17792:  MOVF   FC9,W
17794:  MOVLW  87
17796:  MOVWF  FC9
17798:  RRCF   FC7,W
1779A:  BNC   17798
1779C:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
177A0:  MOVFF  735,871
177A4:  RCALL  176E4
177A6:  MOVFF  01,871
177AA:  MOVF   FC9,W
177AC:  MOVFF  01,FC9
177B0:  RRCF   FC7,W
177B2:  BNC   177B0
177B4:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
177B8:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
177BA:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
177BC:  MOVF   FC9,W
177BE:  MOVLW  83
177C0:  MOVWF  FC9
177C2:  RRCF   FC7,W
177C4:  BNC   177C2
177C6:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
177CA:  MOVFF  732,871
177CE:  RCALL  176E4
177D0:  MOVFF  01,871
177D4:  MOVF   FC9,W
177D6:  MOVFF  01,FC9
177DA:  RRCF   FC7,W
177DC:  BNC   177DA
177DE:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
177E2:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
177E4:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
177E6:  MOVF   FC9,W
177E8:  MOVLW  82
177EA:  MOVWF  FC9
177EC:  RRCF   FC7,W
177EE:  BNC   177EC
177F0:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
177F4:  MOVFF  731,871
177F8:  RCALL  176E4
177FA:  MOVFF  01,871
177FE:  MOVF   FC9,W
17800:  MOVFF  01,FC9
17804:  RRCF   FC7,W
17806:  BNC   17804
17808:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
1780C:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
1780E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
17810:  MOVF   FC9,W
17812:  MOVLW  81
17814:  MOVWF  FC9
17816:  RRCF   FC7,W
17818:  BNC   17816
1781A:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
1781E:  MOVFF  730,871
17822:  RCALL  176E4
17824:  MOVFF  01,871
17828:  MOVF   FC9,W
1782A:  MOVFF  01,FC9
1782E:  RRCF   FC7,W
17830:  BNC   1782E
17832:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
17836:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17838:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
1783A:  MOVF   FC9,W
1783C:  MOVLW  80
1783E:  MOVWF  FC9
17840:  RRCF   FC7,W
17842:  BNC   17840
17844:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
17848:  MOVLB  8
1784A:  CLRF   x71
1784C:  MOVLB  0
1784E:  RCALL  176E4
17850:  MOVFF  01,871
17854:  MOVF   FC9,W
17856:  MOVFF  01,FC9
1785A:  RRCF   FC7,W
1785C:  BNC   1785A
1785E:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
17862:  BSF    F91.0
17864:  MOVLB  8
....................    } 
17866:  MOVLB  0
17868:  GOTO   178F4 (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
183EC:  CALL   E188
....................     
....................    time_error = get_time(); 
183F0:  CALL   1732A
183F4:  MOVFF  01,86F
....................     
....................    if (time_error == 0 ){ 
183F8:  MOVLB  8
183FA:  MOVF   x6F,F
183FC:  BTFSS  FD8.2
183FE:  BRA    18534
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
18400:  MOVFF  735,729
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
18404:  MOVLW  04
18406:  MOVWF  x73
18408:  MOVFF  729,874
1840C:  MOVLB  0
1840E:  CALL   3466
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
18412:  MOVFF  734,871
18416:  CALL   176E4
1841A:  MOVFF  01,734
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
1841E:  MOVLB  7
18420:  BSF    x34.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
18422:  BCF    FC6.5
18424:  MOVLW  21
18426:  MOVWF  FC6
18428:  MOVLW  40
1842A:  MOVWF  FC7
....................       delay_us(10); 
1842C:  MOVLW  35
1842E:  MOVWF  00
18430:  DECFSZ 00,F
18432:  BRA    18430
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
18434:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
18436:  MOVF   FC9,W
18438:  MOVLW  8E
1843A:  MOVWF  FC9
1843C:  RRCF   FC7,W
1843E:  BNC   1843C
18440:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
18444:  MOVFF  730,871
18448:  MOVLB  0
1844A:  CALL   176E4
1844E:  MOVFF  01,871
18452:  MOVF   FC9,W
18454:  MOVFF  01,FC9
18458:  RRCF   FC7,W
1845A:  BNC   18458
1845C:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
18460:  BSF    F91.0
....................       delay_us(1);            // Delays added 1.020A 
18462:  MOVLW  05
18464:  MOVWF  00
18466:  DECFSZ 00,F
18468:  BRA    18466
....................        
....................       output_bit(RTC_CS, ENABLE); 
1846A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
1846C:  MOVF   FC9,W
1846E:  MOVLW  8D
18470:  MOVWF  FC9
18472:  RRCF   FC7,W
18474:  BNC   18472
18476:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
1847A:  MOVFF  731,871
1847E:  CALL   176E4
18482:  MOVFF  01,871
18486:  MOVF   FC9,W
18488:  MOVFF  01,FC9
1848C:  RRCF   FC7,W
1848E:  BNC   1848C
18490:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
18494:  BSF    F91.0
....................       delay_us(1); 
18496:  MOVLW  05
18498:  MOVWF  00
1849A:  DECFSZ 00,F
1849C:  BRA    1849A
....................        
....................       output_bit(RTC_CS, ENABLE); 
1849E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
184A0:  MOVF   FC9,W
184A2:  MOVLW  8C
184A4:  MOVWF  FC9
184A6:  RRCF   FC7,W
184A8:  BNC   184A6
184AA:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
184AE:  MOVFF  732,871
184B2:  CALL   176E4
184B6:  MOVFF  01,871
184BA:  MOVF   FC9,W
184BC:  MOVFF  01,FC9
184C0:  RRCF   FC7,W
184C2:  BNC   184C0
184C4:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
184C8:  BSF    F91.0
....................       delay_us(1);    
184CA:  MOVLW  05
184CC:  MOVWF  00
184CE:  DECFSZ 00,F
184D0:  BRA    184CE
....................        
....................       output_bit(RTC_CS, ENABLE); 
184D2:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
184D4:  MOVF   FC9,W
184D6:  MOVLW  8B
184D8:  MOVWF  FC9
184DA:  RRCF   FC7,W
184DC:  BNC   184DA
184DE:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
184E2:  MOVFF  733,871
184E6:  CALL   176E4
184EA:  MOVFF  01,871
184EE:  MOVF   FC9,W
184F0:  MOVFF  01,FC9
184F4:  RRCF   FC7,W
184F6:  BNC   184F4
184F8:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE);  
184FC:  BSF    F91.0
....................       delay_us(1); 
184FE:  MOVLW  05
18500:  MOVWF  00
18502:  DECFSZ 00,F
18504:  BRA    18502
....................        
....................       output_bit(RTC_CS, ENABLE); 
18506:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8A);        // address - Month 
18508:  MOVF   FC9,W
1850A:  MOVLW  8A
1850C:  MOVWF  FC9
1850E:  RRCF   FC7,W
18510:  BNC   1850E
18512:  MOVFF  FC9,870
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
18516:  MOVF   FC9,W
18518:  MOVFF  734,FC9
1851C:  RRCF   FC7,W
1851E:  BNC   1851C
18520:  MOVFF  FC9,870
....................       output_bit(RTC_CS, DISABLE); 
18524:  BSF    F91.0
....................       delay_us(1); 
18526:  MOVLW  05
18528:  MOVWF  00
1852A:  DECFSZ 00,F
1852C:  BRA    1852A
....................     
....................    RTC_read_alarm(); 
1852E:  CALL   E188
18532:  MOVLB  8
....................    } 
18534:  MOVLB  0
18536:  GOTO   1854C (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
15AD8:  BCF    FC6.5
15ADA:  MOVLW  21
15ADC:  MOVWF  FC6
15ADE:  MOVLW  40
15AE0:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
15AE2:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
15AE4:  MOVF   FC9,W
15AE6:  MOVLW  8E
15AE8:  MOVWF  FC9
15AEA:  RRCF   FC7,W
15AEC:  BNC   15AEA
15AEE:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(0b00000000);  // data 
15AF2:  MOVF   FC9,W
15AF4:  CLRF   FC9
15AF6:  RRCF   FC7,W
15AF8:  BNC   15AF6
15AFA:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE); 
15AFE:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15B00:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15B02:  MOVF   FC9,W
15B04:  MOVLW  8D
15B06:  MOVWF  FC9
15B08:  RRCF   FC7,W
15B0A:  BNC   15B08
15B0C:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(0b10000000);  // data 
15B10:  MOVF   FC9,W
15B12:  MOVLW  80
15B14:  MOVWF  FC9
15B16:  RRCF   FC7,W
15B18:  BNC   15B16
15B1A:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE); 
15B1E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15B20:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15B22:  MOVF   FC9,W
15B24:  MOVLW  8C
15B26:  MOVWF  FC9
15B28:  RRCF   FC7,W
15B2A:  BNC   15B28
15B2C:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(0b10000000);  // data 
15B30:  MOVF   FC9,W
15B32:  MOVLW  80
15B34:  MOVWF  FC9
15B36:  RRCF   FC7,W
15B38:  BNC   15B36
15B3A:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE); 
15B3E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15B40:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15B42:  MOVF   FC9,W
15B44:  MOVLW  8B
15B46:  MOVWF  FC9
15B48:  RRCF   FC7,W
15B4A:  BNC   15B48
15B4C:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(0b11000000);  // data 
15B50:  MOVF   FC9,W
15B52:  MOVLW  C0
15B54:  MOVWF  FC9
15B56:  RRCF   FC7,W
15B58:  BNC   15B56
15B5A:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE);    
15B5E:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15B60:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15B62:  MOVF   FC9,W
15B64:  MOVLW  8A
15B66:  MOVWF  FC9
15B68:  RRCF   FC7,W
15B6A:  BNC   15B68
15B6C:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(0b10000000);  // data 
15B70:  MOVF   FC9,W
15B72:  MOVLW  80
15B74:  MOVWF  FC9
15B76:  RRCF   FC7,W
15B78:  BNC   15B76
15B7A:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE); 
15B7E:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15B80:  CALL   E188
15B84:  GOTO   16944 (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
15326:  MOVLB  8
15328:  CLRF   x71
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
1532A:  BCF    FC6.5
1532C:  MOVLW  21
1532E:  MOVWF  FC6
15330:  MOVLW  40
15332:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15334:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
15336:  MOVF   FC9,W
15338:  MOVLW  0A
1533A:  MOVWF  FC9
1533C:  RRCF   FC7,W
1533E:  BNC   1533C
15340:  MOVFF  FC9,871
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
15344:  MOVF   FC9,W
15346:  MOVFF  871,FC9
1534A:  RRCF   FC7,W
1534C:  BNC   1534A
1534E:  MOVFF  FC9,72A
....................    output_bit(RTC_CS, DISABLE); 
15352:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
15354:  MOVLB  7
15356:  BSF    x2A.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15358:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
1535A:  MOVF   FC9,W
1535C:  MOVLW  8A
1535E:  MOVWF  FC9
15360:  RRCF   FC7,W
15362:  BNC   15360
15364:  MOVFF  FC9,871
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
15368:  MOVF   FC9,W
1536A:  MOVFF  72A,FC9
1536E:  RRCF   FC7,W
15370:  BNC   1536E
15372:  MOVFF  FC9,871
....................    output_bit(RTC_CS, DISABLE); 
15376:  BSF    F91.0
15378:  MOVLB  0
1537A:  GOTO   1686E (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
03496:  MOVFF  721,73B
....................    rtc_last_min   = RTC_Min_Reg; 
0349A:  MOVFF  722,73A
....................    rtc_last_hour  = RTC_Hr_Reg; 
0349E:  MOVFF  723,739
....................    rtc_last_day   = RTC_DOM_Reg; 
034A2:  MOVFF  725,737
....................    rtc_last_month = RTC_Mon_Reg; 
034A6:  MOVFF  726,736
....................    rtc_last_year  = RTC_Yr_Reg; 
034AA:  MOVFF  727,738
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
034AE:  MOVLW  06
034B0:  MOVLB  8
034B2:  MOVWF  x73
034B4:  MOVFF  736,874
034B8:  MOVLB  0
034BA:  RCALL  3466
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
034BC:  MOVLW  08
034BE:  MOVLB  8
034C0:  MOVWF  x73
034C2:  MOVFF  737,874
034C6:  MOVLB  0
034C8:  RCALL  3466
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
034CA:  MOVLW  0A
034CC:  MOVLB  8
034CE:  MOVWF  x73
034D0:  MOVFF  738,874
034D4:  MOVLB  0
034D6:  RCALL  3466
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
034D8:  MOVLW  0C
034DA:  MOVLB  8
034DC:  MOVWF  x73
034DE:  MOVFF  739,874
034E2:  MOVLB  0
034E4:  RCALL  3466
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
034E6:  MOVLW  0E
034E8:  MOVLB  8
034EA:  MOVWF  x73
034EC:  MOVFF  73A,874
034F0:  MOVLB  0
034F2:  RCALL  3466
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
034F4:  MOVLW  10
034F6:  MOVLB  8
034F8:  MOVWF  x73
034FA:  MOVFF  73B,874
034FE:  MOVLB  0
03500:  RCALL  3466
03502:  GOTO   1B2B0 (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
1537E:  MOVLB  8
15380:  CLRF   x74
15382:  CLRF   x73
15384:  CLRF   x72
15386:  CLRF   x71
15388:  CLRF   x78
1538A:  CLRF   x77
1538C:  CLRF   x76
1538E:  CLRF   x75
15390:  CLRF   x7C
15392:  CLRF   x7B
15394:  CLRF   x7A
15396:  CLRF   x79
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
15398:  CLRF   x89
1539A:  CLRF   x8A
1539C:  MOVLW  1F
1539E:  MOVWF  x8B
153A0:  CLRF   x8C
153A2:  MOVLW  3B
153A4:  MOVWF  x8D
153A6:  CLRF   x8E
153A8:  MOVLW  5A
153AA:  MOVWF  x8F
153AC:  CLRF   x90
153AE:  MOVLW  78
153B0:  MOVWF  x91
153B2:  CLRF   x92
153B4:  MOVLW  97
153B6:  MOVWF  x93
153B8:  CLRF   x94
153BA:  MOVLW  B5
153BC:  MOVWF  x95
153BE:  CLRF   x96
153C0:  MOVLW  D4
153C2:  MOVWF  x97
153C4:  CLRF   x98
153C6:  MOVLW  F3
153C8:  MOVWF  x99
153CA:  CLRF   x9A
153CC:  MOVLW  11
153CE:  MOVWF  x9B
153D0:  MOVLW  01
153D2:  MOVWF  x9C
153D4:  MOVLW  30
153D6:  MOVWF  x9D
153D8:  MOVLW  01
153DA:  MOVWF  x9E
153DC:  MOVLW  4E
153DE:  MOVWF  x9F
153E0:  MOVLW  01
153E2:  MOVWF  xA0
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
153E4:  BCF    49.3
....................     
....................    RTC_read(); 
153E6:  MOVLB  0
153E8:  CALL   3398
....................    RTC_read_alarm(); 
153EC:  CALL   E188
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
153F0:  MOVLW  04
153F2:  MOVLB  8
153F4:  MOVWF  xA1
153F6:  MOVLB  0
153F8:  CALL   2A78
153FC:  MOVFF  01,729
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
15400:  MOVLB  7
15402:  MOVF   x27,W
15404:  SUBWF  x29,W
15406:  BC    1540C
15408:  BSF    49.3
1540A:  BRA    15834
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
1540C:  MOVF   x29,W
1540E:  SUBWF  x27,W
15410:  BTFSS  FD8.2
15412:  BRA    15834
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
15414:  MOVLW  01
15416:  SUBWF  x26,W
15418:  MOVWF  00
1541A:  BCF    FD8.0
1541C:  RLCF   00,F
1541E:  MOVF   00,W
15420:  CLRF   03
15422:  ADDLW  89
15424:  MOVWF  FE9
15426:  MOVLW  08
15428:  ADDWFC 03,W
1542A:  MOVWF  FEA
1542C:  MOVFF  FEC,03
15430:  MOVF   FED,F
15432:  MOVFF  FEF,901
15436:  MOVFF  03,902
1543A:  MOVLB  0
1543C:  CALL   C68E
15440:  MOVFF  03,874
15444:  MOVFF  02,873
15448:  MOVFF  01,872
1544C:  MOVFF  00,871
....................          time_now = time_now + RTC_DOM_Reg; 
15450:  MOVLB  9
15452:  CLRF   x02
15454:  MOVFF  725,901
15458:  MOVLB  0
1545A:  CALL   C68E
1545E:  BCF    FD8.1
15460:  MOVFF  874,904
15464:  MOVFF  873,903
15468:  MOVFF  872,902
1546C:  MOVFF  871,901
15470:  MOVFF  03,908
15474:  MOVFF  02,907
15478:  MOVFF  01,906
1547C:  MOVFF  00,905
15480:  CALL   C152
15484:  MOVFF  03,874
15488:  MOVFF  02,873
1548C:  MOVFF  01,872
15490:  MOVFF  00,871
....................           
....................          hour = RTC_Hr_Reg; 
15494:  MOVLB  9
15496:  CLRF   x02
15498:  MOVFF  723,901
1549C:  MOVLB  0
1549E:  CALL   C68E
154A2:  MOVFF  03,880
154A6:  MOVFF  02,87F
154AA:  MOVFF  01,87E
154AE:  MOVFF  00,87D
....................          minute = RTC_Min_Reg; 
154B2:  MOVLB  9
154B4:  CLRF   x02
154B6:  MOVFF  722,901
154BA:  MOVLB  0
154BC:  CALL   C68E
154C0:  MOVFF  03,884
154C4:  MOVFF  02,883
154C8:  MOVFF  01,882
154CC:  MOVFF  00,881
....................          second = RTC_Sec_Reg; 
154D0:  MOVLB  9
154D2:  CLRF   x02
154D4:  MOVFF  721,901
154D8:  MOVLB  0
154DA:  CALL   C68E
154DE:  MOVFF  03,888
154E2:  MOVFF  02,887
154E6:  MOVFF  01,886
154EA:  MOVFF  00,885
....................           
....................          fraction_of_day = (hour / 24); 
154EE:  MOVFF  880,8E8
154F2:  MOVFF  87F,8E7
154F6:  MOVFF  87E,8E6
154FA:  MOVFF  87D,8E5
154FE:  MOVLB  8
15500:  CLRF   xEC
15502:  CLRF   xEB
15504:  MOVLW  40
15506:  MOVWF  xEA
15508:  MOVLW  83
1550A:  MOVWF  xE9
1550C:  MOVLB  0
1550E:  CALL   C6C4
15512:  MOVFF  03,87C
15516:  MOVFF  02,87B
1551A:  MOVFF  01,87A
1551E:  MOVFF  00,879
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15522:  MOVFF  884,8E8
15526:  MOVFF  883,8E7
1552A:  MOVFF  882,8E6
1552E:  MOVFF  881,8E5
15532:  MOVLB  8
15534:  CLRF   xEC
15536:  CLRF   xEB
15538:  MOVLW  34
1553A:  MOVWF  xEA
1553C:  MOVLW  89
1553E:  MOVWF  xE9
15540:  MOVLB  0
15542:  CALL   C6C4
15546:  BCF    FD8.1
15548:  MOVFF  87C,904
1554C:  MOVFF  87B,903
15550:  MOVFF  87A,902
15554:  MOVFF  879,901
15558:  MOVFF  03,908
1555C:  MOVFF  02,907
15560:  MOVFF  01,906
15564:  MOVFF  00,905
15568:  CALL   C152
1556C:  MOVFF  03,87C
15570:  MOVFF  02,87B
15574:  MOVFF  01,87A
15578:  MOVFF  00,879
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
1557C:  MOVFF  888,8E8
15580:  MOVFF  887,8E7
15584:  MOVFF  886,8E6
15588:  MOVFF  885,8E5
1558C:  MOVLB  8
1558E:  CLRF   xEC
15590:  MOVLW  C0
15592:  MOVWF  xEB
15594:  MOVLW  28
15596:  MOVWF  xEA
15598:  MOVLW  8F
1559A:  MOVWF  xE9
1559C:  MOVLB  0
1559E:  CALL   C6C4
155A2:  BCF    FD8.1
155A4:  MOVFF  87C,904
155A8:  MOVFF  87B,903
155AC:  MOVFF  87A,902
155B0:  MOVFF  879,901
155B4:  MOVFF  03,908
155B8:  MOVFF  02,907
155BC:  MOVFF  01,906
155C0:  MOVFF  00,905
155C4:  CALL   C152
155C8:  MOVFF  03,87C
155CC:  MOVFF  02,87B
155D0:  MOVFF  01,87A
155D4:  MOVFF  00,879
....................           
....................          time_now = time_now + fraction_of_day; 
155D8:  BCF    FD8.1
155DA:  MOVFF  874,904
155DE:  MOVFF  873,903
155E2:  MOVFF  872,902
155E6:  MOVFF  871,901
155EA:  MOVFF  87C,908
155EE:  MOVFF  87B,907
155F2:  MOVFF  87A,906
155F6:  MOVFF  879,905
155FA:  CALL   C152
155FE:  MOVFF  03,874
15602:  MOVFF  02,873
15606:  MOVFF  01,872
1560A:  MOVFF  00,871
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
1560E:  MOVLB  9
15610:  CLRF   x02
15612:  MOVFF  72C,901
15616:  MOVLB  0
15618:  CALL   C68E
1561C:  MOVFF  03,880
15620:  MOVFF  02,87F
15624:  MOVFF  01,87E
15628:  MOVFF  00,87D
....................          minute = RTC_Al_Min_Reg; 
1562C:  MOVLB  9
1562E:  CLRF   x02
15630:  MOVFF  72D,901
15634:  MOVLB  0
15636:  CALL   C68E
1563A:  MOVFF  03,884
1563E:  MOVFF  02,883
15642:  MOVFF  01,882
15646:  MOVFF  00,881
....................          second = RTC_Al_Sec_Reg; 
1564A:  MOVLB  9
1564C:  CLRF   x02
1564E:  MOVFF  72E,901
15652:  MOVLB  0
15654:  CALL   C68E
15658:  MOVFF  03,888
1565C:  MOVFF  02,887
15660:  MOVFF  01,886
15664:  MOVFF  00,885
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
15668:  MOVLW  01
1566A:  MOVLB  7
1566C:  SUBWF  x2A,W
1566E:  MOVWF  00
15670:  BCF    FD8.0
15672:  RLCF   00,F
15674:  MOVF   00,W
15676:  CLRF   03
15678:  ADDLW  89
1567A:  MOVWF  FE9
1567C:  MOVLW  08
1567E:  ADDWFC 03,W
15680:  MOVWF  FEA
15682:  MOVFF  FEC,03
15686:  MOVF   FED,F
15688:  MOVFF  FEF,901
1568C:  MOVFF  03,902
15690:  MOVLB  0
15692:  CALL   C68E
15696:  MOVFF  03,878
1569A:  MOVFF  02,877
1569E:  MOVFF  01,876
156A2:  MOVFF  00,875
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
156A6:  MOVLB  9
156A8:  CLRF   x02
156AA:  MOVFF  72B,901
156AE:  MOVLB  0
156B0:  CALL   C68E
156B4:  BCF    FD8.1
156B6:  MOVFF  878,904
156BA:  MOVFF  877,903
156BE:  MOVFF  876,902
156C2:  MOVFF  875,901
156C6:  MOVFF  03,908
156CA:  MOVFF  02,907
156CE:  MOVFF  01,906
156D2:  MOVFF  00,905
156D6:  CALL   C152
156DA:  MOVFF  03,878
156DE:  MOVFF  02,877
156E2:  MOVFF  01,876
156E6:  MOVFF  00,875
....................           
....................          fraction_of_day = (hour / 24); 
156EA:  MOVFF  880,8E8
156EE:  MOVFF  87F,8E7
156F2:  MOVFF  87E,8E6
156F6:  MOVFF  87D,8E5
156FA:  MOVLB  8
156FC:  CLRF   xEC
156FE:  CLRF   xEB
15700:  MOVLW  40
15702:  MOVWF  xEA
15704:  MOVLW  83
15706:  MOVWF  xE9
15708:  MOVLB  0
1570A:  CALL   C6C4
1570E:  MOVFF  03,87C
15712:  MOVFF  02,87B
15716:  MOVFF  01,87A
1571A:  MOVFF  00,879
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
1571E:  MOVFF  884,8E8
15722:  MOVFF  883,8E7
15726:  MOVFF  882,8E6
1572A:  MOVFF  881,8E5
1572E:  MOVLB  8
15730:  CLRF   xEC
15732:  CLRF   xEB
15734:  MOVLW  34
15736:  MOVWF  xEA
15738:  MOVLW  89
1573A:  MOVWF  xE9
1573C:  MOVLB  0
1573E:  CALL   C6C4
15742:  BCF    FD8.1
15744:  MOVFF  87C,904
15748:  MOVFF  87B,903
1574C:  MOVFF  87A,902
15750:  MOVFF  879,901
15754:  MOVFF  03,908
15758:  MOVFF  02,907
1575C:  MOVFF  01,906
15760:  MOVFF  00,905
15764:  CALL   C152
15768:  MOVFF  03,87C
1576C:  MOVFF  02,87B
15770:  MOVFF  01,87A
15774:  MOVFF  00,879
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
15778:  MOVFF  888,8E8
1577C:  MOVFF  887,8E7
15780:  MOVFF  886,8E6
15784:  MOVFF  885,8E5
15788:  MOVLB  8
1578A:  CLRF   xEC
1578C:  MOVLW  C0
1578E:  MOVWF  xEB
15790:  MOVLW  28
15792:  MOVWF  xEA
15794:  MOVLW  8F
15796:  MOVWF  xE9
15798:  MOVLB  0
1579A:  CALL   C6C4
1579E:  BCF    FD8.1
157A0:  MOVFF  87C,904
157A4:  MOVFF  87B,903
157A8:  MOVFF  87A,902
157AC:  MOVFF  879,901
157B0:  MOVFF  03,908
157B4:  MOVFF  02,907
157B8:  MOVFF  01,906
157BC:  MOVFF  00,905
157C0:  CALL   C152
157C4:  MOVFF  03,87C
157C8:  MOVFF  02,87B
157CC:  MOVFF  01,87A
157D0:  MOVFF  00,879
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
157D4:  BCF    FD8.1
157D6:  MOVFF  878,904
157DA:  MOVFF  877,903
157DE:  MOVFF  876,902
157E2:  MOVFF  875,901
157E6:  MOVFF  87C,908
157EA:  MOVFF  87B,907
157EE:  MOVFF  87A,906
157F2:  MOVFF  879,905
157F6:  CALL   C152
157FA:  MOVFF  03,878
157FE:  MOVFF  02,877
15802:  MOVFF  01,876
15806:  MOVFF  00,875
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
1580A:  MOVFF  878,900
1580E:  MOVFF  877,8FF
15812:  MOVFF  876,8FE
15816:  MOVFF  875,8FD
1581A:  MOVFF  874,904
1581E:  MOVFF  873,903
15822:  MOVFF  872,902
15826:  MOVFF  871,901
1582A:  CALL   104EC
1582E:  BNC   15832
15830:  BSF    49.3
15832:  MOVLB  7
....................       } 
....................    } 
15834:  MOVLB  0
15836:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
15838:  BTFSS  49.3
1583A:  BRA    15858
1583C:  MOVLW  C4
1583E:  MOVWF  FF6
15840:  MOVLW  0D
15842:  MOVWF  FF7
15844:  MOVLW  00
15846:  MOVWF  FF8
15848:  CLRF   1B
1584A:  BTFSC  FF2.7
1584C:  BSF    1B.7
1584E:  BCF    FF2.7
15850:  CALL   0E3A
15854:  BTFSC  1B.7
15856:  BSF    FF2.7
15858:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F2EC:  BCF    F67.5
0F2EE:  MOVLW  32
0F2F0:  MOVWF  F67
0F2F2:  MOVLW  40
0F2F4:  MOVWF  F68
....................     
....................    data = 0; 
0F2F6:  MOVLB  8
0F2F8:  CLRF   xC1
0F2FA:  CLRF   xC0
....................     
....................    DAC_MS_byte = 0; 
0F2FC:  CLRF   xC2
....................    DAC_LS_byte = 0; 
0F2FE:  CLRF   xC3
....................     
....................    data = setting & 0b0000111100000000; 
0F300:  CLRF   xC0
0F302:  MOVF   xBF,W
0F304:  ANDLW  0F
0F306:  MOVWF  xC1
....................    data = data >> 8; 
0F308:  MOVFF  8C1,8C0
0F30C:  CLRF   xC1
....................    DAC_MS_byte = data; 
0F30E:  MOVFF  8C0,8C2
....................     
....................    data = setting & 0b0000000011111111; 
0F312:  MOVFF  8BE,8C0
0F316:  CLRF   xC1
....................    DAC_LS_byte = data; 
0F318:  MOVFF  8C0,8C3
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F31C:  MOVLW  01
0F31E:  SUBWF  xBD,W
0F320:  ADDLW  FC
0F322:  BC    F34E
0F324:  ADDLW  04
0F326:  MOVLB  0
0F328:  GOTO   F36C
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F32C:  MOVLW  30
0F32E:  MOVLB  8
0F330:  IORWF  xC2,F
....................          break; 
0F332:  BRA    F34E
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F334:  MOVLW  70
0F336:  MOVLB  8
0F338:  IORWF  xC2,F
....................          break; 
0F33A:  BRA    F34E
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F33C:  MOVLW  B0
0F33E:  MOVLB  8
0F340:  IORWF  xC2,F
....................          break; 
0F342:  BRA    F34E
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F344:  MOVLW  F0
0F346:  MOVLB  8
0F348:  IORWF  xC2,F
....................          break; 
0F34A:  BRA    F34E
0F34C:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F34E:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F350:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F352:  MOVF   F6A,W
0F354:  MOVFF  8C2,F6A
0F358:  RRCF   F68,W
0F35A:  BNC   F358
....................    spi_write2(DAC_LS_byte); 
0F35C:  MOVF   F6A,W
0F35E:  MOVFF  8C3,F6A
0F362:  RRCF   F68,W
0F364:  BNC   F362
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F366:  BSF    F8C.3
0F368:  MOVLB  0
0F36A:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F394:  MOVLB  8
0F396:  CLRF   xC2
0F398:  CLRF   xC3
0F39A:  CLRF   xC4
0F39C:  CLRF   xC5
0F39E:  CLRF   xC6
0F3A0:  CLRF   xC7
0F3A2:  CLRF   xC8
0F3A4:  CLRF   xC9
0F3A6:  CLRF   xCA
0F3A8:  CLRF   xCB
0F3AA:  CLRF   xCC
0F3AC:  CLRF   xCD
0F3AE:  CLRF   xCE
0F3B0:  CLRF   xCF
0F3B2:  CLRF   xD0
0F3B4:  CLRF   xD1
0F3B6:  CLRF   xD2
0F3B8:  CLRF   xD3
0F3BA:  CLRF   xD4
0F3BC:  CLRF   xD5
0F3BE:  CLRF   xD6
0F3C0:  CLRF   xD7
0F3C2:  CLRF   xD8
0F3C4:  CLRF   xD9
0F3C6:  CLRF   xDA
0F3C8:  CLRF   xDB
0F3CA:  CLRF   xDC
0F3CC:  CLRF   xDD
0F3CE:  CLRF   xDE
0F3D0:  CLRF   xDF
0F3D2:  CLRF   xE0
0F3D4:  CLRF   xE1
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F3D6:  CLRF   xE2
0F3D8:  CLRF   xE3
0F3DA:  CLRF   xE4
0F3DC:  CLRF   xE5
0F3DE:  CLRF   xE6
0F3E0:  CLRF   xE7
0F3E2:  CLRF   xE8
0F3E4:  CLRF   xE9
0F3E6:  CLRF   xEA
0F3E8:  CLRF   xEB
0F3EA:  CLRF   xEC
0F3EC:  CLRF   xED
0F3EE:  CLRF   xEE
0F3F0:  CLRF   xEF
0F3F2:  CLRF   xF0
0F3F4:  CLRF   xF1
0F3F6:  CLRF   xF2
0F3F8:  CLRF   xF3
0F3FA:  CLRF   xF4
0F3FC:  CLRF   xF5
0F3FE:  CLRF   xF6
0F400:  CLRF   xF7
0F402:  CLRF   xF8
0F404:  CLRF   xF9
0F406:  CLRF   xFA
0F408:  CLRF   xFB
0F40A:  CLRF   xFC
0F40C:  CLRF   xFD
0F40E:  CLRF   xFE
0F410:  CLRF   xFF
0F412:  MOVLB  9
0F414:  CLRF   x00
0F416:  CLRF   x01
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F418:  MOVLB  8
0F41A:  CLRF   xC1
0F41C:  MOVLW  01
0F41E:  MOVWF  xC0
0F420:  MOVLW  01
0F422:  ADDWF  xBD,W
0F424:  MOVWF  01
0F426:  MOVLW  00
0F428:  ADDWFC xBE,W
0F42A:  MOVWF  03
0F42C:  MOVF   xC1,W
0F42E:  SUBWF  03,W
0F430:  BTFSS  FD8.0
0F432:  BRA    F51E
0F434:  BNZ   F43C
0F436:  MOVF   01,W
0F438:  SUBWF  xC0,W
0F43A:  BC    F51E
....................    { 
....................       for (n=1; n<5; ++n) 
0F43C:  MOVLW  01
0F43E:  MOVWF  xBF
0F440:  MOVF   xBF,W
0F442:  SUBLW  04
0F444:  BNC   F516
....................       { 
....................          set_adc_channel(n,VSS); 
0F446:  RLCF   xBF,W
0F448:  MOVWF  00
0F44A:  RLCF   00,F
0F44C:  MOVLW  FC
0F44E:  ANDWF  00,F
0F450:  MOVF   FC2,W
0F452:  ANDLW  83
0F454:  IORWF  00,W
0F456:  MOVWF  FC2
0F458:  MOVLW  00
0F45A:  MOVWF  01
0F45C:  MOVF   FC1,W
0F45E:  ANDLW  F8
0F460:  IORWF  01,W
0F462:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F464:  MOVF   xBF,W
0F466:  MULLW  04
0F468:  MOVF   FF3,W
0F46A:  CLRF   03
0F46C:  ADDLW  E2
0F46E:  MOVWF  FE9
0F470:  MOVLW  08
0F472:  ADDWFC 03,W
0F474:  MOVWF  FEA
0F476:  BSF    FC2.1
0F478:  BTFSC  FC2.1
0F47A:  BRA    F478
0F47C:  MOVFF  FC3,FEF
0F480:  MOVFF  FC4,FEC
0F484:  CLRF   FEC
0F486:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F488:  MOVF   xBF,W
0F48A:  MULLW  04
0F48C:  MOVF   FF3,W
0F48E:  CLRF   03
0F490:  ADDLW  C2
0F492:  MOVWF  01
0F494:  MOVLW  08
0F496:  ADDWFC 03,F
0F498:  MOVFF  01,902
0F49C:  MOVFF  03,903
0F4A0:  MOVLB  8
0F4A2:  MOVF   xBF,W
0F4A4:  MULLW  04
0F4A6:  MOVF   FF3,W
0F4A8:  CLRF   03
0F4AA:  ADDLW  C2
0F4AC:  MOVWF  FE9
0F4AE:  MOVLW  08
0F4B0:  ADDWFC 03,W
0F4B2:  MOVWF  FEA
0F4B4:  MOVFF  FEF,904
0F4B8:  MOVFF  FEC,905
0F4BC:  MOVFF  FEC,906
0F4C0:  MOVFF  FEC,907
0F4C4:  MOVF   xBF,W
0F4C6:  MULLW  04
0F4C8:  MOVF   FF3,W
0F4CA:  CLRF   03
0F4CC:  ADDLW  E2
0F4CE:  MOVWF  FE9
0F4D0:  MOVLW  08
0F4D2:  ADDWFC 03,W
0F4D4:  MOVWF  FEA
0F4D6:  MOVFF  FEF,00
0F4DA:  MOVFF  FEC,01
0F4DE:  MOVFF  FEC,02
0F4E2:  MOVFF  FEC,03
0F4E6:  MOVLB  9
0F4E8:  MOVF   x04,W
0F4EA:  ADDWF  00,F
0F4EC:  MOVF   x05,W
0F4EE:  ADDWFC 01,F
0F4F0:  MOVF   x06,W
0F4F2:  ADDWFC 02,F
0F4F4:  MOVF   x07,W
0F4F6:  ADDWFC 03,F
0F4F8:  MOVFF  903,FEA
0F4FC:  MOVFF  902,FE9
0F500:  MOVFF  00,FEF
0F504:  MOVFF  01,FEC
0F508:  MOVFF  02,FEC
0F50C:  MOVFF  03,FEC
0F510:  MOVLB  8
0F512:  INCF   xBF,F
0F514:  BRA    F440
....................       } 
0F516:  INCF   xC0,F
0F518:  BTFSC  FD8.2
0F51A:  INCF   xC1,F
0F51C:  BRA    F420
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F51E:  MOVLW  01
0F520:  MOVWF  xBF
0F522:  MOVF   xBF,W
0F524:  SUBLW  04
0F526:  BNC   F59A
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F528:  BCF    FD8.0
0F52A:  RLCF   xBF,W
0F52C:  CLRF   03
0F52E:  ADDLW  A1
0F530:  MOVWF  01
0F532:  MOVLW  04
0F534:  ADDWFC 03,F
0F536:  MOVFF  01,902
0F53A:  MOVFF  03,903
0F53E:  MOVLB  8
0F540:  MOVF   xBF,W
0F542:  MULLW  04
0F544:  MOVF   FF3,W
0F546:  CLRF   03
0F548:  ADDLW  C2
0F54A:  MOVWF  FE9
0F54C:  MOVLW  08
0F54E:  ADDWFC 03,W
0F550:  MOVWF  FEA
0F552:  MOVFF  FEF,A31
0F556:  MOVFF  FEC,A32
0F55A:  MOVFF  FEC,A33
0F55E:  MOVFF  FEC,A34
0F562:  BCF    FD8.1
0F564:  CLRF   1B
0F566:  BTFSC  FF2.7
0F568:  BSF    1B.7
0F56A:  BCF    FF2.7
0F56C:  MOVLB  A
0F56E:  CLRF   x38
0F570:  CLRF   x37
0F572:  MOVFF  8BE,A36
0F576:  MOVFF  8BD,A35
0F57A:  MOVLB  0
0F57C:  CALL   1042
0F580:  BTFSC  1B.7
0F582:  BSF    FF2.7
0F584:  MOVFF  903,FEA
0F588:  MOVFF  902,FE9
0F58C:  MOVFF  00,FEF
0F590:  MOVFF  01,FEC
0F594:  MOVLB  8
0F596:  INCF   xBF,F
0F598:  BRA    F522
....................    } 
0F59A:  MOVLB  0
0F59C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    output_bit(PIN_J7,(!input(PIN_J7))); 
*
00E00:  BTFSS  F88.7
00E02:  BRA    0E08
00E04:  BCF    F91.7
00E06:  BRA    0E0A
00E08:  BSF    F91.7
....................     
....................    rtc_alarm = TRUE; 
00E0A:  BSF    49.0
....................    sleep_mode = FALSE; 
00E0C:  BCF    49.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E0E:  BTFSS  49.2
00E10:  BRA    0E14
....................    { 
....................       ; 
00E12:  BRA    0E0E
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E14:  BSF    49.2
....................    RTC_read_flags(); 
00E16:  RCALL  0DCC
....................    ++nv_elapsed; 
00E18:  INCF   35,F
00E1A:  BTFSC  FD8.2
00E1C:  INCF   36,F
.................... } 
....................  
00E1E:  BCF    FF2.1
00E20:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E64:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E66:  BTFSC  49.1
00E68:  BRA    0EBA
....................    { 
....................       if (kbhit(COM_A)) 
00E6A:  BTFSS  F9E.5
00E6C:  BRA    0EB8
....................       { 
....................          c = getc(COM_A); 
00E6E:  RCALL  0E24
00E70:  MOVFF  01,A1C
....................          switch (c) 
00E74:  MOVLB  A
00E76:  MOVF   x1C,W
00E78:  XORLW  3F
00E7A:  MOVLB  0
00E7C:  BZ    0E88
00E7E:  XORLW  2E
00E80:  BZ    0EAC
00E82:  XORLW  0A
00E84:  BZ    0EB2
00E86:  BRA    0EB8
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00E88:  DECFSZ 4A,W
00E8A:  BRA    0E9C
00E8C:  MOVLW  C4
00E8E:  MOVWF  FF6
00E90:  MOVLW  0E
00E92:  MOVWF  FF7
00E94:  MOVLW  00
00E96:  MOVWF  FF8
00E98:  RCALL  0E3A
00E9A:  BRA    0EAA
....................                else fprintf(COM_A, "@RDY\r\n"); 
00E9C:  MOVLW  CC
00E9E:  MOVWF  FF6
00EA0:  MOVLW  0E
00EA2:  MOVWF  FF7
00EA4:  MOVLW  00
00EA6:  MOVWF  FF8
00EA8:  RCALL  0E3A
....................                break; 
00EAA:  BRA    0EB8
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EAC:  MOVLW  01
00EAE:  MOVWF  4C
....................                break;          
00EB0:  BRA    0EB8
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EB2:  CLRF   32
00EB4:  MOVLW  01
00EB6:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00EB8:  BRA    0EBE
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00EBA:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00EBC:  BCF    F9E.5
....................    } 
00EBE:  BCF    F9E.5
00EC0:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0AE9E:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0AEA0:  MOVF   FAE,W
....................    busy_status = FALSE; 
0AEA2:  CLRF   4A
0AEA4:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
02A14:  MOVLW  01
02A16:  MOVWF  4A
....................    clear_interrupt(INT_RDA); 
02A18:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
02A1A:  BSF    F9D.5
02A1C:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00ED4:  MOVLW  0B
00ED6:  MOVWF  FD7
00ED8:  MOVLW  DC
00EDA:  MOVWF  FD6
....................    restart_wdt(); 
00EDC:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00EDE:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00EE0:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00EE2:  CLRF   FCF
00EE4:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00EE6:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00EE8:  MOVF   2F,W
00EEA:  SUBLW  02
00EEC:  BNZ   0EF4
00EEE:  MOVF   30,F
00EF0:  BNZ   0EF4
00EF2:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00EF4:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00EF6:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00EF8:  BCF    FF2.2
00EFA:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00EFE:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00F00:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00F02:  MOVF   2F,W
00F04:  SUBLW  02
00F06:  BNZ   0F0E
00F08:  MOVF   30,F
00F0A:  BNZ   0F0E
00F0C:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F0E:  BCF    F9E.0
00F10:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
1592C:  MOVLB  8
1592E:  CLRF   x76
15930:  CLRF   x7A
15932:  CLRF   x79
15934:  CLRF   x78
15936:  CLRF   x77
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
15938:  MOVLW  01
1593A:  ADDWF  x77,F
1593C:  BTFSC  FD8.0
1593E:  INCF   x78,F
15940:  BTFSC  FD8.2
15942:  INCF   x79,F
15944:  BTFSC  FD8.2
15946:  INCF   x7A,F
15948:  MOVF   x7A,F
1594A:  BNZ   1598C
1594C:  MOVF   x79,W
1594E:  SUBLW  04
15950:  BNC   1598C
15952:  BNZ   15962
15954:  MOVF   x78,W
15956:  SUBLW  93
15958:  BNC   1598C
1595A:  BNZ   15962
1595C:  MOVF   x77,W
1595E:  SUBLW  DF
15960:  BNC   1598C
....................    { 
....................       if(kbhit(COM_A)) 
15962:  BTFSS  F9E.5
15964:  BRA    15982
....................       { 
....................          c = fgetc(COM_A); 
15966:  MOVLB  0
15968:  CALL   0E24
1596C:  MOVFF  01,876
....................          if (com_echo == TRUE) 
15970:  DECFSZ 48,W
15972:  BRA    1597E
....................          { 
....................             fputc(c, COM_A); 
15974:  MOVLB  8
15976:  MOVF   x76,W
15978:  MOVLB  0
1597A:  CALL   AEA6
....................          } 
....................          break; 
1597E:  MOVLB  8
15980:  BRA    1598C
....................       } 
....................  
....................       delay_us(10); 
15982:  MOVLW  35
15984:  MOVWF  00
15986:  DECFSZ 00,F
15988:  BRA    15986
1598A:  BRA    15938
....................    } 
....................  
....................    return(c); 
1598C:  MOVFF  876,01
15990:  MOVLB  0
15992:  GOTO   159A2 (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AE1A:  MOVLW  58
0AE1C:  MOVLB  8
0AE1E:  MOVWF  x6D
0AE20:  CLRF   x71
0AE22:  CLRF   x70
0AE24:  CLRF   x6F
0AE26:  CLRF   x6E
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AE28:  MOVLW  01
0AE2A:  ADDWF  x6E,F
0AE2C:  BTFSC  FD8.0
0AE2E:  INCF   x6F,F
0AE30:  BTFSC  FD8.2
0AE32:  INCF   x70,F
0AE34:  BTFSC  FD8.2
0AE36:  INCF   x71,F
0AE38:  MOVF   x71,F
0AE3A:  BNZ   AE6A
0AE3C:  MOVF   x70,F
0AE3E:  BNZ   AE6A
0AE40:  MOVF   x6F,W
0AE42:  SUBLW  C3
0AE44:  BNC   AE6A
0AE46:  BNZ   AE4E
0AE48:  MOVF   x6E,W
0AE4A:  SUBLW  4F
0AE4C:  BNC   AE6A
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AE4E:  MOVLW  05
0AE50:  MOVWF  00
0AE52:  DECFSZ 00,F
0AE54:  BRA    AE52
....................  
....................       if(kbhit()) 
0AE56:  BTFSS  F9E.5
0AE58:  BRA    AE68
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AE5A:  MOVLB  0
0AE5C:  CALL   0E24
0AE60:  MOVFF  01,86D
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AE64:  MOVLB  8
0AE66:  BRA    AE6A
....................       } 
0AE68:  BRA    AE28
....................    } 
....................  
....................    return(EscChar); 
0AE6A:  MOVFF  86D,01
0AE6E:  MOVLB  0
0AE70:  GOTO   1B4A4 (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0D7F0:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0D7F2:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0D7F4:  BSF    F8F.3
....................    delay_ms(10); 
0D7F6:  MOVLW  0A
0D7F8:  MOVLB  9
0D7FA:  MOVWF  xD6
0D7FC:  MOVLB  0
0D7FE:  CALL   2964
0D802:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0D8DC:  MOVLB  8
0D8DE:  CLRF   xDE
0D8E0:  CLRF   xDD
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0D8E2:  MOVLB  F
0D8E4:  BTFSC  x21.1
0D8E6:  BRA    D8F4
....................       ++c; 
0D8E8:  MOVLB  8
0D8EA:  INCF   xDD,F
0D8EC:  BTFSC  FD8.2
0D8EE:  INCF   xDE,F
0D8F0:  BRA    D8E2
0D8F2:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0D8F4:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0D8F6:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0D8F8:  BCF    F8F.3
0D8FA:  MOVLB  0
0D8FC:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
16B36:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
16B38:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
16B3A:  BCF    F8F.3
16B3C:  GOTO   16C2A (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
16B40:  MOVLB  8
16B42:  CLRF   x6F
16B44:  CLRF   x70
16B46:  CLRF   xC1
16B48:  CLRF   xC2
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16B4A:  MOVLW  14
16B4C:  MOVWF  FF6
16B4E:  MOVLW  0F
16B50:  MOVWF  FF7
16B52:  MOVLW  00
16B54:  MOVWF  FF8
16B56:  CLRF   1B
16B58:  BTFSC  FF2.7
16B5A:  BSF    1B.7
16B5C:  BCF    FF2.7
16B5E:  MOVLB  0
16B60:  CALL   0E3A
16B64:  BTFSC  1B.7
16B66:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16B68:  MOVLB  8
16B6A:  MOVF   x70,W
16B6C:  SUBLW  04
16B6E:  BZ    16C26
....................    { 
....................        if (kbhit(COM_A)) 
16B70:  BTFSS  F9E.5
16B72:  BRA    16C0A
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16B74:  MOVLB  0
16B76:  CALL   0E24
16B7A:  MOVFF  01,86F
....................           if (com_echo == TRUE) 
16B7E:  DECFSZ 48,W
16B80:  BRA    16B8C
....................           { 
....................              fputc(charFromA, COM_A); 
16B82:  MOVLB  8
16B84:  MOVF   x6F,W
16B86:  MOVLB  0
16B88:  CALL   AEA6
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16B8C:  MOVLB  8
16B8E:  MOVF   xC2,W
16B90:  SUBLW  4F
16B92:  BNC   16BE8
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
16B94:  MOVF   xC2,W
16B96:  INCF   xC2,F
16B98:  CLRF   03
16B9A:  ADDLW  71
16B9C:  MOVWF  FE9
16B9E:  MOVLW  08
16BA0:  ADDWFC 03,W
16BA2:  MOVWF  FEA
16BA4:  MOVFF  86F,FEF
....................              if (CARRIAGE_RET == charFromA) 
16BA8:  MOVF   x6F,W
16BAA:  SUBLW  0D
16BAC:  BNZ   16BE6
....................              { 
....................                 multidrop_on(); 
16BAE:  MOVLB  0
16BB0:  CALL   D7F0
....................                 for (index = 0 ; index < charCount; index++) 
16BB4:  MOVLB  8
16BB6:  CLRF   xC1
16BB8:  MOVF   xC2,W
16BBA:  SUBWF  xC1,W
16BBC:  BC    16BDC
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
16BBE:  CLRF   03
16BC0:  MOVF   xC1,W
16BC2:  ADDLW  71
16BC4:  MOVWF  FE9
16BC6:  MOVLW  08
16BC8:  ADDWFC 03,W
16BCA:  MOVWF  FEA
16BCC:  MOVFF  FEF,8C3
16BD0:  MOVF   xC3,W
16BD2:  MOVLB  0
16BD4:  BRA    16B28
16BD6:  MOVLB  8
16BD8:  INCF   xC1,F
16BDA:  BRA    16BB8
....................                 } 
....................                 charCount = 0; 
16BDC:  CLRF   xC2
....................                 multidrop_off(); 
16BDE:  MOVLB  0
16BE0:  CALL   D8DC
16BE4:  MOVLB  8
....................              } 
....................           } 
16BE6:  BRA    16C0A
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
16BE8:  MOVLW  1C
16BEA:  MOVWF  FF6
16BEC:  MOVLW  0F
16BEE:  MOVWF  FF7
16BF0:  MOVLW  00
16BF2:  MOVWF  FF8
16BF4:  CLRF   1B
16BF6:  BTFSC  FF2.7
16BF8:  BSF    1B.7
16BFA:  BCF    FF2.7
16BFC:  MOVLB  0
16BFE:  CALL   0E3A
16C02:  BTFSC  1B.7
16C04:  BSF    FF2.7
....................              charCount = 0; 
16C06:  MOVLB  8
16C08:  CLRF   xC2
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
16C0A:  BTFSS  FA4.5
16C0C:  BRA    16C24
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
16C0E:  MOVLB  0
16C10:  CALL   12BD2
16C14:  MOVFF  01,870
....................           fputc(charFromB, COM_A);                  // send data via USART 
16C18:  MOVLB  8
16C1A:  MOVF   x70,W
16C1C:  MOVLB  0
16C1E:  CALL   AEA6
16C22:  MOVLB  8
....................        } 
16C24:  BRA    16B6A
....................    } 
....................  
....................    multidrop_shdn(); 
16C26:  MOVLB  0
16C28:  BRA    16B36
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
16C2A:  MOVLW  2C
16C2C:  MOVWF  FF6
16C2E:  MOVLW  0F
16C30:  MOVWF  FF7
16C32:  MOVLW  00
16C34:  MOVWF  FF8
16C36:  CLRF   1B
16C38:  BTFSC  FF2.7
16C3A:  BSF    1B.7
16C3C:  BCF    FF2.7
16C3E:  CALL   0E3A
16C42:  BTFSC  1B.7
16C44:  BSF    FF2.7
16C46:  GOTO   16C60 (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C60C:  MOVLB  8
0C60E:  DECF   x89,F
....................    len=0; 
0C610:  CLRF   x8A
....................    do { 
....................      c=getc(); 
0C612:  MOVLB  0
0C614:  CALL   0E24
0C618:  MOVFF  01,88B
....................      if(c==8) {  // Backspace 
0C61C:  MOVLB  8
0C61E:  MOVF   x8B,W
0C620:  SUBLW  08
0C622:  BNZ   C646
....................         if(len>0) { 
0C624:  MOVF   x8A,F
0C626:  BZ    C644
....................           len--; 
0C628:  DECF   x8A,F
....................           putc(c); 
0C62A:  MOVF   x8B,W
0C62C:  MOVLB  0
0C62E:  CALL   AEA6
....................           putc(' '); 
0C632:  MOVLW  20
0C634:  CALL   AEA6
....................           putc(c); 
0C638:  MOVLB  8
0C63A:  MOVF   x8B,W
0C63C:  MOVLB  0
0C63E:  CALL   AEA6
0C642:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C644:  BRA    C674
0C646:  MOVF   x8B,W
0C648:  SUBLW  1F
0C64A:  BC    C674
0C64C:  MOVF   x8B,W
0C64E:  SUBLW  7E
0C650:  BNC   C674
....................        if(len<=max) { 
0C652:  MOVF   x8A,W
0C654:  SUBWF  x89,W
0C656:  BNC   C674
....................          s[len++]=c; 
0C658:  MOVF   x8A,W
0C65A:  INCF   x8A,F
0C65C:  ADDWF  x87,W
0C65E:  MOVWF  FE9
0C660:  MOVLW  00
0C662:  ADDWFC x88,W
0C664:  MOVWF  FEA
0C666:  MOVFF  88B,FEF
....................          putc(c); 
0C66A:  MOVF   x8B,W
0C66C:  MOVLB  0
0C66E:  CALL   AEA6
0C672:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C674:  MOVF   x8B,W
0C676:  SUBLW  0D
0C678:  BNZ   C612
....................    s[len]=0; 
0C67A:  MOVF   x8A,W
0C67C:  ADDWF  x87,W
0C67E:  MOVWF  FE9
0C680:  MOVLW  00
0C682:  ADDWFC x88,W
0C684:  MOVWF  FEA
0C686:  CLRF   FEF
0C688:  MOVLB  0
0C68A:  GOTO   CA92 (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0CA80:  MOVLW  08
0CA82:  MOVLB  8
0CA84:  MOVWF  x88
0CA86:  MOVLW  6F
0CA88:  MOVWF  x87
0CA8A:  MOVLW  14
0CA8C:  MOVWF  x89
0CA8E:  MOVLB  0
0CA90:  BRA    C60C
....................   f = atof(s); 
0CA92:  MOVLW  08
0CA94:  MOVLB  8
0CA96:  MOVWF  x88
0CA98:  MOVLW  6F
0CA9A:  MOVWF  x87
0CA9C:  CLRF   x8A
0CA9E:  CLRF   x89
0CAA0:  MOVLB  0
0CAA2:  BRA    C822
0CAA4:  MOVFF  03,886
0CAA8:  MOVFF  02,885
0CAAC:  MOVFF  01,884
0CAB0:  MOVFF  00,883
....................   return(f); 
0CAB4:  MOVFF  883,00
0CAB8:  MOVFF  884,01
0CABC:  MOVFF  885,02
0CAC0:  MOVFF  886,03
0CAC4:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
0298E:  MOVLW  2F
02990:  MOVWF  F92
....................    set_tris_b(0b00110111); 
02992:  MOVLW  37
02994:  MOVWF  F93
....................    set_tris_c(0b10010000); 
02996:  MOVLW  90
02998:  MOVWF  F94
....................    set_tris_d(0b00100000); 
0299A:  MOVLW  20
0299C:  MOVWF  F95
....................    set_tris_e(0b01000000); 
0299E:  MOVLW  40
029A0:  MOVWF  F96
....................    set_tris_f(0b00000000); 
029A2:  MOVLW  00
029A4:  MOVWF  F97
....................    set_tris_g(0b11100100); 
029A6:  MOVLW  E4
029A8:  MOVWF  F98
....................    set_tris_h(0b01000000); 
029AA:  MOVLW  40
029AC:  MOVWF  F99
....................    set_tris_j(0b00000000); 
029AE:  MOVLW  00
029B0:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
029B2:  BCF    F8E.3
....................    output_low(HB_IN1); 
029B4:  BCF    F8E.4
....................    output_low(HB_IN2); 
029B6:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
029B8:  BCF    F91.3
....................    output_high(EEP_CS);        
029BA:  BSF    F91.2
....................    output_high(RTC_CS); 
029BC:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
029BE:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
029C0:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
029C2:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
029C4:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
029C6:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
029C8:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
029CA:  BCF    F8F.3
....................    delay_ms(20);   
029CC:  MOVLW  14
029CE:  MOVLB  9
029D0:  MOVWF  xD6
029D2:  MOVLB  0
029D4:  RCALL  2964
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
029D6:  BCF    F8E.1
....................    output_low(VDET);     
029D8:  BCF    F90.7
....................    bus_pwr_status=0; 
029DA:  MOVLB  4
029DC:  CLRF   xB2
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
029DE:  BSF    F8C.2
....................    output_high(DAC_CS); 
029E0:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
029E2:  BCF    F8C.0
....................    output_low(HSW2); 
029E4:  BCF    F8C.1
....................    heater_stat=0; 
029E6:  CLRF   xB1
029E8:  MOVLB  0
029EA:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
1585A:  BSF    F91.1
....................    output_low(EEP_WP);        
1585C:  BCF    F91.3
....................    output_high(EEP_CS);        
1585E:  BSF    F91.2
....................    output_high(RTC_CS);  
15860:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
15862:  BCF    F8E.3
....................    output_low(HB_IN1);        
15864:  BCF    F8E.4
....................    output_low(HB_IN2); 
15866:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
15868:  BCF    F8C.2
....................    output_low(DAC_CS); 
1586A:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
1586C:  BCF    F8C.0
....................    output_low(HSW2); 
1586E:  BCF    F8C.1
....................    heater_stat=0; 
15870:  MOVLB  4
15872:  CLRF   xB1
....................    // Power switches 
....................    output_low(VMOT);         
15874:  BCF    F8E.1
....................    output_low(VDET);  
15876:  BCF    F90.7
....................    bus_pwr_status=0; 
15878:  CLRF   xB2
....................    output_low(VENC1);         
1587A:  BCF    F8E.6
....................    output_low(VENC2);         
1587C:  BCF    F8E.7
....................    output_low(VHBRDG);  
1587E:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
15880:  MOVLW  34
15882:  MOVWF  FF6
15884:  MOVLW  0F
15886:  MOVWF  FF7
15888:  MOVLW  00
1588A:  MOVWF  FF8
1588C:  CLRF   1B
1588E:  BTFSC  FF2.7
15890:  BSF    1B.7
15892:  BCF    FF2.7
15894:  MOVLB  0
15896:  CALL   0E3A
1589A:  BTFSC  1B.7
1589C:  BSF    FF2.7
....................    delay_ms(50); 
1589E:  MOVLW  32
158A0:  MOVLB  9
158A2:  MOVWF  xD6
158A4:  MOVLB  0
158A6:  CALL   2964
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
158AA:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
158AC:  BSF    F91.6
....................    output_low(MD1_TXEN); 
158AE:  BCF    F91.5
....................    output_low(MD2_SHDN);    
158B0:  BCF    F8F.0
....................    output_low(MD2_REN); 
158B2:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
158B4:  BCF    F8F.3
....................  
....................    delay_ms(30); 
158B6:  MOVLW  1E
158B8:  MOVLB  9
158BA:  MOVWF  xD6
158BC:  MOVLB  0
158BE:  CALL   2964
158C2:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
05084:  MOVLB  8
05086:  CLRF   x73
05088:  MOVF   x73,W
0508A:  SUBLW  02
0508C:  BNC   50B2
....................       FS_Status = f_mountdrv(); 
0508E:  MOVLB  0
05090:  RCALL  48A0
05092:  MOVFF  01,720
....................       if (FS_Status) 
05096:  MOVLB  7
05098:  MOVF   x20,F
0509A:  BZ    50A6
....................          { 
....................          display_file_result(FS_Status); 
0509C:  MOVFF  720,874
050A0:  MOVLB  0
050A2:  BRA    4E3E
....................          } 
050A4:  BRA    50AC
....................       else break; 
050A6:  MOVLB  8
050A8:  BRA    50B2
050AA:  MOVLB  0
050AC:  MOVLB  8
050AE:  INCF   x73,F
050B0:  BRA    5088
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
050B2:  MOVLW  3E
050B4:  MOVWF  xD8
050B6:  CLRF   xDA
050B8:  MOVFF  720,8D9
050BC:  MOVLB  0
050BE:  RCALL  501E
....................     
....................    return(FS_Status); 
050C0:  MOVLB  7
050C2:  MOVFF  720,01
050C6:  MOVLB  0
050C8:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
03150:  MOVLW  01
03152:  MOVLB  8
03154:  MOVWF  x6D
03156:  MOVF   x6D,W
03158:  SUBLW  03
0315A:  BNC   3196
....................    { 
....................       output_bit(BOARD_LED, ON); 
0315C:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
0315E:  MOVF   2F,W
03160:  SUBLW  02
03162:  BNZ   316A
03164:  MOVF   30,F
03166:  BNZ   316A
03168:  BSF    F90.6
....................       delay_ms(32); 
0316A:  MOVLW  20
0316C:  MOVLB  9
0316E:  MOVWF  xD6
03170:  MOVLB  0
03172:  CALL   2964
....................       output_bit(BOARD_LED, OFF); 
03176:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
03178:  MOVF   2F,W
0317A:  SUBLW  02
0317C:  BNZ   3184
0317E:  MOVF   30,F
03180:  BNZ   3184
03182:  BCF    F90.6
....................       delay_ms(32); 
03184:  MOVLW  20
03186:  MOVLB  9
03188:  MOVWF  xD6
0318A:  MOVLB  0
0318C:  CALL   2964
03190:  MOVLB  8
03192:  INCF   x6D,F
03194:  BRA    3156
....................    } 
03196:  MOVLB  0
03198:  GOTO   1B2A4 (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
05146:  MOVLB  8
05148:  CLRF   xDD
0514A:  CLRF   xDC
0514C:  CLRF   xDB
0514E:  CLRF   xDA
....................    set_adc_channel(0,VSS); 
05150:  MOVLW  00
05152:  MOVWF  01
05154:  MOVF   FC2,W
05156:  ANDLW  83
05158:  IORWF  01,W
0515A:  MOVWF  FC2
0515C:  MOVLW  00
0515E:  MOVWF  01
05160:  MOVF   FC1,W
05162:  ANDLW  F8
05164:  IORWF  01,W
05166:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
05168:  MOVLW  01
0516A:  MOVWF  xD7
0516C:  MOVF   xD7,W
0516E:  SUBLW  32
05170:  BNC   5196
....................       reading=read_adc(); 
05172:  BSF    FC2.1
05174:  BTFSC  FC2.1
05176:  BRA    5174
05178:  MOVFF  FC3,8DE
0517C:  MOVFF  FC4,8DF
05180:  CLRF   xE0
05182:  CLRF   xE1
....................       delay_ms(5); 
05184:  MOVLW  05
05186:  MOVLB  9
05188:  MOVWF  xD6
0518A:  MOVLB  0
0518C:  CALL   2964
05190:  MOVLB  8
05192:  INCF   xD7,F
05194:  BRA    516C
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
05196:  MOVLW  01
05198:  MOVWF  xD7
0519A:  MOVF   xD7,W
0519C:  SUBLW  64
0519E:  BNC   524C
....................       reading=read_adc(); 
051A0:  BSF    FC2.1
051A2:  BTFSC  FC2.1
051A4:  BRA    51A2
051A6:  MOVFF  FC3,8DE
051AA:  MOVFF  FC4,8DF
051AE:  CLRF   xE0
051B0:  CLRF   xE1
....................       result=(((result*(i-1))+reading)/i); 
051B2:  MOVLW  01
051B4:  SUBWF  xD7,W
051B6:  MOVWF  xE2
051B8:  MOVFF  8DD,9E3
051BC:  MOVFF  8DC,9E2
051C0:  MOVFF  8DB,9E1
051C4:  MOVFF  8DA,9E0
051C8:  MOVLB  9
051CA:  CLRF   xE7
051CC:  CLRF   xE6
051CE:  CLRF   xE5
051D0:  MOVWF  xE4
051D2:  MOVLB  0
051D4:  CALL   4844
051D8:  MOVFF  03,8E5
051DC:  MOVFF  02,8E4
051E0:  MOVFF  01,8E3
051E4:  MOVFF  00,8E2
051E8:  MOVLB  8
051EA:  MOVF   xDE,W
051EC:  ADDWF  xE2,F
051EE:  MOVF   xDF,W
051F0:  ADDWFC xE3,F
051F2:  MOVF   xE0,W
051F4:  ADDWFC xE4,F
051F6:  MOVF   xE1,W
051F8:  ADDWFC xE5,F
051FA:  BCF    FD8.1
051FC:  CLRF   1B
051FE:  BTFSC  FF2.7
05200:  BSF    1B.7
05202:  BCF    FF2.7
05204:  MOVFF  8E5,A34
05208:  MOVFF  8E4,A33
0520C:  MOVFF  8E3,A32
05210:  MOVFF  8E2,A31
05214:  MOVLB  A
05216:  CLRF   x38
05218:  CLRF   x37
0521A:  CLRF   x36
0521C:  MOVFF  8D7,A35
05220:  MOVLB  0
05222:  CALL   1042
05226:  BTFSC  1B.7
05228:  BSF    FF2.7
0522A:  MOVFF  03,8DD
0522E:  MOVFF  02,8DC
05232:  MOVFF  01,8DB
05236:  MOVFF  00,8DA
....................       delay_ms(5); 
0523A:  MOVLW  05
0523C:  MOVLB  9
0523E:  MOVWF  xD6
05240:  MOVLB  0
05242:  CALL   2964
05246:  MOVLB  8
05248:  INCF   xD7,F
0524A:  BRA    519A
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
0524C:  MOVFF  8DD,9E3
05250:  MOVFF  8DC,9E2
05254:  MOVFF  8DB,9E1
05258:  MOVFF  8DA,9E0
0525C:  MOVLB  9
0525E:  CLRF   xE7
05260:  CLRF   xE6
05262:  CLRF   xE5
05264:  MOVLW  64
05266:  MOVWF  xE4
05268:  MOVLB  0
0526A:  CALL   4844
0526E:  MOVFF  03,8E5
05272:  MOVFF  02,8E4
05276:  MOVFF  01,8E3
0527A:  MOVFF  00,8E2
0527E:  BCF    FD8.1
05280:  CLRF   1B
05282:  BTFSC  FF2.7
05284:  BSF    1B.7
05286:  BCF    FF2.7
05288:  MOVFF  03,A34
0528C:  MOVFF  02,A33
05290:  MOVFF  01,A32
05294:  MOVFF  00,A31
05298:  MOVLB  A
0529A:  CLRF   x38
0529C:  CLRF   x37
0529E:  MOVLW  01
052A0:  MOVWF  x36
052A2:  MOVLW  10
052A4:  MOVWF  x35
052A6:  MOVLB  0
052A8:  CALL   1042
052AC:  BTFSC  1B.7
052AE:  BSF    FF2.7
052B0:  MOVLW  56
052B2:  MOVLB  8
052B4:  ADDWF  00,W
052B6:  MOVWF  xD8
052B8:  MOVLW  00
052BA:  ADDWFC 01,W
052BC:  MOVWF  xD9
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
052BE:  MOVFF  8D8,01
052C2:  MOVFF  8D9,02
052C6:  MOVLB  0
052C8:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
05130:  MOVLW  02
05132:  MOVWF  FEA
05134:  MOVLW  95
05136:  MOVWF  FE9
05138:  CLRF   00
0513A:  CLRF   02
0513C:  MOVLW  1E
0513E:  MOVWF  01
05140:  CALL   357A
05144:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
12AFA:  MOVLW  02
12AFC:  MOVWF  FEA
12AFE:  MOVLW  B3
12B00:  MOVWF  FE9
12B02:  CLRF   00
12B04:  CLRF   02
12B06:  MOVLW  1E
12B08:  MOVWF  01
12B0A:  CALL   357A
12B0E:  GOTO   12DBA (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
05464:  RCALL  5130
....................     
....................    v_supply = read_supply(); 
05466:  RCALL  5146
05468:  MOVFF  02,8D6
0546C:  MOVFF  01,8D5
....................    RTC_read(); 
05470:  CALL   3398
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
05474:  MOVLW  02
05476:  MOVWF  1E
05478:  MOVLW  95
0547A:  MOVWF  1D
0547C:  MOVFF  726,8D7
05480:  MOVLW  01
05482:  MOVLB  8
05484:  MOVWF  xD8
05486:  MOVLB  0
05488:  RCALL  52CA
0548A:  MOVLW  2F
0548C:  MOVLB  8
0548E:  MOVWF  xE9
05490:  MOVLB  0
05492:  RCALL  50E8
05494:  MOVFF  725,8D7
05498:  MOVLW  01
0549A:  MOVLB  8
0549C:  MOVWF  xD8
0549E:  MOVLB  0
054A0:  RCALL  52CA
054A2:  MOVLW  2F
054A4:  MOVLB  8
054A6:  MOVWF  xE9
054A8:  MOVLB  0
054AA:  RCALL  50E8
054AC:  MOVFF  727,8D7
054B0:  MOVLW  01
054B2:  MOVLB  8
054B4:  MOVWF  xD8
054B6:  MOVLB  0
054B8:  RCALL  52CA
054BA:  MOVLW  20
054BC:  MOVLB  8
054BE:  MOVWF  xE9
054C0:  MOVLB  0
054C2:  RCALL  50E8
054C4:  MOVFF  723,8D7
054C8:  MOVLW  01
054CA:  MOVLB  8
054CC:  MOVWF  xD8
054CE:  MOVLB  0
054D0:  RCALL  52CA
054D2:  MOVLW  3A
054D4:  MOVLB  8
054D6:  MOVWF  xE9
054D8:  MOVLB  0
054DA:  RCALL  50E8
054DC:  MOVFF  722,8D7
054E0:  MOVLW  01
054E2:  MOVLB  8
054E4:  MOVWF  xD8
054E6:  MOVLB  0
054E8:  RCALL  52CA
054EA:  MOVLW  3A
054EC:  MOVLB  8
054EE:  MOVWF  xE9
054F0:  MOVLB  0
054F2:  RCALL  50E8
054F4:  MOVFF  721,8D7
054F8:  MOVLW  01
054FA:  MOVLB  8
054FC:  MOVWF  xD8
054FE:  MOVLB  0
05500:  RCALL  52CA
05502:  MOVLW  2C
05504:  MOVLB  8
05506:  MOVWF  xE9
05508:  MOVLB  0
0550A:  RCALL  50E8
0550C:  MOVLW  44
0550E:  MOVWF  FE9
05510:  MOVLB  8
05512:  CLRF   xDA
05514:  CLRF   xD9
05516:  MOVFF  8D6,8D8
0551A:  MOVFF  8D5,8D7
0551E:  MOVLW  02
05520:  MOVWF  xDB
05522:  MOVLB  0
05524:  RCALL  5364
05526:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
0850C:  MOVLB  2
0850E:  MOVF   xD8,F
08510:  BNZ   858C
....................    { 
....................       strcopy(event_buffer,""); 
08512:  MOVLW  01
08514:  MOVWF  FEA
08516:  MOVLW  03
08518:  MOVWF  FE9
0851A:  MOVLW  00
0851C:  MOVLB  0
0851E:  CALL   02CE
08522:  TBLRD*-
08524:  TBLRD*+
08526:  MOVF   FF5,W
08528:  MOVWF  FEE
0852A:  IORLW  00
0852C:  BNZ   8524
....................       time_stamp(); 
0852E:  CALL   5464
....................       strcat(event_buffer, time_stmp_str); 
08532:  MOVLW  01
08534:  MOVLB  8
08536:  MOVWF  xE3
08538:  MOVLW  03
0853A:  MOVWF  xE2
0853C:  MOVLW  02
0853E:  MOVWF  xE5
08540:  MOVLW  95
08542:  MOVWF  xE4
08544:  MOVLB  0
08546:  CALL   5528
....................       strcat(event_buffer, event_str); 
0854A:  MOVLW  01
0854C:  MOVLB  8
0854E:  MOVWF  xE3
08550:  MOVLW  03
08552:  MOVWF  xE2
08554:  MOVLW  01
08556:  MOVWF  xE5
08558:  MOVLW  A3
0855A:  MOVWF  xE4
0855C:  MOVLB  0
0855E:  CALL   5528
....................       buffer_select = 1; 
08562:  MOVLW  01
08564:  MOVWF  x62
....................     
....................       heartbeat(FALSE); 
08566:  MOVLB  8
08568:  CLRF   xD7
0856A:  MOVLB  0
0856C:  CALL   55CC
....................          append_data(file_ptr_events); 
08570:  MOVLW  03
08572:  MOVLB  8
08574:  MOVWF  xD8
08576:  MOVLW  11
08578:  MOVWF  xD7
0857A:  MOVLB  0
0857C:  RCALL  832A
....................       heartbeat(TRUE); 
0857E:  MOVLW  01
08580:  MOVLB  8
08582:  MOVWF  xD7
08584:  MOVLB  0
08586:  CALL   55CC
0858A:  MOVLB  2
....................    } 
0858C:  MOVLB  0
0858E:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
02918:  BCF    F8B.2
0291A:  MOVLW  0C
0291C:  MOVWF  FBB
0291E:  CLRF   FBE
02920:  CLRF   FBF
02922:  MOVLW  01
02924:  MOVWF  F9C
02926:  MOVLW  F8
02928:  MOVLB  F
0292A:  ANDWF  x2D,F
0292C:  MOVLW  00
0292E:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
02930:  BCF    F8B.1
02932:  MOVLW  0C
02934:  MOVWF  x4E
02936:  CLRF   x51
02938:  CLRF   x52
0293A:  MOVLW  01
0293C:  MOVWF  x1B
0293E:  MOVLW  C7
02940:  ANDWF  x2D,F
02942:  MOVLW  00
02944:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
02946:  IORLW  05
02948:  MOVWF  FCA
0294A:  MOVLW  7F
0294C:  MOVWF  FCB
0294E:  MOVLB  0
02950:  GOTO   1B25A (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09D34:  MOVLW  3E
09D36:  MOVWF  FF6
09D38:  MOVLW  0F
09D3A:  MOVWF  FF7
09D3C:  MOVLW  00
09D3E:  MOVWF  FF8
09D40:  CLRF   1B
09D42:  BTFSC  FF2.7
09D44:  BSF    1B.7
09D46:  BCF    FF2.7
09D48:  MOVLW  05
09D4A:  MOVLB  A
09D4C:  MOVWF  x25
09D4E:  MOVLB  0
09D50:  CALL   1010
09D54:  BTFSC  1B.7
09D56:  BSF    FF2.7
09D58:  MOVLW  10
09D5A:  MOVWF  FE9
09D5C:  CLRF   1B
09D5E:  BTFSC  FF2.7
09D60:  BSF    1B.7
09D62:  BCF    FF2.7
09D64:  MOVFF  793,A26
09D68:  MOVFF  792,A25
09D6C:  CALL   1192
09D70:  BTFSC  1B.7
09D72:  BSF    FF2.7
09D74:  MOVLW  2C
09D76:  BTFSS  F9E.4
09D78:  BRA    9D76
09D7A:  MOVWF  FAD
09D7C:  MOVLW  10
09D7E:  MOVWF  FE9
09D80:  CLRF   1B
09D82:  BTFSC  FF2.7
09D84:  BSF    1B.7
09D86:  BCF    FF2.7
09D88:  MOVFF  795,A26
09D8C:  MOVFF  794,A25
09D90:  CALL   1192
09D94:  BTFSC  1B.7
09D96:  BSF    FF2.7
09D98:  MOVLW  0D
09D9A:  BTFSS  F9E.4
09D9C:  BRA    9D9A
09D9E:  MOVWF  FAD
09DA0:  MOVLW  0A
09DA2:  BTFSS  F9E.4
09DA4:  BRA    9DA2
09DA6:  MOVWF  FAD
09DA8:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02D6E:  MOVLW  86
02D70:  MOVLB  8
02D72:  MOVWF  x81
02D74:  MOVLB  0
02D76:  RCALL  2A1E
02D78:  MOVFF  02,73F
02D7C:  MOVFF  01,73E
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02D80:  MOVLW  8A
02D82:  MOVLB  8
02D84:  MOVWF  x81
02D86:  MOVLB  0
02D88:  RCALL  2A1E
02D8A:  MOVFF  02,743
02D8E:  MOVFF  01,742
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02D92:  MOVLW  8E
02D94:  MOVLB  8
02D96:  MOVWF  x81
02D98:  MOVLB  0
02D9A:  RCALL  2A1E
02D9C:  MOVFF  02,747
02DA0:  MOVFF  01,746
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02DA4:  MOVLW  92
02DA6:  MOVLB  8
02DA8:  MOVWF  x81
02DAA:  MOVLB  0
02DAC:  RCALL  2A1E
02DAE:  MOVFF  02,74B
02DB2:  MOVFF  01,74A
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02DB6:  MOVLW  96
02DB8:  MOVLB  8
02DBA:  MOVWF  x81
02DBC:  MOVLB  0
02DBE:  RCALL  2A1E
02DC0:  MOVFF  02,74F
02DC4:  MOVFF  01,74E
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02DC8:  MOVLW  9A
02DCA:  MOVLB  8
02DCC:  MOVWF  x81
02DCE:  MOVLB  0
02DD0:  RCALL  2A1E
02DD2:  MOVFF  02,753
02DD6:  MOVFF  01,752
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02DDA:  MOVLW  9E
02DDC:  MOVLB  8
02DDE:  MOVWF  x81
02DE0:  MOVLB  0
02DE2:  RCALL  2A1E
02DE4:  MOVFF  02,757
02DE8:  MOVFF  01,756
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02DEC:  MOVLW  A2
02DEE:  MOVLB  8
02DF0:  MOVWF  x81
02DF2:  MOVLB  0
02DF4:  RCALL  2A1E
02DF6:  MOVFF  02,75B
02DFA:  MOVFF  01,75A
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02DFE:  MOVLW  A6
02E00:  MOVLB  8
02E02:  MOVWF  x81
02E04:  MOVLB  0
02E06:  RCALL  2A1E
02E08:  MOVFF  02,75F
02E0C:  MOVFF  01,75E
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02E10:  MOVLW  82
02E12:  MOVLB  8
02E14:  MOVWF  x81
02E16:  MOVLB  0
02E18:  RCALL  2A1E
02E1A:  MOVFF  02,763
02E1E:  MOVFF  01,762
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02E22:  MOVLW  7E
02E24:  MOVLB  8
02E26:  MOVWF  x81
02E28:  MOVLB  0
02E2A:  RCALL  2A1E
02E2C:  MOVFF  02,7BC
02E30:  MOVFF  01,7BB
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02E34:  MOVLW  AA
02E36:  MOVLB  8
02E38:  MOVWF  x81
02E3A:  MOVLB  0
02E3C:  RCALL  2A1E
02E3E:  MOVFF  02,7C0
02E42:  MOVFF  01,7BF
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02E46:  MOVLW  7A
02E48:  MOVLB  8
02E4A:  MOVWF  x81
02E4C:  MOVLB  0
02E4E:  RCALL  2A1E
02E50:  MOVFF  02,767
02E54:  MOVFF  01,766
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02E58:  MOVLW  76
02E5A:  MOVLB  8
02E5C:  MOVWF  x81
02E5E:  MOVLB  0
02E60:  RCALL  2A1E
02E62:  MOVFF  02,76B
02E66:  MOVFF  01,76A
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02E6A:  MOVLW  72
02E6C:  MOVLB  8
02E6E:  MOVWF  x81
02E70:  MOVLB  0
02E72:  RCALL  2A1E
02E74:  MOVFF  02,76F
02E78:  MOVFF  01,76E
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02E7C:  MOVLW  6E
02E7E:  MOVLB  8
02E80:  MOVWF  x81
02E82:  MOVLB  0
02E84:  RCALL  2A1E
02E86:  MOVFF  02,793
02E8A:  MOVFF  01,792
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02E8E:  MOVLW  AE
02E90:  MOVLB  8
02E92:  MOVWF  x81
02E94:  MOVLB  0
02E96:  RCALL  2A1E
02E98:  MOVFF  02,773
02E9C:  MOVFF  01,772
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02EA0:  MOVLW  B2
02EA2:  MOVLB  8
02EA4:  MOVWF  x81
02EA6:  MOVLB  0
02EA8:  RCALL  2A1E
02EAA:  MOVFF  02,7AC
02EAE:  MOVFF  01,7AB
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02EB2:  MOVLW  B6
02EB4:  MOVLB  8
02EB6:  MOVWF  x81
02EB8:  MOVLB  0
02EBA:  RCALL  2A1E
02EBC:  MOVFF  02,7B0
02EC0:  MOVFF  01,7AF
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02EC4:  MOVLW  BA
02EC6:  MOVLB  8
02EC8:  MOVWF  x81
02ECA:  MOVLB  0
02ECC:  RCALL  2A1E
02ECE:  MOVFF  02,777
02ED2:  MOVFF  01,776
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02ED6:  MOVLW  BE
02ED8:  MOVLB  8
02EDA:  MOVWF  x81
02EDC:  MOVLB  0
02EDE:  RCALL  2A1E
02EE0:  MOVFF  02,77B
02EE4:  MOVFF  01,77A
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02EE8:  MOVLW  C2
02EEA:  MOVLB  8
02EEC:  MOVWF  x81
02EEE:  MOVLB  0
02EF0:  RCALL  2A1E
02EF2:  MOVFF  02,77F
02EF6:  MOVFF  01,77E
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02EFA:  MOVLW  88
02EFC:  MOVLB  8
02EFE:  MOVWF  x81
02F00:  MOVLB  0
02F02:  RCALL  2A1E
02F04:  MOVFF  02,741
02F08:  MOVFF  01,740
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02F0C:  MOVLW  8C
02F0E:  MOVLB  8
02F10:  MOVWF  x81
02F12:  MOVLB  0
02F14:  RCALL  2A1E
02F16:  MOVFF  02,745
02F1A:  MOVFF  01,744
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02F1E:  MOVLW  90
02F20:  MOVLB  8
02F22:  MOVWF  x81
02F24:  MOVLB  0
02F26:  RCALL  2A1E
02F28:  MOVFF  02,749
02F2C:  MOVFF  01,748
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02F30:  MOVLW  94
02F32:  MOVLB  8
02F34:  MOVWF  x81
02F36:  MOVLB  0
02F38:  RCALL  2A1E
02F3A:  MOVFF  02,74D
02F3E:  MOVFF  01,74C
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02F42:  MOVLW  98
02F44:  MOVLB  8
02F46:  MOVWF  x81
02F48:  MOVLB  0
02F4A:  RCALL  2A1E
02F4C:  MOVFF  02,751
02F50:  MOVFF  01,750
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02F54:  MOVLW  9C
02F56:  MOVLB  8
02F58:  MOVWF  x81
02F5A:  MOVLB  0
02F5C:  RCALL  2A1E
02F5E:  MOVFF  02,755
02F62:  MOVFF  01,754
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02F66:  MOVLW  A0
02F68:  MOVLB  8
02F6A:  MOVWF  x81
02F6C:  MOVLB  0
02F6E:  RCALL  2A1E
02F70:  MOVFF  02,759
02F74:  MOVFF  01,758
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02F78:  MOVLW  A4
02F7A:  MOVLB  8
02F7C:  MOVWF  x81
02F7E:  MOVLB  0
02F80:  RCALL  2A1E
02F82:  MOVFF  02,75D
02F86:  MOVFF  01,75C
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02F8A:  MOVLW  A8
02F8C:  MOVLB  8
02F8E:  MOVWF  x81
02F90:  MOVLB  0
02F92:  RCALL  2A1E
02F94:  MOVFF  02,761
02F98:  MOVFF  01,760
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02F9C:  MOVLW  84
02F9E:  MOVLB  8
02FA0:  MOVWF  x81
02FA2:  MOVLB  0
02FA4:  RCALL  2A1E
02FA6:  MOVFF  02,765
02FAA:  MOVFF  01,764
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02FAE:  MOVLW  80
02FB0:  MOVLB  8
02FB2:  MOVWF  x81
02FB4:  MOVLB  0
02FB6:  RCALL  2A1E
02FB8:  MOVFF  02,7BE
02FBC:  MOVFF  01,7BD
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02FC0:  MOVLW  AC
02FC2:  MOVLB  8
02FC4:  MOVWF  x81
02FC6:  MOVLB  0
02FC8:  RCALL  2A1E
02FCA:  MOVFF  02,7C2
02FCE:  MOVFF  01,7C1
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02FD2:  MOVLW  7C
02FD4:  MOVLB  8
02FD6:  MOVWF  x81
02FD8:  MOVLB  0
02FDA:  RCALL  2A1E
02FDC:  MOVFF  02,769
02FE0:  MOVFF  01,768
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02FE4:  MOVLW  78
02FE6:  MOVLB  8
02FE8:  MOVWF  x81
02FEA:  MOVLB  0
02FEC:  RCALL  2A1E
02FEE:  MOVFF  02,76D
02FF2:  MOVFF  01,76C
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02FF6:  MOVLW  74
02FF8:  MOVLB  8
02FFA:  MOVWF  x81
02FFC:  MOVLB  0
02FFE:  RCALL  2A1E
03000:  MOVFF  02,771
03004:  MOVFF  01,770
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
03008:  MOVLW  70
0300A:  MOVLB  8
0300C:  MOVWF  x81
0300E:  MOVLB  0
03010:  RCALL  2A1E
03012:  MOVFF  02,795
03016:  MOVFF  01,794
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
0301A:  MOVLW  B0
0301C:  MOVLB  8
0301E:  MOVWF  x81
03020:  MOVLB  0
03022:  RCALL  2A1E
03024:  MOVFF  02,775
03028:  MOVFF  01,774
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
0302C:  MOVLW  B4
0302E:  MOVLB  8
03030:  MOVWF  x81
03032:  MOVLB  0
03034:  RCALL  2A1E
03036:  MOVFF  02,7AE
0303A:  MOVFF  01,7AD
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
0303E:  MOVLW  B8
03040:  MOVLB  8
03042:  MOVWF  x81
03044:  MOVLB  0
03046:  RCALL  2A1E
03048:  MOVFF  02,7B2
0304C:  MOVFF  01,7B1
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
03050:  MOVLW  BC
03052:  MOVLB  8
03054:  MOVWF  x81
03056:  MOVLB  0
03058:  RCALL  2A1E
0305A:  MOVFF  02,779
0305E:  MOVFF  01,778
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
03062:  MOVLW  C0
03064:  MOVLB  8
03066:  MOVWF  x81
03068:  MOVLB  0
0306A:  RCALL  2A1E
0306C:  MOVFF  02,77D
03070:  MOVFF  01,77C
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
03074:  MOVLW  C4
03076:  MOVLB  8
03078:  MOVWF  x81
0307A:  MOVLB  0
0307C:  RCALL  2A1E
0307E:  MOVFF  02,781
03082:  MOVFF  01,780
....................     
....................    motor=0; 
03086:  MOVLB  7
03088:  CLRF   x3C
....................    m_fixed=1; 
0308A:  MOVLW  01
0308C:  MOVWF  x3D
....................    m_step_cnt[0]=0; 
0308E:  CLRF   xA1
03090:  CLRF   xA0
03092:  CLRF   x9F
03094:  CLRF   x9E
....................    m_step_cnt[1]=0; 
03096:  CLRF   xA5
03098:  CLRF   xA4
0309A:  CLRF   xA3
0309C:  CLRF   xA2
....................    e_cha_cnt[0]=0; 
0309E:  CLRF   xB8
030A0:  CLRF   xB7
....................    e_cha_cnt[1]=0;  
030A2:  CLRF   xBA
030A4:  CLRF   xB9
....................    m_gb_cnt[0]=0; 
030A6:  CLRF   x97
030A8:  CLRF   x96
....................    m_gb_cnt[1]=0; 
030AA:  CLRF   x99
030AC:  CLRF   x98
....................    e_mode_rst[0]=0; 
030AE:  CLRF   x9B
030B0:  CLRF   x9A
....................    e_mode_rst[1]=0;    
030B2:  CLRF   x9D
030B4:  CLRF   x9C
....................    e_port_dist[0]=0; 
030B6:  CLRF   xB4
030B8:  CLRF   xB3
....................    e_port_dist[1]=0; 
030BA:  CLRF   xB6
030BC:  CLRF   xB5
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
030BE:  MOVFF  773,8C6
030C2:  MOVFF  772,8C5
030C6:  MOVFF  75F,8C8
030CA:  MOVFF  75E,8C7
030CE:  MOVLB  0
030D0:  RCALL  2D28
030D2:  BCF    FD8.0
030D4:  MOVLB  8
030D6:  RLCF   01,W
030D8:  MOVLB  7
030DA:  MOVWF  xA7
030DC:  MOVLB  8
030DE:  RLCF   02,W
030E0:  MOVLB  7
030E2:  MOVWF  xA8
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
030E4:  MOVFF  775,8C6
030E8:  MOVFF  774,8C5
030EC:  MOVFF  761,8C8
030F0:  MOVFF  760,8C7
030F4:  MOVLB  0
030F6:  RCALL  2D28
030F8:  BCF    FD8.0
030FA:  MOVLB  8
030FC:  RLCF   01,W
030FE:  MOVLB  7
03100:  MOVWF  xA9
03102:  MOVLB  8
03104:  RLCF   02,W
03106:  MOVLB  7
03108:  MOVWF  xAA
0310A:  MOVLB  0
0310C:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
19CC2:  MOVLW  86
19CC4:  MOVLB  8
19CC6:  MOVWF  xD8
19CC8:  CLRF   xDA
19CCA:  MOVLW  01
19CCC:  MOVWF  xD9
19CCE:  MOVLB  0
19CD0:  CALL   501E
....................    write16(ADDR_M1_MODE,FULL); 
19CD4:  MOVLW  8A
19CD6:  MOVLB  8
19CD8:  MOVWF  xD8
19CDA:  CLRF   xDA
19CDC:  CLRF   xD9
19CDE:  MOVLB  0
19CE0:  CALL   501E
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
19CE4:  MOVLW  8E
19CE6:  MOVLB  8
19CE8:  MOVWF  xD8
19CEA:  CLRF   xDA
19CEC:  MOVLW  0A
19CEE:  MOVWF  xD9
19CF0:  MOVLB  0
19CF2:  CALL   501E
....................    write16(ADDR_M1_POS_DIR,0); 
19CF6:  MOVLW  92
19CF8:  MOVLB  8
19CFA:  MOVWF  xD8
19CFC:  CLRF   xDA
19CFE:  CLRF   xD9
19D00:  MOVLB  0
19D02:  CALL   501E
....................    write16(ADDR_M1_PWM_HLD,0); 
19D06:  MOVLW  96
19D08:  MOVLB  8
19D0A:  MOVWF  xD8
19D0C:  CLRF   xDA
19D0E:  CLRF   xD9
19D10:  MOVLB  0
19D12:  CALL   501E
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
19D16:  MOVLW  9A
19D18:  MOVLB  8
19D1A:  MOVWF  xD8
19D1C:  CLRF   xDA
19D1E:  MOVLW  7F
19D20:  MOVWF  xD9
19D22:  MOVLB  0
19D24:  CALL   501E
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
19D28:  MOVLW  9E
19D2A:  MOVLB  8
19D2C:  MOVWF  xD8
19D2E:  MOVLW  17
19D30:  MOVWF  xDA
19D32:  MOVLW  70
19D34:  MOVWF  xD9
19D36:  MOVLB  0
19D38:  CALL   501E
....................    write16(ADDR_E1_CPR,16); 
19D3C:  MOVLW  A2
19D3E:  MOVLB  8
19D40:  MOVWF  xD8
19D42:  CLRF   xDA
19D44:  MOVLW  10
19D46:  MOVWF  xD9
19D48:  MOVLB  0
19D4A:  CALL   501E
....................    write16(ADDR_E1_PPR,16); 
19D4E:  MOVLW  A6
19D50:  MOVLB  8
19D52:  MOVWF  xD8
19D54:  CLRF   xDA
19D56:  MOVLW  10
19D58:  MOVWF  xD9
19D5A:  MOVLB  0
19D5C:  CALL   501E
....................    write16(ADDR_E1_MODE,2); 
19D60:  MOVLW  82
19D62:  MOVLB  8
19D64:  MOVWF  xD8
19D66:  CLRF   xDA
19D68:  MOVLW  02
19D6A:  MOVWF  xD9
19D6C:  MOVLB  0
19D6E:  CALL   501E
....................    write16(ADDR_E1_POS,0); 
19D72:  MOVLW  7E
19D74:  MOVLB  8
19D76:  MOVWF  xD8
19D78:  CLRF   xDA
19D7A:  CLRF   xD9
19D7C:  MOVLB  0
19D7E:  CALL   501E
....................    write16(ADDR_E1_PORT,0); 
19D82:  MOVLW  AA
19D84:  MOVLB  8
19D86:  MOVWF  xD8
19D88:  CLRF   xDA
19D8A:  CLRF   xD9
19D8C:  MOVLB  0
19D8E:  CALL   501E
....................    write16(ADDR_E1_TYPE,2); 
19D92:  MOVLW  7A
19D94:  MOVLB  8
19D96:  MOVWF  xD8
19D98:  CLRF   xDA
19D9A:  MOVLW  02
19D9C:  MOVWF  xD9
19D9E:  MOVLB  0
19DA0:  CALL   501E
....................    write16(ADDR_M1_RUN,270); 
19DA4:  MOVLW  76
19DA6:  MOVLB  8
19DA8:  MOVWF  xD8
19DAA:  MOVLW  01
19DAC:  MOVWF  xDA
19DAE:  MOVLW  0E
19DB0:  MOVWF  xD9
19DB2:  MOVLB  0
19DB4:  CALL   501E
....................    write16(ADDR_M1_BKLSH,0); 
19DB8:  MOVLW  72
19DBA:  MOVLB  8
19DBC:  MOVWF  xD8
19DBE:  CLRF   xDA
19DC0:  CLRF   xD9
19DC2:  MOVLB  0
19DC4:  CALL   501E
....................    write16(ADDR_M1_ERROR,0);   
19DC8:  MOVLW  6E
19DCA:  MOVLB  8
19DCC:  MOVWF  xD8
19DCE:  CLRF   xDA
19DD0:  CLRF   xD9
19DD2:  MOVLB  0
19DD4:  CALL   501E
....................    write16(ADDR_M1_SPR,38400); 
19DD8:  MOVLW  AE
19DDA:  MOVLB  8
19DDC:  MOVWF  xD8
19DDE:  MOVLW  96
19DE0:  MOVWF  xDA
19DE2:  CLRF   xD9
19DE4:  MOVLB  0
19DE6:  CALL   501E
....................    write16(ADDR_M1_COMP,0); 
19DEA:  MOVLW  B2
19DEC:  MOVLB  8
19DEE:  MOVWF  xD8
19DF0:  CLRF   xDA
19DF2:  CLRF   xD9
19DF4:  MOVLB  0
19DF6:  CALL   501E
....................    write16(ADDR_M1_LIN_POS,0); 
19DFA:  MOVLW  B6
19DFC:  MOVLB  8
19DFE:  MOVWF  xD8
19E00:  CLRF   xDA
19E02:  CLRF   xD9
19E04:  MOVLB  0
19E06:  CALL   501E
....................    write16(ADDR_E1_INDEX,1); 
19E0A:  MOVLW  BA
19E0C:  MOVLB  8
19E0E:  MOVWF  xD8
19E10:  CLRF   xDA
19E12:  MOVLW  01
19E14:  MOVWF  xD9
19E16:  MOVLB  0
19E18:  CALL   501E
....................    write16(ADDR_M1_EVN_SO,0); 
19E1C:  MOVLW  BE
19E1E:  MOVLB  8
19E20:  MOVWF  xD8
19E22:  CLRF   xDA
19E24:  CLRF   xD9
19E26:  MOVLB  0
19E28:  CALL   501E
....................    write16(ADDR_M1_ALIGN_OS,0); 
19E2C:  MOVLW  C2
19E2E:  MOVLB  8
19E30:  MOVWF  xD8
19E32:  CLRF   xDA
19E34:  CLRF   xD9
19E36:  MOVLB  0
19E38:  CALL   501E
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
19E3C:  MOVLW  88
19E3E:  MOVLB  8
19E40:  MOVWF  xD8
19E42:  CLRF   xDA
19E44:  MOVLW  01
19E46:  MOVWF  xD9
19E48:  MOVLB  0
19E4A:  CALL   501E
....................    write16(ADDR_M2_MODE,HALF); 
19E4E:  MOVLW  8C
19E50:  MOVLB  8
19E52:  MOVWF  xD8
19E54:  CLRF   xDA
19E56:  MOVLW  01
19E58:  MOVWF  xD9
19E5A:  MOVLB  0
19E5C:  CALL   501E
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
19E60:  MOVLW  90
19E62:  MOVLB  8
19E64:  MOVWF  xD8
19E66:  CLRF   xDA
19E68:  MOVLW  05
19E6A:  MOVWF  xD9
19E6C:  MOVLB  0
19E6E:  CALL   501E
....................    write16(ADDR_M2_POS_DIR,0); 
19E72:  MOVLW  94
19E74:  MOVLB  8
19E76:  MOVWF  xD8
19E78:  CLRF   xDA
19E7A:  CLRF   xD9
19E7C:  MOVLB  0
19E7E:  CALL   501E
....................    write16(ADDR_M2_PWM_HLD,0); 
19E82:  MOVLW  98
19E84:  MOVLB  8
19E86:  MOVWF  xD8
19E88:  CLRF   xDA
19E8A:  CLRF   xD9
19E8C:  MOVLB  0
19E8E:  CALL   501E
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
19E92:  MOVLW  9C
19E94:  MOVLB  8
19E96:  MOVWF  xD8
19E98:  CLRF   xDA
19E9A:  MOVLW  7F
19E9C:  MOVWF  xD9
19E9E:  MOVLB  0
19EA0:  CALL   501E
....................    write16(ADDR_M2_GB_ERR,0); 
19EA4:  MOVLW  A0
19EA6:  MOVLB  8
19EA8:  MOVWF  xD8
19EAA:  CLRF   xDA
19EAC:  CLRF   xD9
19EAE:  MOVLB  0
19EB0:  CALL   501E
....................    write16(ADDR_E2_CPR,0); 
19EB4:  MOVLW  A4
19EB6:  MOVLB  8
19EB8:  MOVWF  xD8
19EBA:  CLRF   xDA
19EBC:  CLRF   xD9
19EBE:  MOVLB  0
19EC0:  CALL   501E
....................    write16(ADDR_E2_PPR,0);   
19EC4:  MOVLW  A8
19EC6:  MOVLB  8
19EC8:  MOVWF  xD8
19ECA:  CLRF   xDA
19ECC:  CLRF   xD9
19ECE:  MOVLB  0
19ED0:  CALL   501E
....................    write16(ADDR_E2_MODE,0); 
19ED4:  MOVLW  84
19ED6:  MOVLB  8
19ED8:  MOVWF  xD8
19EDA:  CLRF   xDA
19EDC:  CLRF   xD9
19EDE:  MOVLB  0
19EE0:  CALL   501E
....................    write16(ADDR_E2_POS,0); 
19EE4:  MOVLW  80
19EE6:  MOVLB  8
19EE8:  MOVWF  xD8
19EEA:  CLRF   xDA
19EEC:  CLRF   xD9
19EEE:  MOVLB  0
19EF0:  CALL   501E
....................    write16(ADDR_E2_PORT,0); 
19EF4:  MOVLW  AC
19EF6:  MOVLB  8
19EF8:  MOVWF  xD8
19EFA:  CLRF   xDA
19EFC:  CLRF   xD9
19EFE:  MOVLB  0
19F00:  CALL   501E
....................    write16(ADDR_E2_TYPE,0); 
19F04:  MOVLW  7C
19F06:  MOVLB  8
19F08:  MOVWF  xD8
19F0A:  CLRF   xDA
19F0C:  CLRF   xD9
19F0E:  MOVLB  0
19F10:  CALL   501E
....................    write16(ADDR_M2_RUN,0); 
19F14:  MOVLW  78
19F16:  MOVLB  8
19F18:  MOVWF  xD8
19F1A:  CLRF   xDA
19F1C:  CLRF   xD9
19F1E:  MOVLB  0
19F20:  CALL   501E
....................    write16(ADDR_M2_BKLSH,0); 
19F24:  MOVLW  74
19F26:  MOVLB  8
19F28:  MOVWF  xD8
19F2A:  CLRF   xDA
19F2C:  CLRF   xD9
19F2E:  MOVLB  0
19F30:  CALL   501E
....................    write16(ADDR_M2_ERROR,0);   
19F34:  MOVLW  70
19F36:  MOVLB  8
19F38:  MOVWF  xD8
19F3A:  CLRF   xDA
19F3C:  CLRF   xD9
19F3E:  MOVLB  0
19F40:  CALL   501E
....................    write16(ADDR_M2_SPR,0); 
19F44:  MOVLW  B0
19F46:  MOVLB  8
19F48:  MOVWF  xD8
19F4A:  CLRF   xDA
19F4C:  CLRF   xD9
19F4E:  MOVLB  0
19F50:  CALL   501E
....................    write16(ADDR_M2_COMP,0); 
19F54:  MOVLW  B4
19F56:  MOVLB  8
19F58:  MOVWF  xD8
19F5A:  CLRF   xDA
19F5C:  CLRF   xD9
19F5E:  MOVLB  0
19F60:  CALL   501E
....................    write16(ADDR_M2_LIN_POS,0);    
19F64:  MOVLW  B8
19F66:  MOVLB  8
19F68:  MOVWF  xD8
19F6A:  CLRF   xDA
19F6C:  CLRF   xD9
19F6E:  MOVLB  0
19F70:  CALL   501E
....................    write16(ADDR_E2_INDEX,0); 
19F74:  MOVLW  BC
19F76:  MOVLB  8
19F78:  MOVWF  xD8
19F7A:  CLRF   xDA
19F7C:  CLRF   xD9
19F7E:  MOVLB  0
19F80:  CALL   501E
....................    write16(ADDR_M2_EVN_SO,0); 
19F84:  MOVLW  C0
19F86:  MOVLB  8
19F88:  MOVWF  xD8
19F8A:  CLRF   xDA
19F8C:  CLRF   xD9
19F8E:  MOVLB  0
19F90:  CALL   501E
....................    write16(ADDR_M2_ALIGN_OS,0); 
19F94:  MOVLW  C4
19F96:  MOVLB  8
19F98:  MOVWF  xD8
19F9A:  CLRF   xDA
19F9C:  CLRF   xD9
19F9E:  MOVLB  0
19FA0:  CALL   501E
....................     
....................    get_step_vars(); 
19FA4:  CALL   2D6E
19FA8:  GOTO   1A7F2 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
19FAC:  MOVLW  86
19FAE:  MOVLB  8
19FB0:  MOVWF  xD8
19FB2:  CLRF   xDA
19FB4:  MOVLW  01
19FB6:  MOVWF  xD9
19FB8:  MOVLB  0
19FBA:  CALL   501E
....................    write16(ADDR_M1_MODE,FULL); 
19FBE:  MOVLW  8A
19FC0:  MOVLB  8
19FC2:  MOVWF  xD8
19FC4:  CLRF   xDA
19FC6:  CLRF   xD9
19FC8:  MOVLB  0
19FCA:  CALL   501E
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
19FCE:  MOVLW  8E
19FD0:  MOVLB  8
19FD2:  MOVWF  xD8
19FD4:  CLRF   xDA
19FD6:  MOVLW  14
19FD8:  MOVWF  xD9
19FDA:  MOVLB  0
19FDC:  CALL   501E
....................    write16(ADDR_M1_POS_DIR,1); 
19FE0:  MOVLW  92
19FE2:  MOVLB  8
19FE4:  MOVWF  xD8
19FE6:  CLRF   xDA
19FE8:  MOVLW  01
19FEA:  MOVWF  xD9
19FEC:  MOVLB  0
19FEE:  CALL   501E
....................    write16(ADDR_M1_PWM_HLD,51); 
19FF2:  MOVLW  96
19FF4:  MOVLB  8
19FF6:  MOVWF  xD8
19FF8:  CLRF   xDA
19FFA:  MOVLW  33
19FFC:  MOVWF  xD9
19FFE:  MOVLB  0
1A000:  CALL   501E
....................    write16(ADDR_M1_PWM_DRV,511); 
1A004:  MOVLW  9A
1A006:  MOVLB  8
1A008:  MOVWF  xD8
1A00A:  MOVLW  01
1A00C:  MOVWF  xDA
1A00E:  SETF   xD9
1A010:  MOVLB  0
1A012:  CALL   501E
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
1A016:  MOVLW  9E
1A018:  MOVLB  8
1A01A:  MOVWF  xD8
1A01C:  MOVLW  02
1A01E:  MOVWF  xDA
1A020:  MOVLW  9E
1A022:  MOVWF  xD9
1A024:  MOVLB  0
1A026:  CALL   501E
....................    write16(ADDR_E1_CPR,24); 
1A02A:  MOVLW  A2
1A02C:  MOVLB  8
1A02E:  MOVWF  xD8
1A030:  CLRF   xDA
1A032:  MOVLW  18
1A034:  MOVWF  xD9
1A036:  MOVLB  0
1A038:  CALL   501E
....................    write16(ADDR_E1_PPR,48); 
1A03C:  MOVLW  A6
1A03E:  MOVLB  8
1A040:  MOVWF  xD8
1A042:  CLRF   xDA
1A044:  MOVLW  30
1A046:  MOVWF  xD9
1A048:  MOVLB  0
1A04A:  CALL   501E
....................    write16(ADDR_E1_MODE,2); 
1A04E:  MOVLW  82
1A050:  MOVLB  8
1A052:  MOVWF  xD8
1A054:  CLRF   xDA
1A056:  MOVLW  02
1A058:  MOVWF  xD9
1A05A:  MOVLB  0
1A05C:  CALL   501E
....................    write16(ADDR_E1_POS,0); 
1A060:  MOVLW  7E
1A062:  MOVLB  8
1A064:  MOVWF  xD8
1A066:  CLRF   xDA
1A068:  CLRF   xD9
1A06A:  MOVLB  0
1A06C:  CALL   501E
....................    write16(ADDR_E1_PORT,0); 
1A070:  MOVLW  AA
1A072:  MOVLB  8
1A074:  MOVWF  xD8
1A076:  CLRF   xDA
1A078:  CLRF   xD9
1A07A:  MOVLB  0
1A07C:  CALL   501E
....................    write16(ADDR_E1_TYPE,2); 
1A080:  MOVLW  7A
1A082:  MOVLB  8
1A084:  MOVWF  xD8
1A086:  CLRF   xDA
1A088:  MOVLW  02
1A08A:  MOVWF  xD9
1A08C:  MOVLB  0
1A08E:  CALL   501E
....................    write16(ADDR_M1_RUN,34); 
1A092:  MOVLW  76
1A094:  MOVLB  8
1A096:  MOVWF  xD8
1A098:  CLRF   xDA
1A09A:  MOVLW  22
1A09C:  MOVWF  xD9
1A09E:  MOVLB  0
1A0A0:  CALL   501E
....................    write16(ADDR_M1_BKLSH,0); 
1A0A4:  MOVLW  72
1A0A6:  MOVLB  8
1A0A8:  MOVWF  xD8
1A0AA:  CLRF   xDA
1A0AC:  CLRF   xD9
1A0AE:  MOVLB  0
1A0B0:  CALL   501E
....................    write16(ADDR_M1_ERROR,0);   
1A0B4:  MOVLW  6E
1A0B6:  MOVLB  8
1A0B8:  MOVWF  xD8
1A0BA:  CLRF   xDA
1A0BC:  CLRF   xD9
1A0BE:  MOVLB  0
1A0C0:  CALL   501E
....................    write16(ADDR_M1_SPR,6400); 
1A0C4:  MOVLW  AE
1A0C6:  MOVLB  8
1A0C8:  MOVWF  xD8
1A0CA:  MOVLW  19
1A0CC:  MOVWF  xDA
1A0CE:  CLRF   xD9
1A0D0:  MOVLB  0
1A0D2:  CALL   501E
....................    write16(ADDR_M1_COMP,0); 
1A0D6:  MOVLW  B2
1A0D8:  MOVLB  8
1A0DA:  MOVWF  xD8
1A0DC:  CLRF   xDA
1A0DE:  CLRF   xD9
1A0E0:  MOVLB  0
1A0E2:  CALL   501E
....................    write16(ADDR_M1_LIN_POS,0); 
1A0E6:  MOVLW  B6
1A0E8:  MOVLB  8
1A0EA:  MOVWF  xD8
1A0EC:  CLRF   xDA
1A0EE:  CLRF   xD9
1A0F0:  MOVLB  0
1A0F2:  CALL   501E
....................    write16(ADDR_E1_INDEX,1);    
1A0F6:  MOVLW  BA
1A0F8:  MOVLB  8
1A0FA:  MOVWF  xD8
1A0FC:  CLRF   xDA
1A0FE:  MOVLW  01
1A100:  MOVWF  xD9
1A102:  MOVLB  0
1A104:  CALL   501E
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A108:  MOVLW  88
1A10A:  MOVLB  8
1A10C:  MOVWF  xD8
1A10E:  CLRF   xDA
1A110:  MOVLW  01
1A112:  MOVWF  xD9
1A114:  MOVLB  0
1A116:  CALL   501E
....................    write16(ADDR_M2_MODE,HALF); 
1A11A:  MOVLW  8C
1A11C:  MOVLB  8
1A11E:  MOVWF  xD8
1A120:  CLRF   xDA
1A122:  MOVLW  01
1A124:  MOVWF  xD9
1A126:  MOVLB  0
1A128:  CALL   501E
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A12C:  MOVLW  90
1A12E:  MOVLB  8
1A130:  MOVWF  xD8
1A132:  CLRF   xDA
1A134:  MOVLW  28
1A136:  MOVWF  xD9
1A138:  MOVLB  0
1A13A:  CALL   501E
....................    write16(ADDR_M2_POS_DIR,0); 
1A13E:  MOVLW  94
1A140:  MOVLB  8
1A142:  MOVWF  xD8
1A144:  CLRF   xDA
1A146:  CLRF   xD9
1A148:  MOVLB  0
1A14A:  CALL   501E
....................    write16(ADDR_M2_PWM_HLD,0); 
1A14E:  MOVLW  98
1A150:  MOVLB  8
1A152:  MOVWF  xD8
1A154:  CLRF   xDA
1A156:  CLRF   xD9
1A158:  MOVLB  0
1A15A:  CALL   501E
....................    write16(ADDR_M2_PWM_DRV,511); 
1A15E:  MOVLW  9C
1A160:  MOVLB  8
1A162:  MOVWF  xD8
1A164:  MOVLW  01
1A166:  MOVWF  xDA
1A168:  SETF   xD9
1A16A:  MOVLB  0
1A16C:  CALL   501E
....................    write16(ADDR_M2_GB_ERR,0); 
1A170:  MOVLW  A0
1A172:  MOVLB  8
1A174:  MOVWF  xD8
1A176:  CLRF   xDA
1A178:  CLRF   xD9
1A17A:  MOVLB  0
1A17C:  CALL   501E
....................    write16(ADDR_E2_CPR,0); 
1A180:  MOVLW  A4
1A182:  MOVLB  8
1A184:  MOVWF  xD8
1A186:  CLRF   xDA
1A188:  CLRF   xD9
1A18A:  MOVLB  0
1A18C:  CALL   501E
....................    write16(ADDR_E2_PPR,0);   
1A190:  MOVLW  A8
1A192:  MOVLB  8
1A194:  MOVWF  xD8
1A196:  CLRF   xDA
1A198:  CLRF   xD9
1A19A:  MOVLB  0
1A19C:  CALL   501E
....................    write16(ADDR_E2_MODE,0); 
1A1A0:  MOVLW  84
1A1A2:  MOVLB  8
1A1A4:  MOVWF  xD8
1A1A6:  CLRF   xDA
1A1A8:  CLRF   xD9
1A1AA:  MOVLB  0
1A1AC:  CALL   501E
....................    write16(ADDR_E2_POS,0); 
1A1B0:  MOVLW  80
1A1B2:  MOVLB  8
1A1B4:  MOVWF  xD8
1A1B6:  CLRF   xDA
1A1B8:  CLRF   xD9
1A1BA:  MOVLB  0
1A1BC:  CALL   501E
....................    write16(ADDR_E2_PORT,0); 
1A1C0:  MOVLW  AC
1A1C2:  MOVLB  8
1A1C4:  MOVWF  xD8
1A1C6:  CLRF   xDA
1A1C8:  CLRF   xD9
1A1CA:  MOVLB  0
1A1CC:  CALL   501E
....................    write16(ADDR_E2_TYPE,0); 
1A1D0:  MOVLW  7C
1A1D2:  MOVLB  8
1A1D4:  MOVWF  xD8
1A1D6:  CLRF   xDA
1A1D8:  CLRF   xD9
1A1DA:  MOVLB  0
1A1DC:  CALL   501E
....................    write16(ADDR_M2_RUN,0); 
1A1E0:  MOVLW  78
1A1E2:  MOVLB  8
1A1E4:  MOVWF  xD8
1A1E6:  CLRF   xDA
1A1E8:  CLRF   xD9
1A1EA:  MOVLB  0
1A1EC:  CALL   501E
....................    write16(ADDR_M2_BKLSH,0); 
1A1F0:  MOVLW  74
1A1F2:  MOVLB  8
1A1F4:  MOVWF  xD8
1A1F6:  CLRF   xDA
1A1F8:  CLRF   xD9
1A1FA:  MOVLB  0
1A1FC:  CALL   501E
....................    write16(ADDR_M2_ERROR,0);   
1A200:  MOVLW  70
1A202:  MOVLB  8
1A204:  MOVWF  xD8
1A206:  CLRF   xDA
1A208:  CLRF   xD9
1A20A:  MOVLB  0
1A20C:  CALL   501E
....................    write16(ADDR_M2_SPR,0); 
1A210:  MOVLW  B0
1A212:  MOVLB  8
1A214:  MOVWF  xD8
1A216:  CLRF   xDA
1A218:  CLRF   xD9
1A21A:  MOVLB  0
1A21C:  CALL   501E
....................    write16(ADDR_M2_COMP,0); 
1A220:  MOVLW  B4
1A222:  MOVLB  8
1A224:  MOVWF  xD8
1A226:  CLRF   xDA
1A228:  CLRF   xD9
1A22A:  MOVLB  0
1A22C:  CALL   501E
....................    write16(ADDR_M2_LIN_POS,0);   
1A230:  MOVLW  B8
1A232:  MOVLB  8
1A234:  MOVWF  xD8
1A236:  CLRF   xDA
1A238:  CLRF   xD9
1A23A:  MOVLB  0
1A23C:  CALL   501E
....................    write16(ADDR_E2_INDEX,0);    
1A240:  MOVLW  BC
1A242:  MOVLB  8
1A244:  MOVWF  xD8
1A246:  CLRF   xDA
1A248:  CLRF   xD9
1A24A:  MOVLB  0
1A24C:  CALL   501E
....................     
....................    get_step_vars(); 
1A250:  CALL   2D6E
1A254:  GOTO   1A7F2 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A258:  MOVLW  86
1A25A:  MOVLB  8
1A25C:  MOVWF  xD8
1A25E:  CLRF   xDA
1A260:  MOVLW  01
1A262:  MOVWF  xD9
1A264:  MOVLB  0
1A266:  CALL   501E
....................    write16(ADDR_M1_MODE,FULL); 
1A26A:  MOVLW  8A
1A26C:  MOVLB  8
1A26E:  MOVWF  xD8
1A270:  CLRF   xDA
1A272:  CLRF   xD9
1A274:  MOVLB  0
1A276:  CALL   501E
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A27A:  MOVLW  8E
1A27C:  MOVLB  8
1A27E:  MOVWF  xD8
1A280:  CLRF   xDA
1A282:  MOVLW  0A
1A284:  MOVWF  xD9
1A286:  MOVLB  0
1A288:  CALL   501E
....................    write16(ADDR_M1_POS_DIR,0); 
1A28C:  MOVLW  92
1A28E:  MOVLB  8
1A290:  MOVWF  xD8
1A292:  CLRF   xDA
1A294:  CLRF   xD9
1A296:  MOVLB  0
1A298:  CALL   501E
....................    write16(ADDR_M1_PWM_HLD,0); 
1A29C:  MOVLW  96
1A29E:  MOVLB  8
1A2A0:  MOVWF  xD8
1A2A2:  CLRF   xDA
1A2A4:  CLRF   xD9
1A2A6:  MOVLB  0
1A2A8:  CALL   501E
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A2AC:  MOVLW  9A
1A2AE:  MOVLB  8
1A2B0:  MOVWF  xD8
1A2B2:  CLRF   xDA
1A2B4:  MOVLW  7F
1A2B6:  MOVWF  xD9
1A2B8:  MOVLB  0
1A2BA:  CALL   501E
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A2BE:  MOVLW  9E
1A2C0:  MOVLB  8
1A2C2:  MOVWF  xD8
1A2C4:  MOVLW  17
1A2C6:  MOVWF  xDA
1A2C8:  MOVLW  70
1A2CA:  MOVWF  xD9
1A2CC:  MOVLB  0
1A2CE:  CALL   501E
....................    write16(ADDR_E1_CPR,16); 
1A2D2:  MOVLW  A2
1A2D4:  MOVLB  8
1A2D6:  MOVWF  xD8
1A2D8:  CLRF   xDA
1A2DA:  MOVLW  10
1A2DC:  MOVWF  xD9
1A2DE:  MOVLB  0
1A2E0:  CALL   501E
....................    write16(ADDR_E1_PPR,16); 
1A2E4:  MOVLW  A6
1A2E6:  MOVLB  8
1A2E8:  MOVWF  xD8
1A2EA:  CLRF   xDA
1A2EC:  MOVLW  10
1A2EE:  MOVWF  xD9
1A2F0:  MOVLB  0
1A2F2:  CALL   501E
....................    write16(ADDR_E1_MODE,2); 
1A2F6:  MOVLW  82
1A2F8:  MOVLB  8
1A2FA:  MOVWF  xD8
1A2FC:  CLRF   xDA
1A2FE:  MOVLW  02
1A300:  MOVWF  xD9
1A302:  MOVLB  0
1A304:  CALL   501E
....................    write16(ADDR_E1_POS,0); 
1A308:  MOVLW  7E
1A30A:  MOVLB  8
1A30C:  MOVWF  xD8
1A30E:  CLRF   xDA
1A310:  CLRF   xD9
1A312:  MOVLB  0
1A314:  CALL   501E
....................    write16(ADDR_E1_PORT,0); 
1A318:  MOVLW  AA
1A31A:  MOVLB  8
1A31C:  MOVWF  xD8
1A31E:  CLRF   xDA
1A320:  CLRF   xD9
1A322:  MOVLB  0
1A324:  CALL   501E
....................    write16(ADDR_E1_TYPE,2); 
1A328:  MOVLW  7A
1A32A:  MOVLB  8
1A32C:  MOVWF  xD8
1A32E:  CLRF   xDA
1A330:  MOVLW  02
1A332:  MOVWF  xD9
1A334:  MOVLB  0
1A336:  CALL   501E
....................    write16(ADDR_M1_RUN,270); 
1A33A:  MOVLW  76
1A33C:  MOVLB  8
1A33E:  MOVWF  xD8
1A340:  MOVLW  01
1A342:  MOVWF  xDA
1A344:  MOVLW  0E
1A346:  MOVWF  xD9
1A348:  MOVLB  0
1A34A:  CALL   501E
....................    write16(ADDR_M1_BKLSH,0); 
1A34E:  MOVLW  72
1A350:  MOVLB  8
1A352:  MOVWF  xD8
1A354:  CLRF   xDA
1A356:  CLRF   xD9
1A358:  MOVLB  0
1A35A:  CALL   501E
....................    write16(ADDR_M1_ERROR,0);   
1A35E:  MOVLW  6E
1A360:  MOVLB  8
1A362:  MOVWF  xD8
1A364:  CLRF   xDA
1A366:  CLRF   xD9
1A368:  MOVLB  0
1A36A:  CALL   501E
....................    write16(ADDR_M1_SPR,38400); 
1A36E:  MOVLW  AE
1A370:  MOVLB  8
1A372:  MOVWF  xD8
1A374:  MOVLW  96
1A376:  MOVWF  xDA
1A378:  CLRF   xD9
1A37A:  MOVLB  0
1A37C:  CALL   501E
....................    write16(ADDR_M1_COMP,0); 
1A380:  MOVLW  B2
1A382:  MOVLB  8
1A384:  MOVWF  xD8
1A386:  CLRF   xDA
1A388:  CLRF   xD9
1A38A:  MOVLB  0
1A38C:  CALL   501E
....................    write16(ADDR_M1_LIN_POS,0); 
1A390:  MOVLW  B6
1A392:  MOVLB  8
1A394:  MOVWF  xD8
1A396:  CLRF   xDA
1A398:  CLRF   xD9
1A39A:  MOVLB  0
1A39C:  CALL   501E
....................    write16(ADDR_E1_INDEX,1); 
1A3A0:  MOVLW  BA
1A3A2:  MOVLB  8
1A3A4:  MOVWF  xD8
1A3A6:  CLRF   xDA
1A3A8:  MOVLW  01
1A3AA:  MOVWF  xD9
1A3AC:  MOVLB  0
1A3AE:  CALL   501E
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A3B2:  MOVLW  88
1A3B4:  MOVLB  8
1A3B6:  MOVWF  xD8
1A3B8:  CLRF   xDA
1A3BA:  MOVLW  01
1A3BC:  MOVWF  xD9
1A3BE:  MOVLB  0
1A3C0:  CALL   501E
....................    write16(ADDR_M2_MODE,HALF); 
1A3C4:  MOVLW  8C
1A3C6:  MOVLB  8
1A3C8:  MOVWF  xD8
1A3CA:  CLRF   xDA
1A3CC:  MOVLW  01
1A3CE:  MOVWF  xD9
1A3D0:  MOVLB  0
1A3D2:  CALL   501E
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A3D6:  MOVLW  90
1A3D8:  MOVLB  8
1A3DA:  MOVWF  xD8
1A3DC:  CLRF   xDA
1A3DE:  MOVLW  64
1A3E0:  MOVWF  xD9
1A3E2:  MOVLB  0
1A3E4:  CALL   501E
....................    write16(ADDR_M2_POS_DIR,0); 
1A3E8:  MOVLW  94
1A3EA:  MOVLB  8
1A3EC:  MOVWF  xD8
1A3EE:  CLRF   xDA
1A3F0:  CLRF   xD9
1A3F2:  MOVLB  0
1A3F4:  CALL   501E
....................    write16(ADDR_M2_PWM_HLD,0); 
1A3F8:  MOVLW  98
1A3FA:  MOVLB  8
1A3FC:  MOVWF  xD8
1A3FE:  CLRF   xDA
1A400:  CLRF   xD9
1A402:  MOVLB  0
1A404:  CALL   501E
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A408:  MOVLW  9C
1A40A:  MOVLB  8
1A40C:  MOVWF  xD8
1A40E:  CLRF   xDA
1A410:  MOVLW  7F
1A412:  MOVWF  xD9
1A414:  MOVLB  0
1A416:  CALL   501E
....................    write16(ADDR_M2_GB_ERR,0); 
1A41A:  MOVLW  A0
1A41C:  MOVLB  8
1A41E:  MOVWF  xD8
1A420:  CLRF   xDA
1A422:  CLRF   xD9
1A424:  MOVLB  0
1A426:  CALL   501E
....................    write16(ADDR_E2_CPR,0); 
1A42A:  MOVLW  A4
1A42C:  MOVLB  8
1A42E:  MOVWF  xD8
1A430:  CLRF   xDA
1A432:  CLRF   xD9
1A434:  MOVLB  0
1A436:  CALL   501E
....................    write16(ADDR_E2_PPR,0);   
1A43A:  MOVLW  A8
1A43C:  MOVLB  8
1A43E:  MOVWF  xD8
1A440:  CLRF   xDA
1A442:  CLRF   xD9
1A444:  MOVLB  0
1A446:  CALL   501E
....................    write16(ADDR_E2_MODE,0); 
1A44A:  MOVLW  84
1A44C:  MOVLB  8
1A44E:  MOVWF  xD8
1A450:  CLRF   xDA
1A452:  CLRF   xD9
1A454:  MOVLB  0
1A456:  CALL   501E
....................    write16(ADDR_E2_POS,0); 
1A45A:  MOVLW  80
1A45C:  MOVLB  8
1A45E:  MOVWF  xD8
1A460:  CLRF   xDA
1A462:  CLRF   xD9
1A464:  MOVLB  0
1A466:  CALL   501E
....................    write16(ADDR_E2_PORT,0); 
1A46A:  MOVLW  AC
1A46C:  MOVLB  8
1A46E:  MOVWF  xD8
1A470:  CLRF   xDA
1A472:  CLRF   xD9
1A474:  MOVLB  0
1A476:  CALL   501E
....................    write16(ADDR_E2_TYPE,0); 
1A47A:  MOVLW  7C
1A47C:  MOVLB  8
1A47E:  MOVWF  xD8
1A480:  CLRF   xDA
1A482:  CLRF   xD9
1A484:  MOVLB  0
1A486:  CALL   501E
....................    write16(ADDR_M2_RUN,0); 
1A48A:  MOVLW  78
1A48C:  MOVLB  8
1A48E:  MOVWF  xD8
1A490:  CLRF   xDA
1A492:  CLRF   xD9
1A494:  MOVLB  0
1A496:  CALL   501E
....................    write16(ADDR_M2_BKLSH,0); 
1A49A:  MOVLW  74
1A49C:  MOVLB  8
1A49E:  MOVWF  xD8
1A4A0:  CLRF   xDA
1A4A2:  CLRF   xD9
1A4A4:  MOVLB  0
1A4A6:  CALL   501E
....................    write16(ADDR_M2_ERROR,0);   
1A4AA:  MOVLW  70
1A4AC:  MOVLB  8
1A4AE:  MOVWF  xD8
1A4B0:  CLRF   xDA
1A4B2:  CLRF   xD9
1A4B4:  MOVLB  0
1A4B6:  CALL   501E
....................    write16(ADDR_M2_SPR,0); 
1A4BA:  MOVLW  B0
1A4BC:  MOVLB  8
1A4BE:  MOVWF  xD8
1A4C0:  CLRF   xDA
1A4C2:  CLRF   xD9
1A4C4:  MOVLB  0
1A4C6:  CALL   501E
....................    write16(ADDR_M2_COMP,0); 
1A4CA:  MOVLW  B4
1A4CC:  MOVLB  8
1A4CE:  MOVWF  xD8
1A4D0:  CLRF   xDA
1A4D2:  CLRF   xD9
1A4D4:  MOVLB  0
1A4D6:  CALL   501E
....................    write16(ADDR_M2_LIN_POS,0);    
1A4DA:  MOVLW  B8
1A4DC:  MOVLB  8
1A4DE:  MOVWF  xD8
1A4E0:  CLRF   xDA
1A4E2:  CLRF   xD9
1A4E4:  MOVLB  0
1A4E6:  CALL   501E
....................     
....................    get_step_vars(); 
1A4EA:  CALL   2D6E
1A4EE:  GOTO   1A7F2 (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A4F2:  MOVLW  86
1A4F4:  MOVLB  8
1A4F6:  MOVWF  xD8
1A4F8:  CLRF   xDA
1A4FA:  MOVLW  01
1A4FC:  MOVWF  xD9
1A4FE:  MOVLB  0
1A500:  CALL   501E
....................    write16(ADDR_M1_MODE,FULL); 
1A504:  MOVLW  8A
1A506:  MOVLB  8
1A508:  MOVWF  xD8
1A50A:  CLRF   xDA
1A50C:  CLRF   xD9
1A50E:  MOVLB  0
1A510:  CALL   501E
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1A514:  MOVLW  8E
1A516:  MOVLB  8
1A518:  MOVWF  xD8
1A51A:  CLRF   xDA
1A51C:  MOVLW  28
1A51E:  MOVWF  xD9
1A520:  MOVLB  0
1A522:  CALL   501E
....................    write16(ADDR_M1_POS_DIR,1); 
1A526:  MOVLW  92
1A528:  MOVLB  8
1A52A:  MOVWF  xD8
1A52C:  CLRF   xDA
1A52E:  MOVLW  01
1A530:  MOVWF  xD9
1A532:  MOVLB  0
1A534:  CALL   501E
....................    write16(ADDR_M1_PWM_HLD,0); 
1A538:  MOVLW  96
1A53A:  MOVLB  8
1A53C:  MOVWF  xD8
1A53E:  CLRF   xDA
1A540:  CLRF   xD9
1A542:  MOVLB  0
1A544:  CALL   501E
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A548:  MOVLW  9A
1A54A:  MOVLB  8
1A54C:  MOVWF  xD8
1A54E:  CLRF   xDA
1A550:  MOVLW  7F
1A552:  MOVWF  xD9
1A554:  MOVLB  0
1A556:  CALL   501E
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1A55A:  MOVLW  9E
1A55C:  MOVLB  8
1A55E:  MOVWF  xD8
1A560:  MOVLW  02
1A562:  MOVWF  xDA
1A564:  MOVLW  9E
1A566:  MOVWF  xD9
1A568:  MOVLB  0
1A56A:  CALL   501E
....................    write16(ADDR_E1_CPR,500); 
1A56E:  MOVLW  A2
1A570:  MOVLB  8
1A572:  MOVWF  xD8
1A574:  MOVLW  01
1A576:  MOVWF  xDA
1A578:  MOVLW  F4
1A57A:  MOVWF  xD9
1A57C:  MOVLB  0
1A57E:  CALL   501E
....................    write16(ADDR_E1_PPR,50); 
1A582:  MOVLW  A6
1A584:  MOVLB  8
1A586:  MOVWF  xD8
1A588:  CLRF   xDA
1A58A:  MOVLW  32
1A58C:  MOVWF  xD9
1A58E:  MOVLB  0
1A590:  CALL   501E
....................    write16(ADDR_E1_MODE,2); 
1A594:  MOVLW  82
1A596:  MOVLB  8
1A598:  MOVWF  xD8
1A59A:  CLRF   xDA
1A59C:  MOVLW  02
1A59E:  MOVWF  xD9
1A5A0:  MOVLB  0
1A5A2:  CALL   501E
....................    write16(ADDR_E1_POS,0); 
1A5A6:  MOVLW  7E
1A5A8:  MOVLB  8
1A5AA:  MOVWF  xD8
1A5AC:  CLRF   xDA
1A5AE:  CLRF   xD9
1A5B0:  MOVLB  0
1A5B2:  CALL   501E
....................    write16(ADDR_E1_PORT,0); 
1A5B6:  MOVLW  AA
1A5B8:  MOVLB  8
1A5BA:  MOVWF  xD8
1A5BC:  CLRF   xDA
1A5BE:  CLRF   xD9
1A5C0:  MOVLB  0
1A5C2:  CALL   501E
....................    write16(ADDR_E1_TYPE,1); 
1A5C6:  MOVLW  7A
1A5C8:  MOVLB  8
1A5CA:  MOVWF  xD8
1A5CC:  CLRF   xDA
1A5CE:  MOVLW  01
1A5D0:  MOVWF  xD9
1A5D2:  MOVLB  0
1A5D4:  CALL   501E
....................    write16(ADDR_M1_RUN,0); 
1A5D8:  MOVLW  76
1A5DA:  MOVLB  8
1A5DC:  MOVWF  xD8
1A5DE:  CLRF   xDA
1A5E0:  CLRF   xD9
1A5E2:  MOVLB  0
1A5E4:  CALL   501E
....................    write16(ADDR_M1_BKLSH,1300); 
1A5E8:  MOVLW  72
1A5EA:  MOVLB  8
1A5EC:  MOVWF  xD8
1A5EE:  MOVLW  05
1A5F0:  MOVWF  xDA
1A5F2:  MOVLW  14
1A5F4:  MOVWF  xD9
1A5F6:  MOVLB  0
1A5F8:  CALL   501E
....................    write16(ADDR_M1_ERROR,0);   
1A5FC:  MOVLW  6E
1A5FE:  MOVLB  8
1A600:  MOVWF  xD8
1A602:  CLRF   xDA
1A604:  CLRF   xD9
1A606:  MOVLB  0
1A608:  CALL   501E
....................    write16(ADDR_M1_SPR,20000); 
1A60C:  MOVLW  AE
1A60E:  MOVLB  8
1A610:  MOVWF  xD8
1A612:  MOVLW  4E
1A614:  MOVWF  xDA
1A616:  MOVLW  20
1A618:  MOVWF  xD9
1A61A:  MOVLB  0
1A61C:  CALL   501E
....................    write16(ADDR_M1_COMP,0); 
1A620:  MOVLW  B2
1A622:  MOVLB  8
1A624:  MOVWF  xD8
1A626:  CLRF   xDA
1A628:  CLRF   xD9
1A62A:  MOVLB  0
1A62C:  CALL   501E
....................    write16(ADDR_M1_LIN_POS,0); 
1A630:  MOVLW  B6
1A632:  MOVLB  8
1A634:  MOVWF  xD8
1A636:  CLRF   xDA
1A638:  CLRF   xD9
1A63A:  MOVLB  0
1A63C:  CALL   501E
....................    write16(ADDR_E1_INDEX,0); 
1A640:  MOVLW  BA
1A642:  MOVLB  8
1A644:  MOVWF  xD8
1A646:  CLRF   xDA
1A648:  CLRF   xD9
1A64A:  MOVLB  0
1A64C:  CALL   501E
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A650:  MOVLW  88
1A652:  MOVLB  8
1A654:  MOVWF  xD8
1A656:  CLRF   xDA
1A658:  MOVLW  01
1A65A:  MOVWF  xD9
1A65C:  MOVLB  0
1A65E:  CALL   501E
....................    write16(ADDR_M2_MODE,HALF); 
1A662:  MOVLW  8C
1A664:  MOVLB  8
1A666:  MOVWF  xD8
1A668:  CLRF   xDA
1A66A:  MOVLW  01
1A66C:  MOVWF  xD9
1A66E:  MOVLB  0
1A670:  CALL   501E
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A674:  MOVLW  90
1A676:  MOVLB  8
1A678:  MOVWF  xD8
1A67A:  CLRF   xDA
1A67C:  MOVLW  28
1A67E:  MOVWF  xD9
1A680:  MOVLB  0
1A682:  CALL   501E
....................    write16(ADDR_M2_POS_DIR,1); 
1A686:  MOVLW  94
1A688:  MOVLB  8
1A68A:  MOVWF  xD8
1A68C:  CLRF   xDA
1A68E:  MOVLW  01
1A690:  MOVWF  xD9
1A692:  MOVLB  0
1A694:  CALL   501E
....................    write16(ADDR_M2_PWM_HLD,0); 
1A698:  MOVLW  98
1A69A:  MOVLB  8
1A69C:  MOVWF  xD8
1A69E:  CLRF   xDA
1A6A0:  CLRF   xD9
1A6A2:  MOVLB  0
1A6A4:  CALL   501E
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A6A8:  MOVLW  9C
1A6AA:  MOVLB  8
1A6AC:  MOVWF  xD8
1A6AE:  CLRF   xDA
1A6B0:  MOVLW  7F
1A6B2:  MOVWF  xD9
1A6B4:  MOVLB  0
1A6B6:  CALL   501E
....................    write16(ADDR_M2_GB_ERR,0); 
1A6BA:  MOVLW  A0
1A6BC:  MOVLB  8
1A6BE:  MOVWF  xD8
1A6C0:  CLRF   xDA
1A6C2:  CLRF   xD9
1A6C4:  MOVLB  0
1A6C6:  CALL   501E
....................    write16(ADDR_E2_CPR,0); 
1A6CA:  MOVLW  A4
1A6CC:  MOVLB  8
1A6CE:  MOVWF  xD8
1A6D0:  CLRF   xDA
1A6D2:  CLRF   xD9
1A6D4:  MOVLB  0
1A6D6:  CALL   501E
....................    write16(ADDR_E2_PPR,0);   
1A6DA:  MOVLW  A8
1A6DC:  MOVLB  8
1A6DE:  MOVWF  xD8
1A6E0:  CLRF   xDA
1A6E2:  CLRF   xD9
1A6E4:  MOVLB  0
1A6E6:  CALL   501E
....................    write16(ADDR_E2_MODE,0); 
1A6EA:  MOVLW  84
1A6EC:  MOVLB  8
1A6EE:  MOVWF  xD8
1A6F0:  CLRF   xDA
1A6F2:  CLRF   xD9
1A6F4:  MOVLB  0
1A6F6:  CALL   501E
....................    write16(ADDR_E2_POS,0); 
1A6FA:  MOVLW  80
1A6FC:  MOVLB  8
1A6FE:  MOVWF  xD8
1A700:  CLRF   xDA
1A702:  CLRF   xD9
1A704:  MOVLB  0
1A706:  CALL   501E
....................    write16(ADDR_E2_PORT,0); 
1A70A:  MOVLW  AC
1A70C:  MOVLB  8
1A70E:  MOVWF  xD8
1A710:  CLRF   xDA
1A712:  CLRF   xD9
1A714:  MOVLB  0
1A716:  CALL   501E
....................    write16(ADDR_E2_TYPE,0); 
1A71A:  MOVLW  7C
1A71C:  MOVLB  8
1A71E:  MOVWF  xD8
1A720:  CLRF   xDA
1A722:  CLRF   xD9
1A724:  MOVLB  0
1A726:  CALL   501E
....................    write16(ADDR_M2_RUN,0); 
1A72A:  MOVLW  78
1A72C:  MOVLB  8
1A72E:  MOVWF  xD8
1A730:  CLRF   xDA
1A732:  CLRF   xD9
1A734:  MOVLB  0
1A736:  CALL   501E
....................    write16(ADDR_M2_BKLSH,0); 
1A73A:  MOVLW  74
1A73C:  MOVLB  8
1A73E:  MOVWF  xD8
1A740:  CLRF   xDA
1A742:  CLRF   xD9
1A744:  MOVLB  0
1A746:  CALL   501E
....................    write16(ADDR_M2_ERROR,0);   
1A74A:  MOVLW  70
1A74C:  MOVLB  8
1A74E:  MOVWF  xD8
1A750:  CLRF   xDA
1A752:  CLRF   xD9
1A754:  MOVLB  0
1A756:  CALL   501E
....................    write16(ADDR_M2_SPR,0); 
1A75A:  MOVLW  B0
1A75C:  MOVLB  8
1A75E:  MOVWF  xD8
1A760:  CLRF   xDA
1A762:  CLRF   xD9
1A764:  MOVLB  0
1A766:  CALL   501E
....................    write16(ADDR_M2_COMP,0); 
1A76A:  MOVLW  B4
1A76C:  MOVLB  8
1A76E:  MOVWF  xD8
1A770:  CLRF   xDA
1A772:  CLRF   xD9
1A774:  MOVLB  0
1A776:  CALL   501E
....................    write16(ADDR_M2_LIN_POS,0);    
1A77A:  MOVLW  B8
1A77C:  MOVLB  8
1A77E:  MOVWF  xD8
1A780:  CLRF   xDA
1A782:  CLRF   xD9
1A784:  MOVLB  0
1A786:  CALL   501E
....................    write16(ADDR_E2_INDEX,0); 
1A78A:  MOVLW  BC
1A78C:  MOVLB  8
1A78E:  MOVWF  xD8
1A790:  CLRF   xDA
1A792:  CLRF   xD9
1A794:  MOVLB  0
1A796:  CALL   501E
....................     
....................    get_step_vars(); 
1A79A:  CALL   2D6E
1A79E:  GOTO   1A7F2 (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
029EC:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
029EE:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
029F0:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
029F2:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
029F4:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
029F6:  BCF    F90.5
....................    set_pwm1_duty(0);    
029F8:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
029FA:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
029FC:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
029FE:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
02A00:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
02A02:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
02A04:  BCF    F8D.5
....................    set_pwm2_duty(0);  
02A06:  MOVLB  F
02A08:  CLRF   x4F
....................  
....................    output_low(VENC1); 
02A0A:  BCF    F8E.6
....................    output_low(VENC2);         
02A0C:  BCF    F8E.7
....................    output_low(VHBRDG); 
02A0E:  BCF    F8E.2
02A10:  MOVLB  0
02A12:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
01246:  BCF    FD8.0
01248:  MOVLB  7
0124A:  RLCF   x3C,W
0124C:  CLRF   03
0124E:  ADDLW  4A
01250:  MOVWF  FE9
01252:  MOVLW  07
01254:  ADDWFC 03,W
01256:  MOVWF  FEA
01258:  MOVFF  FEC,A1D
0125C:  MOVF   FED,F
0125E:  MOVFF  FEF,A1C
01262:  MOVLB  A
01264:  MOVF   x1C,F
01266:  BTFSS  FD8.2
01268:  BRA    13F0
0126A:  MOVF   x1D,F
0126C:  BTFSS  FD8.2
0126E:  BRA    13F0
....................       if(m_way[motor]==POS) { 
01270:  BCF    FD8.0
01272:  MOVLB  7
01274:  RLCF   x3C,W
01276:  CLRF   03
01278:  ADDLW  82
0127A:  MOVWF  FE9
0127C:  MOVLW  07
0127E:  ADDWFC 03,W
01280:  MOVWF  FEA
01282:  MOVFF  FEC,A1D
01286:  MOVF   FED,F
01288:  MOVFF  FEF,A1C
0128C:  MOVLB  A
0128E:  MOVF   x1C,F
01290:  BNZ   132A
01292:  MOVF   x1D,F
01294:  BNZ   132A
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
01296:  BCF    FD8.0
01298:  MOVLB  7
0129A:  RLCF   x3C,W
0129C:  CLRF   03
0129E:  ADDLW  BB
012A0:  MOVWF  FE9
012A2:  MOVLW  07
012A4:  ADDWFC 03,W
012A6:  MOVWF  FEA
012A8:  MOVFF  FEC,A1D
012AC:  MOVF   FED,F
012AE:  MOVFF  FEF,A1C
012B2:  BCF    FD8.0
012B4:  RLCF   x3C,W
012B6:  CLRF   03
012B8:  ADDLW  5A
012BA:  MOVWF  FE9
012BC:  MOVLW  07
012BE:  ADDWFC 03,W
012C0:  MOVWF  FEA
012C2:  MOVFF  FEC,03
012C6:  MOVF   FED,F
012C8:  MOVFF  FEF,01
012CC:  MOVF   03,W
012CE:  MOVLB  A
012D0:  SUBWF  x1D,W
012D2:  BNC   12F6
012D4:  BNZ   12DC
012D6:  MOVF   01,W
012D8:  SUBWF  x1C,W
012DA:  BNC   12F6
012DC:  BCF    FD8.0
012DE:  MOVLB  7
012E0:  RLCF   x3C,W
012E2:  CLRF   03
012E4:  ADDLW  BB
012E6:  MOVWF  FE9
012E8:  MOVLW  07
012EA:  ADDWFC 03,W
012EC:  MOVWF  FEA
012EE:  CLRF   FEC
012F0:  MOVF   FED,F
012F2:  CLRF   FEF
012F4:  MOVLB  A
....................          e_pos[motor]++; 
012F6:  BCF    FD8.0
012F8:  MOVLB  7
012FA:  RLCF   x3C,W
012FC:  CLRF   03
012FE:  ADDLW  BB
01300:  MOVWF  FE9
01302:  MOVLW  07
01304:  ADDWFC 03,W
01306:  MOVWF  FEA
01308:  MOVLW  01
0130A:  ADDWF  FEE,F
0130C:  BNC   1310
0130E:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
01310:  BCF    FD8.0
01312:  RLCF   x3C,W
01314:  CLRF   03
01316:  ADDLW  96
01318:  MOVWF  FE9
0131A:  MOVLW  07
0131C:  ADDWFC 03,W
0131E:  MOVWF  FEA
01320:  CLRF   FEC
01322:  MOVF   FED,F
01324:  CLRF   FEF
....................       } 
01326:  BRA    13EE
01328:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
0132A:  BCF    FD8.0
0132C:  MOVLB  7
0132E:  RLCF   x3C,W
01330:  CLRF   03
01332:  ADDLW  82
01334:  MOVWF  FE9
01336:  MOVLW  07
01338:  ADDWFC 03,W
0133A:  MOVWF  FEA
0133C:  MOVFF  FEC,A1D
01340:  MOVF   FED,F
01342:  MOVFF  FEF,A1C
01346:  MOVLB  A
01348:  DECFSZ x1C,W
0134A:  BRA    13F0
0134C:  MOVF   x1D,F
0134E:  BNZ   13F0
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01350:  BCF    FD8.0
01352:  MOVLB  7
01354:  RLCF   x3C,W
01356:  CLRF   03
01358:  ADDLW  BB
0135A:  MOVWF  FE9
0135C:  MOVLW  07
0135E:  ADDWFC 03,W
01360:  MOVWF  FEA
01362:  MOVFF  FEC,A1D
01366:  MOVF   FED,F
01368:  MOVFF  FEF,A1C
0136C:  MOVLB  A
0136E:  MOVF   x1C,F
01370:  BNZ   13BC
01372:  MOVF   x1D,F
01374:  BNZ   13BC
01376:  BCF    FD8.0
01378:  MOVLB  7
0137A:  RLCF   x3C,W
0137C:  CLRF   03
0137E:  ADDLW  BB
01380:  MOVWF  01
01382:  MOVLW  07
01384:  ADDWFC 03,F
01386:  MOVLB  A
01388:  MOVFF  03,A1D
0138C:  BCF    FD8.0
0138E:  MOVLB  7
01390:  RLCF   x3C,W
01392:  CLRF   03
01394:  ADDLW  5A
01396:  MOVWF  FE9
01398:  MOVLW  07
0139A:  ADDWFC 03,W
0139C:  MOVWF  FEA
0139E:  MOVFF  FEC,03
013A2:  MOVF   FED,F
013A4:  MOVFF  FEF,A1E
013A8:  MOVLB  A
013AA:  MOVFF  A1D,FEA
013AE:  MOVFF  01,FE9
013B2:  MOVFF  03,FEC
013B6:  MOVF   FED,F
013B8:  MOVFF  A1E,FEF
....................          e_pos[motor]--; 
013BC:  BCF    FD8.0
013BE:  MOVLB  7
013C0:  RLCF   x3C,W
013C2:  CLRF   03
013C4:  ADDLW  BB
013C6:  MOVWF  FE9
013C8:  MOVLW  07
013CA:  ADDWFC 03,W
013CC:  MOVWF  FEA
013CE:  MOVLW  FF
013D0:  ADDWF  FEF,F
013D2:  BC    13D8
013D4:  MOVF   FEE,F
013D6:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
013D8:  BCF    FD8.0
013DA:  RLCF   x3C,W
013DC:  CLRF   03
013DE:  ADDLW  96
013E0:  MOVWF  FE9
013E2:  MOVLW  07
013E4:  ADDWFC 03,W
013E6:  MOVWF  FEA
013E8:  CLRF   FEC
013EA:  MOVF   FED,F
013EC:  CLRF   FEF
013EE:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
013F0:  BCF    FD8.0
013F2:  MOVLB  7
013F4:  RLCF   x3C,W
013F6:  CLRF   03
013F8:  ADDLW  4A
013FA:  MOVWF  FE9
013FC:  MOVLW  07
013FE:  ADDWFC 03,W
01400:  MOVWF  FEA
01402:  MOVFF  FEC,A1D
01406:  MOVF   FED,F
01408:  MOVFF  FEF,A1C
0140C:  MOVLB  A
0140E:  DECFSZ x1C,W
01410:  BRA    1598
01412:  MOVF   x1D,F
01414:  BTFSS  FD8.2
01416:  BRA    1598
....................       if(m_way[motor]==NEG) { 
01418:  BCF    FD8.0
0141A:  MOVLB  7
0141C:  RLCF   x3C,W
0141E:  CLRF   03
01420:  ADDLW  82
01422:  MOVWF  FE9
01424:  MOVLW  07
01426:  ADDWFC 03,W
01428:  MOVWF  FEA
0142A:  MOVFF  FEC,A1D
0142E:  MOVF   FED,F
01430:  MOVFF  FEF,A1C
01434:  MOVLB  A
01436:  DECFSZ x1C,W
01438:  BRA    14D2
0143A:  MOVF   x1D,F
0143C:  BNZ   14D2
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
0143E:  BCF    FD8.0
01440:  MOVLB  7
01442:  RLCF   x3C,W
01444:  CLRF   03
01446:  ADDLW  BB
01448:  MOVWF  FE9
0144A:  MOVLW  07
0144C:  ADDWFC 03,W
0144E:  MOVWF  FEA
01450:  MOVFF  FEC,A1D
01454:  MOVF   FED,F
01456:  MOVFF  FEF,A1C
0145A:  BCF    FD8.0
0145C:  RLCF   x3C,W
0145E:  CLRF   03
01460:  ADDLW  5A
01462:  MOVWF  FE9
01464:  MOVLW  07
01466:  ADDWFC 03,W
01468:  MOVWF  FEA
0146A:  MOVFF  FEC,03
0146E:  MOVF   FED,F
01470:  MOVFF  FEF,01
01474:  MOVF   03,W
01476:  MOVLB  A
01478:  SUBWF  x1D,W
0147A:  BNC   149E
0147C:  BNZ   1484
0147E:  MOVF   01,W
01480:  SUBWF  x1C,W
01482:  BNC   149E
01484:  BCF    FD8.0
01486:  MOVLB  7
01488:  RLCF   x3C,W
0148A:  CLRF   03
0148C:  ADDLW  BB
0148E:  MOVWF  FE9
01490:  MOVLW  07
01492:  ADDWFC 03,W
01494:  MOVWF  FEA
01496:  CLRF   FEC
01498:  MOVF   FED,F
0149A:  CLRF   FEF
0149C:  MOVLB  A
....................          e_pos[motor]++; 
0149E:  BCF    FD8.0
014A0:  MOVLB  7
014A2:  RLCF   x3C,W
014A4:  CLRF   03
014A6:  ADDLW  BB
014A8:  MOVWF  FE9
014AA:  MOVLW  07
014AC:  ADDWFC 03,W
014AE:  MOVWF  FEA
014B0:  MOVLW  01
014B2:  ADDWF  FEE,F
014B4:  BNC   14B8
014B6:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014B8:  BCF    FD8.0
014BA:  RLCF   x3C,W
014BC:  CLRF   03
014BE:  ADDLW  96
014C0:  MOVWF  FE9
014C2:  MOVLW  07
014C4:  ADDWFC 03,W
014C6:  MOVWF  FEA
014C8:  CLRF   FEC
014CA:  MOVF   FED,F
014CC:  CLRF   FEF
....................       } 
014CE:  BRA    1596
014D0:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
014D2:  BCF    FD8.0
014D4:  MOVLB  7
014D6:  RLCF   x3C,W
014D8:  CLRF   03
014DA:  ADDLW  82
014DC:  MOVWF  FE9
014DE:  MOVLW  07
014E0:  ADDWFC 03,W
014E2:  MOVWF  FEA
014E4:  MOVFF  FEC,A1D
014E8:  MOVF   FED,F
014EA:  MOVFF  FEF,A1C
014EE:  MOVLB  A
014F0:  MOVF   x1C,F
014F2:  BNZ   1598
014F4:  MOVF   x1D,F
014F6:  BNZ   1598
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
014F8:  BCF    FD8.0
014FA:  MOVLB  7
014FC:  RLCF   x3C,W
014FE:  CLRF   03
01500:  ADDLW  BB
01502:  MOVWF  FE9
01504:  MOVLW  07
01506:  ADDWFC 03,W
01508:  MOVWF  FEA
0150A:  MOVFF  FEC,A1D
0150E:  MOVF   FED,F
01510:  MOVFF  FEF,A1C
01514:  MOVLB  A
01516:  MOVF   x1C,F
01518:  BNZ   1564
0151A:  MOVF   x1D,F
0151C:  BNZ   1564
0151E:  BCF    FD8.0
01520:  MOVLB  7
01522:  RLCF   x3C,W
01524:  CLRF   03
01526:  ADDLW  BB
01528:  MOVWF  01
0152A:  MOVLW  07
0152C:  ADDWFC 03,F
0152E:  MOVLB  A
01530:  MOVFF  03,A1D
01534:  BCF    FD8.0
01536:  MOVLB  7
01538:  RLCF   x3C,W
0153A:  CLRF   03
0153C:  ADDLW  5A
0153E:  MOVWF  FE9
01540:  MOVLW  07
01542:  ADDWFC 03,W
01544:  MOVWF  FEA
01546:  MOVFF  FEC,03
0154A:  MOVF   FED,F
0154C:  MOVFF  FEF,A1E
01550:  MOVLB  A
01552:  MOVFF  A1D,FEA
01556:  MOVFF  01,FE9
0155A:  MOVFF  03,FEC
0155E:  MOVF   FED,F
01560:  MOVFF  A1E,FEF
....................          e_pos[motor]--; 
01564:  BCF    FD8.0
01566:  MOVLB  7
01568:  RLCF   x3C,W
0156A:  CLRF   03
0156C:  ADDLW  BB
0156E:  MOVWF  FE9
01570:  MOVLW  07
01572:  ADDWFC 03,W
01574:  MOVWF  FEA
01576:  MOVLW  FF
01578:  ADDWF  FEF,F
0157A:  BC    1580
0157C:  MOVF   FEE,F
0157E:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
01580:  BCF    FD8.0
01582:  RLCF   x3C,W
01584:  CLRF   03
01586:  ADDLW  96
01588:  MOVWF  FE9
0158A:  MOVLW  07
0158C:  ADDWFC 03,W
0158E:  MOVWF  FEA
01590:  CLRF   FEC
01592:  MOVF   FED,F
01594:  CLRF   FEF
01596:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
01598:  MOVF   1F,W
0159A:  SUBLW  04
0159C:  BTFSS  FD8.2
0159E:  BRA    16D2
015A0:  MOVF   20,F
015A2:  BTFSS  FD8.2
015A4:  BRA    16D2
015A6:  BCF    FD8.0
015A8:  MOVLB  7
015AA:  RLCF   x3C,W
015AC:  CLRF   03
015AE:  ADDLW  66
015B0:  MOVWF  FE9
015B2:  MOVLW  07
015B4:  ADDWFC 03,W
015B6:  MOVWF  FEA
015B8:  MOVFF  FEC,A1D
015BC:  MOVF   FED,F
015BE:  MOVFF  FEF,A1C
015C2:  MOVLB  A
015C4:  MOVF   x1C,W
015C6:  SUBLW  02
015C8:  BTFSS  FD8.2
015CA:  BRA    16D2
015CC:  MOVF   x1D,F
015CE:  BTFSS  FD8.2
015D0:  BRA    16D2
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
015D2:  MOVLW  01
015D4:  MOVLB  7
015D6:  ADDWF  x3C,W
015D8:  MOVLB  A
015DA:  MOVWF  x1C
015DC:  MOVLB  7
015DE:  MOVF   x3C,W
015E0:  MULLW  04
015E2:  MOVF   FF3,W
015E4:  CLRF   03
015E6:  ADDLW  9E
015E8:  MOVWF  FE9
015EA:  MOVLW  07
015EC:  ADDWFC 03,W
015EE:  MOVWF  FEA
015F0:  MOVFF  FEF,A1D
015F4:  MOVFF  FEC,A1E
015F8:  MOVFF  FEC,A1F
015FC:  MOVFF  FEC,A20
01600:  BCF    FD8.0
01602:  RLCF   x3C,W
01604:  CLRF   03
01606:  ADDLW  B7
01608:  MOVWF  FE9
0160A:  MOVLW  07
0160C:  ADDWFC 03,W
0160E:  MOVWF  FEA
01610:  MOVFF  FEC,A22
01614:  MOVF   FED,F
01616:  MOVFF  FEF,A21
0161A:  BCF    FD8.0
0161C:  RLCF   x3C,W
0161E:  CLRF   03
01620:  ADDLW  BB
01622:  MOVWF  FE9
01624:  MOVLW  07
01626:  ADDWFC 03,W
01628:  MOVWF  FEA
0162A:  MOVFF  FEC,A24
0162E:  MOVF   FED,F
01630:  MOVFF  FEF,A23
01634:  MOVLW  6D
01636:  BTFSS  F9E.4
01638:  BRA    1636
0163A:  MOVWF  FAD
0163C:  MOVLW  3A
0163E:  BTFSS  F9E.4
01640:  BRA    163E
01642:  MOVWF  FAD
01644:  MOVFF  A1C,A25
01648:  MOVLW  1B
0164A:  MOVLB  A
0164C:  MOVWF  x26
0164E:  MOVLB  0
01650:  RCALL  0F92
01652:  MOVLW  2C
01654:  BTFSS  F9E.4
01656:  BRA    1654
01658:  MOVWF  FAD
0165A:  MOVFF  7A6,A25
0165E:  MOVLW  1B
01660:  MOVLB  A
01662:  MOVWF  x26
01664:  MOVLB  0
01666:  RCALL  0F92
01668:  MOVLW  55
0166A:  MOVWF  FF6
0166C:  MOVLW  0F
0166E:  MOVWF  FF7
01670:  MOVLW  00
01672:  MOVWF  FF8
01674:  MOVLW  03
01676:  MOVLB  A
01678:  MOVWF  x25
0167A:  MOVLB  0
0167C:  RCALL  1010
0167E:  MOVLW  41
01680:  MOVWF  FE9
01682:  MOVFF  A20,A28
01686:  MOVFF  A1F,A27
0168A:  MOVFF  A1E,A26
0168E:  MOVFF  A1D,A25
01692:  RCALL  10D6
01694:  MOVLW  2C
01696:  BTFSS  F9E.4
01698:  BRA    1696
0169A:  MOVWF  FAD
0169C:  MOVLW  10
0169E:  MOVWF  FE9
016A0:  MOVFF  A22,A26
016A4:  MOVFF  A21,A25
016A8:  RCALL  1192
016AA:  MOVLW  2C
016AC:  BTFSS  F9E.4
016AE:  BRA    16AC
016B0:  MOVWF  FAD
016B2:  MOVLW  10
016B4:  MOVWF  FE9
016B6:  MOVFF  A24,A26
016BA:  MOVFF  A23,A25
016BE:  RCALL  1192
016C0:  MOVLW  0D
016C2:  BTFSS  F9E.4
016C4:  BRA    16C2
016C6:  MOVWF  FAD
016C8:  MOVLW  0A
016CA:  BTFSS  F9E.4
016CC:  BRA    16CA
016CE:  MOVWF  FAD
016D0:  MOVLB  A
....................    }    
016D2:  MOVLB  0
016D4:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A7B4:  MOVLB  7
0A7B6:  MOVF   x3C,W
0A7B8:  XORLW  00
0A7BA:  MOVLB  0
0A7BC:  BZ    A7C4
0A7BE:  XORLW  01
0A7C0:  BZ    A854
0A7C2:  BRA    A8E2
....................       case 0 : if (e_type[motor]==1) { 
0A7C4:  BCF    FD8.0
0A7C6:  MOVLB  7
0A7C8:  RLCF   x3C,W
0A7CA:  CLRF   03
0A7CC:  ADDLW  66
0A7CE:  MOVWF  FE9
0A7D0:  MOVLW  07
0A7D2:  ADDWFC 03,W
0A7D4:  MOVWF  FEA
0A7D6:  MOVFF  FEC,8B2
0A7DA:  MOVF   FED,F
0A7DC:  MOVFF  FEF,8B1
0A7E0:  MOVLB  8
0A7E2:  DECFSZ xB1,W
0A7E4:  BRA    A804
0A7E6:  MOVF   xB2,F
0A7E8:  BNZ   A804
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A7EA:  CLRF   03
0A7EC:  MOVLB  7
0A7EE:  MOVF   x3C,W
0A7F0:  ADDLW  C7
0A7F2:  MOVWF  FE9
0A7F4:  MOVLW  07
0A7F6:  ADDWFC 03,W
0A7F8:  MOVWF  FEA
0A7FA:  MOVLW  00
0A7FC:  BTFSC  F81.4
0A7FE:  MOVLW  01
0A800:  MOVWF  FEF
0A802:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A804:  BCF    FD8.0
0A806:  MOVLB  7
0A808:  RLCF   x3C,W
0A80A:  CLRF   03
0A80C:  ADDLW  66
0A80E:  MOVWF  FE9
0A810:  MOVLW  07
0A812:  ADDWFC 03,W
0A814:  MOVWF  FEA
0A816:  MOVFF  FEC,8B2
0A81A:  MOVF   FED,F
0A81C:  MOVFF  FEF,8B1
0A820:  MOVLB  8
0A822:  MOVF   xB1,W
0A824:  SUBLW  02
0A826:  BNZ   A850
0A828:  MOVF   xB2,F
0A82A:  BNZ   A850
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A82C:  CLRF   03
0A82E:  MOVLB  7
0A830:  MOVF   x3C,W
0A832:  ADDLW  C7
0A834:  MOVWF  FE9
0A836:  MOVLW  07
0A838:  ADDWFC 03,W
0A83A:  MOVWF  FEA
0A83C:  MOVLW  00
0A83E:  BTFSC  F81.4
0A840:  MOVLW  01
0A842:  MOVLB  8
0A844:  MOVWF  xB3
0A846:  MOVLW  00
0A848:  BTFSC  F81.1
0A84A:  MOVLW  01
0A84C:  ANDWF  xB3,W
0A84E:  MOVWF  FEF
....................                } 
....................          break; 
0A850:  MOVLB  0
0A852:  BRA    A8E2
....................       case 1 : if (e_type[motor]==1) { 
0A854:  BCF    FD8.0
0A856:  MOVLB  7
0A858:  RLCF   x3C,W
0A85A:  CLRF   03
0A85C:  ADDLW  66
0A85E:  MOVWF  FE9
0A860:  MOVLW  07
0A862:  ADDWFC 03,W
0A864:  MOVWF  FEA
0A866:  MOVFF  FEC,8B2
0A86A:  MOVF   FED,F
0A86C:  MOVFF  FEF,8B1
0A870:  MOVLB  8
0A872:  DECFSZ xB1,W
0A874:  BRA    A894
0A876:  MOVF   xB2,F
0A878:  BNZ   A894
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A87A:  CLRF   03
0A87C:  MOVLB  7
0A87E:  MOVF   x3C,W
0A880:  ADDLW  C7
0A882:  MOVWF  FE9
0A884:  MOVLW  07
0A886:  ADDWFC 03,W
0A888:  MOVWF  FEA
0A88A:  MOVLW  00
0A88C:  BTFSC  F81.5
0A88E:  MOVLW  01
0A890:  MOVWF  FEF
0A892:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A894:  BCF    FD8.0
0A896:  MOVLB  7
0A898:  RLCF   x3C,W
0A89A:  CLRF   03
0A89C:  ADDLW  66
0A89E:  MOVWF  FE9
0A8A0:  MOVLW  07
0A8A2:  ADDWFC 03,W
0A8A4:  MOVWF  FEA
0A8A6:  MOVFF  FEC,8B2
0A8AA:  MOVF   FED,F
0A8AC:  MOVFF  FEF,8B1
0A8B0:  MOVLB  8
0A8B2:  MOVF   xB1,W
0A8B4:  SUBLW  02
0A8B6:  BNZ   A8E0
0A8B8:  MOVF   xB2,F
0A8BA:  BNZ   A8E0
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A8BC:  CLRF   03
0A8BE:  MOVLB  7
0A8C0:  MOVF   x3C,W
0A8C2:  ADDLW  C7
0A8C4:  MOVWF  FE9
0A8C6:  MOVLW  07
0A8C8:  ADDWFC 03,W
0A8CA:  MOVWF  FEA
0A8CC:  MOVLW  00
0A8CE:  BTFSC  F81.5
0A8D0:  MOVLW  01
0A8D2:  MOVLB  8
0A8D4:  MOVWF  xB3
0A8D6:  MOVLW  00
0A8D8:  BTFSC  F81.2
0A8DA:  MOVLW  01
0A8DC:  ANDWF  xB3,W
0A8DE:  MOVWF  FEF
....................                } 
....................          break; 
0A8E0:  MOVLB  0
....................    } 
0A8E2:  GOTO   A99C (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017C2:  MOVLB  7
017C4:  MOVF   x3C,W
017C6:  XORLW  00
017C8:  MOVLB  0
017CA:  BZ    17D2
017CC:  XORLW  01
017CE:  BZ    1862
017D0:  BRA    18F0
....................       case 0 : if (e_type[motor]==1) { 
017D2:  BCF    FD8.0
017D4:  MOVLB  7
017D6:  RLCF   x3C,W
017D8:  CLRF   03
017DA:  ADDLW  66
017DC:  MOVWF  FE9
017DE:  MOVLW  07
017E0:  ADDWFC 03,W
017E2:  MOVWF  FEA
017E4:  MOVFF  FEC,A1D
017E8:  MOVF   FED,F
017EA:  MOVFF  FEF,A1C
017EE:  MOVLB  A
017F0:  DECFSZ x1C,W
017F2:  BRA    1812
017F4:  MOVF   x1D,F
017F6:  BNZ   1812
....................                   e_ch_n[motor]=input(ENC1_IND); 
017F8:  CLRF   03
017FA:  MOVLB  7
017FC:  MOVF   x3C,W
017FE:  ADDLW  C7
01800:  MOVWF  FE9
01802:  MOVLW  07
01804:  ADDWFC 03,W
01806:  MOVWF  FEA
01808:  MOVLW  00
0180A:  BTFSC  F81.4
0180C:  MOVLW  01
0180E:  MOVWF  FEF
01810:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
01812:  BCF    FD8.0
01814:  MOVLB  7
01816:  RLCF   x3C,W
01818:  CLRF   03
0181A:  ADDLW  66
0181C:  MOVWF  FE9
0181E:  MOVLW  07
01820:  ADDWFC 03,W
01822:  MOVWF  FEA
01824:  MOVFF  FEC,A1D
01828:  MOVF   FED,F
0182A:  MOVFF  FEF,A1C
0182E:  MOVLB  A
01830:  MOVF   x1C,W
01832:  SUBLW  02
01834:  BNZ   185E
01836:  MOVF   x1D,F
01838:  BNZ   185E
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0183A:  CLRF   03
0183C:  MOVLB  7
0183E:  MOVF   x3C,W
01840:  ADDLW  C7
01842:  MOVWF  FE9
01844:  MOVLW  07
01846:  ADDWFC 03,W
01848:  MOVWF  FEA
0184A:  MOVLW  00
0184C:  BTFSC  F81.4
0184E:  MOVLW  01
01850:  MOVLB  A
01852:  MOVWF  x1E
01854:  MOVLW  00
01856:  BTFSC  F81.1
01858:  MOVLW  01
0185A:  ANDWF  x1E,W
0185C:  MOVWF  FEF
....................                } 
....................          break; 
0185E:  MOVLB  0
01860:  BRA    18F0
....................       case 1 : if (e_type[motor]==1) { 
01862:  BCF    FD8.0
01864:  MOVLB  7
01866:  RLCF   x3C,W
01868:  CLRF   03
0186A:  ADDLW  66
0186C:  MOVWF  FE9
0186E:  MOVLW  07
01870:  ADDWFC 03,W
01872:  MOVWF  FEA
01874:  MOVFF  FEC,A1D
01878:  MOVF   FED,F
0187A:  MOVFF  FEF,A1C
0187E:  MOVLB  A
01880:  DECFSZ x1C,W
01882:  BRA    18A2
01884:  MOVF   x1D,F
01886:  BNZ   18A2
....................                   e_ch_n[motor]=input(ENC2_IND); 
01888:  CLRF   03
0188A:  MOVLB  7
0188C:  MOVF   x3C,W
0188E:  ADDLW  C7
01890:  MOVWF  FE9
01892:  MOVLW  07
01894:  ADDWFC 03,W
01896:  MOVWF  FEA
01898:  MOVLW  00
0189A:  BTFSC  F81.5
0189C:  MOVLW  01
0189E:  MOVWF  FEF
018A0:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
018A2:  BCF    FD8.0
018A4:  MOVLB  7
018A6:  RLCF   x3C,W
018A8:  CLRF   03
018AA:  ADDLW  66
018AC:  MOVWF  FE9
018AE:  MOVLW  07
018B0:  ADDWFC 03,W
018B2:  MOVWF  FEA
018B4:  MOVFF  FEC,A1D
018B8:  MOVF   FED,F
018BA:  MOVFF  FEF,A1C
018BE:  MOVLB  A
018C0:  MOVF   x1C,W
018C2:  SUBLW  02
018C4:  BNZ   18EE
018C6:  MOVF   x1D,F
018C8:  BNZ   18EE
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018CA:  CLRF   03
018CC:  MOVLB  7
018CE:  MOVF   x3C,W
018D0:  ADDLW  C7
018D2:  MOVWF  FE9
018D4:  MOVLW  07
018D6:  ADDWFC 03,W
018D8:  MOVWF  FEA
018DA:  MOVLW  00
018DC:  BTFSC  F81.5
018DE:  MOVLW  01
018E0:  MOVLB  A
018E2:  MOVWF  x1E
018E4:  MOVLW  00
018E6:  BTFSC  F81.2
018E8:  MOVLW  01
018EA:  ANDWF  x1E,W
018EC:  MOVWF  FEF
....................                } 
....................          break; 
018EE:  MOVLB  0
....................    } 
018F0:  GOTO   1A3E (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
016D6:  BCF    FD8.0
016D8:  MOVLB  7
016DA:  RLCF   x3C,W
016DC:  CLRF   03
016DE:  ADDLW  B7
016E0:  MOVWF  FE9
016E2:  MOVLW  07
016E4:  ADDWFC 03,W
016E6:  MOVWF  FEA
016E8:  MOVLW  01
016EA:  ADDWF  FEE,F
016EC:  BNC   16F0
016EE:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
016F0:  MOVF   xA6,W
016F2:  XORLW  00
016F4:  MOVLB  0
016F6:  BZ    1702
016F8:  XORLW  01
016FA:  BZ    1708
016FC:  XORLW  03
016FE:  BZ    171A
01700:  BRA    1744
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
01702:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
01704:  BCF    FF0.0
....................          break; 
01706:  BRA    1744
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01708:  MOVLW  02
0170A:  MOVLB  7
0170C:  MOVWF  xA6
....................                disable_interrupts(INT_EXT1_L2H); 
0170E:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
01710:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
01712:  BSF    FF0.3
01714:  BCF    FF1.5
....................          break; 
01716:  MOVLB  0
01718:  BRA    1744
....................       case 2 : edge_mode=1; 
0171A:  MOVLW  01
0171C:  MOVLB  7
0171E:  MOVWF  xA6
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01720:  BCF    FD8.0
01722:  RLCF   x3C,W
01724:  CLRF   03
01726:  ADDLW  B7
01728:  MOVWF  FE9
0172A:  MOVLW  07
0172C:  ADDWFC 03,W
0172E:  MOVWF  FEA
01730:  MOVLW  FF
01732:  ADDWF  FEF,F
01734:  BC    173A
01736:  MOVF   FEE,F
01738:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
0173A:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
0173C:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
0173E:  BSF    FF0.3
01740:  BSF    FF1.5
....................          break; 
01742:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
01744:  RCALL  1246
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
01746:  BCF    FF0.0
01748:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
0174C:  BCF    FD8.0
0174E:  MOVLB  7
01750:  RLCF   x3C,W
01752:  CLRF   03
01754:  ADDLW  B7
01756:  MOVWF  FE9
01758:  MOVLW  07
0175A:  ADDWFC 03,W
0175C:  MOVWF  FEA
0175E:  MOVLW  01
01760:  ADDWF  FEE,F
01762:  BNC   1766
01764:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
01766:  MOVF   xA6,W
01768:  XORLW  00
0176A:  MOVLB  0
0176C:  BZ    1778
0176E:  XORLW  01
01770:  BZ    177E
01772:  XORLW  03
01774:  BZ    1790
01776:  BRA    17BA
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
01778:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
0177A:  BCF    FF0.1
....................          break; 
0177C:  BRA    17BA
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
0177E:  MOVLW  02
01780:  MOVLB  7
01782:  MOVWF  xA6
....................                disable_interrupts(INT_EXT2_L2H); 
01784:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
01786:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
01788:  BSF    FF0.4
0178A:  BCF    FF1.4
....................          break; 
0178C:  MOVLB  0
0178E:  BRA    17BA
....................       case 2 : edge_mode=1; 
01790:  MOVLW  01
01792:  MOVLB  7
01794:  MOVWF  xA6
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01796:  BCF    FD8.0
01798:  RLCF   x3C,W
0179A:  CLRF   03
0179C:  ADDLW  B7
0179E:  MOVWF  FE9
017A0:  MOVLW  07
017A2:  ADDWFC 03,W
017A4:  MOVWF  FEA
017A6:  MOVLW  FF
017A8:  ADDWF  FEF,F
017AA:  BC    17B0
017AC:  MOVF   FEE,F
017AE:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017B0:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017B2:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017B4:  BSF    FF0.4
017B6:  BSF    FF1.4
....................          break; 
017B8:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017BA:  RCALL  1246
.................... } 
....................  
.................... // motor step timer interrupt 
017BC:  BCF    FF0.1
017BE:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
018F4:  MOVLW  F9
018F6:  MOVWF  FB3
018F8:  MOVLW  C0
018FA:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
018FC:  BCF    FD8.0
018FE:  MOVLB  7
01900:  RLCF   x3C,W
01902:  CLRF   03
01904:  ADDLW  8A
01906:  MOVWF  FE9
01908:  MOVLW  07
0190A:  ADDWFC 03,W
0190C:  MOVWF  FEA
0190E:  MOVLW  01
01910:  ADDWF  FEE,F
01912:  BNC   1916
01914:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
01916:  BCF    FD8.0
01918:  RLCF   x3C,W
0191A:  CLRF   03
0191C:  ADDLW  8A
0191E:  MOVWF  FE9
01920:  MOVLW  07
01922:  ADDWFC 03,W
01924:  MOVWF  FEA
01926:  MOVFF  FEC,A1D
0192A:  MOVF   FED,F
0192C:  MOVFF  FEF,A1C
01930:  BCF    FD8.0
01932:  RLCF   x3C,W
01934:  CLRF   03
01936:  ADDLW  46
01938:  MOVWF  FE9
0193A:  MOVLW  07
0193C:  ADDWFC 03,W
0193E:  MOVWF  FEA
01940:  MOVFF  FEC,03
01944:  MOVF   FED,F
01946:  MOVFF  FEF,01
0194A:  MOVF   03,W
0194C:  MOVLB  A
0194E:  SUBWF  x1D,W
01950:  BTFSS  FD8.0
01952:  BRA    1A40
01954:  BNZ   195E
01956:  MOVF   01,W
01958:  SUBWF  x1C,W
0195A:  BTFSS  FD8.0
0195C:  BRA    1A40
....................    { 
....................       m_step_cnt[motor]++; 
0195E:  MOVLB  7
01960:  MOVF   x3C,W
01962:  MULLW  04
01964:  MOVF   FF3,W
01966:  CLRF   03
01968:  ADDLW  9E
0196A:  MOVWF  FE9
0196C:  MOVLW  07
0196E:  ADDWFC 03,W
01970:  MOVWF  FEA
01972:  MOVLW  01
01974:  ADDWF  FEE,F
01976:  MOVLW  00
01978:  ADDWFC FEE,F
0197A:  ADDWFC FEE,F
0197C:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
0197E:  BCF    FD8.0
01980:  RLCF   x3C,W
01982:  CLRF   03
01984:  ADDLW  96
01986:  MOVWF  FE9
01988:  MOVLW  07
0198A:  ADDWFC 03,W
0198C:  MOVWF  FEA
0198E:  MOVLW  01
01990:  ADDWF  FEE,F
01992:  BNC   1996
01994:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
01996:  BCF    FD8.0
01998:  RLCF   x3C,W
0199A:  CLRF   03
0199C:  ADDLW  8A
0199E:  MOVWF  FE9
019A0:  MOVLW  07
019A2:  ADDWFC 03,W
019A4:  MOVWF  FEA
019A6:  CLRF   FEC
019A8:  MOVF   FED,F
019AA:  CLRF   FEF
....................  
....................       if (motor==0) 
019AC:  MOVF   x3C,F
019AE:  BNZ   19B4
....................       { 
....................          output_toggle(M1_CLOCK); 
019B0:  BTG    F90.4
....................       } 
019B2:  BRA    1A14
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019B4:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019B6:  BCF    FD8.0
019B8:  RLCF   x3C,W
019BA:  CLRF   03
019BC:  ADDLW  82
019BE:  MOVWF  FE9
019C0:  MOVLW  07
019C2:  ADDWFC 03,W
019C4:  MOVWF  FEA
019C6:  MOVFF  FEC,A1D
019CA:  MOVF   FED,F
019CC:  MOVFF  FEF,A1C
019D0:  MOVLB  A
019D2:  MOVF   x1C,F
019D4:  BNZ   19FA
019D6:  MOVF   x1D,F
019D8:  BNZ   19FA
019DA:  BCF    FD8.0
019DC:  MOVLB  7
019DE:  RLCF   x3C,W
019E0:  CLRF   03
019E2:  ADDLW  AF
019E4:  MOVWF  FE9
019E6:  MOVLW  07
019E8:  ADDWFC 03,W
019EA:  MOVWF  FEA
019EC:  MOVLW  FF
019EE:  ADDWF  FEF,F
019F0:  BC    19F6
019F2:  MOVF   FEE,F
019F4:  DECF   FED,F
019F6:  BRA    1A14
019F8:  MOVLB  A
....................          else m_lin_pos[motor]++;          
019FA:  BCF    FD8.0
019FC:  MOVLB  7
019FE:  RLCF   x3C,W
01A00:  CLRF   03
01A02:  ADDLW  AF
01A04:  MOVWF  FE9
01A06:  MOVLW  07
01A08:  ADDWFC 03,W
01A0A:  MOVWF  FEA
01A0C:  MOVLW  01
01A0E:  ADDWF  FEE,F
01A10:  BNC   1A14
01A12:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A14:  BCF    FD8.0
01A16:  RLCF   x3C,W
01A18:  CLRF   03
01A1A:  ADDLW  62
01A1C:  MOVWF  FE9
01A1E:  MOVLW  07
01A20:  ADDWFC 03,W
01A22:  MOVWF  FEA
01A24:  MOVFF  FEC,A1D
01A28:  MOVF   FED,F
01A2A:  MOVFF  FEF,A1C
01A2E:  MOVLB  A
01A30:  MOVF   x1C,W
01A32:  SUBLW  03
01A34:  BNZ   1A40
01A36:  MOVF   x1D,F
01A38:  BNZ   1A40
01A3A:  MOVLB  0
01A3C:  BRA    17C2
01A3E:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A40:  BCF    FA1.1
01A42:  BCF    FA1.1
01A44:  MOVLB  0
01A46:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
08A16:  BCF    FD8.0
08A18:  MOVLB  7
08A1A:  RLCF   x3C,W
08A1C:  CLRF   03
08A1E:  ADDLW  4A
08A20:  MOVWF  FE9
08A22:  MOVLW  07
08A24:  ADDWFC 03,W
08A26:  MOVWF  FEA
08A28:  MOVFF  FEC,8C3
08A2C:  MOVF   FED,F
08A2E:  MOVFF  FEF,8C2
08A32:  MOVLB  8
08A34:  DECFSZ xC2,W
08A36:  BRA    8A86
08A38:  MOVF   xC3,F
08A3A:  BNZ   8A86
08A3C:  BCF    FD8.0
08A3E:  MOVLB  7
08A40:  RLCF   x3C,W
08A42:  CLRF   03
08A44:  ADDLW  82
08A46:  MOVWF  01
08A48:  MOVLW  07
08A4A:  ADDWFC 03,F
08A4C:  MOVFF  01,8C2
08A50:  MOVLB  8
08A52:  MOVFF  03,8C3
08A56:  BCF    FD8.0
08A58:  MOVLB  7
08A5A:  RLCF   x3C,W
08A5C:  CLRF   03
08A5E:  ADDLW  82
08A60:  MOVWF  FE9
08A62:  MOVLW  07
08A64:  ADDWFC 03,W
08A66:  MOVWF  FEA
08A68:  MOVF   FEF,F
08A6A:  BNZ   8A70
08A6C:  MOVF   FEC,F
08A6E:  BZ    8A74
08A70:  MOVLW  00
08A72:  BRA    8A76
08A74:  MOVLW  01
08A76:  MOVLB  8
08A78:  MOVFF  8C3,FEA
08A7C:  MOVFF  8C2,FE9
08A80:  CLRF   FEC
08A82:  MOVF   FED,F
08A84:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
08A86:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
08A88:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
08A8A:  BCF    FD8.0
08A8C:  MOVLB  7
08A8E:  RLCF   x3C,W
08A90:  CLRF   03
08A92:  ADDLW  3E
08A94:  MOVWF  FE9
08A96:  MOVLW  07
08A98:  ADDWFC 03,W
08A9A:  MOVWF  FEA
08A9C:  MOVF   FEF,F
08A9E:  BNZ   8AA8
08AA0:  MOVF   FEC,F
08AA2:  BNZ   8AA8
08AA4:  BCF    F90.2
08AA6:  BRA    8AAA
08AA8:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
08AAA:  BCF    FD8.0
08AAC:  RLCF   x3C,W
08AAE:  CLRF   03
08AB0:  ADDLW  42
08AB2:  MOVWF  FE9
08AB4:  MOVLW  07
08AB6:  ADDWFC 03,W
08AB8:  MOVWF  FEA
08ABA:  MOVF   FEF,F
08ABC:  BNZ   8AC6
08ABE:  MOVF   FEC,F
08AC0:  BNZ   8AC6
08AC2:  BCF    F90.3
08AC4:  BRA    8AC8
08AC6:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
08AC8:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
08ACA:  BCF    FD8.0
08ACC:  RLCF   x3C,W
08ACE:  CLRF   03
08AD0:  ADDLW  82
08AD2:  MOVWF  FE9
08AD4:  MOVLW  07
08AD6:  ADDWFC 03,W
08AD8:  MOVWF  FEA
08ADA:  MOVF   FEF,F
08ADC:  BNZ   8AE6
08ADE:  MOVF   FEC,F
08AE0:  BNZ   8AE6
08AE2:  BCF    F90.5
08AE4:  BRA    8AE8
08AE6:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
08AE8:  BCF    FD8.0
08AEA:  RLCF   x3C,W
08AEC:  CLRF   03
08AEE:  ADDLW  52
08AF0:  MOVWF  FE9
08AF2:  MOVLW  07
08AF4:  ADDWFC 03,W
08AF6:  MOVWF  FEA
08AF8:  MOVFF  FEC,8C3
08AFC:  MOVF   FED,F
08AFE:  MOVFF  FEF,8C2
08B02:  MOVLB  8
08B04:  RRCF   xC3,F
08B06:  RRCF   xC2,F
08B08:  RRCF   xC3,F
08B0A:  RRCF   xC2,F
08B0C:  RRCF   xC3,F
08B0E:  MOVFF  8C2,FBC
08B12:  RRCF   xC3,F
08B14:  RRCF   xC3,W
08B16:  ANDLW  30
08B18:  MOVWF  00
08B1A:  MOVF   FBB,W
08B1C:  ANDLW  CF
08B1E:  IORWF  00,W
08B20:  MOVWF  FBB
08B22:  MOVLB  0
08B24:  GOTO   8CAE (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08B28:  BCF    FD8.0
08B2A:  MOVLB  7
08B2C:  RLCF   x3C,W
08B2E:  CLRF   03
08B30:  ADDLW  4A
08B32:  MOVWF  FE9
08B34:  MOVLW  07
08B36:  ADDWFC 03,W
08B38:  MOVWF  FEA
08B3A:  MOVFF  FEC,8C3
08B3E:  MOVF   FED,F
08B40:  MOVFF  FEF,8C2
08B44:  MOVLB  8
08B46:  DECFSZ xC2,W
08B48:  BRA    8B98
08B4A:  MOVF   xC3,F
08B4C:  BNZ   8B98
08B4E:  BCF    FD8.0
08B50:  MOVLB  7
08B52:  RLCF   x3C,W
08B54:  CLRF   03
08B56:  ADDLW  82
08B58:  MOVWF  01
08B5A:  MOVLW  07
08B5C:  ADDWFC 03,F
08B5E:  MOVFF  01,8C2
08B62:  MOVLB  8
08B64:  MOVFF  03,8C3
08B68:  BCF    FD8.0
08B6A:  MOVLB  7
08B6C:  RLCF   x3C,W
08B6E:  CLRF   03
08B70:  ADDLW  82
08B72:  MOVWF  FE9
08B74:  MOVLW  07
08B76:  ADDWFC 03,W
08B78:  MOVWF  FEA
08B7A:  MOVF   FEF,F
08B7C:  BNZ   8B82
08B7E:  MOVF   FEC,F
08B80:  BZ    8B86
08B82:  MOVLW  00
08B84:  BRA    8B88
08B86:  MOVLW  01
08B88:  MOVLB  8
08B8A:  MOVFF  8C3,FEA
08B8E:  MOVFF  8C2,FE9
08B92:  CLRF   FEC
08B94:  MOVF   FED,F
08B96:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08B98:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08B9A:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08B9C:  BCF    FD8.0
08B9E:  MOVLB  7
08BA0:  RLCF   x3C,W
08BA2:  CLRF   03
08BA4:  ADDLW  3E
08BA6:  MOVWF  FE9
08BA8:  MOVLW  07
08BAA:  ADDWFC 03,W
08BAC:  MOVWF  FEA
08BAE:  MOVF   FEF,F
08BB0:  BNZ   8BBA
08BB2:  MOVF   FEC,F
08BB4:  BNZ   8BBA
08BB6:  BCF    F8D.2
08BB8:  BRA    8BBC
08BBA:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08BBC:  BCF    FD8.0
08BBE:  RLCF   x3C,W
08BC0:  CLRF   03
08BC2:  ADDLW  42
08BC4:  MOVWF  FE9
08BC6:  MOVLW  07
08BC8:  ADDWFC 03,W
08BCA:  MOVWF  FEA
08BCC:  MOVF   FEF,F
08BCE:  BNZ   8BD8
08BD0:  MOVF   FEC,F
08BD2:  BNZ   8BD8
08BD4:  BCF    F8D.3
08BD6:  BRA    8BDA
08BD8:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08BDA:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08BDC:  BCF    FD8.0
08BDE:  RLCF   x3C,W
08BE0:  CLRF   03
08BE2:  ADDLW  82
08BE4:  MOVWF  FE9
08BE6:  MOVLW  07
08BE8:  ADDWFC 03,W
08BEA:  MOVWF  FEA
08BEC:  MOVF   FEF,F
08BEE:  BNZ   8BF8
08BF0:  MOVF   FEC,F
08BF2:  BNZ   8BF8
08BF4:  BCF    F8D.5
08BF6:  BRA    8BFA
08BF8:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08BFA:  BCF    FD8.0
08BFC:  RLCF   x3C,W
08BFE:  CLRF   03
08C00:  ADDLW  52
08C02:  MOVWF  FE9
08C04:  MOVLW  07
08C06:  ADDWFC 03,W
08C08:  MOVWF  FEA
08C0A:  MOVFF  FEC,8C3
08C0E:  MOVF   FED,F
08C10:  MOVFF  FEF,8C2
08C14:  MOVLB  8
08C16:  RRCF   xC3,F
08C18:  RRCF   xC2,F
08C1A:  RRCF   xC3,F
08C1C:  RRCF   xC2,F
08C1E:  RRCF   xC3,F
08C20:  MOVFF  8C2,F4F
08C24:  RRCF   xC3,F
08C26:  RRCF   xC3,W
08C28:  ANDLW  30
08C2A:  MOVWF  00
08C2C:  MOVLB  F
08C2E:  MOVF   x4E,W
08C30:  ANDLW  CF
08C32:  IORWF  00,W
08C34:  MOVWF  x4E
08C36:  MOVLB  0
08C38:  GOTO   8CAE (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
08A02:  MOVLB  8
08A04:  MOVF   xD6,F
08A06:  BZ    8A0E
....................       output_bit(VENC1,ON); 
08A08:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
08A0A:  BSF    F8E.7
....................    } 
08A0C:  BRA    8A12
....................    else {       
....................       output_bit(VENC1,OFF); 
08A0E:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
08A10:  BCF    F8E.7
....................    } 
08A12:  MOVLB  0
08A14:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08D9C:  MOVLB  8
08D9E:  MOVF   xD7,F
08DA0:  BNZ   8DC8
08DA2:  MOVF   xD8,F
08DA4:  BNZ   8DC8
....................       edge_mode=0; 
08DA6:  MOVLB  7
08DA8:  CLRF   xA6
....................       switch (motor){ 
08DAA:  MOVF   x3C,W
08DAC:  XORLW  00
08DAE:  MOVLB  0
08DB0:  BZ    8DB8
08DB2:  XORLW  01
08DB4:  BZ    8DC0
08DB6:  BRA    8DC6
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08DB8:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08DBA:  BSF    FF0.3
08DBC:  BCF    FF1.5
....................             break; 
08DBE:  BRA    8DC6
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08DC0:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08DC2:  BSF    FF0.4
08DC4:  BCF    FF1.4
....................             break; 
08DC6:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08DC8:  DECFSZ xD7,W
08DCA:  BRA    8DF2
08DCC:  MOVF   xD8,F
08DCE:  BNZ   8DF2
....................       edge_mode=0; 
08DD0:  MOVLB  7
08DD2:  CLRF   xA6
....................       switch (motor){ 
08DD4:  MOVF   x3C,W
08DD6:  XORLW  00
08DD8:  MOVLB  0
08DDA:  BZ    8DE2
08DDC:  XORLW  01
08DDE:  BZ    8DEA
08DE0:  BRA    8DF0
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08DE2:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08DE4:  BSF    FF0.3
08DE6:  BSF    FF1.5
....................             break; 
08DE8:  BRA    8DF0
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08DEA:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08DEC:  BSF    FF0.4
08DEE:  BSF    FF1.4
....................             break; 
08DF0:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08DF2:  MOVF   xD7,W
08DF4:  SUBLW  02
08DF6:  BNZ   8E48
08DF8:  MOVF   xD8,F
08DFA:  BNZ   8E48
08DFC:  BCF    FD8.0
08DFE:  MOVLB  7
08E00:  RLCF   x3C,W
08E02:  CLRF   03
08E04:  ADDLW  66
08E06:  MOVWF  FE9
08E08:  MOVLW  07
08E0A:  ADDWFC 03,W
08E0C:  MOVWF  FEA
08E0E:  MOVFF  FEC,8DA
08E12:  MOVF   FED,F
08E14:  MOVFF  FEF,8D9
08E18:  MOVLB  8
08E1A:  MOVF   xD9,W
08E1C:  SUBLW  02
08E1E:  BNZ   8E48
08E20:  MOVF   xDA,F
08E22:  BNZ   8E48
....................       edge_mode=1; 
08E24:  MOVLW  01
08E26:  MOVLB  7
08E28:  MOVWF  xA6
....................       switch (motor){ 
08E2A:  MOVF   x3C,W
08E2C:  XORLW  00
08E2E:  MOVLB  0
08E30:  BZ    8E38
08E32:  XORLW  01
08E34:  BZ    8E40
08E36:  BRA    8E46
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08E38:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08E3A:  BSF    FF0.3
08E3C:  BSF    FF1.5
....................             break; 
08E3E:  BRA    8E46
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08E40:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08E42:  BSF    FF0.4
08E44:  BSF    FF1.4
....................             break; 
08E46:  MOVLB  8
....................       }  
....................    }     
08E48:  MOVLB  0
08E4A:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08FB2:  MOVLB  7
08FB4:  MOVF   x3C,W
08FB6:  XORLW  00
08FB8:  MOVLB  0
08FBA:  BZ    8FC2
08FBC:  XORLW  01
08FBE:  BZ    8FEC
08FC0:  BRA    9014
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08FC2:  BCF    FD8.0
08FC4:  MOVLB  7
08FC6:  RLCF   x3C,W
08FC8:  CLRF   03
08FCA:  ADDLW  92
08FCC:  MOVWF  FE9
08FCE:  MOVLW  07
08FD0:  ADDWFC 03,W
08FD2:  MOVWF  FEA
08FD4:  MOVFF  FEC,8DA
08FD8:  MOVF   FED,F
08FDA:  MOVFF  FEF,8D9
08FDE:  MOVLW  6E
08FE0:  MOVLB  8
08FE2:  MOVWF  xD8
08FE4:  MOVLB  0
08FE6:  CALL   501E
....................          break; 
08FEA:  BRA    9014
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08FEC:  BCF    FD8.0
08FEE:  MOVLB  7
08FF0:  RLCF   x3C,W
08FF2:  CLRF   03
08FF4:  ADDLW  92
08FF6:  MOVWF  FE9
08FF8:  MOVLW  07
08FFA:  ADDWFC 03,W
08FFC:  MOVWF  FEA
08FFE:  MOVFF  FEC,8DA
09002:  MOVF   FED,F
09004:  MOVFF  FEF,8D9
09008:  MOVLW  70
0900A:  MOVLB  8
0900C:  MOVWF  xD8
0900E:  MOVLB  0
09010:  CALL   501E
....................          break;          
....................    } 
09014:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08E4C:  MOVLB  8
08E4E:  MOVF   xD6,F
08E50:  BNZ   8E6E
....................    { 
....................       switch (motor) 
08E52:  MOVLB  7
08E54:  MOVF   x3C,W
08E56:  XORLW  00
08E58:  MOVLB  0
08E5A:  BZ    8E62
08E5C:  XORLW  01
08E5E:  BZ    8E68
08E60:  BRA    8E6C
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08E62:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08E64:  BCF    FF0.3
....................             break; 
08E66:  BRA    8E6C
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08E68:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08E6A:  BCF    FF0.4
....................             break; 
08E6C:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08E6E:  DECFSZ xD6,W
08E70:  BRA    8ED6
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08E72:  BCF    FD8.0
08E74:  MOVLB  7
08E76:  RLCF   x3C,W
08E78:  CLRF   03
08E7A:  ADDLW  66
08E7C:  MOVWF  FE9
08E7E:  MOVLW  07
08E80:  ADDWFC 03,W
08E82:  MOVWF  FEA
08E84:  MOVFF  FEC,8D8
08E88:  MOVF   FED,F
08E8A:  MOVFF  FEF,8D7
08E8E:  MOVLB  8
08E90:  DECFSZ xD7,W
08E92:  BRA    8EA2
08E94:  MOVF   xD8,F
08E96:  BNZ   8EA2
08E98:  CLRF   xD8
08E9A:  CLRF   xD7
08E9C:  MOVLB  0
08E9E:  RCALL  8D9C
08EA0:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08EA2:  BCF    FD8.0
08EA4:  MOVLB  7
08EA6:  RLCF   x3C,W
08EA8:  CLRF   03
08EAA:  ADDLW  66
08EAC:  MOVWF  FE9
08EAE:  MOVLW  07
08EB0:  ADDWFC 03,W
08EB2:  MOVWF  FEA
08EB4:  MOVFF  FEC,8D8
08EB8:  MOVF   FED,F
08EBA:  MOVFF  FEF,8D7
08EBE:  MOVLB  8
08EC0:  MOVF   xD7,W
08EC2:  SUBLW  02
08EC4:  BNZ   8ED6
08EC6:  MOVF   xD8,F
08EC8:  BNZ   8ED6
08ECA:  CLRF   xD8
08ECC:  MOVLW  01
08ECE:  MOVWF  xD7
08ED0:  MOVLB  0
08ED2:  RCALL  8D9C
08ED4:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08ED6:  MOVF   xD6,W
08ED8:  SUBLW  02
08EDA:  BNZ   8F10
08EDC:  BCF    FD8.0
08EDE:  MOVLB  7
08EE0:  RLCF   x3C,W
08EE2:  CLRF   03
08EE4:  ADDLW  66
08EE6:  MOVWF  FE9
08EE8:  MOVLW  07
08EEA:  ADDWFC 03,W
08EEC:  MOVWF  FEA
08EEE:  MOVFF  FEC,8D8
08EF2:  MOVF   FED,F
08EF4:  MOVFF  FEF,8D7
08EF8:  MOVLB  8
08EFA:  MOVF   xD7,W
08EFC:  SUBLW  02
08EFE:  BNZ   8F10
08F00:  MOVF   xD8,F
08F02:  BNZ   8F10
....................    { 
....................       enable_enc_isr(2);   
08F04:  CLRF   xD8
08F06:  MOVLW  02
08F08:  MOVWF  xD7
08F0A:  MOVLB  0
08F0C:  RCALL  8D9C
08F0E:  MOVLB  8
....................    } 
08F10:  MOVLB  0
08F12:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08C3C:  BCF    FD8.0
08C3E:  MOVLB  7
08C40:  RLCF   x3C,W
08C42:  CLRF   03
08C44:  ADDLW  8A
08C46:  MOVWF  FE9
08C48:  MOVLW  07
08C4A:  ADDWFC 03,W
08C4C:  MOVWF  FEA
08C4E:  CLRF   FEC
08C50:  MOVF   FED,F
08C52:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08C54:  BCF    FD8.0
08C56:  RLCF   x3C,W
08C58:  CLRF   03
08C5A:  ADDLW  B7
08C5C:  MOVWF  FE9
08C5E:  MOVLW  07
08C60:  ADDWFC 03,W
08C62:  MOVWF  FEA
08C64:  CLRF   FEC
08C66:  MOVF   FED,F
08C68:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08C6A:  BCF    FD8.0
08C6C:  RLCF   x3C,W
08C6E:  CLRF   03
08C70:  ADDLW  96
08C72:  MOVWF  FE9
08C74:  MOVLW  07
08C76:  ADDWFC 03,W
08C78:  MOVWF  FEA
08C7A:  CLRF   FEC
08C7C:  MOVF   FED,F
08C7E:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08C80:  BSF    F8E.1
....................    enc_pwr(ON); 
08C82:  MOVLW  01
08C84:  MOVLB  8
08C86:  MOVWF  xD6
08C88:  MOVLB  0
08C8A:  RCALL  8A02
....................    delay_ms(100); 
08C8C:  MOVLW  64
08C8E:  MOVLB  9
08C90:  MOVWF  xD6
08C92:  MOVLB  0
08C94:  CALL   2964
....................     
....................    switch (motor){ 
08C98:  MOVLB  7
08C9A:  MOVF   x3C,W
08C9C:  XORLW  00
08C9E:  MOVLB  0
08CA0:  BZ    8CA8
08CA2:  XORLW  01
08CA4:  BZ    8CAC
08CA6:  BRA    8CAE
....................       case 0 : motor_setup1(); 
08CA8:  BRA    8A16
....................          break; 
08CAA:  BRA    8CAE
....................       case 1 : motor_setup2(); 
08CAC:  BRA    8B28
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08CAE:  BCF    FD8.0
08CB0:  MOVLB  7
08CB2:  RLCF   x3C,W
08CB4:  CLRF   03
08CB6:  ADDLW  86
08CB8:  MOVWF  FE9
08CBA:  MOVLW  07
08CBC:  ADDWFC 03,W
08CBE:  MOVWF  FEA
08CC0:  MOVFF  FEC,8C3
08CC4:  MOVF   FED,F
08CC6:  MOVFF  FEF,8C2
08CCA:  BCF    FD8.0
08CCC:  RLCF   x3C,W
08CCE:  CLRF   03
08CD0:  ADDLW  82
08CD2:  MOVWF  FE9
08CD4:  MOVLW  07
08CD6:  ADDWFC 03,W
08CD8:  MOVWF  FEA
08CDA:  MOVFF  FEC,03
08CDE:  MOVF   FED,F
08CE0:  MOVF   FEF,W
08CE2:  MOVLB  8
08CE4:  SUBWF  xC2,W
08CE6:  BNZ   8CEE
08CE8:  MOVF   03,W
08CEA:  SUBWF  xC3,W
08CEC:  BZ    8D96
....................       m_way_rst[motor]=m_way[motor]; 
08CEE:  BCF    FD8.0
08CF0:  MOVLB  7
08CF2:  RLCF   x3C,W
08CF4:  CLRF   03
08CF6:  ADDLW  86
08CF8:  MOVWF  01
08CFA:  MOVLW  07
08CFC:  ADDWFC 03,F
08CFE:  MOVLB  8
08D00:  MOVFF  03,8C3
08D04:  BCF    FD8.0
08D06:  MOVLB  7
08D08:  RLCF   x3C,W
08D0A:  CLRF   03
08D0C:  ADDLW  82
08D0E:  MOVWF  FE9
08D10:  MOVLW  07
08D12:  ADDWFC 03,W
08D14:  MOVWF  FEA
08D16:  MOVFF  FEC,03
08D1A:  MOVF   FED,F
08D1C:  MOVFF  FEF,8C4
08D20:  MOVLB  8
08D22:  MOVFF  8C3,FEA
08D26:  MOVFF  01,FE9
08D2A:  MOVFF  03,FEC
08D2E:  MOVF   FED,F
08D30:  MOVFF  8C4,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08D34:  BCF    FD8.0
08D36:  MOVLB  7
08D38:  RLCF   x3C,W
08D3A:  CLRF   03
08D3C:  ADDLW  9A
08D3E:  MOVWF  01
08D40:  MOVLW  07
08D42:  ADDWFC 03,F
08D44:  MOVLB  8
08D46:  MOVFF  03,8C3
08D4A:  BCF    FD8.0
08D4C:  MOVLB  7
08D4E:  RLCF   x3C,W
08D50:  CLRF   03
08D52:  ADDLW  62
08D54:  MOVWF  FE9
08D56:  MOVLW  07
08D58:  ADDWFC 03,W
08D5A:  MOVWF  FEA
08D5C:  MOVFF  FEC,03
08D60:  MOVF   FED,F
08D62:  MOVFF  FEF,8C4
08D66:  MOVLB  8
08D68:  MOVFF  8C3,FEA
08D6C:  MOVFF  01,FE9
08D70:  MOVFF  03,FEC
08D74:  MOVF   FED,F
08D76:  MOVFF  8C4,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08D7A:  BCF    FD8.0
08D7C:  MOVLB  7
08D7E:  RLCF   x3C,W
08D80:  CLRF   03
08D82:  ADDLW  62
08D84:  MOVWF  FE9
08D86:  MOVLW  07
08D88:  ADDWFC 03,W
08D8A:  MOVWF  FEA
08D8C:  CLRF   FEC
08D8E:  MOVF   FED,F
08D90:  MOVLW  05
08D92:  MOVWF  FEF
08D94:  MOVLB  8
....................    } 
08D96:  MOVLB  0
08D98:  GOTO   8F16 (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08F14:  BRA    8C3C
....................     
....................    m_comp[motor]=FALSE; 
08F16:  BCF    FD8.0
08F18:  MOVLB  7
08F1A:  RLCF   x3C,W
08F1C:  CLRF   03
08F1E:  ADDLW  AB
08F20:  MOVWF  FE9
08F22:  MOVLW  07
08F24:  ADDWFC 03,W
08F26:  MOVWF  FEA
08F28:  CLRF   FEC
08F2A:  MOVF   FED,F
08F2C:  CLRF   FEF
....................     
....................    switch (motor){ 
08F2E:  MOVF   x3C,W
08F30:  XORLW  00
08F32:  MOVLB  0
08F34:  BZ    8F3C
08F36:  XORLW  01
08F38:  BZ    8F4E
08F3A:  BRA    8F5E
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08F3C:  MOVLW  B2
08F3E:  MOVLB  8
08F40:  MOVWF  xD8
08F42:  CLRF   xDA
08F44:  CLRF   xD9
08F46:  MOVLB  0
08F48:  CALL   501E
....................          break; 
08F4C:  BRA    8F5E
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08F4E:  MOVLW  B4
08F50:  MOVLB  8
08F52:  MOVWF  xD8
08F54:  CLRF   xDA
08F56:  CLRF   xD9
08F58:  MOVLB  0
08F5A:  CALL   501E
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08F5E:  MOVLB  7
08F60:  MOVF   x3C,W
08F62:  XORLW  00
08F64:  MOVLB  0
08F66:  BZ    8F6E
08F68:  XORLW  01
08F6A:  BZ    8F72
08F6C:  BRA    8F74
....................       case 0 : output_bit(M1_ENABLE, ON); 
08F6E:  BSF    F90.1
....................          break; 
08F70:  BRA    8F74
....................       case 1 : output_bit(M2_ENABLE, ON); 
08F72:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08F74:  MOVLW  32
08F76:  MOVLB  9
08F78:  MOVWF  xD6
08F7A:  MOVLB  0
08F7C:  CALL   2964
....................     
....................    set_timer3(STEP_INTERVAL); 
08F80:  MOVLW  F9
08F82:  MOVWF  FB3
08F84:  MOVLW  C0
08F86:  MOVWF  FB2
....................    enc_isr(int_mode); 
08F88:  MOVFF  8C1,8D6
08F8C:  RCALL  8E4C
....................    clear_interrupt(INT_TIMER3); 
08F8E:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08F90:  BCF    FD8.0
08F92:  MOVLB  7
08F94:  RLCF   x3C,W
08F96:  CLRF   03
08F98:  ADDLW  8E
08F9A:  MOVWF  FE9
08F9C:  MOVLW  07
08F9E:  ADDWFC 03,W
08FA0:  MOVWF  FEA
08FA2:  CLRF   FEC
08FA4:  MOVF   FED,F
08FA6:  MOVLW  01
08FA8:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08FAA:  BSF    FA0.1
08FAC:  MOVLB  0
08FAE:  GOTO   A226 (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
08638:  MOVFF  8C4,8CC
0863C:  MOVFF  8C3,8CB
08640:  MOVFF  8C2,8CA
08644:  MOVFF  8C1,8C9
....................    enc_res    = e_cpr[motor]; 
08648:  BCF    FD8.0
0864A:  MOVLB  7
0864C:  RLCF   x3C,W
0864E:  CLRF   03
08650:  ADDLW  5A
08652:  MOVWF  FE9
08654:  MOVLW  07
08656:  ADDWFC 03,W
08658:  MOVWF  FEA
0865A:  MOVLB  8
0865C:  CLRF   xD0
0865E:  CLRF   xCF
08660:  MOVFF  FEC,8CE
08664:  MOVF   FED,F
08666:  MOVFF  FEF,8CD
....................    ports      = e_ppr[motor]; 
0866A:  BCF    FD8.0
0866C:  MOVLB  7
0866E:  RLCF   x3C,W
08670:  CLRF   03
08672:  ADDLW  5E
08674:  MOVWF  FE9
08676:  MOVLW  07
08678:  ADDWFC 03,W
0867A:  MOVWF  FEA
0867C:  MOVLB  8
0867E:  CLRF   xD8
08680:  CLRF   xD7
08682:  MOVFF  FEC,8D6
08686:  MOVF   FED,F
08688:  MOVFF  FEF,8D5
....................     
....................    enc_res = enc_res * 1000; 
0868C:  MOVFF  8D0,9E3
08690:  MOVFF  8CF,9E2
08694:  MOVFF  8CE,9E1
08698:  MOVFF  8CD,9E0
0869C:  MOVLB  9
0869E:  CLRF   xE7
086A0:  CLRF   xE6
086A2:  MOVLW  03
086A4:  MOVWF  xE5
086A6:  MOVLW  E8
086A8:  MOVWF  xE4
086AA:  MOVLB  0
086AC:  CALL   4844
086B0:  MOVFF  03,8D0
086B4:  MOVFF  02,8CF
086B8:  MOVFF  01,8CE
086BC:  MOVFF  00,8CD
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
086C0:  BCF    FD8.1
086C2:  CLRF   1B
086C4:  BTFSC  FF2.7
086C6:  BSF    1B.7
086C8:  BCF    FF2.7
086CA:  MOVFF  8D0,A34
086CE:  MOVFF  8CF,A33
086D2:  MOVFF  8CE,A32
086D6:  MOVFF  8CD,A31
086DA:  MOVFF  8D8,A38
086DE:  MOVFF  8D7,A37
086E2:  MOVFF  8D6,A36
086E6:  MOVFF  8D5,A35
086EA:  CALL   1042
086EE:  BTFSC  1B.7
086F0:  BSF    FF2.7
086F2:  MOVFF  03,8C8
086F6:  MOVFF  02,8C7
086FA:  MOVFF  01,8C6
086FE:  MOVFF  00,8C5
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
08702:  MOVFF  8C4,9E3
08706:  MOVFF  8C3,9E2
0870A:  MOVFF  8C2,9E1
0870E:  MOVFF  8C1,9E0
08712:  MOVFF  8C8,9E7
08716:  MOVFF  8C7,9E6
0871A:  MOVFF  8C6,9E5
0871E:  MOVFF  8C5,9E4
08722:  CALL   4844
08726:  MOVLB  8
08728:  MOVF   xC5,W
0872A:  SUBWF  00,W
0872C:  MOVWF  xC9
0872E:  MOVF   xC6,W
08730:  SUBWFB 01,W
08732:  MOVWF  xCA
08734:  MOVF   xC7,W
08736:  SUBWFB 02,W
08738:  MOVWF  xCB
0873A:  MOVF   xC8,W
0873C:  SUBWFB 03,W
0873E:  MOVWF  xCC
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
08740:  BCF    FD8.1
08742:  CLRF   1B
08744:  BTFSC  FF2.7
08746:  BSF    1B.7
08748:  BCF    FF2.7
0874A:  MOVFF  8CC,A34
0874E:  MOVFF  8CB,A33
08752:  MOVFF  8CA,A32
08756:  MOVFF  8C9,A31
0875A:  MOVLB  A
0875C:  CLRF   x38
0875E:  CLRF   x37
08760:  MOVLW  03
08762:  MOVWF  x36
08764:  MOVLW  E8
08766:  MOVWF  x35
08768:  MOVLB  0
0876A:  CALL   1042
0876E:  BTFSC  1B.7
08770:  BSF    FF2.7
08772:  MOVFF  03,8D4
08776:  MOVFF  02,8D3
0877A:  MOVFF  01,8D2
0877E:  MOVFF  00,8D1
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
08782:  MOVFF  8D4,9E3
08786:  MOVFF  8D3,9E2
0878A:  MOVFF  8D2,9E1
0878E:  MOVFF  8D1,9E0
08792:  MOVLB  9
08794:  CLRF   xE7
08796:  CLRF   xE6
08798:  MOVLW  03
0879A:  MOVWF  xE5
0879C:  MOVLW  E8
0879E:  MOVWF  xE4
087A0:  MOVLB  0
087A2:  CALL   4844
087A6:  MOVFF  03,8D4
087AA:  MOVFF  02,8D3
087AE:  MOVFF  01,8D2
087B2:  MOVFF  00,8D1
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
087B6:  MOVLB  8
087B8:  MOVF   xD1,W
087BA:  SUBWF  xC9,F
087BC:  MOVF   xD2,W
087BE:  SUBWFB xCA,F
087C0:  MOVF   xD3,W
087C2:  SUBWFB xCB,F
087C4:  MOVF   xD4,W
087C6:  SUBWFB xCC,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
087C8:  BCF    FD8.1
087CA:  CLRF   1B
087CC:  BTFSC  FF2.7
087CE:  BSF    1B.7
087D0:  BCF    FF2.7
087D2:  MOVFF  8D4,A34
087D6:  MOVFF  8D3,A33
087DA:  MOVFF  8D2,A32
087DE:  MOVFF  8D1,A31
087E2:  MOVLB  A
087E4:  CLRF   x38
087E6:  CLRF   x37
087E8:  MOVLW  03
087EA:  MOVWF  x36
087EC:  MOVLW  E8
087EE:  MOVWF  x35
087F0:  MOVLB  0
087F2:  CALL   1042
087F6:  BTFSC  1B.7
087F8:  BSF    FF2.7
087FA:  MOVFF  03,8D4
087FE:  MOVFF  02,8D3
08802:  MOVFF  01,8D2
08806:  MOVFF  00,8D1
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
0880A:  MOVLB  8
0880C:  MOVF   xCC,F
0880E:  BNZ   8824
08810:  MOVF   xCB,F
08812:  BNZ   8824
08814:  MOVF   xCA,W
08816:  SUBLW  00
08818:  BC    8834
0881A:  XORLW  FF
0881C:  BNZ   8824
0881E:  MOVF   xC9,W
08820:  SUBLW  F3
08822:  BC    8834
08824:  MOVLW  01
08826:  ADDWF  xD1,F
08828:  BTFSC  FD8.0
0882A:  INCF   xD2,F
0882C:  BTFSC  FD8.2
0882E:  INCF   xD3,F
08830:  BTFSC  FD8.2
08832:  INCF   xD4,F
....................    return(enc_pos); 
08834:  MOVFF  8D1,00
08838:  MOVFF  8D2,01
0883C:  MOVFF  8D3,02
08840:  MOVFF  8D4,03
08844:  MOVLB  0
08846:  GOTO   A1AE (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
0884A:  BCF    FD8.0
0884C:  MOVLB  7
0884E:  RLCF   x3C,W
08850:  CLRF   03
08852:  ADDLW  BB
08854:  MOVWF  FE9
08856:  MOVLW  07
08858:  ADDWFC 03,W
0885A:  MOVWF  FEA
0885C:  MOVFF  FEC,03
08860:  MOVF   FED,F
08862:  MOVFF  FEF,01
08866:  MOVF   03,W
08868:  MOVLB  8
0886A:  SUBWF  xC4,W
0886C:  BNC   8934
0886E:  BNZ   8876
08870:  MOVF   xC3,W
08872:  SUBWF  01,W
08874:  BC    8934
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
08876:  BCF    FD8.0
08878:  MOVLB  7
0887A:  RLCF   x3C,W
0887C:  CLRF   03
0887E:  ADDLW  BB
08880:  MOVWF  FE9
08882:  MOVLW  07
08884:  ADDWFC 03,W
08886:  MOVWF  FEA
08888:  MOVFF  FEC,03
0888C:  MOVF   FED,F
0888E:  MOVF   FEF,W
08890:  MOVLB  8
08892:  SUBWF  xC3,W
08894:  MOVWF  xC5
08896:  MOVF   03,W
08898:  SUBWFB xC4,W
0889A:  MOVWF  xC6
....................       if (e_pos_r > (e_cpr[motor]/2)) 
0889C:  BCF    FD8.0
0889E:  MOVLB  7
088A0:  RLCF   x3C,W
088A2:  CLRF   03
088A4:  ADDLW  5A
088A6:  MOVWF  FE9
088A8:  MOVLW  07
088AA:  ADDWFC 03,W
088AC:  MOVWF  FEA
088AE:  MOVFF  FEC,8C8
088B2:  MOVF   FED,F
088B4:  MOVFF  FEF,8C7
088B8:  BCF    FD8.0
088BA:  MOVLB  8
088BC:  RRCF   xC8,W
088BE:  MOVWF  03
088C0:  RRCF   xC7,W
088C2:  MOVWF  02
088C4:  MOVWF  01
088C6:  MOVF   03,W
088C8:  SUBWF  xC6,W
088CA:  BNC   8918
088CC:  BNZ   88D4
088CE:  MOVF   xC5,W
088D0:  SUBWF  01,W
088D2:  BC    8918
....................       { 
....................          m_way[motor] = NEG; 
088D4:  BCF    FD8.0
088D6:  MOVLB  7
088D8:  RLCF   x3C,W
088DA:  CLRF   03
088DC:  ADDLW  82
088DE:  MOVWF  FE9
088E0:  MOVLW  07
088E2:  ADDWFC 03,W
088E4:  MOVWF  FEA
088E6:  CLRF   FEC
088E8:  MOVF   FED,F
088EA:  MOVLW  01
088EC:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088EE:  BCF    FD8.0
088F0:  RLCF   x3C,W
088F2:  CLRF   03
088F4:  ADDLW  5A
088F6:  MOVWF  FE9
088F8:  MOVLW  07
088FA:  ADDWFC 03,W
088FC:  MOVWF  FEA
088FE:  MOVFF  FEC,8C8
08902:  MOVF   FED,F
08904:  MOVFF  FEF,8C7
08908:  MOVLB  8
0890A:  MOVF   xC5,W
0890C:  SUBWF  xC7,W
0890E:  MOVWF  xC5
08910:  MOVF   xC6,W
08912:  SUBWFB xC8,W
08914:  MOVWF  xC6
....................       } 
08916:  BRA    8932
....................       else 
....................       { 
....................          m_way[motor] = POS; 
08918:  BCF    FD8.0
0891A:  MOVLB  7
0891C:  RLCF   x3C,W
0891E:  CLRF   03
08920:  ADDLW  82
08922:  MOVWF  FE9
08924:  MOVLW  07
08926:  ADDWFC 03,W
08928:  MOVWF  FEA
0892A:  CLRF   FEC
0892C:  MOVF   FED,F
0892E:  CLRF   FEF
08930:  MOVLB  8
....................       } 
....................    } 
08932:  BRA    89F4
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
08934:  BCF    FD8.0
08936:  MOVLB  7
08938:  RLCF   x3C,W
0893A:  CLRF   03
0893C:  ADDLW  BB
0893E:  MOVWF  FE9
08940:  MOVLW  07
08942:  ADDWFC 03,W
08944:  MOVWF  FEA
08946:  MOVFF  FEC,8C8
0894A:  MOVF   FED,F
0894C:  MOVFF  FEF,8C7
08950:  MOVLB  8
08952:  MOVF   xC3,W
08954:  SUBWF  xC7,W
08956:  MOVWF  xC5
08958:  MOVF   xC4,W
0895A:  SUBWFB xC8,W
0895C:  MOVWF  xC6
....................       if (e_pos_r > (e_cpr[motor]/2)) 
0895E:  BCF    FD8.0
08960:  MOVLB  7
08962:  RLCF   x3C,W
08964:  CLRF   03
08966:  ADDLW  5A
08968:  MOVWF  FE9
0896A:  MOVLW  07
0896C:  ADDWFC 03,W
0896E:  MOVWF  FEA
08970:  MOVFF  FEC,8C8
08974:  MOVF   FED,F
08976:  MOVFF  FEF,8C7
0897A:  BCF    FD8.0
0897C:  MOVLB  8
0897E:  RRCF   xC8,W
08980:  MOVWF  03
08982:  RRCF   xC7,W
08984:  MOVWF  02
08986:  MOVWF  01
08988:  MOVF   03,W
0898A:  SUBWF  xC6,W
0898C:  BNC   89D8
0898E:  BNZ   8996
08990:  MOVF   xC5,W
08992:  SUBWF  01,W
08994:  BC    89D8
....................       { 
....................          m_way[motor] = POS; 
08996:  BCF    FD8.0
08998:  MOVLB  7
0899A:  RLCF   x3C,W
0899C:  CLRF   03
0899E:  ADDLW  82
089A0:  MOVWF  FE9
089A2:  MOVLW  07
089A4:  ADDWFC 03,W
089A6:  MOVWF  FEA
089A8:  CLRF   FEC
089AA:  MOVF   FED,F
089AC:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
089AE:  BCF    FD8.0
089B0:  RLCF   x3C,W
089B2:  CLRF   03
089B4:  ADDLW  5A
089B6:  MOVWF  FE9
089B8:  MOVLW  07
089BA:  ADDWFC 03,W
089BC:  MOVWF  FEA
089BE:  MOVFF  FEC,8C8
089C2:  MOVF   FED,F
089C4:  MOVFF  FEF,8C7
089C8:  MOVLB  8
089CA:  MOVF   xC5,W
089CC:  SUBWF  xC7,W
089CE:  MOVWF  xC5
089D0:  MOVF   xC6,W
089D2:  SUBWFB xC8,W
089D4:  MOVWF  xC6
....................       } 
089D6:  BRA    89F4
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
089D8:  BCF    FD8.0
089DA:  MOVLB  7
089DC:  RLCF   x3C,W
089DE:  CLRF   03
089E0:  ADDLW  82
089E2:  MOVWF  FE9
089E4:  MOVLW  07
089E6:  ADDWFC 03,W
089E8:  MOVWF  FEA
089EA:  CLRF   FEC
089EC:  MOVF   FED,F
089EE:  MOVLW  01
089F0:  MOVWF  FEF
089F2:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
089F4:  MOVFF  8C5,01
089F8:  MOVFF  8C6,02
089FC:  MOVLB  0
089FE:  GOTO   A1DA (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
09102:  BCF    FD8.0
09104:  MOVLB  7
09106:  RLCF   x3C,W
09108:  CLRF   03
0910A:  ADDLW  8E
0910C:  MOVWF  FE9
0910E:  MOVLW  07
09110:  ADDWFC 03,W
09112:  MOVWF  FEA
09114:  CLRF   FEC
09116:  MOVF   FED,F
09118:  CLRF   FEF
....................           
....................    switch (motor){ 
0911A:  MOVF   x3C,W
0911C:  XORLW  00
0911E:  MOVLB  0
09120:  BZ    9128
09122:  XORLW  01
09124:  BZ    9192
09126:  BRA    9200
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
09128:  BCF    FD8.0
0912A:  MOVLB  7
0912C:  RLCF   x3C,W
0912E:  CLRF   03
09130:  ADDLW  4E
09132:  MOVWF  FE9
09134:  MOVLW  07
09136:  ADDWFC 03,W
09138:  MOVWF  FEA
0913A:  MOVFF  FEC,8D7
0913E:  MOVF   FED,F
09140:  MOVFF  FEF,8D6
09144:  MOVLB  8
09146:  MOVF   xD6,F
09148:  BNZ   914E
0914A:  MOVF   xD7,F
0914C:  BZ    918C
0914E:  BCF    FD8.0
09150:  MOVLB  7
09152:  RLCF   x3C,W
09154:  CLRF   03
09156:  ADDLW  4E
09158:  MOVWF  FE9
0915A:  MOVLW  07
0915C:  ADDWFC 03,W
0915E:  MOVWF  FEA
09160:  MOVFF  FEC,8D7
09164:  MOVF   FED,F
09166:  MOVFF  FEF,8D6
0916A:  MOVLB  8
0916C:  RRCF   xD7,F
0916E:  RRCF   xD6,F
09170:  RRCF   xD7,F
09172:  RRCF   xD6,F
09174:  RRCF   xD7,F
09176:  MOVFF  8D6,FBC
0917A:  RRCF   xD7,F
0917C:  RRCF   xD7,W
0917E:  ANDLW  30
09180:  MOVWF  00
09182:  MOVF   FBB,W
09184:  ANDLW  CF
09186:  IORWF  00,W
09188:  MOVWF  FBB
0918A:  BRA    918E
....................                else output_bit(M1_ENABLE, OFF); 
0918C:  BCF    F90.1
....................          break;   
0918E:  MOVLB  0
09190:  BRA    9200
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
09192:  BCF    FD8.0
09194:  MOVLB  7
09196:  RLCF   x3C,W
09198:  CLRF   03
0919A:  ADDLW  4E
0919C:  MOVWF  FE9
0919E:  MOVLW  07
091A0:  ADDWFC 03,W
091A2:  MOVWF  FEA
091A4:  MOVFF  FEC,8D7
091A8:  MOVF   FED,F
091AA:  MOVFF  FEF,8D6
091AE:  MOVLB  8
091B0:  MOVF   xD6,F
091B2:  BNZ   91B8
091B4:  MOVF   xD7,F
091B6:  BZ    91FA
091B8:  BCF    FD8.0
091BA:  MOVLB  7
091BC:  RLCF   x3C,W
091BE:  CLRF   03
091C0:  ADDLW  4E
091C2:  MOVWF  FE9
091C4:  MOVLW  07
091C6:  ADDWFC 03,W
091C8:  MOVWF  FEA
091CA:  MOVFF  FEC,8D7
091CE:  MOVF   FED,F
091D0:  MOVFF  FEF,8D6
091D4:  MOVLB  8
091D6:  RRCF   xD7,F
091D8:  RRCF   xD6,F
091DA:  RRCF   xD7,F
091DC:  RRCF   xD6,F
091DE:  RRCF   xD7,F
091E0:  MOVFF  8D6,F4F
091E4:  RRCF   xD7,F
091E6:  RRCF   xD7,W
091E8:  ANDLW  30
091EA:  MOVWF  00
091EC:  MOVLB  F
091EE:  MOVF   x4E,W
091F0:  ANDLW  CF
091F2:  IORWF  00,W
091F4:  MOVWF  x4E
091F6:  BRA    91FE
091F8:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
091FA:  BCF    F8D.1
091FC:  MOVLB  F
....................          break; 
091FE:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
09200:  BCF    FA0.1
....................    enc_isr(OFF); 
09202:  MOVLB  8
09204:  CLRF   xD6
09206:  MOVLB  0
09208:  RCALL  8E4C
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
0920A:  MOVLB  7
0920C:  MOVF   x4E,F
0920E:  BNZ   921E
09210:  MOVF   x4F,F
09212:  BNZ   921E
09214:  MOVF   x50,F
09216:  BNZ   921E
09218:  MOVF   x51,F
0921A:  BNZ   921E
....................    { 
....................       output_bit(VMOT,OFF); 
0921C:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
0921E:  MOVLB  8
09220:  CLRF   xD6
09222:  MOVLB  0
09224:  CALL   8A02
....................  
....................    if(success==TRUE) 
09228:  MOVLB  8
0922A:  DECFSZ xD5,W
0922C:  BRA    93C8
....................    { 
....................       m_error[motor]=FALSE; 
0922E:  BCF    FD8.0
09230:  MOVLB  7
09232:  RLCF   x3C,W
09234:  CLRF   03
09236:  ADDLW  92
09238:  MOVWF  FE9
0923A:  MOVLW  07
0923C:  ADDWFC 03,W
0923E:  MOVWF  FEA
09240:  CLRF   FEC
09242:  MOVF   FED,F
09244:  CLRF   FEF
....................       wrt_m_error(); 
09246:  MOVLB  0
09248:  RCALL  8FB2
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
0924A:  BCF    FD8.0
0924C:  MOVLB  7
0924E:  RLCF   x3C,W
09250:  CLRF   03
09252:  ADDLW  62
09254:  MOVWF  FE9
09256:  MOVLW  07
09258:  ADDWFC 03,W
0925A:  MOVWF  FEA
0925C:  MOVFF  FEC,8D7
09260:  MOVF   FED,F
09262:  MOVFF  FEF,8D6
09266:  MOVLB  8
09268:  MOVF   xD6,W
0926A:  SUBLW  03
0926C:  BNZ   92A4
0926E:  MOVF   xD7,F
09270:  BNZ   92A4
....................       { 
....................          e_pos[motor] = 0; 
09272:  BCF    FD8.0
09274:  MOVLB  7
09276:  RLCF   x3C,W
09278:  CLRF   03
0927A:  ADDLW  BB
0927C:  MOVWF  FE9
0927E:  MOVLW  07
09280:  ADDWFC 03,W
09282:  MOVWF  FEA
09284:  CLRF   FEC
09286:  MOVF   FED,F
09288:  CLRF   FEF
....................          e_port[motor] = 1; 
0928A:  BCF    FD8.0
0928C:  RLCF   x3C,W
0928E:  CLRF   03
09290:  ADDLW  BF
09292:  MOVWF  FE9
09294:  MOVLW  07
09296:  ADDWFC 03,W
09298:  MOVWF  FEA
0929A:  CLRF   FEC
0929C:  MOVF   FED,F
0929E:  MOVLW  01
092A0:  MOVWF  FEF
092A2:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
092A4:  BCF    FD8.0
092A6:  MOVLB  7
092A8:  RLCF   x3C,W
092AA:  CLRF   03
092AC:  ADDLW  62
092AE:  MOVWF  FE9
092B0:  MOVLW  07
092B2:  ADDWFC 03,W
092B4:  MOVWF  FEA
092B6:  MOVFF  FEC,8D7
092BA:  MOVF   FED,F
092BC:  MOVFF  FEF,8D6
092C0:  MOVLB  8
092C2:  MOVF   xD6,W
092C4:  SUBLW  02
092C6:  BNZ   9312
092C8:  MOVF   xD7,F
092CA:  BNZ   9312
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
092CC:  BCF    FD8.0
092CE:  MOVLB  7
092D0:  RLCF   x3C,W
092D2:  CLRF   03
092D4:  ADDLW  BF
092D6:  MOVWF  01
092D8:  MOVLW  07
092DA:  ADDWFC 03,F
092DC:  MOVLB  8
092DE:  MOVFF  03,8D7
092E2:  BCF    FD8.0
092E4:  MOVLB  7
092E6:  RLCF   x3C,W
092E8:  CLRF   03
092EA:  ADDLW  C3
092EC:  MOVWF  FE9
092EE:  MOVLW  07
092F0:  ADDWFC 03,W
092F2:  MOVWF  FEA
092F4:  MOVFF  FEC,03
092F8:  MOVF   FED,F
092FA:  MOVFF  FEF,8D8
092FE:  MOVLB  8
09300:  MOVFF  8D7,FEA
09304:  MOVFF  01,FE9
09308:  MOVFF  03,FEC
0930C:  MOVF   FED,F
0930E:  MOVFF  8D8,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
09312:  BCF    FD8.0
09314:  MOVLB  7
09316:  RLCF   x3C,W
09318:  CLRF   03
0931A:  ADDLW  62
0931C:  MOVWF  FE9
0931E:  MOVLW  07
09320:  ADDWFC 03,W
09322:  MOVWF  FEA
09324:  MOVFF  FEC,8D7
09328:  MOVF   FED,F
0932A:  MOVFF  FEF,8D6
0932E:  MOVLB  8
09330:  MOVF   xD6,W
09332:  SUBLW  02
09334:  BNZ   933A
09336:  MOVF   xD7,F
09338:  BZ    9362
0933A:  BCF    FD8.0
0933C:  MOVLB  7
0933E:  RLCF   x3C,W
09340:  CLRF   03
09342:  ADDLW  62
09344:  MOVWF  FE9
09346:  MOVLW  07
09348:  ADDWFC 03,W
0934A:  MOVWF  FEA
0934C:  MOVFF  FEC,8D7
09350:  MOVF   FED,F
09352:  MOVFF  FEF,8D6
09356:  MOVLB  8
09358:  MOVF   xD6,W
0935A:  SUBLW  03
0935C:  BNZ   93C6
0935E:  MOVF   xD7,F
09360:  BNZ   93C6
....................       { 
....................          switch(motor) 
09362:  MOVLB  7
09364:  MOVF   x3C,W
09366:  XORLW  00
09368:  MOVLB  0
0936A:  BZ    9372
0936C:  XORLW  01
0936E:  BZ    939C
09370:  BRA    93C4
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09372:  MOVLW  7E
09374:  MOVLB  8
09376:  MOVWF  xD8
09378:  MOVFF  7BC,8DA
0937C:  MOVFF  7BB,8D9
09380:  MOVLB  0
09382:  CALL   501E
....................                      write16(ADDR_E1_PORT,e_port[0]); 
09386:  MOVLW  AA
09388:  MOVLB  8
0938A:  MOVWF  xD8
0938C:  MOVFF  7C0,8DA
09390:  MOVFF  7BF,8D9
09394:  MOVLB  0
09396:  CALL   501E
....................                break; 
0939A:  BRA    93C4
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
0939C:  MOVLW  80
0939E:  MOVLB  8
093A0:  MOVWF  xD8
093A2:  MOVFF  7BE,8DA
093A6:  MOVFF  7BD,8D9
093AA:  MOVLB  0
093AC:  CALL   501E
....................                      write16(ADDR_E2_PORT,e_port[1]); 
093B0:  MOVLW  AC
093B2:  MOVLB  8
093B4:  MOVWF  xD8
093B6:  MOVFF  7C2,8DA
093BA:  MOVFF  7C1,8D9
093BE:  MOVLB  0
093C0:  CALL   501E
....................                break;             
093C4:  MOVLB  8
....................          } 
....................       } 
....................    } 
093C6:  BRA    9470
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
093C8:  BCF    FD8.0
093CA:  MOVLB  7
093CC:  RLCF   x3C,W
093CE:  CLRF   03
093D0:  ADDLW  92
093D2:  MOVWF  FE9
093D4:  MOVLW  07
093D6:  ADDWFC 03,W
093D8:  MOVWF  FEA
093DA:  CLRF   FEC
093DC:  MOVF   FED,F
093DE:  MOVLW  01
093E0:  MOVWF  FEF
....................       e_pos[motor] = 0; 
093E2:  BCF    FD8.0
093E4:  RLCF   x3C,W
093E6:  CLRF   03
093E8:  ADDLW  BB
093EA:  MOVWF  FE9
093EC:  MOVLW  07
093EE:  ADDWFC 03,W
093F0:  MOVWF  FEA
093F2:  CLRF   FEC
093F4:  MOVF   FED,F
093F6:  CLRF   FEF
....................       e_port[motor] = 0; 
093F8:  BCF    FD8.0
093FA:  RLCF   x3C,W
093FC:  CLRF   03
093FE:  ADDLW  BF
09400:  MOVWF  FE9
09402:  MOVLW  07
09404:  ADDWFC 03,W
09406:  MOVWF  FEA
09408:  CLRF   FEC
0940A:  MOVF   FED,F
0940C:  CLRF   FEF
....................       switch(motor) 
0940E:  MOVF   x3C,W
09410:  XORLW  00
09412:  MOVLB  0
09414:  BZ    941C
09416:  XORLW  01
09418:  BZ    9446
0941A:  BRA    946E
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
0941C:  MOVLW  7E
0941E:  MOVLB  8
09420:  MOVWF  xD8
09422:  MOVFF  7BC,8DA
09426:  MOVFF  7BB,8D9
0942A:  MOVLB  0
0942C:  CALL   501E
....................                   write16(ADDR_E1_PORT,e_port[0]); 
09430:  MOVLW  AA
09432:  MOVLB  8
09434:  MOVWF  xD8
09436:  MOVFF  7C0,8DA
0943A:  MOVFF  7BF,8D9
0943E:  MOVLB  0
09440:  CALL   501E
....................             break; 
09444:  BRA    946E
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
09446:  MOVLW  80
09448:  MOVLB  8
0944A:  MOVWF  xD8
0944C:  MOVFF  7BE,8DA
09450:  MOVFF  7BD,8D9
09454:  MOVLB  0
09456:  CALL   501E
....................                   write16(ADDR_E2_PORT,e_port[1]); 
0945A:  MOVLW  AC
0945C:  MOVLB  8
0945E:  MOVWF  xD8
09460:  MOVFF  7C2,8DA
09464:  MOVFF  7C1,8D9
09468:  MOVLB  0
0946A:  CALL   501E
....................             break;             
0946E:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
09470:  BCF    FD8.0
09472:  MOVLB  7
09474:  RLCF   x3C,W
09476:  CLRF   03
09478:  ADDLW  AB
0947A:  MOVWF  FE9
0947C:  MOVLW  07
0947E:  ADDWFC 03,W
09480:  MOVWF  FEA
09482:  CLRF   FEC
09484:  MOVF   FED,F
09486:  MOVLW  01
09488:  MOVWF  FEF
....................     
....................    switch (motor) 
0948A:  MOVF   x3C,W
0948C:  XORLW  00
0948E:  MOVLB  0
09490:  BZ    9498
09492:  XORLW  01
09494:  BZ    94C0
09496:  BRA    94E6
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
09498:  MOVLW  B2
0949A:  MOVLB  8
0949C:  MOVWF  xD8
0949E:  CLRF   xDA
094A0:  MOVLW  01
094A2:  MOVWF  xD9
094A4:  MOVLB  0
094A6:  CALL   501E
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
094AA:  MOVLW  B6
094AC:  MOVLB  8
094AE:  MOVWF  xD8
094B0:  MOVFF  7B0,8DA
094B4:  MOVFF  7AF,8D9
094B8:  MOVLB  0
094BA:  CALL   501E
....................          break; 
094BE:  BRA    94E6
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
094C0:  MOVLW  B4
094C2:  MOVLB  8
094C4:  MOVWF  xD8
094C6:  CLRF   xDA
094C8:  MOVLW  01
094CA:  MOVWF  xD9
094CC:  MOVLB  0
094CE:  CALL   501E
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
094D2:  MOVLW  B8
094D4:  MOVLB  8
094D6:  MOVWF  xD8
094D8:  MOVFF  7B2,8DA
094DC:  MOVFF  7B1,8D9
094E0:  MOVLB  0
094E2:  CALL   501E
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
094E6:  MOVF   1F,W
094E8:  SUBLW  04
094EA:  BNZ   9590
094EC:  MOVF   20,F
094EE:  BNZ   9590
....................    { 
....................       if(motor==1) 
094F0:  MOVLB  7
094F2:  DECFSZ x3C,W
094F4:  BRA    9592
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
094F6:  BCF    FD8.0
094F8:  RLCF   x3C,W
094FA:  CLRF   03
094FC:  ADDLW  AB
094FE:  MOVWF  FE9
09500:  MOVLW  07
09502:  ADDWFC 03,W
09504:  MOVWF  FEA
09506:  MOVFF  FEC,8D7
0950A:  MOVF   FED,F
0950C:  MOVFF  FEF,8D6
09510:  BCF    FD8.0
09512:  RLCF   x3C,W
09514:  CLRF   03
09516:  ADDLW  AF
09518:  MOVWF  FE9
0951A:  MOVLW  07
0951C:  ADDWFC 03,W
0951E:  MOVWF  FEA
09520:  MOVFF  FEC,8D9
09524:  MOVF   FED,F
09526:  MOVFF  FEF,8D8
0952A:  MOVLW  4A
0952C:  MOVWF  FF6
0952E:  MOVLW  1A
09530:  MOVWF  FF7
09532:  MOVLW  00
09534:  MOVWF  FF8
09536:  CLRF   1B
09538:  BTFSC  FF2.7
0953A:  BSF    1B.7
0953C:  BCF    FF2.7
0953E:  MOVLW  05
09540:  MOVLB  A
09542:  MOVWF  x25
09544:  MOVLB  0
09546:  CALL   1010
0954A:  BTFSC  1B.7
0954C:  BSF    FF2.7
0954E:  MOVLW  10
09550:  MOVWF  FE9
09552:  CLRF   1B
09554:  BTFSC  FF2.7
09556:  BSF    1B.7
09558:  BCF    FF2.7
0955A:  MOVFF  8D7,A26
0955E:  MOVFF  8D6,A25
09562:  CALL   1192
09566:  BTFSC  1B.7
09568:  BSF    FF2.7
0956A:  MOVLW  2C
0956C:  BTFSS  F9E.4
0956E:  BRA    956C
09570:  MOVWF  FAD
09572:  MOVLW  10
09574:  MOVWF  FE9
09576:  MOVFF  8D9,8DB
0957A:  MOVFF  8D8,8DA
0957E:  RCALL  9016
09580:  MOVLW  0D
09582:  BTFSS  F9E.4
09584:  BRA    9582
09586:  MOVWF  FAD
09588:  MOVLW  0A
0958A:  BTFSS  F9E.4
0958C:  BRA    958A
0958E:  MOVWF  FAD
09590:  MOVLB  7
....................       } 
....................    } 
09592:  MOVLB  0
09594:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
096C2:  BCF    FD8.0
096C4:  MOVLB  7
096C6:  RLCF   x3C,W
096C8:  CLRF   03
096CA:  ADDLW  66
096CC:  MOVWF  FE9
096CE:  MOVLW  07
096D0:  ADDWFC 03,W
096D2:  MOVWF  FEA
096D4:  MOVFF  FEC,8D6
096D8:  MOVF   FED,F
096DA:  MOVFF  FEF,8D5
096DE:  MOVLB  8
096E0:  DECFSZ xD5,W
096E2:  BRA    96F2
096E4:  MOVF   xD6,F
096E6:  BNZ   96F2
096E8:  MOVLW  01
096EA:  MOVWF  xD5
096EC:  MOVLB  0
096EE:  RCALL  9102
096F0:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
096F2:  BCF    FD8.0
096F4:  MOVLB  7
096F6:  RLCF   x3C,W
096F8:  CLRF   03
096FA:  ADDLW  66
096FC:  MOVWF  FE9
096FE:  MOVLW  07
09700:  ADDWFC 03,W
09702:  MOVWF  FEA
09704:  MOVFF  FEC,8D6
09708:  MOVF   FED,F
0970A:  MOVFF  FEF,8D5
0970E:  MOVLB  8
09710:  MOVF   xD5,W
09712:  SUBLW  02
09714:  BTFSS  FD8.2
09716:  BRA    9D20
09718:  MOVF   xD6,F
0971A:  BTFSS  FD8.2
0971C:  BRA    9D20
....................       if (e_mode[motor]==2){ 
0971E:  BCF    FD8.0
09720:  MOVLB  7
09722:  RLCF   x3C,W
09724:  CLRF   03
09726:  ADDLW  62
09728:  MOVWF  FE9
0972A:  MOVLW  07
0972C:  ADDWFC 03,W
0972E:  MOVWF  FEA
09730:  MOVFF  FEC,8D6
09734:  MOVF   FED,F
09736:  MOVFF  FEF,8D5
0973A:  MOVLB  8
0973C:  MOVF   xD5,W
0973E:  SUBLW  02
09740:  BTFSS  FD8.2
09742:  BRA    9C9C
09744:  MOVF   xD6,F
09746:  BTFSS  FD8.2
09748:  BRA    9C9C
....................          if(nv_product==ECO || nv_product==WMS2){ 
0974A:  MOVF   2F,F
0974C:  BNZ   9752
0974E:  MOVF   30,F
09750:  BZ    9760
09752:  MOVF   2F,W
09754:  SUBLW  03
09756:  BTFSS  FD8.2
09758:  BRA    98A4
0975A:  MOVF   30,F
0975C:  BTFSS  FD8.2
0975E:  BRA    98A4
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
09760:  BCF    FD8.0
09762:  MOVLB  7
09764:  RLCF   x3C,W
09766:  CLRF   03
09768:  ADDLW  A7
0976A:  MOVWF  FE9
0976C:  MOVLW  07
0976E:  ADDWFC 03,W
09770:  MOVWF  FEA
09772:  MOVFF  FEC,9E1
09776:  MOVF   FED,F
09778:  MOVFF  FEF,9E0
0977C:  MOVFF  FEA,8D8
09780:  MOVFF  FE9,8D7
09784:  MOVLB  9
09786:  CLRF   xE3
09788:  CLRF   xE2
0978A:  MOVFF  8C6,9E7
0978E:  MOVFF  8C5,9E6
09792:  MOVFF  8C4,9E5
09796:  MOVFF  8C3,9E4
0979A:  MOVLB  0
0979C:  CALL   4844
097A0:  MOVFF  8D8,FEA
097A4:  MOVFF  8D7,FE9
097A8:  MOVFF  03,8D8
097AC:  MOVFF  02,8D7
097B0:  MOVFF  01,8D6
097B4:  MOVFF  00,8D5
097B8:  BCF    FD8.0
097BA:  MOVLB  7
097BC:  RLCF   x3C,W
097BE:  CLRF   03
097C0:  ADDLW  A7
097C2:  MOVWF  FE9
097C4:  MOVLW  07
097C6:  ADDWFC 03,W
097C8:  MOVWF  FEA
097CA:  MOVFF  FEC,8DA
097CE:  MOVF   FED,F
097D0:  MOVFF  FEF,8D9
097D4:  BCF    FD8.0
097D6:  MOVLB  8
097D8:  RRCF   xDA,W
097DA:  MOVWF  03
097DC:  RRCF   xD9,W
097DE:  MOVWF  02
097E0:  ADDWF  00,W
097E2:  MOVWF  00
097E4:  MOVF   03,W
097E6:  ADDWFC 01,W
097E8:  MOVWF  01
097EA:  MOVLW  00
097EC:  ADDWFC xD7,W
097EE:  MOVWF  02
097F0:  MOVLW  00
097F2:  ADDWFC xD8,W
097F4:  MOVWF  xD0
097F6:  MOVFF  02,8CF
097FA:  MOVFF  01,8CE
097FE:  MOVFF  00,8CD
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
09802:  BCF    FD8.0
09804:  MOVLB  7
09806:  RLCF   x3C,W
09808:  CLRF   03
0980A:  ADDLW  A7
0980C:  MOVWF  FE9
0980E:  MOVLW  07
09810:  ADDWFC 03,W
09812:  MOVWF  FEA
09814:  MOVFF  FEC,9E1
09818:  MOVF   FED,F
0981A:  MOVFF  FEF,9E0
0981E:  MOVFF  FEA,8D8
09822:  MOVFF  FE9,8D7
09826:  MOVLB  9
09828:  CLRF   xE3
0982A:  CLRF   xE2
0982C:  MOVFF  8C6,9E7
09830:  MOVFF  8C5,9E6
09834:  MOVFF  8C4,9E5
09838:  MOVFF  8C3,9E4
0983C:  MOVLB  0
0983E:  CALL   4844
09842:  MOVFF  8D8,FEA
09846:  MOVFF  8D7,FE9
0984A:  MOVFF  03,8D8
0984E:  MOVFF  02,8D7
09852:  MOVFF  01,8D6
09856:  MOVFF  00,8D5
0985A:  BCF    FD8.0
0985C:  MOVLB  7
0985E:  RLCF   x3C,W
09860:  CLRF   03
09862:  ADDLW  A7
09864:  MOVWF  FE9
09866:  MOVLW  07
09868:  ADDWFC 03,W
0986A:  MOVWF  FEA
0986C:  MOVFF  FEC,8DA
09870:  MOVF   FED,F
09872:  MOVFF  FEF,8D9
09876:  BCF    FD8.0
09878:  MOVLB  8
0987A:  RRCF   xDA,W
0987C:  MOVWF  03
0987E:  RRCF   xD9,W
09880:  MOVWF  02
09882:  SUBWF  00,W
09884:  MOVWF  00
09886:  MOVF   03,W
09888:  SUBWFB 01,W
0988A:  MOVWF  01
0988C:  MOVLW  00
0988E:  SUBWFB xD7,W
09890:  MOVWF  02
09892:  MOVLW  00
09894:  SUBWFB xD8,W
09896:  MOVWF  xD4
09898:  MOVFF  02,8D3
0989C:  MOVFF  01,8D2
098A0:  MOVFF  00,8D1
....................          } 
....................          if (nv_product==WMS4){ 
098A4:  DECFSZ 2F,W
098A6:  BRA    9ABE
098A8:  MOVF   30,F
098AA:  BTFSS  FD8.2
098AC:  BRA    9ABE
....................             if (end_even_port==FALSE){ 
098AE:  MOVLB  2
098B0:  MOVF   xD7,F
098B2:  BNZ   99A8
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
098B4:  BCF    FD8.0
098B6:  MOVLB  7
098B8:  RLCF   x3C,W
098BA:  CLRF   03
098BC:  ADDLW  A7
098BE:  MOVWF  FE9
098C0:  MOVLW  07
098C2:  ADDWFC 03,W
098C4:  MOVWF  FEA
098C6:  MOVFF  FEC,9F7
098CA:  MOVF   FED,F
098CC:  MOVFF  FEF,9F6
098D0:  MOVFF  8C8,9F9
098D4:  MOVFF  8C7,9F8
098D8:  MOVLB  0
098DA:  CALL   5D06
098DE:  MOVFF  02,8D6
098E2:  MOVFF  01,8D5
098E6:  BCF    FD8.0
098E8:  MOVLB  7
098EA:  RLCF   x3C,W
098EC:  CLRF   03
098EE:  ADDLW  A7
098F0:  MOVWF  FE9
098F2:  MOVLW  07
098F4:  ADDWFC 03,W
098F6:  MOVWF  FEA
098F8:  MOVFF  FEC,8D8
098FC:  MOVF   FED,F
098FE:  MOVFF  FEF,8D7
09902:  BCF    FD8.0
09904:  MOVLB  8
09906:  RRCF   xD8,W
09908:  MOVWF  03
0990A:  RRCF   xD7,W
0990C:  MOVWF  02
0990E:  ADDWF  01,W
09910:  MOVWF  01
09912:  MOVF   xD6,W
09914:  ADDWFC 03,F
09916:  MOVFF  01,8CD
0991A:  MOVFF  03,8CE
0991E:  CLRF   02
09920:  CLRF   03
09922:  MOVFF  03,8D0
09926:  MOVFF  02,8CF
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
0992A:  BCF    FD8.0
0992C:  MOVLB  7
0992E:  RLCF   x3C,W
09930:  CLRF   03
09932:  ADDLW  A7
09934:  MOVWF  FE9
09936:  MOVLW  07
09938:  ADDWFC 03,W
0993A:  MOVWF  FEA
0993C:  MOVFF  FEC,9F7
09940:  MOVF   FED,F
09942:  MOVFF  FEF,9F6
09946:  MOVFF  8C8,9F9
0994A:  MOVFF  8C7,9F8
0994E:  MOVLB  0
09950:  CALL   5D06
09954:  MOVFF  02,8D6
09958:  MOVFF  01,8D5
0995C:  BCF    FD8.0
0995E:  MOVLB  7
09960:  RLCF   x3C,W
09962:  CLRF   03
09964:  ADDLW  A7
09966:  MOVWF  FE9
09968:  MOVLW  07
0996A:  ADDWFC 03,W
0996C:  MOVWF  FEA
0996E:  MOVFF  FEC,8D8
09972:  MOVF   FED,F
09974:  MOVFF  FEF,8D7
09978:  BCF    FD8.0
0997A:  MOVLB  8
0997C:  RRCF   xD8,W
0997E:  MOVWF  03
09980:  RRCF   xD7,W
09982:  MOVWF  02
09984:  SUBWF  01,W
09986:  MOVWF  00
09988:  MOVF   03,W
0998A:  SUBWFB xD6,W
0998C:  MOVWF  03
0998E:  MOVF   00,W
09990:  MOVFF  03,8D2
09994:  CLRF   02
09996:  CLRF   03
09998:  MOVFF  03,8D4
0999C:  MOVFF  02,8D3
099A0:  MOVFF  00,8D1
....................             } 
099A4:  BRA    9ABE
099A6:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
099A8:  DECFSZ xD7,W
099AA:  BRA    9AC0
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
099AC:  BCF    FD8.0
099AE:  MOVLB  7
099B0:  RLCF   x3C,W
099B2:  CLRF   03
099B4:  ADDLW  A7
099B6:  MOVWF  FE9
099B8:  MOVLW  07
099BA:  ADDWFC 03,W
099BC:  MOVWF  FEA
099BE:  MOVFF  FEC,9F7
099C2:  MOVF   FED,F
099C4:  MOVFF  FEF,9F6
099C8:  MOVLW  01
099CA:  MOVLB  8
099CC:  SUBWF  xC7,W
099CE:  MOVWF  00
099D0:  MOVLW  00
099D2:  SUBWFB xC8,W
099D4:  MOVWF  03
099D6:  MOVFF  00,8D7
099DA:  MOVWF  xD8
099DC:  MOVFF  FE8,9F9
099E0:  MOVFF  00,9F8
099E4:  MOVLB  0
099E6:  CALL   5D06
099EA:  MOVFF  02,8D6
099EE:  MOVFF  01,8D5
099F2:  BCF    FD8.0
099F4:  MOVLB  7
099F6:  RLCF   x3C,W
099F8:  CLRF   03
099FA:  ADDLW  A7
099FC:  MOVWF  FE9
099FE:  MOVLW  07
09A00:  ADDWFC 03,W
09A02:  MOVWF  FEA
09A04:  MOVFF  FEC,8D8
09A08:  MOVF   FED,F
09A0A:  MOVFF  FEF,8D7
09A0E:  BCF    FD8.0
09A10:  MOVLB  8
09A12:  RRCF   xD8,W
09A14:  MOVWF  03
09A16:  RRCF   xD7,W
09A18:  MOVWF  02
09A1A:  ADDWF  01,W
09A1C:  MOVWF  01
09A1E:  MOVF   xD6,W
09A20:  ADDWFC 03,F
09A22:  MOVFF  01,8CD
09A26:  MOVFF  03,8CE
09A2A:  CLRF   02
09A2C:  CLRF   03
09A2E:  MOVFF  03,8D0
09A32:  MOVFF  02,8CF
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
09A36:  BCF    FD8.0
09A38:  MOVLB  7
09A3A:  RLCF   x3C,W
09A3C:  CLRF   03
09A3E:  ADDLW  A7
09A40:  MOVWF  FE9
09A42:  MOVLW  07
09A44:  ADDWFC 03,W
09A46:  MOVWF  FEA
09A48:  MOVFF  FEC,9F7
09A4C:  MOVF   FED,F
09A4E:  MOVFF  FEF,9F6
09A52:  MOVLW  01
09A54:  MOVLB  8
09A56:  SUBWF  xC7,W
09A58:  MOVWF  00
09A5A:  MOVLW  00
09A5C:  SUBWFB xC8,W
09A5E:  MOVWF  03
09A60:  MOVFF  00,8D7
09A64:  MOVWF  xD8
09A66:  MOVFF  FE8,9F9
09A6A:  MOVFF  00,9F8
09A6E:  MOVLB  0
09A70:  CALL   5D06
09A74:  MOVFF  02,03
09A78:  MOVFF  01,8D1
09A7C:  MOVFF  02,8D2
09A80:  CLRF   02
09A82:  CLRF   03
09A84:  MOVFF  03,8D4
09A88:  MOVFF  02,8D3
....................                m_pll = m_pll -(m_ppp[motor]/2); 
09A8C:  BCF    FD8.0
09A8E:  MOVLB  7
09A90:  RLCF   x3C,W
09A92:  CLRF   03
09A94:  ADDLW  A7
09A96:  MOVWF  FE9
09A98:  MOVLW  07
09A9A:  ADDWFC 03,W
09A9C:  MOVWF  FEA
09A9E:  MOVFF  FEC,8D6
09AA2:  MOVF   FED,F
09AA4:  MOVFF  FEF,8D5
09AA8:  BCF    FD8.0
09AAA:  MOVLB  8
09AAC:  RRCF   xD6,W
09AAE:  MOVWF  03
09AB0:  RRCF   xD5,W
09AB2:  SUBWF  xD1,F
09AB4:  MOVF   03,W
09AB6:  SUBWFB xD2,F
09AB8:  MOVLW  00
09ABA:  SUBWFB xD3,F
09ABC:  SUBWFB xD4,F
09ABE:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
09AC0:  MOVLB  7
09AC2:  MOVF   x3C,W
09AC4:  MULLW  04
09AC6:  MOVF   FF3,W
09AC8:  CLRF   03
09ACA:  ADDLW  9E
09ACC:  MOVWF  FE9
09ACE:  MOVLW  07
09AD0:  ADDWFC 03,W
09AD2:  MOVWF  FEA
09AD4:  MOVFF  FEF,8D5
09AD8:  MOVFF  FEC,8D6
09ADC:  MOVFF  FEC,8D7
09AE0:  MOVFF  FEC,8D8
09AE4:  MOVLB  8
09AE6:  BTFSC  xD0.7
09AE8:  BRA    9B58
09AEA:  MOVF   xD0,W
09AEC:  SUBWF  xD8,W
09AEE:  BNC   9B08
09AF0:  BNZ   9B58
09AF2:  MOVF   xCF,W
09AF4:  SUBWF  xD7,W
09AF6:  BNC   9B08
09AF8:  BNZ   9B58
09AFA:  MOVF   xCE,W
09AFC:  SUBWF  xD6,W
09AFE:  BNC   9B08
09B00:  BNZ   9B58
09B02:  MOVF   xD5,W
09B04:  SUBWF  xCD,W
09B06:  BNC   9B58
09B08:  MOVLB  7
09B0A:  MOVF   x3C,W
09B0C:  MULLW  04
09B0E:  MOVF   FF3,W
09B10:  CLRF   03
09B12:  ADDLW  9E
09B14:  MOVWF  FE9
09B16:  MOVLW  07
09B18:  ADDWFC 03,W
09B1A:  MOVWF  FEA
09B1C:  MOVFF  FEF,8D5
09B20:  MOVFF  FEC,8D6
09B24:  MOVFF  FEC,8D7
09B28:  MOVFF  FEC,8D8
09B2C:  MOVLB  8
09B2E:  BTFSC  xD4.7
09B30:  BRA    9C9C
09B32:  MOVF   xD8,W
09B34:  SUBWF  xD4,W
09B36:  BTFSS  FD8.0
09B38:  BRA    9C9C
09B3A:  BNZ   9B58
09B3C:  MOVF   xD7,W
09B3E:  SUBWF  xD3,W
09B40:  BTFSS  FD8.0
09B42:  BRA    9C9C
09B44:  BNZ   9B58
09B46:  MOVF   xD6,W
09B48:  SUBWF  xD2,W
09B4A:  BTFSS  FD8.0
09B4C:  BRA    9C9C
09B4E:  BNZ   9B58
09B50:  MOVF   xD1,W
09B52:  SUBWF  xD5,W
09B54:  BTFSC  FD8.0
09B56:  BRA    9C9C
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09B58:  MOVLW  01
09B5A:  MOVLB  7
09B5C:  ADDWF  x3C,W
09B5E:  MOVLB  8
09B60:  MOVWF  xD5
09B62:  BCF    FD8.0
09B64:  MOVLB  7
09B66:  RLCF   x3C,W
09B68:  CLRF   03
09B6A:  ADDLW  A7
09B6C:  MOVWF  FE9
09B6E:  MOVLW  07
09B70:  ADDWFC 03,W
09B72:  MOVWF  FEA
09B74:  MOVFF  FEC,8D7
09B78:  MOVF   FED,F
09B7A:  MOVFF  FEF,8D6
09B7E:  MOVF   x3C,W
09B80:  MULLW  04
09B82:  MOVF   FF3,W
09B84:  CLRF   03
09B86:  ADDLW  9E
09B88:  MOVWF  FE9
09B8A:  MOVLW  07
09B8C:  ADDWFC 03,W
09B8E:  MOVWF  FEA
09B90:  MOVFF  FEF,8D8
09B94:  MOVFF  FEC,8D9
09B98:  MOVFF  FEC,8DA
09B9C:  MOVFF  FEC,8DB
09BA0:  MOVLW  5A
09BA2:  MOVWF  FF6
09BA4:  MOVLW  1A
09BA6:  MOVWF  FF7
09BA8:  MOVLW  00
09BAA:  MOVWF  FF8
09BAC:  CLRF   1B
09BAE:  BTFSC  FF2.7
09BB0:  BSF    1B.7
09BB2:  BCF    FF2.7
09BB4:  MOVLW  05
09BB6:  MOVLB  A
09BB8:  MOVWF  x25
09BBA:  MOVLB  0
09BBC:  CALL   1010
09BC0:  BTFSC  1B.7
09BC2:  BSF    FF2.7
09BC4:  CLRF   1B
09BC6:  BTFSC  FF2.7
09BC8:  BSF    1B.7
09BCA:  BCF    FF2.7
09BCC:  MOVFF  8D5,A25
09BD0:  MOVLW  1B
09BD2:  MOVLB  A
09BD4:  MOVWF  x26
09BD6:  MOVLB  0
09BD8:  CALL   0F92
09BDC:  BTFSC  1B.7
09BDE:  BSF    FF2.7
09BE0:  MOVLW  2C
09BE2:  BTFSS  F9E.4
09BE4:  BRA    9BE2
09BE6:  MOVWF  FAD
09BE8:  MOVLW  41
09BEA:  MOVWF  FE9
09BEC:  MOVFF  8C6,8DF
09BF0:  MOVFF  8C5,8DE
09BF4:  MOVFF  8C4,8DD
09BF8:  MOVFF  8C3,8DC
09BFC:  RCALL  9596
09BFE:  MOVLW  2C
09C00:  BTFSS  F9E.4
09C02:  BRA    9C00
09C04:  MOVWF  FAD
09C06:  MOVLW  10
09C08:  MOVWF  FE9
09C0A:  CLRF   1B
09C0C:  BTFSC  FF2.7
09C0E:  BSF    1B.7
09C10:  BCF    FF2.7
09C12:  MOVFF  8D7,A26
09C16:  MOVFF  8D6,A25
09C1A:  CALL   1192
09C1E:  BTFSC  1B.7
09C20:  BSF    FF2.7
09C22:  MOVLW  2C
09C24:  BTFSS  F9E.4
09C26:  BRA    9C24
09C28:  MOVWF  FAD
09C2A:  MOVLW  41
09C2C:  MOVWF  FE9
09C2E:  CLRF   1B
09C30:  BTFSC  FF2.7
09C32:  BSF    1B.7
09C34:  BCF    FF2.7
09C36:  MOVFF  8DB,A28
09C3A:  MOVFF  8DA,A27
09C3E:  MOVFF  8D9,A26
09C42:  MOVFF  8D8,A25
09C46:  CALL   10D6
09C4A:  BTFSC  1B.7
09C4C:  BSF    FF2.7
09C4E:  MOVLW  2C
09C50:  BTFSS  F9E.4
09C52:  BRA    9C50
09C54:  MOVWF  FAD
09C56:  MOVLW  41
09C58:  MOVWF  FE9
09C5A:  MOVFF  8D0,8DF
09C5E:  MOVFF  8CF,8DE
09C62:  MOVFF  8CE,8DD
09C66:  MOVFF  8CD,8DC
09C6A:  RCALL  9596
09C6C:  MOVLW  2C
09C6E:  BTFSS  F9E.4
09C70:  BRA    9C6E
09C72:  MOVWF  FAD
09C74:  MOVLW  41
09C76:  MOVWF  FE9
09C78:  MOVFF  8D4,8DF
09C7C:  MOVFF  8D3,8DE
09C80:  MOVFF  8D2,8DD
09C84:  MOVFF  8D1,8DC
09C88:  RCALL  9596
09C8A:  MOVLW  0D
09C8C:  BTFSS  F9E.4
09C8E:  BRA    9C8C
09C90:  MOVWF  FAD
09C92:  MOVLW  0A
09C94:  BTFSS  F9E.4
09C96:  BRA    9C94
09C98:  MOVWF  FAD
09C9A:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09C9C:  BCF    FD8.0
09C9E:  MOVLB  7
09CA0:  RLCF   x3C,W
09CA2:  CLRF   03
09CA4:  ADDLW  9A
09CA6:  MOVWF  01
09CA8:  MOVLW  07
09CAA:  ADDWFC 03,F
09CAC:  MOVLB  8
09CAE:  MOVFF  03,8D6
09CB2:  BCF    FD8.0
09CB4:  MOVLB  7
09CB6:  RLCF   x3C,W
09CB8:  CLRF   03
09CBA:  ADDLW  62
09CBC:  MOVWF  FE9
09CBE:  MOVLW  07
09CC0:  ADDWFC 03,W
09CC2:  MOVWF  FEA
09CC4:  MOVFF  FEC,03
09CC8:  MOVF   FED,F
09CCA:  MOVFF  FEF,8D7
09CCE:  MOVLB  8
09CD0:  MOVFF  8D6,FEA
09CD4:  MOVFF  01,FE9
09CD8:  MOVFF  03,FEC
09CDC:  MOVF   FED,F
09CDE:  MOVFF  8D7,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09CE2:  BCF    FD8.0
09CE4:  MOVLB  7
09CE6:  RLCF   x3C,W
09CE8:  CLRF   03
09CEA:  ADDLW  62
09CEC:  MOVWF  FE9
09CEE:  MOVLW  07
09CF0:  ADDWFC 03,W
09CF2:  MOVWF  FEA
09CF4:  CLRF   FEC
09CF6:  MOVF   FED,F
09CF8:  MOVLW  04
09CFA:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09CFC:  MOVF   x3C,W
09CFE:  MULLW  04
09D00:  MOVF   FF3,W
09D02:  CLRF   03
09D04:  ADDLW  9E
09D06:  MOVWF  FE9
09D08:  MOVLW  07
09D0A:  ADDWFC 03,W
09D0C:  MOVWF  FEA
09D0E:  MOVFF  FEF,8C9
09D12:  MOVFF  FEC,8CA
09D16:  MOVFF  FEC,8CB
09D1A:  MOVFF  FEC,8CC
09D1E:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09D20:  MOVFF  8C9,00
09D24:  MOVFF  8CA,01
09D28:  MOVFF  8CB,02
09D2C:  MOVFF  8CC,03
09D30:  MOVLB  0
09D32:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
08590:  MOVLB  2
08592:  CLRF   xD7
....................    start_even_port = FALSE; 
08594:  CLRF   xD6
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
08596:  BCF    FD8.0
08598:  MOVLB  7
0859A:  RLCF   x3C,W
0859C:  CLRF   03
0859E:  ADDLW  C3
085A0:  MOVWF  FE9
085A2:  MOVLW  07
085A4:  ADDWFC 03,W
085A6:  MOVWF  FEA
085A8:  MOVFF  FEC,8C3
085AC:  MOVF   FED,F
085AE:  MOVFF  FEF,8C2
085B2:  MOVLW  01
085B4:  MOVLB  8
085B6:  ANDWF  xC2,F
085B8:  CLRF   xC3
085BA:  MOVF   xC2,F
085BC:  BNZ   85CA
085BE:  MOVF   xC3,F
085C0:  BNZ   85CA
....................    { 
....................       end_even_port = TRUE; 
085C2:  MOVLW  01
085C4:  MOVLB  2
085C6:  MOVWF  xD7
085C8:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
085CA:  BCF    FD8.0
085CC:  MOVLB  7
085CE:  RLCF   x3C,W
085D0:  CLRF   03
085D2:  ADDLW  BF
085D4:  MOVWF  FE9
085D6:  MOVLW  07
085D8:  ADDWFC 03,W
085DA:  MOVWF  FEA
085DC:  MOVFF  FEC,8C3
085E0:  MOVF   FED,F
085E2:  MOVFF  FEF,8C2
085E6:  MOVLW  01
085E8:  MOVLB  8
085EA:  ANDWF  xC2,F
085EC:  CLRF   xC3
085EE:  MOVF   xC2,F
085F0:  BNZ   85FE
085F2:  MOVF   xC3,F
085F4:  BNZ   85FE
....................    { 
....................       start_even_port = TRUE; 
085F6:  MOVLW  01
085F8:  MOVLB  2
085FA:  MOVWF  xD6
085FC:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
085FE:  MOVLB  2
08600:  MOVF   xD6,F
08602:  BNZ   8618
....................    { 
....................       evenOdd = 0; 
08604:  MOVLB  8
08606:  CLRF   xC1
....................       if (TRUE == end_even_port) 
08608:  MOVLB  2
0860A:  DECFSZ xD7,W
0860C:  BRA    8616
....................       { 
....................          evenOdd = 1; 
0860E:  MOVLW  01
08610:  MOVLB  8
08612:  MOVWF  xC1
08614:  MOVLB  2
....................       } 
....................    } 
08616:  BRA    862C
....................    else 
....................    { 
....................       evenOdd = 2; 
08618:  MOVLW  02
0861A:  MOVLB  8
0861C:  MOVWF  xC1
....................       if (TRUE == end_even_port) 
0861E:  MOVLB  2
08620:  DECFSZ xD7,W
08622:  BRA    862C
....................       { 
....................          evenOdd = 3; 
08624:  MOVLW  03
08626:  MOVLB  8
08628:  MOVWF  xC1
0862A:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
0862C:  MOVLB  8
0862E:  MOVFF  8C1,01
08632:  MOVLB  0
08634:  GOTO   A082 (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09DAA:  BCF    FD8.0
09DAC:  MOVLB  7
09DAE:  RLCF   x3C,W
09DB0:  CLRF   03
09DB2:  ADDLW  82
09DB4:  MOVWF  FE9
09DB6:  MOVLW  07
09DB8:  ADDWFC 03,W
09DBA:  MOVWF  FEA
09DBC:  CLRF   FEC
09DBE:  MOVF   FED,F
09DC0:  MOVFF  8B2,FEF
....................    m_step_cnt[motor] = 0; 
09DC4:  MOVF   x3C,W
09DC6:  MULLW  04
09DC8:  MOVF   FF3,W
09DCA:  CLRF   03
09DCC:  ADDLW  9E
09DCE:  MOVWF  FE9
09DD0:  MOVLW  07
09DD2:  ADDWFC 03,W
09DD4:  MOVWF  FEA
09DD6:  MOVF   FEE,F
09DD8:  MOVF   FEE,F
09DDA:  CLRF   FEC
09DDC:  MOVF   FED,F
09DDE:  CLRF   FEF
09DE0:  MOVF   FED,F
09DE2:  CLRF   FEF
09DE4:  MOVF   FED,F
09DE6:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09DE8:  BCF    FD8.0
09DEA:  RLCF   x3C,W
09DEC:  CLRF   03
09DEE:  ADDLW  6A
09DF0:  MOVWF  FE9
09DF2:  MOVLW  07
09DF4:  ADDWFC 03,W
09DF6:  MOVWF  FEA
09DF8:  MOVFF  FEC,8BF
09DFC:  MOVF   FED,F
09DFE:  MOVFF  FEF,8BE
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09E02:  BCF    FD8.0
09E04:  RLCF   x3C,W
09E06:  CLRF   03
09E08:  ADDLW  72
09E0A:  MOVWF  FE9
09E0C:  MOVLW  07
09E0E:  ADDWFC 03,W
09E10:  MOVWF  FEA
09E12:  MOVFF  FEC,8C6
09E16:  MOVF   FED,F
09E18:  MOVFF  FEF,8C5
09E1C:  BCF    FD8.0
09E1E:  RLCF   x3C,W
09E20:  CLRF   03
09E22:  ADDLW  5A
09E24:  MOVWF  FE9
09E26:  MOVLW  07
09E28:  ADDWFC 03,W
09E2A:  MOVWF  FEA
09E2C:  MOVFF  FEC,03
09E30:  MOVF   FED,F
09E32:  MOVFF  FEF,8C7
09E36:  MOVFF  03,8C4
09E3A:  MOVFF  03,8C8
09E3E:  MOVLB  0
09E40:  CALL   2D28
09E44:  MOVFF  02,8BD
09E48:  MOVFF  01,8BC
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09E4C:  BCF    FD8.0
09E4E:  MOVLB  7
09E50:  RLCF   x3C,W
09E52:  CLRF   03
09E54:  ADDLW  62
09E56:  MOVWF  FE9
09E58:  MOVLW  07
09E5A:  ADDWFC 03,W
09E5C:  MOVWF  FEA
09E5E:  MOVFF  FEC,8C2
09E62:  MOVF   FED,F
09E64:  MOVFF  FEF,8C1
09E68:  MOVLB  8
09E6A:  MOVF   xC1,W
09E6C:  SUBLW  02
09E6E:  BNZ   9E9E
09E70:  MOVF   xC2,F
09E72:  BNZ   9E9E
09E74:  BCF    FD8.0
09E76:  MOVLB  7
09E78:  RLCF   x3C,W
09E7A:  CLRF   03
09E7C:  ADDLW  BF
09E7E:  MOVWF  FE9
09E80:  MOVLW  07
09E82:  ADDWFC 03,W
09E84:  MOVWF  FEA
09E86:  MOVFF  FEC,8C2
09E8A:  MOVF   FED,F
09E8C:  MOVFF  FEF,8C1
09E90:  MOVLB  8
09E92:  MOVF   xC1,F
09E94:  BNZ   9E9E
09E96:  MOVF   xC2,F
09E98:  BTFSC  FD8.2
09E9A:  GOTO   A73C
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09E9E:  BCF    FD8.0
09EA0:  MOVLB  7
09EA2:  RLCF   x3C,W
09EA4:  CLRF   03
09EA6:  ADDLW  62
09EA8:  MOVWF  FE9
09EAA:  MOVLW  07
09EAC:  ADDWFC 03,W
09EAE:  MOVWF  FEA
09EB0:  MOVFF  FEC,8C2
09EB4:  MOVF   FED,F
09EB6:  MOVFF  FEF,8C1
09EBA:  MOVLB  8
09EBC:  MOVF   xC1,W
09EBE:  SUBLW  02
09EC0:  BTFSS  FD8.2
09EC2:  BRA    A21C
09EC4:  MOVF   xC2,F
09EC6:  BTFSS  FD8.2
09EC8:  BRA    A21C
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09ECA:  BCF    FD8.0
09ECC:  MOVLB  7
09ECE:  RLCF   x3C,W
09ED0:  CLRF   03
09ED2:  ADDLW  C3
09ED4:  MOVWF  FE9
09ED6:  MOVLW  07
09ED8:  ADDWFC 03,W
09EDA:  MOVWF  FEA
09EDC:  MOVFF  8B3,FEF
09EE0:  MOVFF  8B4,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09EE4:  DECFSZ 2F,W
09EE6:  BRA    A198
09EE8:  MOVF   30,F
09EEA:  BTFSS  FD8.2
09EEC:  BRA    A198
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09EEE:  BCF    FD8.0
09EF0:  RLCF   x3C,W
09EF2:  CLRF   03
09EF4:  ADDLW  C3
09EF6:  MOVWF  FE9
09EF8:  MOVLW  07
09EFA:  ADDWFC 03,W
09EFC:  MOVWF  FEA
09EFE:  MOVFF  FEC,8C2
09F02:  MOVF   FED,F
09F04:  MOVFF  FEF,8C1
09F08:  BCF    FD8.0
09F0A:  RLCF   x3C,W
09F0C:  CLRF   03
09F0E:  ADDLW  BF
09F10:  MOVWF  FE9
09F12:  MOVLW  07
09F14:  ADDWFC 03,W
09F16:  MOVWF  FEA
09F18:  MOVFF  FEC,03
09F1C:  MOVF   FED,F
09F1E:  MOVFF  FEF,01
09F22:  MOVF   03,W
09F24:  MOVLB  8
09F26:  SUBWF  xC2,W
09F28:  BNC   9FC4
09F2A:  BNZ   9F32
09F2C:  MOVF   xC1,W
09F2E:  SUBWF  01,W
09F30:  BC    9FC4
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09F32:  BCF    FD8.0
09F34:  MOVLB  7
09F36:  RLCF   x3C,W
09F38:  CLRF   03
09F3A:  ADDLW  B3
09F3C:  MOVWF  01
09F3E:  MOVLW  07
09F40:  ADDWFC 03,F
09F42:  MOVLB  8
09F44:  MOVFF  03,8C2
09F48:  BCF    FD8.0
09F4A:  MOVLB  7
09F4C:  RLCF   x3C,W
09F4E:  CLRF   03
09F50:  ADDLW  C3
09F52:  MOVWF  FE9
09F54:  MOVLW  07
09F56:  ADDWFC 03,W
09F58:  MOVWF  FEA
09F5A:  MOVFF  FEC,8C4
09F5E:  MOVF   FED,F
09F60:  MOVFF  FEF,8C3
09F64:  BCF    FD8.0
09F66:  RLCF   x3C,W
09F68:  CLRF   03
09F6A:  ADDLW  BF
09F6C:  MOVWF  FE9
09F6E:  MOVLW  07
09F70:  ADDWFC 03,W
09F72:  MOVWF  FEA
09F74:  MOVFF  FEC,03
09F78:  MOVF   FED,F
09F7A:  MOVF   FEF,W
09F7C:  MOVLB  8
09F7E:  SUBWF  xC3,W
09F80:  MOVWF  00
09F82:  MOVF   03,W
09F84:  SUBWFB xC4,W
09F86:  MOVFF  8C2,FEA
09F8A:  MOVFF  01,FE9
09F8E:  MOVWF  FEC
09F90:  MOVF   FED,F
09F92:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F96:  BCF    FD8.0
09F98:  MOVLB  7
09F9A:  RLCF   x3C,W
09F9C:  CLRF   03
09F9E:  ADDLW  B3
09FA0:  MOVWF  FE9
09FA2:  MOVLW  07
09FA4:  ADDWFC 03,W
09FA6:  MOVWF  FEA
09FA8:  MOVFF  FEC,8C2
09FAC:  MOVF   FED,F
09FAE:  MOVFF  FEF,8C1
09FB2:  BCF    FD8.0
09FB4:  MOVLB  8
09FB6:  CLRF   xB6
09FB8:  CLRF   xB5
09FBA:  RRCF   xC2,W
09FBC:  MOVWF  xB4
09FBE:  RRCF   xC1,W
09FC0:  MOVWF  xB3
....................             } 
09FC2:  BRA    A07C
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09FC4:  BCF    FD8.0
09FC6:  MOVLB  7
09FC8:  RLCF   x3C,W
09FCA:  CLRF   03
09FCC:  ADDLW  B3
09FCE:  MOVWF  01
09FD0:  MOVLW  07
09FD2:  ADDWFC 03,F
09FD4:  MOVFF  01,8C1
09FD8:  MOVLB  8
09FDA:  MOVFF  03,8C2
09FDE:  BCF    FD8.0
09FE0:  MOVLB  7
09FE2:  RLCF   x3C,W
09FE4:  CLRF   03
09FE6:  ADDLW  5E
09FE8:  MOVWF  FE9
09FEA:  MOVLW  07
09FEC:  ADDWFC 03,W
09FEE:  MOVWF  FEA
09FF0:  MOVFF  FEC,8C4
09FF4:  MOVF   FED,F
09FF6:  MOVFF  FEF,8C3
09FFA:  BCF    FD8.0
09FFC:  RLCF   x3C,W
09FFE:  CLRF   03
0A000:  ADDLW  BF
0A002:  MOVWF  FE9
0A004:  MOVLW  07
0A006:  ADDWFC 03,W
0A008:  MOVWF  FEA
0A00A:  MOVFF  FEC,03
0A00E:  MOVF   FED,F
0A010:  MOVF   FEF,W
0A012:  MOVLB  8
0A014:  SUBWF  xC3,F
0A016:  MOVF   03,W
0A018:  SUBWFB xC4,F
0A01A:  BCF    FD8.0
0A01C:  MOVLB  7
0A01E:  RLCF   x3C,W
0A020:  CLRF   03
0A022:  ADDLW  C3
0A024:  MOVWF  FE9
0A026:  MOVLW  07
0A028:  ADDWFC 03,W
0A02A:  MOVWF  FEA
0A02C:  MOVFF  FEC,03
0A030:  MOVF   FED,F
0A032:  MOVF   FEF,W
0A034:  MOVLB  8
0A036:  ADDWF  xC3,W
0A038:  MOVWF  01
0A03A:  MOVF   xC4,W
0A03C:  ADDWFC 03,F
0A03E:  MOVFF  8C2,FEA
0A042:  MOVFF  8C1,FE9
0A046:  MOVFF  03,FEC
0A04A:  MOVF   FED,F
0A04C:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
0A050:  BCF    FD8.0
0A052:  MOVLB  7
0A054:  RLCF   x3C,W
0A056:  CLRF   03
0A058:  ADDLW  B3
0A05A:  MOVWF  FE9
0A05C:  MOVLW  07
0A05E:  ADDWFC 03,W
0A060:  MOVWF  FEA
0A062:  MOVFF  FEC,8C2
0A066:  MOVF   FED,F
0A068:  MOVFF  FEF,8C1
0A06C:  BCF    FD8.0
0A06E:  MOVLB  8
0A070:  CLRF   xB6
0A072:  CLRF   xB5
0A074:  RRCF   xC2,W
0A076:  MOVWF  xB4
0A078:  RRCF   xC1,W
0A07A:  MOVWF  xB3
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
0A07C:  MOVLB  0
0A07E:  GOTO   8590
0A082:  MOVFF  01,8C0
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
0A086:  BCF    FD8.0
0A088:  MOVLB  7
0A08A:  RLCF   x3C,W
0A08C:  CLRF   03
0A08E:  ADDLW  C3
0A090:  MOVWF  FE9
0A092:  MOVLW  07
0A094:  ADDWFC 03,W
0A096:  MOVWF  FEA
0A098:  MOVFF  FEC,8C2
0A09C:  MOVF   FED,F
0A09E:  MOVFF  FEF,8C1
0A0A2:  MOVLB  8
0A0A4:  MOVF   xC1,W
0A0A6:  SUBLW  02
0A0A8:  BNZ   A0D8
0A0AA:  MOVF   xC2,F
0A0AC:  BNZ   A0D8
0A0AE:  BCF    FD8.0
0A0B0:  MOVLB  7
0A0B2:  RLCF   x3C,W
0A0B4:  CLRF   03
0A0B6:  ADDLW  BF
0A0B8:  MOVWF  FE9
0A0BA:  MOVLW  07
0A0BC:  ADDWFC 03,W
0A0BE:  MOVWF  FEA
0A0C0:  MOVFF  FEC,8C2
0A0C4:  MOVF   FED,F
0A0C6:  MOVFF  FEF,8C1
0A0CA:  MOVLB  8
0A0CC:  DECFSZ xC1,W
0A0CE:  BRA    A0D8
0A0D0:  MOVF   xC2,F
0A0D2:  BNZ   A0D8
....................             { 
....................                port_port=4; 
0A0D4:  MOVLW  04
0A0D6:  MOVWF  xC0
....................             } 
....................              
....................             switch(port_port){ 
0A0D8:  MOVF   xC0,W
0A0DA:  ADDLW  FB
0A0DC:  BC    A194
0A0DE:  ADDLW  05
0A0E0:  MOVLB  0
0A0E2:  GOTO   A78A
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
0A0E6:  BCF    FD8.0
0A0E8:  MOVLB  7
0A0EA:  RLCF   x3C,W
0A0EC:  CLRF   03
0A0EE:  ADDLW  6A
0A0F0:  MOVWF  FE9
0A0F2:  MOVLW  07
0A0F4:  ADDWFC 03,W
0A0F6:  MOVWF  FEA
0A0F8:  MOVFF  FEC,8BF
0A0FC:  MOVF   FED,F
0A0FE:  MOVFF  FEF,8BE
....................                   break; 
0A102:  MOVLB  8
0A104:  BRA    A194
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A106:  BCF    FD8.0
0A108:  MOVLB  7
0A10A:  RLCF   x3C,W
0A10C:  CLRF   03
0A10E:  ADDLW  7A
0A110:  MOVWF  FE9
0A112:  MOVLW  07
0A114:  ADDWFC 03,W
0A116:  MOVWF  FEA
0A118:  MOVFF  FEC,03
0A11C:  MOVF   FED,F
0A11E:  MOVF   FEF,W
0A120:  MOVLB  8
0A122:  ADDWF  xBC,W
0A124:  MOVWF  xBE
0A126:  MOVF   03,W
0A128:  ADDWFC xBD,W
0A12A:  MOVWF  xBF
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A12C:  BRA    A194
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A12E:  BCF    FD8.0
0A130:  MOVLB  7
0A132:  RLCF   x3C,W
0A134:  CLRF   03
0A136:  ADDLW  6A
0A138:  MOVWF  FE9
0A13A:  MOVLW  07
0A13C:  ADDWFC 03,W
0A13E:  MOVWF  FEA
0A140:  MOVFF  FEC,8BF
0A144:  MOVF   FED,F
0A146:  MOVFF  FEF,8BE
....................                         ++m_steps; 
0A14A:  MOVLW  01
0A14C:  MOVLB  8
0A14E:  ADDWF  xB3,F
0A150:  BTFSC  FD8.0
0A152:  INCF   xB4,F
0A154:  BTFSC  FD8.2
0A156:  INCF   xB5,F
0A158:  BTFSC  FD8.2
0A15A:  INCF   xB6,F
....................                   break; 
0A15C:  BRA    A194
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A15E:  BCF    FD8.0
0A160:  MOVLB  7
0A162:  RLCF   x3C,W
0A164:  CLRF   03
0A166:  ADDLW  7A
0A168:  MOVWF  FE9
0A16A:  MOVLW  07
0A16C:  ADDWFC 03,W
0A16E:  MOVWF  FEA
0A170:  MOVFF  FEC,03
0A174:  MOVF   FED,F
0A176:  MOVF   FEF,W
0A178:  MOVLB  8
0A17A:  ADDWF  xBC,W
0A17C:  MOVWF  xBE
0A17E:  MOVF   03,W
0A180:  ADDWFC xBD,W
0A182:  MOVWF  xBF
....................  
....................                   break; 
0A184:  BRA    A194
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A186:  MOVFF  8BD,8BF
0A18A:  MOVFF  8BC,8BE
....................                   break;     
0A18E:  MOVLB  8
0A190:  BRA    A194
0A192:  MOVLB  8
....................             } 
....................          } 
0A194:  BRA    A1C0
0A196:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A198:  MOVFF  8B6,8C4
0A19C:  MOVFF  8B5,8C3
0A1A0:  MOVFF  8B4,8C2
0A1A4:  MOVFF  8B3,8C1
0A1A8:  MOVLB  0
0A1AA:  GOTO   8638
0A1AE:  MOVFF  03,8B6
0A1B2:  MOVFF  02,8B5
0A1B6:  MOVFF  01,8B4
0A1BA:  MOVFF  00,8B3
0A1BE:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A1C0:  DECFSZ xB1,W
0A1C2:  BRA    A1EA
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A1C4:  MOVFF  8B4,8C2
0A1C8:  MOVFF  8B3,8C1
0A1CC:  MOVFF  8B4,8C4
0A1D0:  MOVFF  8B3,8C3
0A1D4:  MOVLB  0
0A1D6:  GOTO   884A
0A1DA:  MOVLB  8
0A1DC:  CLRF   xB6
0A1DE:  CLRF   xB5
0A1E0:  MOVFF  02,8B4
0A1E4:  MOVFF  01,8B3
....................          } 
0A1E8:  BRA    A21C
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A1EA:  MOVF   2F,W
0A1EC:  SUBLW  03
0A1EE:  BNZ   A21C
0A1F0:  MOVF   30,F
0A1F2:  BNZ   A21C
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A1F4:  BCF    FD8.0
0A1F6:  MOVLB  7
0A1F8:  RLCF   x3C,W
0A1FA:  CLRF   03
0A1FC:  ADDLW  BB
0A1FE:  MOVWF  FE9
0A200:  MOVLW  07
0A202:  ADDWFC 03,W
0A204:  MOVWF  FEA
0A206:  MOVFF  FEC,03
0A20A:  MOVF   FED,F
0A20C:  MOVF   FEF,W
0A20E:  MOVLB  8
0A210:  SUBWF  xB3,F
0A212:  MOVF   03,W
0A214:  SUBWFB xB4,F
0A216:  MOVLW  00
0A218:  SUBWFB xB5,F
0A21A:  SUBWFB xB6,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A21C:  MOVFF  8B7,8C1
0A220:  MOVLB  0
0A222:  GOTO   8F14
....................  
....................       while (m_running[motor]) 
0A226:  BCF    FD8.0
0A228:  MOVLB  7
0A22A:  RLCF   x3C,W
0A22C:  CLRF   03
0A22E:  ADDLW  8E
0A230:  MOVWF  FE9
0A232:  MOVLW  07
0A234:  ADDWFC 03,W
0A236:  MOVWF  FEA
0A238:  MOVF   FEF,F
0A23A:  BNZ   A242
0A23C:  MOVF   FEC,F
0A23E:  BTFSC  FD8.2
0A240:  BRA    A738
....................       { 
....................          switch(e_mode[motor]) 
0A242:  BCF    FD8.0
0A244:  RLCF   x3C,W
0A246:  CLRF   03
0A248:  ADDLW  62
0A24A:  MOVWF  FE9
0A24C:  MOVLW  07
0A24E:  ADDWFC 03,W
0A250:  MOVWF  FEA
0A252:  MOVF   FEF,W
0A254:  MOVWF  00
0A256:  MOVF   FEE,F
0A258:  MOVF   FED,W
0A25A:  MOVWF  03
0A25C:  MOVF   03,W
0A25E:  BNZ   A268
0A260:  MOVF   00,F
0A262:  MOVLB  0
0A264:  BZ    A2B6
0A266:  MOVLB  7
0A268:  MOVF   03,W
0A26A:  BNZ   A276
0A26C:  MOVLW  01
0A26E:  SUBWF  00,W
0A270:  MOVLB  0
0A272:  BZ    A30C
0A274:  MOVLB  7
0A276:  MOVF   03,W
0A278:  BNZ   A284
0A27A:  MOVLW  02
0A27C:  SUBWF  00,W
0A27E:  MOVLB  0
0A280:  BZ    A30C
0A282:  MOVLB  7
0A284:  MOVF   03,W
0A286:  BNZ   A294
0A288:  MOVLW  03
0A28A:  SUBWF  00,W
0A28C:  MOVLB  0
0A28E:  BTFSC  FD8.2
0A290:  BRA    A3DA
0A292:  MOVLB  7
0A294:  MOVF   03,W
0A296:  BNZ   A2A4
0A298:  MOVLW  04
0A29A:  SUBWF  00,W
0A29C:  MOVLB  0
0A29E:  BTFSC  FD8.2
0A2A0:  BRA    A52A
0A2A2:  MOVLB  7
0A2A4:  MOVF   03,W
0A2A6:  BNZ   A2B4
0A2A8:  MOVLW  05
0A2AA:  SUBWF  00,W
0A2AC:  MOVLB  0
0A2AE:  BTFSC  FD8.2
0A2B0:  BRA    A67A
0A2B2:  MOVLB  7
0A2B4:  BRA    A732
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A2B6:  MOVLB  7
0A2B8:  MOVF   x3C,W
0A2BA:  MULLW  04
0A2BC:  MOVF   FF3,W
0A2BE:  CLRF   03
0A2C0:  ADDLW  9E
0A2C2:  MOVWF  FE9
0A2C4:  MOVLW  07
0A2C6:  ADDWFC 03,W
0A2C8:  MOVWF  FEA
0A2CA:  MOVFF  FEF,8C1
0A2CE:  MOVFF  FEC,8C2
0A2D2:  MOVFF  FEC,8C3
0A2D6:  MOVFF  FEC,8C4
0A2DA:  MOVLB  8
0A2DC:  MOVF   xB6,W
0A2DE:  SUBWF  xC4,W
0A2E0:  BNC   A306
0A2E2:  BNZ   A2FA
0A2E4:  MOVF   xB5,W
0A2E6:  SUBWF  xC3,W
0A2E8:  BNC   A306
0A2EA:  BNZ   A2FA
0A2EC:  MOVF   xB4,W
0A2EE:  SUBWF  xC2,W
0A2F0:  BNC   A306
0A2F2:  BNZ   A2FA
0A2F4:  MOVF   xB3,W
0A2F6:  SUBWF  xC1,W
0A2F8:  BNC   A306
....................                { 
....................                   terminate(1); 
0A2FA:  MOVLW  01
0A2FC:  MOVWF  xD5
0A2FE:  MOVLB  0
0A300:  CALL   9102
0A304:  MOVLB  8
....................                } 
....................                break; 
0A306:  MOVLB  7
0A308:  BRA    A732
0A30A:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A30C:  BCF    FD8.0
0A30E:  MOVLB  7
0A310:  RLCF   x3C,W
0A312:  CLRF   03
0A314:  ADDLW  96
0A316:  MOVWF  FE9
0A318:  MOVLW  07
0A31A:  ADDWFC 03,W
0A31C:  MOVWF  FEA
0A31E:  MOVFF  FEC,8C2
0A322:  MOVF   FED,F
0A324:  MOVFF  FEF,8C1
0A328:  BCF    FD8.0
0A32A:  RLCF   x3C,W
0A32C:  CLRF   03
0A32E:  ADDLW  56
0A330:  MOVWF  FE9
0A332:  MOVLW  07
0A334:  ADDWFC 03,W
0A336:  MOVWF  FEA
0A338:  MOVFF  FEC,03
0A33C:  MOVF   FED,F
0A33E:  MOVFF  FEF,01
0A342:  MOVF   03,W
0A344:  MOVLB  8
0A346:  SUBWF  xC2,W
0A348:  BNC   A35C
0A34A:  BNZ   A352
0A34C:  MOVF   01,W
0A34E:  SUBWF  xC1,W
0A350:  BNC   A35C
....................                { 
....................                   terminate(0); 
0A352:  CLRF   xD5
0A354:  MOVLB  0
0A356:  CALL   9102
0A35A:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A35C:  BCF    FD8.0
0A35E:  MOVLB  7
0A360:  RLCF   x3C,W
0A362:  CLRF   03
0A364:  ADDLW  B7
0A366:  MOVWF  FE9
0A368:  MOVLW  07
0A36A:  ADDWFC 03,W
0A36C:  MOVWF  FEA
0A36E:  MOVFF  FEC,8C2
0A372:  MOVF   FED,F
0A374:  MOVFF  FEF,8C1
0A378:  MOVLB  8
0A37A:  MOVF   xB6,F
0A37C:  BNZ   A3D4
0A37E:  MOVF   xB5,F
0A380:  BNZ   A3D4
0A382:  MOVF   xB4,W
0A384:  SUBWF  xC2,W
0A386:  BNC   A3D4
0A388:  BNZ   A390
0A38A:  MOVF   xB3,W
0A38C:  SUBWF  xC1,W
0A38E:  BNC   A3D4
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A390:  BCF    FD8.0
0A392:  MOVLB  7
0A394:  RLCF   x3C,W
0A396:  CLRF   03
0A398:  ADDLW  B3
0A39A:  MOVWF  FE9
0A39C:  MOVLW  07
0A39E:  ADDWFC 03,W
0A3A0:  MOVWF  FEA
0A3A2:  MOVFF  FEC,8C8
0A3A6:  MOVF   FED,F
0A3A8:  MOVFF  FEF,8C7
0A3AC:  MOVFF  8B6,8C6
0A3B0:  MOVFF  8B5,8C5
0A3B4:  MOVFF  8B4,8C4
0A3B8:  MOVFF  8B3,8C3
0A3BC:  MOVLB  0
0A3BE:  CALL   96C2
0A3C2:  MOVFF  03,8BB
0A3C6:  MOVFF  02,8BA
0A3CA:  MOVFF  01,8B9
0A3CE:  MOVFF  00,8B8
0A3D2:  MOVLB  8
....................                } 
....................                break; 
0A3D4:  MOVLB  7
0A3D6:  BRA    A732
0A3D8:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A3DA:  BCF    FD8.0
0A3DC:  MOVLB  7
0A3DE:  RLCF   x3C,W
0A3E0:  CLRF   03
0A3E2:  ADDLW  B7
0A3E4:  MOVWF  FE9
0A3E6:  MOVLW  07
0A3E8:  ADDWFC 03,W
0A3EA:  MOVWF  FEA
0A3EC:  MOVFF  FEC,8C2
0A3F0:  MOVF   FED,F
0A3F2:  MOVFF  FEF,8C1
0A3F6:  MOVLB  8
0A3F8:  MOVF   xB6,F
0A3FA:  BNZ   A418
0A3FC:  MOVF   xB5,F
0A3FE:  BNZ   A418
0A400:  MOVF   xB4,W
0A402:  SUBWF  xC2,W
0A404:  BNC   A418
0A406:  BNZ   A40E
0A408:  MOVF   xB3,W
0A40A:  SUBWF  xC1,W
0A40C:  BNC   A418
....................                { 
....................                   terminate(0); 
0A40E:  CLRF   xD5
0A410:  MOVLB  0
0A412:  CALL   9102
0A416:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A418:  BCF    FD8.0
0A41A:  MOVLB  7
0A41C:  RLCF   x3C,W
0A41E:  CLRF   03
0A420:  ADDLW  76
0A422:  MOVWF  FE9
0A424:  MOVLW  07
0A426:  ADDWFC 03,W
0A428:  MOVWF  FEA
0A42A:  MOVFF  FEC,8C2
0A42E:  MOVF   FED,F
0A430:  MOVFF  FEF,8C1
0A434:  MOVLB  8
0A436:  MOVF   xC1,F
0A438:  BNZ   A49E
0A43A:  MOVF   xC2,F
0A43C:  BNZ   A49E
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A43E:  CLRF   03
0A440:  MOVLB  7
0A442:  MOVF   x3C,W
0A444:  ADDLW  C7
0A446:  MOVWF  FE9
0A448:  MOVLW  07
0A44A:  ADDWFC 03,W
0A44C:  MOVWF  FEA
0A44E:  MOVF   FEF,F
0A450:  BNZ   A49C
....................                   { 
....................                      wrt_m_error(); 
0A452:  MOVLB  0
0A454:  CALL   8FB2
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A458:  BCF    FD8.0
0A45A:  MOVLB  7
0A45C:  RLCF   x3C,W
0A45E:  CLRF   03
0A460:  ADDLW  B3
0A462:  MOVWF  FE9
0A464:  MOVLW  07
0A466:  ADDWFC 03,W
0A468:  MOVWF  FEA
0A46A:  MOVFF  FEC,8C8
0A46E:  MOVF   FED,F
0A470:  MOVFF  FEF,8C7
0A474:  MOVFF  8B6,8C6
0A478:  MOVFF  8B5,8C5
0A47C:  MOVFF  8B4,8C4
0A480:  MOVFF  8B3,8C3
0A484:  MOVLB  0
0A486:  CALL   96C2
0A48A:  MOVFF  03,8BB
0A48E:  MOVFF  02,8BA
0A492:  MOVFF  01,8B9
0A496:  MOVFF  00,8B8
0A49A:  MOVLB  7
0A49C:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A49E:  BCF    FD8.0
0A4A0:  MOVLB  7
0A4A2:  RLCF   x3C,W
0A4A4:  CLRF   03
0A4A6:  ADDLW  76
0A4A8:  MOVWF  FE9
0A4AA:  MOVLW  07
0A4AC:  ADDWFC 03,W
0A4AE:  MOVWF  FEA
0A4B0:  MOVFF  FEC,8C2
0A4B4:  MOVF   FED,F
0A4B6:  MOVFF  FEF,8C1
0A4BA:  MOVLB  8
0A4BC:  DECFSZ xC1,W
0A4BE:  BRA    A524
0A4C0:  MOVF   xC2,F
0A4C2:  BNZ   A524
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A4C4:  CLRF   03
0A4C6:  MOVLB  7
0A4C8:  MOVF   x3C,W
0A4CA:  ADDLW  C7
0A4CC:  MOVWF  FE9
0A4CE:  MOVLW  07
0A4D0:  ADDWFC 03,W
0A4D2:  MOVWF  FEA
0A4D4:  DECFSZ FEF,W
0A4D6:  BRA    A522
....................                   { 
....................                      wrt_m_error(); 
0A4D8:  MOVLB  0
0A4DA:  CALL   8FB2
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A4DE:  BCF    FD8.0
0A4E0:  MOVLB  7
0A4E2:  RLCF   x3C,W
0A4E4:  CLRF   03
0A4E6:  ADDLW  B3
0A4E8:  MOVWF  FE9
0A4EA:  MOVLW  07
0A4EC:  ADDWFC 03,W
0A4EE:  MOVWF  FEA
0A4F0:  MOVFF  FEC,8C8
0A4F4:  MOVF   FED,F
0A4F6:  MOVFF  FEF,8C7
0A4FA:  MOVFF  8B6,8C6
0A4FE:  MOVFF  8B5,8C5
0A502:  MOVFF  8B4,8C4
0A506:  MOVFF  8B3,8C3
0A50A:  MOVLB  0
0A50C:  CALL   96C2
0A510:  MOVFF  03,8BB
0A514:  MOVFF  02,8BA
0A518:  MOVFF  01,8B9
0A51C:  MOVFF  00,8B8
0A520:  MOVLB  7
0A522:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A524:  MOVLB  7
0A526:  BRA    A732
0A528:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A52A:  MOVLB  7
0A52C:  MOVF   x3C,W
0A52E:  MULLW  04
0A530:  MOVF   FF3,W
0A532:  CLRF   03
0A534:  ADDLW  9E
0A536:  MOVWF  FE9
0A538:  MOVLW  07
0A53A:  ADDWFC 03,W
0A53C:  MOVWF  FEA
0A53E:  MOVFF  FEF,8C1
0A542:  MOVFF  FEC,8C2
0A546:  MOVFF  FEC,8C3
0A54A:  MOVFF  FEC,8C4
0A54E:  MOVLB  8
0A550:  MOVF   xB8,W
0A552:  SUBWF  xC1,F
0A554:  MOVF   xB9,W
0A556:  SUBWFB xC2,F
0A558:  MOVF   xBA,W
0A55A:  SUBWFB xC3,F
0A55C:  MOVF   xBB,W
0A55E:  SUBWFB xC4,F
0A560:  BNZ   A578
0A562:  MOVF   xC3,F
0A564:  BNZ   A578
0A566:  MOVF   xBF,W
0A568:  SUBWF  xC2,W
0A56A:  BTFSS  FD8.0
0A56C:  BRA    A674
0A56E:  BNZ   A578
0A570:  MOVF   xBE,W
0A572:  SUBWF  xC1,W
0A574:  BTFSS  FD8.0
0A576:  BRA    A674
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A578:  BCF    FD8.0
0A57A:  MOVLB  7
0A57C:  RLCF   x3C,W
0A57E:  CLRF   03
0A580:  ADDLW  62
0A582:  MOVWF  01
0A584:  MOVLW  07
0A586:  ADDWFC 03,F
0A588:  MOVLB  8
0A58A:  MOVFF  03,8C2
0A58E:  BCF    FD8.0
0A590:  MOVLB  7
0A592:  RLCF   x3C,W
0A594:  CLRF   03
0A596:  ADDLW  9A
0A598:  MOVWF  FE9
0A59A:  MOVLW  07
0A59C:  ADDWFC 03,W
0A59E:  MOVWF  FEA
0A5A0:  MOVFF  FEC,03
0A5A4:  MOVF   FED,F
0A5A6:  MOVFF  FEF,8C3
0A5AA:  MOVLB  8
0A5AC:  MOVFF  8C2,FEA
0A5B0:  MOVFF  01,FE9
0A5B4:  MOVFF  03,FEC
0A5B8:  MOVF   FED,F
0A5BA:  MOVFF  8C3,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A5BE:  MOVLB  7
0A5C0:  MOVF   x3C,W
0A5C2:  MULLW  04
0A5C4:  MOVF   FF3,W
0A5C6:  CLRF   03
0A5C8:  ADDLW  9E
0A5CA:  MOVWF  FE9
0A5CC:  MOVLW  07
0A5CE:  ADDWFC 03,W
0A5D0:  MOVWF  FEA
0A5D2:  MOVFF  FEF,8C1
0A5D6:  MOVFF  FEC,8C2
0A5DA:  MOVFF  FEC,8C3
0A5DE:  MOVFF  FEC,8C4
0A5E2:  MOVLW  78
0A5E4:  MOVWF  FF6
0A5E6:  MOVLW  1A
0A5E8:  MOVWF  FF7
0A5EA:  MOVLW  00
0A5EC:  MOVWF  FF8
0A5EE:  CLRF   1B
0A5F0:  BTFSC  FF2.7
0A5F2:  BSF    1B.7
0A5F4:  BCF    FF2.7
0A5F6:  MOVLW  0B
0A5F8:  MOVLB  A
0A5FA:  MOVWF  x25
0A5FC:  MOVLB  0
0A5FE:  CALL   1010
0A602:  BTFSC  1B.7
0A604:  BSF    FF2.7
0A606:  MOVLW  41
0A608:  MOVWF  FE9
0A60A:  CLRF   1B
0A60C:  BTFSC  FF2.7
0A60E:  BSF    1B.7
0A610:  BCF    FF2.7
0A612:  MOVFF  8C4,A28
0A616:  MOVFF  8C3,A27
0A61A:  MOVFF  8C2,A26
0A61E:  MOVFF  8C1,A25
0A622:  CALL   10D6
0A626:  BTFSC  1B.7
0A628:  BSF    FF2.7
0A62A:  MOVLW  2C
0A62C:  BTFSS  F9E.4
0A62E:  BRA    A62C
0A630:  MOVWF  FAD
0A632:  MOVLW  41
0A634:  MOVWF  FE9
0A636:  CLRF   1B
0A638:  BTFSC  FF2.7
0A63A:  BSF    1B.7
0A63C:  BCF    FF2.7
0A63E:  MOVFF  8BB,A28
0A642:  MOVFF  8BA,A27
0A646:  MOVFF  8B9,A26
0A64A:  MOVFF  8B8,A25
0A64E:  CALL   10D6
0A652:  BTFSC  1B.7
0A654:  BSF    FF2.7
0A656:  MOVLW  0D
0A658:  BTFSS  F9E.4
0A65A:  BRA    A658
0A65C:  MOVWF  FAD
0A65E:  MOVLW  0A
0A660:  BTFSS  F9E.4
0A662:  BRA    A660
0A664:  MOVWF  FAD
....................                   terminate(1); 
0A666:  MOVLW  01
0A668:  MOVLB  8
0A66A:  MOVWF  xD5
0A66C:  MOVLB  0
0A66E:  CALL   9102
0A672:  MOVLB  8
....................                } 
....................                break; 
0A674:  MOVLB  7
0A676:  BRA    A732
0A678:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A67A:  MOVLB  7
0A67C:  MOVF   x3C,W
0A67E:  MULLW  04
0A680:  MOVF   FF3,W
0A682:  CLRF   03
0A684:  ADDLW  9E
0A686:  MOVWF  FE9
0A688:  MOVLW  07
0A68A:  ADDWFC 03,W
0A68C:  MOVWF  FEA
0A68E:  MOVFF  FEF,8C1
0A692:  MOVFF  FEC,8C2
0A696:  MOVFF  FEC,8C3
0A69A:  MOVFF  FEC,8C4
0A69E:  BCF    FD8.0
0A6A0:  RLCF   x3C,W
0A6A2:  CLRF   03
0A6A4:  ADDLW  6E
0A6A6:  MOVWF  FE9
0A6A8:  MOVLW  07
0A6AA:  ADDWFC 03,W
0A6AC:  MOVWF  FEA
0A6AE:  MOVFF  FEC,03
0A6B2:  MOVF   FED,F
0A6B4:  MOVFF  FEF,01
0A6B8:  MOVLB  8
0A6BA:  MOVF   xC4,F
0A6BC:  BNZ   A6D0
0A6BE:  MOVF   xC3,F
0A6C0:  BNZ   A6D0
0A6C2:  MOVF   03,W
0A6C4:  SUBWF  xC2,W
0A6C6:  BNC   A730
0A6C8:  BNZ   A6D0
0A6CA:  MOVF   01,W
0A6CC:  SUBWF  xC1,W
0A6CE:  BNC   A730
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A6D0:  BCF    FD8.0
0A6D2:  MOVLB  7
0A6D4:  RLCF   x3C,W
0A6D6:  CLRF   03
0A6D8:  ADDLW  62
0A6DA:  MOVWF  01
0A6DC:  MOVLW  07
0A6DE:  ADDWFC 03,F
0A6E0:  MOVLB  8
0A6E2:  MOVFF  03,8C2
0A6E6:  BCF    FD8.0
0A6E8:  MOVLB  7
0A6EA:  RLCF   x3C,W
0A6EC:  CLRF   03
0A6EE:  ADDLW  9A
0A6F0:  MOVWF  FE9
0A6F2:  MOVLW  07
0A6F4:  ADDWFC 03,W
0A6F6:  MOVWF  FEA
0A6F8:  MOVFF  FEC,03
0A6FC:  MOVF   FED,F
0A6FE:  MOVFF  FEF,8C3
0A702:  MOVLB  8
0A704:  MOVFF  8C2,FEA
0A708:  MOVFF  01,FE9
0A70C:  MOVFF  03,FEC
0A710:  MOVF   FED,F
0A712:  MOVFF  8C3,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A716:  BCF    FD8.0
0A718:  MOVLB  7
0A71A:  RLCF   x3C,W
0A71C:  CLRF   03
0A71E:  ADDLW  B7
0A720:  MOVWF  FE9
0A722:  MOVLW  07
0A724:  ADDWFC 03,W
0A726:  MOVWF  FEA
0A728:  CLRF   FEC
0A72A:  MOVF   FED,F
0A72C:  CLRF   FEF
0A72E:  MOVLB  8
....................                } 
....................                break; 
0A730:  MOVLB  7
....................             } 
....................          } 
0A732:  MOVLB  0
0A734:  BRA    A226
0A736:  MOVLB  7
....................       } 
....................    } 
0A738:  BRA    A756
0A73A:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A73C:  BCF    FD8.0
0A73E:  MOVLB  7
0A740:  RLCF   x3C,W
0A742:  CLRF   03
0A744:  ADDLW  92
0A746:  MOVWF  FE9
0A748:  MOVLW  07
0A74A:  ADDWFC 03,W
0A74C:  MOVWF  FEA
0A74E:  CLRF   FEC
0A750:  MOVF   FED,F
0A752:  MOVLW  01
0A754:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A756:  BCF    FD8.0
0A758:  RLCF   x3C,W
0A75A:  CLRF   03
0A75C:  ADDLW  92
0A75E:  MOVWF  FE9
0A760:  MOVLW  07
0A762:  ADDWFC 03,W
0A764:  MOVWF  FEA
0A766:  MOVFF  FEC,8C2
0A76A:  MOVF   FED,F
0A76C:  MOVFF  FEF,8C1
0A770:  MOVLB  8
0A772:  DECFSZ xC1,W
0A774:  BRA    A786
0A776:  MOVF   xC2,F
0A778:  BNZ   A786
....................       wrt_m_error(); 
0A77A:  MOVLB  0
0A77C:  CALL   8FB2
....................       msg_mer(); 
0A780:  CALL   9D34
0A784:  MOVLB  8
....................    } 
0A786:  MOVLB  0
0A788:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
16C6E:  MOVF   44,F
16C70:  BNZ   16C7E
16C72:  MOVF   45,F
16C74:  BNZ   16C7E
16C76:  MOVF   46,F
16C78:  BNZ   16C7E
16C7A:  MOVF   47,F
16C7C:  BZ    16CAA
16C7E:  MOVF   47,F
16C80:  BNZ   16CAA
16C82:  MOVF   46,W
16C84:  SUBLW  00
16C86:  BNC   16CAA
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
16C88:  MOVFF  86F,8B1
16C8C:  MOVFF  870,8B2
16C90:  MOVFF  47,8B6
16C94:  MOVFF  46,8B5
16C98:  MOVFF  45,8B4
16C9C:  MOVFF  44,8B3
16CA0:  MOVFF  871,8B7
16CA4:  CALL   9DAA
....................    } 
16CA8:  BRA    16D26
....................    else if(arg==0) 
16CAA:  MOVF   44,F
16CAC:  BNZ   16D22
16CAE:  MOVF   45,F
16CB0:  BNZ   16D22
16CB2:  MOVF   46,F
16CB4:  BNZ   16D22
16CB6:  MOVF   47,F
16CB8:  BNZ   16D22
....................    { 
....................       m_lin_pos[motor]=0; 
16CBA:  BCF    FD8.0
16CBC:  MOVLB  7
16CBE:  RLCF   x3C,W
16CC0:  CLRF   03
16CC2:  ADDLW  AF
16CC4:  MOVWF  FE9
16CC6:  MOVLW  07
16CC8:  ADDWFC 03,W
16CCA:  MOVWF  FEA
16CCC:  CLRF   FEC
16CCE:  MOVF   FED,F
16CD0:  CLRF   FEF
....................       switch (motor){ 
16CD2:  MOVF   x3C,W
16CD4:  XORLW  00
16CD6:  MOVLB  0
16CD8:  BZ    16CE0
16CDA:  XORLW  01
16CDC:  BZ    16CF2
16CDE:  BRA    16D02
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
16CE0:  MOVLW  B6
16CE2:  MOVLB  8
16CE4:  MOVWF  xD8
16CE6:  CLRF   xDA
16CE8:  CLRF   xD9
16CEA:  MOVLB  0
16CEC:  CALL   501E
....................             break; 
16CF0:  BRA    16D02
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
16CF2:  MOVLW  B8
16CF4:  MOVLB  8
16CF6:  MOVWF  xD8
16CF8:  CLRF   xDA
16CFA:  CLRF   xD9
16CFC:  MOVLB  0
16CFE:  CALL   501E
....................             break; 
....................       }  
....................       m_error[motor]=0; 
16D02:  BCF    FD8.0
16D04:  MOVLB  7
16D06:  RLCF   x3C,W
16D08:  CLRF   03
16D0A:  ADDLW  92
16D0C:  MOVWF  FE9
16D0E:  MOVLW  07
16D10:  ADDWFC 03,W
16D12:  MOVWF  FEA
16D14:  CLRF   FEC
16D16:  MOVF   FED,F
16D18:  CLRF   FEF
....................       wrt_m_error(); 
16D1A:  MOVLB  0
16D1C:  CALL   8FB2
....................    } 
16D20:  BRA    16D26
....................    else cmd_arg(); 
16D22:  CALL   B062
16D26:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
18718:  MOVLW  01
1871A:  MOVLB  8
1871C:  MOVWF  xD6
1871E:  MOVLB  0
18720:  CALL   8A02
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
18724:  MOVLW  FA
18726:  MOVLB  9
18728:  MOVWF  xD6
1872A:  MOVLB  0
1872C:  CALL   2964
....................       switch(motor) 
18730:  MOVLB  7
18732:  MOVF   x3C,W
18734:  XORLW  00
18736:  MOVLB  0
18738:  BZ    18740
1873A:  XORLW  01
1873C:  BZ    18752
1873E:  BRA    18762
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18740:  MOVLB  8
18742:  CLRF   x6F
18744:  BTFSC  F81.4
18746:  INCF   x6F,F
....................             chanA = input(ENC1_PHA); 
18748:  CLRF   x70
1874A:  BTFSC  F81.1
1874C:  INCF   x70,F
....................             break; 
1874E:  MOVLB  0
18750:  BRA    18762
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
18752:  MOVLB  8
18754:  CLRF   x6F
18756:  BTFSC  F81.5
18758:  INCF   x6F,F
....................             chanA = input(ENC2_PHA); 
1875A:  CLRF   x70
1875C:  BTFSC  F81.2
1875E:  INCF   x70,F
....................             break; 
18760:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
18762:  MOVLW  8E
18764:  MOVWF  FF6
18766:  MOVLW  1A
18768:  MOVWF  FF7
1876A:  MOVLW  00
1876C:  MOVWF  FF8
1876E:  CLRF   1B
18770:  BTFSC  FF2.7
18772:  BSF    1B.7
18774:  BCF    FF2.7
18776:  MOVLW  04
18778:  MOVLB  A
1877A:  MOVWF  x25
1877C:  MOVLB  0
1877E:  CALL   1010
18782:  BTFSC  1B.7
18784:  BSF    FF2.7
18786:  CLRF   1B
18788:  BTFSC  FF2.7
1878A:  BSF    1B.7
1878C:  BCF    FF2.7
1878E:  MOVFF  86F,A25
18792:  MOVLW  1B
18794:  MOVLB  A
18796:  MOVWF  x26
18798:  MOVLB  0
1879A:  CALL   0F92
1879E:  BTFSC  1B.7
187A0:  BSF    FF2.7
187A2:  MOVLW  94
187A4:  MOVWF  FF6
187A6:  MOVLW  1A
187A8:  MOVWF  FF7
187AA:  MOVLW  00
187AC:  MOVWF  FF8
187AE:  CLRF   1B
187B0:  BTFSC  FF2.7
187B2:  BSF    1B.7
187B4:  BCF    FF2.7
187B6:  MOVLW  07
187B8:  MOVLB  A
187BA:  MOVWF  x25
187BC:  MOVLB  0
187BE:  CALL   1010
187C2:  BTFSC  1B.7
187C4:  BSF    FF2.7
187C6:  CLRF   1B
187C8:  BTFSC  FF2.7
187CA:  BSF    1B.7
187CC:  BCF    FF2.7
187CE:  MOVFF  870,A25
187D2:  MOVLW  1B
187D4:  MOVLB  A
187D6:  MOVWF  x26
187D8:  MOVLB  0
187DA:  CALL   0F92
187DE:  BTFSC  1B.7
187E0:  BSF    FF2.7
187E2:  MOVLW  0D
187E4:  BTFSS  F9E.4
187E6:  BRA    187E4
187E8:  MOVWF  FAD
187EA:  MOVLW  0A
187EC:  BTFSS  F9E.4
187EE:  BRA    187EC
187F0:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
187F2:  BTFSS  F9E.5
187F4:  BRA    18802
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
187F6:  CALL   0E24
187FA:  MOVF   01,W
187FC:  SUBLW  1B
187FE:  BNZ   18802
....................          { 
....................             break; 
18800:  BRA    18804
....................          } 
....................       } 
18802:  BRA    18724
....................    } 
....................  
....................    delay_ms(100); 
18804:  MOVLW  64
18806:  MOVLB  9
18808:  MOVWF  xD6
1880A:  MOVLB  0
1880C:  CALL   2964
....................    enc_pwr(OFF); 
18810:  MOVLB  8
18812:  CLRF   xD6
18814:  MOVLB  0
18816:  CALL   8A02
1881A:  GOTO   18836 (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A8E6:  BCF    FD8.0
0A8E8:  MOVLB  7
0A8EA:  RLCF   x3C,W
0A8EC:  CLRF   03
0A8EE:  ADDLW  62
0A8F0:  MOVWF  FE9
0A8F2:  MOVLW  07
0A8F4:  ADDWFC 03,W
0A8F6:  MOVWF  FEA
0A8F8:  MOVFF  FEC,8B0
0A8FC:  MOVF   FED,F
0A8FE:  MOVFF  FEF,8AF
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A902:  BCF    FD8.0
0A904:  RLCF   x3C,W
0A906:  CLRF   03
0A908:  ADDLW  72
0A90A:  MOVWF  FE9
0A90C:  MOVLW  07
0A90E:  ADDWFC 03,W
0A910:  MOVWF  FEA
0A912:  MOVFF  FEC,8C6
0A916:  MOVF   FED,F
0A918:  MOVFF  FEF,8C5
0A91C:  BCF    FD8.0
0A91E:  RLCF   x3C,W
0A920:  CLRF   03
0A922:  ADDLW  5E
0A924:  MOVWF  FE9
0A926:  MOVLW  07
0A928:  ADDWFC 03,W
0A92A:  MOVWF  FEA
0A92C:  MOVFF  FEC,03
0A930:  MOVF   FED,F
0A932:  MOVFF  FEF,8C7
0A936:  MOVFF  03,8B4
0A93A:  MOVFF  03,8C8
0A93E:  MOVLB  0
0A940:  CALL   2D28
0A944:  MOVFF  02,8AE
0A948:  MOVFF  01,8AD
....................    e_mode[motor] = 0;                          // motor steps 
0A94C:  BCF    FD8.0
0A94E:  MOVLB  7
0A950:  RLCF   x3C,W
0A952:  CLRF   03
0A954:  ADDLW  62
0A956:  MOVWF  FE9
0A958:  MOVLW  07
0A95A:  ADDWFC 03,W
0A95C:  MOVWF  FEA
0A95E:  CLRF   FEC
0A960:  MOVF   FED,F
0A962:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A964:  MOVLB  8
0A966:  CLRF   xB1
0A968:  MOVFF  8AC,8B2
0A96C:  CLRF   xB6
0A96E:  CLRF   xB5
0A970:  MOVFF  8AE,8B4
0A974:  MOVFF  8AD,8B3
0A978:  MOVLW  01
0A97A:  MOVWF  xB7
0A97C:  MOVLB  0
0A97E:  CALL   9DAA
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A982:  MOVLW  01
0A984:  MOVLB  8
0A986:  MOVWF  xD6
0A988:  MOVLB  0
0A98A:  CALL   8A02
....................    delay_ms(100); 
0A98E:  MOVLW  64
0A990:  MOVLB  9
0A992:  MOVWF  xD6
0A994:  MOVLB  0
0A996:  CALL   2964
....................    poll_index(); 
0A99A:  BRA    A7B4
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A99C:  BCF    FD8.0
0A99E:  MOVLB  7
0A9A0:  RLCF   x3C,W
0A9A2:  CLRF   03
0A9A4:  ADDLW  5A
0A9A6:  MOVWF  FE9
0A9A8:  MOVLW  07
0A9AA:  ADDWFC 03,W
0A9AC:  MOVWF  FEA
0A9AE:  MOVFF  FEC,8B2
0A9B2:  MOVF   FED,F
0A9B4:  MOVFF  FEF,8B1
0A9B8:  MOVLW  02
0A9BA:  MOVLB  8
0A9BC:  ADDWF  xB1,W
0A9BE:  MOVWF  xAD
0A9C0:  MOVLW  00
0A9C2:  ADDWFC xB2,W
0A9C4:  MOVWF  xAE
....................    e_mode[motor] = 3; 
0A9C6:  BCF    FD8.0
0A9C8:  MOVLB  7
0A9CA:  RLCF   x3C,W
0A9CC:  CLRF   03
0A9CE:  ADDLW  62
0A9D0:  MOVWF  FE9
0A9D2:  MOVLW  07
0A9D4:  ADDWFC 03,W
0A9D6:  MOVWF  FEA
0A9D8:  CLRF   FEC
0A9DA:  MOVF   FED,F
0A9DC:  MOVLW  03
0A9DE:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A9E0:  MOVLB  8
0A9E2:  CLRF   xB1
0A9E4:  MOVFF  8AC,8B2
0A9E8:  CLRF   xB6
0A9EA:  CLRF   xB5
0A9EC:  MOVFF  8AE,8B4
0A9F0:  MOVFF  8AD,8B3
0A9F4:  MOVLW  01
0A9F6:  MOVWF  xB7
0A9F8:  MOVLB  0
0A9FA:  CALL   9DAA
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A9FE:  MOVFF  77F,8AE
0AA02:  MOVFF  77E,8AD
....................    e_mode[motor] = 0;                          // motor steps 
0AA06:  BCF    FD8.0
0AA08:  MOVLB  7
0AA0A:  RLCF   x3C,W
0AA0C:  CLRF   03
0AA0E:  ADDLW  62
0AA10:  MOVWF  FE9
0AA12:  MOVLW  07
0AA14:  ADDWFC 03,W
0AA16:  MOVWF  FEA
0AA18:  CLRF   FEC
0AA1A:  MOVF   FED,F
0AA1C:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0AA1E:  MOVLB  8
0AA20:  CLRF   xB1
0AA22:  MOVFF  8AC,8B2
0AA26:  CLRF   xB6
0AA28:  CLRF   xB5
0AA2A:  MOVFF  8AE,8B4
0AA2E:  MOVFF  8AD,8B3
0AA32:  MOVLW  01
0AA34:  MOVWF  xB7
0AA36:  MOVLB  0
0AA38:  CALL   9DAA
....................  
....................    e_pos[motor] = 0; 
0AA3C:  BCF    FD8.0
0AA3E:  MOVLB  7
0AA40:  RLCF   x3C,W
0AA42:  CLRF   03
0AA44:  ADDLW  BB
0AA46:  MOVWF  FE9
0AA48:  MOVLW  07
0AA4A:  ADDWFC 03,W
0AA4C:  MOVWF  FEA
0AA4E:  CLRF   FEC
0AA50:  MOVF   FED,F
0AA52:  CLRF   FEF
....................    e_port[motor] = 1; 
0AA54:  BCF    FD8.0
0AA56:  RLCF   x3C,W
0AA58:  CLRF   03
0AA5A:  ADDLW  BF
0AA5C:  MOVWF  FE9
0AA5E:  MOVLW  07
0AA60:  ADDWFC 03,W
0AA62:  MOVWF  FEA
0AA64:  CLRF   FEC
0AA66:  MOVF   FED,F
0AA68:  MOVLW  01
0AA6A:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0AA6C:  BCF    FD8.0
0AA6E:  RLCF   x3C,W
0AA70:  CLRF   03
0AA72:  ADDLW  62
0AA74:  MOVWF  FE9
0AA76:  MOVLW  07
0AA78:  ADDWFC 03,W
0AA7A:  MOVWF  FEA
0AA7C:  MOVFF  8B0,FEC
0AA80:  MOVF   FED,F
0AA82:  MOVFF  8AF,FEF
0AA86:  MOVLB  0
0AA88:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0DE28:  BCF    FD8.0
0DE2A:  MOVLB  7
0DE2C:  RLCF   x3C,W
0DE2E:  CLRF   03
0DE30:  ADDLW  5A
0DE32:  MOVWF  FE9
0DE34:  MOVLW  07
0DE36:  ADDWFC 03,W
0DE38:  MOVWF  FEA
0DE3A:  MOVFF  FEC,873
0DE3E:  MOVF   FED,F
0DE40:  MOVFF  FEF,872
0DE44:  MOVLW  02
0DE46:  MOVLB  8
0DE48:  ADDWF  x72,W
0DE4A:  MOVWF  x70
0DE4C:  MOVLW  00
0DE4E:  ADDWFC x73,W
0DE50:  MOVWF  x71
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0DE52:  CLRF   xB1
0DE54:  MOVFF  86F,8B2
0DE58:  CLRF   xB6
0DE5A:  CLRF   xB5
0DE5C:  MOVFF  871,8B4
0DE60:  MOVFF  870,8B3
0DE64:  MOVLW  02
0DE66:  MOVWF  xB7
0DE68:  MOVLB  0
0DE6A:  CALL   9DAA
0DE6E:  GOTO   DEEE (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0AA8A:  MOVF   2F,W
0AA8C:  SUBLW  02
0AA8E:  BNZ   AA94
0AA90:  MOVF   30,F
0AA92:  BZ    AAF4
....................    { 
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0AA94:  MOVLW  A0
0AA96:  MOVWF  FF6
0AA98:  MOVLW  1A
0AA9A:  MOVWF  FF7
0AA9C:  MOVLW  00
0AA9E:  MOVWF  FF8
0AAA0:  CLRF   1B
0AAA2:  BTFSC  FF2.7
0AAA4:  BSF    1B.7
0AAA6:  BCF    FF2.7
0AAA8:  CALL   0E3A
0AAAC:  BTFSC  1B.7
0AAAE:  BSF    FF2.7
....................       motor=0; 
0AAB0:  MOVLB  7
0AAB2:  CLRF   x3C
....................       align(0); 
0AAB4:  MOVLB  8
0AAB6:  CLRF   xAC
0AAB8:  MOVLB  0
0AABA:  RCALL  A8E6
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0AABC:  MOVLW  01
0AABE:  MOVLB  7
0AAC0:  MOVWF  x3C
....................       move_motor(0,0,22000,1); 
0AAC2:  MOVLB  8
0AAC4:  CLRF   xB1
0AAC6:  CLRF   xB2
0AAC8:  CLRF   xB6
0AACA:  CLRF   xB5
0AACC:  MOVLW  55
0AACE:  MOVWF  xB4
0AAD0:  MOVLW  F0
0AAD2:  MOVWF  xB3
0AAD4:  MOVLW  01
0AAD6:  MOVWF  xB7
0AAD8:  MOVLB  0
0AADA:  CALL   9DAA
....................        
....................       m_lin_pos[1]=0; 
0AADE:  MOVLB  7
0AAE0:  CLRF   xB2
0AAE2:  CLRF   xB1
....................       write16(ADDR_M2_LIN_POS,0); 
0AAE4:  MOVLW  B8
0AAE6:  MOVLB  8
0AAE8:  MOVWF  xD8
0AAEA:  CLRF   xDA
0AAEC:  CLRF   xD9
0AAEE:  MOVLB  0
0AAF0:  CALL   501E
....................    } 
0AAF4:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0BF66:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BF68:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0BF6A:  BCF    F8E.3
....................   delay_ms(20); 
0BF6C:  MOVLW  14
0BF6E:  MOVLB  9
0BF70:  MOVWF  xD6
0BF72:  MOVLB  0
0BF74:  CALL   2964
....................   output_bit(VMOT,  OFF); 
0BF78:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0BF7A:  BCF    F8E.2
0BF7C:  GOTO   BFD2 (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BF80:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BF82:  BSF    F8E.1
....................   delay_ms(50); 
0BF84:  MOVLW  32
0BF86:  MOVLB  9
0BF88:  MOVWF  xD6
0BF8A:  MOVLB  0
0BF8C:  CALL   2964
....................   output_bit(HB_IN1,ON);           
0BF90:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0BF92:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0BF94:  BSF    F8E.3
0BF96:  GOTO   BFD2 (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0BF9A:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0BF9C:  BSF    F8E.1
....................   delay_ms(50); 
0BF9E:  MOVLW  32
0BFA0:  MOVLB  9
0BFA2:  MOVWF  xD6
0BFA4:  MOVLB  0
0BFA6:  CALL   2964
....................   output_bit(HB_IN1,OFF);           
0BFAA:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0BFAC:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0BFAE:  BSF    F8E.3
0BFB0:  GOTO   BFD2 (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0BFB4:  MOVLB  8
0BFB6:  MOVF   x9F,W
0BFB8:  XORLW  00
0BFBA:  MOVLB  0
0BFBC:  BZ    BFC8
0BFBE:  XORLW  01
0BFC0:  BZ    BFCC
0BFC2:  XORLW  03
0BFC4:  BZ    BFD0
0BFC6:  BRA    BFD2
....................       case 0:  HB_all_OFF(); 
0BFC8:  BRA    BF66
....................          break; 
0BFCA:  BRA    BFD2
....................       case 1:  HB_m1_ON(); 
0BFCC:  BRA    BF80
....................          break; 
0BFCE:  BRA    BFD2
....................       case 2:  HB_m2_ON(); 
0BFD0:  BRA    BF9A
....................          break; 
....................    } 
0BFD2:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
15996:  MOVLB  8
15998:  CLRF   x73
1599A:  CLRF   x74
1599C:  CLRF   x75
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
1599E:  MOVLB  0
159A0:  BRA    1592C
159A2:  MOVFF  01,874
....................       if (serChar) 
159A6:  MOVLB  8
159A8:  MOVF   x74,F
159AA:  BZ    159D4
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
159AC:  MOVF   x74,W
159AE:  SUBLW  24
159B0:  BNZ   159BA
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
159B2:  MOVLW  02
159B4:  MOVWF  x75
....................             break; 
159B6:  BRA    159E0
....................          }else if (serChar == 'D'){ 
159B8:  BRA    159D4
159BA:  MOVF   x74,W
159BC:  SUBLW  44
159BE:  BNZ   159D0
....................             wakeup_char_is_D = 1; 
159C0:  MOVLW  01
159C2:  MOVLB  7
159C4:  MOVWF  xC9
....................             wakeUpReason = WAKE_UP_GOOD; 
159C6:  MOVLW  02
159C8:  MOVLB  8
159CA:  MOVWF  x75
....................             break; 
159CC:  BRA    159E0
....................          }else 
159CE:  BRA    159D4
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
159D0:  MOVLW  01
159D2:  MOVWF  x75
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
159D4:  INCF   x73,F
159D6:  MOVF   x73,W
159D8:  SUBLW  02
159DA:  BC    159DE
....................       { 
....................          break; 
159DC:  BRA    159E0
....................       } 
159DE:  BRA    1599E
....................    } 
....................  
....................    return (wakeUpReason); 
159E0:  MOVFF  875,01
159E4:  MOVLB  0
159E6:  GOTO   159FA (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
158C4:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
158C6:  BSF    49.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
158C8:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
158CA:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
158CC:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
158CE:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
158D0:  BSF    FF2.6
158D2:  GOTO   158DE (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
158D6:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
158D8:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
158DA:  BCF    49.0
....................    set_usart_int(); 
158DC:  BRA    158C4
....................    kill_wd(); 
158DE:  CALL   314A
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
158E2:  BSF    FF2.4
....................    sleep();  
158E4:  MOVFF  FD3,00
158E8:  BCF    FD1.7
158EA:  BCF    FD3.7
158EC:  SLEEP 
158EE:  MOVFF  00,FD3
....................    delay_cycles(1); 
158F2:  NOP   
158F4:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
159EA:  MOVLB  8
159EC:  CLRF   x72
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
159EE:  MOVLB  0
159F0:  RCALL  158F6
....................  
....................    if (TRUE != rtc_alarm) 
159F2:  BTFSC  49.0
159F4:  BRA    15AB2
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
159F6:  RCALL  158F6
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
159F8:  BRA    15996
159FA:  MOVFF  01,872
....................       if (WAKE_UP_GOOD == serWakeupReason) 
159FE:  MOVLB  8
15A00:  MOVF   x72,W
15A02:  SUBLW  02
15A04:  BNZ   15AAA
....................       { 
....................          sleep_mode = FALSE; 
15A06:  BCF    49.1
....................          start_heartbeat(); 
15A08:  MOVLB  0
15A0A:  CALL   2954
....................          init_hardware(); 
15A0E:  CALL   298E
....................          init_rtc();                      // This is the FAT RTC 
15A12:  CALL   355C
....................          sd_status = init_sdcard(); 
15A16:  CALL   5084
15A1A:  MOVFF  01,2D8
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
15A1E:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
15A20:  MOVLW  01
15A22:  MOVWF  1E
15A24:  MOVLW  A3
15A26:  MOVWF  1D
15A28:  MOVLW  D6
15A2A:  MOVWF  FF6
15A2C:  MOVLW  1A
15A2E:  MOVWF  FF7
15A30:  MOVLW  00
15A32:  MOVWF  FF8
15A34:  CALL   5108
....................          record_event(); 
15A38:  CALL   850C
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15A3C:  CLRF   32
15A3E:  MOVLW  01
15A40:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
15A42:  MOVLW  02
15A44:  MOVLB  8
15A46:  MOVWF  x73
15A48:  MOVFF  31,874
15A4C:  MOVLB  0
15A4E:  CALL   3466
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
15A52:  MOVLB  7
15A54:  MOVF   xC9,F
15A56:  BZ    15A78
....................             file_list(file_ptr_rel_new); 
15A58:  MOVLW  03
15A5A:  MOVLB  8
15A5C:  MOVWF  x74
15A5E:  MOVWF  x73
15A60:  MOVLB  0
15A62:  CALL   B888
....................             f_unlink(file_ptr_rel_new); 
15A66:  MOVLW  03
15A68:  MOVLB  8
15A6A:  MOVWF  x74
15A6C:  MOVWF  x73
15A6E:  MOVLB  0
15A70:  CALL   BA02
....................              
....................             wakeup_char_is_D = 0; 
15A74:  MOVLB  7
15A76:  CLRF   xC9
....................          } 
....................          if(sd_status>0) 
15A78:  MOVLB  2
15A7A:  MOVF   xD8,F
15A7C:  BZ    15A86
....................          { 
....................             msg_card_fail(); 
15A7E:  MOVLB  0
15A80:  CALL   50CA
15A84:  MOVLB  2
....................          } 
....................  
....................          fprintf(COM_A, "@RST\r\n"); 
15A86:  MOVLW  F8
15A88:  MOVWF  FF6
15A8A:  MOVLW  1A
15A8C:  MOVWF  FF7
15A8E:  MOVLW  00
15A90:  MOVWF  FF8
15A92:  CLRF   1B
15A94:  BTFSC  FF2.7
15A96:  BSF    1B.7
15A98:  BCF    FF2.7
15A9A:  MOVLB  0
15A9C:  CALL   0E3A
15AA0:  BTFSC  1B.7
15AA2:  BSF    FF2.7
....................          reset_cpu(); 
15AA4:  RESET
....................       } 
15AA6:  BRA    15AB2
15AA8:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
15AAA:  DECFSZ x72,W
15AAC:  BRA    15AB4
....................          { 
....................             initilizeSleepState(); 
15AAE:  MOVLB  0
15AB0:  RCALL  158D6
15AB2:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
15AB4:  MOVLW  00
15AB6:  BTFSC  49.0
15AB8:  MOVLW  01
15ABA:  MOVWF  01
15ABC:  MOVLB  0
15ABE:  GOTO   15AC8 (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
15AC2:  RCALL  1585A
....................    initilizeSleepState(); 
15AC4:  RCALL  158D6
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
15AC6:  BRA    159EA
15AC8:  DECFSZ 01,W
15ACA:  BRA    15AD0
....................       { 
....................          rtc_alarm = FALSE; 
15ACC:  BCF    49.0
....................          break; 
15ACE:  BRA    15AD6
....................       } 
....................  
....................       blip(); 
15AD0:  RCALL  158F6
....................       blip(); 
15AD2:  RCALL  158F6
15AD4:  BRA    15AC6
....................    } 
15AD6:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0ABF0:  MOVF   FD0,W
0ABF2:  ANDLW  0F
0ABF4:  BTFSS  FD0.4
0ABF6:  MOVLW  00
0ABF8:  BSF    FD0.0
0ABFA:  BSF    FD0.1
0ABFC:  BSF    FD0.4
0ABFE:  BSF    FD8.3
0AC00:  BSF    FD8.4
0AC02:  ADDLW  F0
0AC04:  BTFSC  FD8.0
0AC06:  BRA    ADD6
0AC08:  ADDLW  10
0AC0A:  GOTO   ADDA
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0AC0E:  MOVLW  00
0AC10:  MOVWF  FF6
0AC12:  MOVLW  1B
0AC14:  MOVWF  FF7
0AC16:  MOVLW  00
0AC18:  MOVWF  FF8
0AC1A:  CLRF   1B
0AC1C:  BTFSC  FF2.7
0AC1E:  BSF    1B.7
0AC20:  BCF    FF2.7
0AC22:  CALL   0E3A
0AC26:  BTFSC  1B.7
0AC28:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0AC2A:  MOVLW  01
0AC2C:  MOVWF  1E
0AC2E:  MOVLW  A3
0AC30:  MOVWF  1D
0AC32:  MOVLW  08
0AC34:  MOVWF  FF6
0AC36:  MOVLW  1B
0AC38:  MOVWF  FF7
0AC3A:  MOVLW  00
0AC3C:  MOVWF  FF8
0AC3E:  CALL   5108
....................          record_event(); 
0AC42:  CALL   850C
....................          recovery(); 
0AC46:  RCALL  AA8A
....................          break; 
0AC48:  BRA    ADD6
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AC4A:  MOVLW  26
0AC4C:  MOVWF  FF6
0AC4E:  MOVLW  1B
0AC50:  MOVWF  FF7
0AC52:  MOVLW  00
0AC54:  MOVWF  FF8
0AC56:  CLRF   1B
0AC58:  BTFSC  FF2.7
0AC5A:  BSF    1B.7
0AC5C:  BCF    FF2.7
0AC5E:  CALL   0E3A
0AC62:  BTFSC  1B.7
0AC64:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AC66:  MOVLW  01
0AC68:  MOVWF  1E
0AC6A:  MOVLW  A3
0AC6C:  MOVWF  1D
0AC6E:  MOVLW  2E
0AC70:  MOVWF  FF6
0AC72:  MOVLW  1B
0AC74:  MOVWF  FF7
0AC76:  MOVLW  00
0AC78:  MOVWF  FF8
0AC7A:  CALL   5108
....................          record_event(); 
0AC7E:  CALL   850C
....................          recovery(); 
0AC82:  RCALL  AA8A
....................          break; 
0AC84:  BRA    ADD6
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0AC86:  MOVLW  4E
0AC88:  MOVWF  FF6
0AC8A:  MOVLW  1B
0AC8C:  MOVWF  FF7
0AC8E:  MOVLW  00
0AC90:  MOVWF  FF8
0AC92:  CLRF   1B
0AC94:  BTFSC  FF2.7
0AC96:  BSF    1B.7
0AC98:  BCF    FF2.7
0AC9A:  CALL   0E3A
0AC9E:  BTFSC  1B.7
0ACA0:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0ACA2:  MOVLW  01
0ACA4:  MOVWF  1E
0ACA6:  MOVLW  A3
0ACA8:  MOVWF  1D
0ACAA:  MOVLW  56
0ACAC:  MOVWF  FF6
0ACAE:  MOVLW  1B
0ACB0:  MOVWF  FF7
0ACB2:  MOVLW  00
0ACB4:  MOVWF  FF8
0ACB6:  MOVLW  05
0ACB8:  MOVLB  8
0ACBA:  MOVWF  xD5
0ACBC:  MOVLB  0
0ACBE:  RCALL  AAF6
0ACC0:  MOVLW  10
0ACC2:  MOVWF  FE9
0ACC4:  MOVFF  26,8E1
0ACC8:  MOVFF  25,8E0
0ACCC:  RCALL  AB28
0ACCE:  MOVLW  5E
0ACD0:  MOVWF  FF6
0ACD2:  MOVLW  1B
0ACD4:  MOVWF  FF7
0ACD6:  MOVLW  00
0ACD8:  MOVWF  FF8
0ACDA:  MOVLW  20
0ACDC:  MOVLB  8
0ACDE:  MOVWF  xD5
0ACE0:  MOVLB  0
0ACE2:  RCALL  AAF6
....................          record_event(); 
0ACE4:  CALL   850C
....................          break; 
0ACE8:  BRA    ADD6
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0ACEA:  MOVLW  80
0ACEC:  MOVWF  FF6
0ACEE:  MOVLW  1B
0ACF0:  MOVWF  FF7
0ACF2:  MOVLW  00
0ACF4:  MOVWF  FF8
0ACF6:  CLRF   1B
0ACF8:  BTFSC  FF2.7
0ACFA:  BSF    1B.7
0ACFC:  BCF    FF2.7
0ACFE:  CALL   0E3A
0AD02:  BTFSC  1B.7
0AD04:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0AD06:  MOVLW  01
0AD08:  MOVWF  1E
0AD0A:  MOVLW  A3
0AD0C:  MOVWF  1D
0AD0E:  MOVLW  88
0AD10:  MOVWF  FF6
0AD12:  MOVLW  1B
0AD14:  MOVWF  FF7
0AD16:  MOVLW  00
0AD18:  MOVWF  FF8
0AD1A:  CALL   5108
....................          record_event(); 
0AD1E:  CALL   850C
....................          break; 
0AD22:  BRA    ADD6
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0AD24:  MOVLW  AC
0AD26:  MOVWF  FF6
0AD28:  MOVLW  1B
0AD2A:  MOVWF  FF7
0AD2C:  MOVLW  00
0AD2E:  MOVWF  FF8
0AD30:  CLRF   1B
0AD32:  BTFSC  FF2.7
0AD34:  BSF    1B.7
0AD36:  BCF    FF2.7
0AD38:  CALL   0E3A
0AD3C:  BTFSC  1B.7
0AD3E:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AD40:  MOVLW  01
0AD42:  MOVWF  1E
0AD44:  MOVLW  A3
0AD46:  MOVWF  1D
0AD48:  MOVLW  B4
0AD4A:  MOVWF  FF6
0AD4C:  MOVLW  1B
0AD4E:  MOVWF  FF7
0AD50:  MOVLW  00
0AD52:  MOVWF  FF8
0AD54:  CALL   5108
....................          record_event(); 
0AD58:  CALL   850C
....................          recovery(); 
0AD5C:  RCALL  AA8A
....................          break; 
0AD5E:  BRA    ADD6
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AD60:  MOVLW  D0
0AD62:  MOVWF  FF6
0AD64:  MOVLW  1B
0AD66:  MOVWF  FF7
0AD68:  MOVLW  00
0AD6A:  MOVWF  FF8
0AD6C:  CLRF   1B
0AD6E:  BTFSC  FF2.7
0AD70:  BSF    1B.7
0AD72:  BCF    FF2.7
0AD74:  CALL   0E3A
0AD78:  BTFSC  1B.7
0AD7A:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0AD7C:  MOVLW  01
0AD7E:  MOVWF  1E
0AD80:  MOVLW  A3
0AD82:  MOVWF  1D
0AD84:  MOVLW  D8
0AD86:  MOVWF  FF6
0AD88:  MOVLW  1B
0AD8A:  MOVWF  FF7
0AD8C:  MOVLW  00
0AD8E:  MOVWF  FF8
0AD90:  CALL   5108
....................          record_event(); 
0AD94:  CALL   850C
....................          recovery(); 
0AD98:  RCALL  AA8A
....................          break; 
0AD9A:  BRA    ADD6
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0AD9C:  MOVLW  FA
0AD9E:  MOVWF  FF6
0ADA0:  MOVLW  1B
0ADA2:  MOVWF  FF7
0ADA4:  MOVLW  00
0ADA6:  MOVWF  FF8
0ADA8:  CLRF   1B
0ADAA:  BTFSC  FF2.7
0ADAC:  BSF    1B.7
0ADAE:  BCF    FF2.7
0ADB0:  CALL   0E3A
0ADB4:  BTFSC  1B.7
0ADB6:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0ADB8:  MOVLW  01
0ADBA:  MOVWF  1E
0ADBC:  MOVLW  A3
0ADBE:  MOVWF  1D
0ADC0:  MOVLW  02
0ADC2:  MOVWF  FF6
0ADC4:  MOVLW  1C
0ADC6:  MOVWF  FF7
0ADC8:  MOVLW  00
0ADCA:  MOVWF  FF8
0ADCC:  CALL   5108
....................          record_event(); 
0ADD0:  CALL   850C
....................          recovery(); 
0ADD4:  RCALL  AA8A
....................          break; 
....................       }         
....................    } 
0ADD6:  GOTO   1B340 (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02B0C:  MOVLW  1E
02B0E:  MOVLB  8
02B10:  MOVWF  x81
02B12:  MOVLB  0
02B14:  RCALL  2A1E
02B16:  MOVFF  02,30
02B1A:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02B1E:  MOVLW  1C
02B20:  MOVLB  8
02B22:  MOVWF  x81
02B24:  MOVLB  0
02B26:  RCALL  2A1E
02B28:  MOVFF  02,20
02B2C:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02B30:  MOVLW  16
02B32:  MOVLB  8
02B34:  MOVWF  x81
02B36:  MOVLB  0
02B38:  RCALL  2A1E
02B3A:  MOVFF  02,22
02B3E:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02B42:  MOVLW  14
02B44:  MOVLB  8
02B46:  MOVWF  x81
02B48:  MOVLB  0
02B4A:  RCALL  2A1E
02B4C:  MOVFF  02,24
02B50:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02B54:  MOVLB  8
02B56:  CLRF   x81
02B58:  MOVLB  0
02B5A:  RCALL  2A1E
02B5C:  MOVFF  02,26
02B60:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02B64:  MOVLW  18
02B66:  MOVLB  8
02B68:  MOVWF  x81
02B6A:  MOVLB  0
02B6C:  RCALL  2A1E
02B6E:  MOVFF  02,28
02B72:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02B76:  MOVLW  02
02B78:  MOVLB  8
02B7A:  MOVWF  xA1
02B7C:  MOVLB  0
02B7E:  RCALL  2A78
02B80:  CLRF   32
02B82:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02B86:  MOVLW  28
02B88:  MOVLB  8
02B8A:  MOVWF  xA1
02B8C:  MOVLB  0
02B8E:  RCALL  2A78
02B90:  CLRF   34
02B92:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02B96:  MOVLW  12
02B98:  MOVLB  8
02B9A:  MOVWF  x81
02B9C:  MOVLB  0
02B9E:  RCALL  2A1E
02BA0:  MOVFF  02,36
02BA4:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02BA8:  MOVLW  3A
02BAA:  MOVLB  8
02BAC:  MOVWF  x81
02BAE:  MOVLB  0
02BB0:  RCALL  2A1E
02BB2:  MOVFF  02,38
02BB6:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02BBA:  MOVLW  3C
02BBC:  MOVLB  8
02BBE:  MOVWF  x81
02BC0:  MOVLB  0
02BC2:  RCALL  2A1E
02BC4:  MOVFF  02,3A
02BC8:  MOVFF  01,39
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02BCC:  MOVLW  3E
02BCE:  MOVLB  8
02BD0:  MOVWF  x81
02BD2:  MOVLB  0
02BD4:  RCALL  2A1E
02BD6:  MOVFF  02,3C
02BDA:  MOVFF  01,3B
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02BDE:  MOVLW  40
02BE0:  MOVLB  8
02BE2:  MOVWF  x81
02BE4:  MOVLB  0
02BE6:  RCALL  2A1E
02BE8:  MOVFF  02,3E
02BEC:  MOVFF  01,3D
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02BF0:  MOVLW  42
02BF2:  MOVLB  8
02BF4:  MOVWF  x81
02BF6:  MOVLB  0
02BF8:  RCALL  2A1E
02BFA:  MOVFF  02,40
02BFE:  MOVFF  01,3F
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02C02:  MOVLW  04
02C04:  MOVLB  8
02C06:  MOVWF  xA1
02C08:  MOVLB  0
02C0A:  RCALL  2A78
02C0C:  MOVFF  01,729
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02C10:  MOVLB  8
02C12:  CLRF   x70
02C14:  MOVLW  44
02C16:  MOVWF  x6F
02C18:  MOVLB  0
02C1A:  RCALL  2A9E
02C1C:  MOVFF  03,3F4
02C20:  MOVFF  02,3F3
02C24:  MOVFF  01,3F2
02C28:  MOVFF  00,3F1
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02C2C:  MOVLB  8
02C2E:  CLRF   x70
02C30:  MOVLW  48
02C32:  MOVWF  x6F
02C34:  MOVLB  0
02C36:  RCALL  2A9E
02C38:  MOVFF  03,3F8
02C3C:  MOVFF  02,3F7
02C40:  MOVFF  01,3F6
02C44:  MOVFF  00,3F5
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02C48:  MOVLB  8
02C4A:  CLRF   x70
02C4C:  MOVLW  4C
02C4E:  MOVWF  x6F
02C50:  MOVLB  0
02C52:  RCALL  2A9E
02C54:  MOVFF  03,3FC
02C58:  MOVFF  02,3FB
02C5C:  MOVFF  01,3FA
02C60:  MOVFF  00,3F9
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02C64:  MOVLB  8
02C66:  CLRF   x70
02C68:  MOVLW  52
02C6A:  MOVWF  x6F
02C6C:  MOVLB  0
02C6E:  RCALL  2A9E
02C70:  MOVFF  03,400
02C74:  MOVFF  02,3FF
02C78:  MOVFF  01,3FE
02C7C:  MOVFF  00,3FD
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02C80:  MOVLB  8
02C82:  CLRF   x70
02C84:  MOVLW  56
02C86:  MOVWF  x6F
02C88:  MOVLB  0
02C8A:  RCALL  2A9E
02C8C:  MOVFF  03,404
02C90:  MOVFF  02,403
02C94:  MOVFF  01,402
02C98:  MOVFF  00,401
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02C9C:  MOVLB  8
02C9E:  CLRF   x70
02CA0:  MOVLW  5A
02CA2:  MOVWF  x6F
02CA4:  MOVLB  0
02CA6:  RCALL  2A9E
02CA8:  MOVFF  03,408
02CAC:  MOVFF  02,407
02CB0:  MOVFF  01,406
02CB4:  MOVFF  00,405
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02CB8:  MOVLB  8
02CBA:  CLRF   x70
02CBC:  MOVLW  5E
02CBE:  MOVWF  x6F
02CC0:  MOVLB  0
02CC2:  RCALL  2A9E
02CC4:  MOVFF  03,40C
02CC8:  MOVFF  02,40B
02CCC:  MOVFF  01,40A
02CD0:  MOVFF  00,409
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02CD4:  MOVLB  8
02CD6:  CLRF   x70
02CD8:  MOVLW  62
02CDA:  MOVWF  x6F
02CDC:  MOVLB  0
02CDE:  RCALL  2A9E
02CE0:  MOVFF  03,410
02CE4:  MOVFF  02,40F
02CE8:  MOVFF  01,40E
02CEC:  MOVFF  00,40D
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02CF0:  MOVLW  20
02CF2:  MOVLB  8
02CF4:  MOVWF  x81
02CF6:  MOVLB  0
02CF8:  RCALL  2A1E
02CFA:  MOVFF  02,2A
02CFE:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02D02:  MOVLW  22
02D04:  MOVLB  8
02D06:  MOVWF  x81
02D08:  MOVLB  0
02D0A:  RCALL  2A1E
02D0C:  MOVFF  02,2C
02D10:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02D14:  MOVLW  24
02D16:  MOVLB  8
02D18:  MOVWF  x81
02D1A:  MOVLB  0
02D1C:  RCALL  2A1E
02D1E:  MOVFF  02,2E
02D22:  MOVFF  01,2D
02D26:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DC20:  MOVLW  1C
0DC22:  MOVLB  8
0DC24:  MOVWF  xD8
0DC26:  CLRF   xDA
0DC28:  CLRF   xD9
0DC2A:  MOVLB  0
0DC2C:  CALL   501E
....................    write16(ADDR_SAMPLE,0); 
0DC30:  MOVLW  16
0DC32:  MOVLB  8
0DC34:  MOVWF  xD8
0DC36:  CLRF   xDA
0DC38:  CLRF   xD9
0DC3A:  MOVLB  0
0DC3C:  CALL   501E
....................    write16(ADDR_INTERVAL,60); 
0DC40:  MOVLW  14
0DC42:  MOVLB  8
0DC44:  MOVWF  xD8
0DC46:  CLRF   xDA
0DC48:  MOVLW  3C
0DC4A:  MOVWF  xD9
0DC4C:  MOVLB  0
0DC4E:  CALL   501E
....................    write16(ADDR_SERIALNO,9999); 
0DC52:  MOVLB  8
0DC54:  CLRF   xD8
0DC56:  MOVLW  27
0DC58:  MOVWF  xDA
0DC5A:  MOVLW  0F
0DC5C:  MOVWF  xD9
0DC5E:  MOVLB  0
0DC60:  CALL   501E
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DC64:  MOVLW  18
0DC66:  MOVLB  8
0DC68:  MOVWF  xD8
0DC6A:  MOVLW  0D
0DC6C:  MOVWF  xDA
0DC6E:  MOVLW  20
0DC70:  MOVWF  xD9
0DC72:  MOVLB  0
0DC74:  CALL   501E
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DC78:  MOVLW  02
0DC7A:  MOVLB  8
0DC7C:  MOVWF  x73
0DC7E:  MOVLW  01
0DC80:  MOVWF  x74
0DC82:  MOVLB  0
0DC84:  CALL   3466
....................    write16(ADDR_MACRO_STEP, 0); 
0DC88:  MOVLW  3A
0DC8A:  MOVLB  8
0DC8C:  MOVWF  xD8
0DC8E:  CLRF   xDA
0DC90:  CLRF   xD9
0DC92:  MOVLB  0
0DC94:  CALL   501E
....................    write16(ADDR_COM_ERR,3); 
0DC98:  MOVLW  3C
0DC9A:  MOVLB  8
0DC9C:  MOVWF  xD8
0DC9E:  CLRF   xDA
0DCA0:  MOVLW  03
0DCA2:  MOVWF  xD9
0DCA4:  MOVLB  0
0DCA6:  CALL   501E
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DCAA:  MOVLW  04
0DCAC:  MOVLB  8
0DCAE:  MOVWF  x73
0DCB0:  MOVLW  0A
0DCB2:  MOVWF  x74
0DCB4:  MOVLB  0
0DCB6:  CALL   3466
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DCBA:  MOVLB  8
0DCBC:  CLRF   x70
0DCBE:  MOVLW  44
0DCC0:  MOVWF  x6F
0DCC2:  CLRF   x74
0DCC4:  CLRF   x73
0DCC6:  CLRF   x72
0DCC8:  MOVLW  7F
0DCCA:  MOVWF  x71
0DCCC:  MOVLB  0
0DCCE:  CALL   CAC6
....................    write_float(ADDR_CAL_C1,0); 
0DCD2:  MOVLB  8
0DCD4:  CLRF   x70
0DCD6:  MOVLW  48
0DCD8:  MOVWF  x6F
0DCDA:  CLRF   x74
0DCDC:  CLRF   x73
0DCDE:  CLRF   x72
0DCE0:  CLRF   x71
0DCE2:  MOVLB  0
0DCE4:  CALL   CAC6
....................    write_float(ADDR_CAL_M2,1); 
0DCE8:  MOVLB  8
0DCEA:  CLRF   x70
0DCEC:  MOVLW  4C
0DCEE:  MOVWF  x6F
0DCF0:  CLRF   x74
0DCF2:  CLRF   x73
0DCF4:  CLRF   x72
0DCF6:  MOVLW  7F
0DCF8:  MOVWF  x71
0DCFA:  MOVLB  0
0DCFC:  CALL   CAC6
....................    write_float(ADDR_CAL_C2,0); 
0DD00:  MOVLB  8
0DD02:  CLRF   x70
0DD04:  MOVLW  52
0DD06:  MOVWF  x6F
0DD08:  CLRF   x74
0DD0A:  CLRF   x73
0DD0C:  CLRF   x72
0DD0E:  CLRF   x71
0DD10:  MOVLB  0
0DD12:  CALL   CAC6
....................    write_float(ADDR_CAL_M3,1); 
0DD16:  MOVLB  8
0DD18:  CLRF   x70
0DD1A:  MOVLW  56
0DD1C:  MOVWF  x6F
0DD1E:  CLRF   x74
0DD20:  CLRF   x73
0DD22:  CLRF   x72
0DD24:  MOVLW  7F
0DD26:  MOVWF  x71
0DD28:  MOVLB  0
0DD2A:  CALL   CAC6
....................    write_float(ADDR_CAL_C3,0); 
0DD2E:  MOVLB  8
0DD30:  CLRF   x70
0DD32:  MOVLW  5A
0DD34:  MOVWF  x6F
0DD36:  CLRF   x74
0DD38:  CLRF   x73
0DD3A:  CLRF   x72
0DD3C:  CLRF   x71
0DD3E:  MOVLB  0
0DD40:  CALL   CAC6
....................    write_float(ADDR_CAL_M4,1); 
0DD44:  MOVLB  8
0DD46:  CLRF   x70
0DD48:  MOVLW  5E
0DD4A:  MOVWF  x6F
0DD4C:  CLRF   x74
0DD4E:  CLRF   x73
0DD50:  CLRF   x72
0DD52:  MOVLW  7F
0DD54:  MOVWF  x71
0DD56:  MOVLB  0
0DD58:  CALL   CAC6
....................    write_float(ADDR_CAL_C4,0);  
0DD5C:  MOVLB  8
0DD5E:  CLRF   x70
0DD60:  MOVLW  62
0DD62:  MOVWF  x6F
0DD64:  CLRF   x74
0DD66:  CLRF   x73
0DD68:  CLRF   x72
0DD6A:  CLRF   x71
0DD6C:  MOVLB  0
0DD6E:  CALL   CAC6
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0DD72:  MOVLW  40
0DD74:  MOVLB  8
0DD76:  MOVWF  xD8
0DD78:  MOVLW  4E
0DD7A:  MOVWF  xDA
0DD7C:  MOVLW  20
0DD7E:  MOVWF  xD9
0DD80:  MOVLB  0
0DD82:  CALL   501E
....................    write16(ADDR_D2_TEMP,20000); 
0DD86:  MOVLW  42
0DD88:  MOVLB  8
0DD8A:  MOVWF  xD8
0DD8C:  MOVLW  4E
0DD8E:  MOVWF  xDA
0DD90:  MOVLW  20
0DD92:  MOVWF  xD9
0DD94:  MOVLB  0
0DD96:  CALL   501E
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0DD9A:  MOVLW  20
0DD9C:  MOVLB  8
0DD9E:  MOVWF  xD8
0DDA0:  CLRF   xDA
0DDA2:  CLRF   xD9
0DDA4:  MOVLB  0
0DDA6:  CALL   501E
....................    write16(ADDR_VOLUME,22500);  
0DDAA:  MOVLW  22
0DDAC:  MOVLB  8
0DDAE:  MOVWF  xD8
0DDB0:  MOVLW  57
0DDB2:  MOVWF  xDA
0DDB4:  MOVLW  E4
0DDB6:  MOVWF  xD9
0DDB8:  MOVLB  0
0DDBA:  CALL   501E
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0DDBE:  MOVF   2F,W
0DDC0:  SUBLW  02
0DDC2:  BNZ   DDC8
0DDC4:  MOVF   30,F
0DDC6:  BZ    DDDC
0DDC8:  MOVLW  24
0DDCA:  MOVLB  8
0DDCC:  MOVWF  xD8
0DDCE:  CLRF   xDA
0DDD0:  MOVLW  02
0DDD2:  MOVWF  xD9
0DDD4:  MOVLB  0
0DDD6:  CALL   501E
0DDDA:  BRA    DDEE
....................    else write16(ADDR_PORT,1); 
0DDDC:  MOVLW  24
0DDDE:  MOVLB  8
0DDE0:  MOVWF  xD8
0DDE2:  CLRF   xDA
0DDE4:  MOVLW  01
0DDE6:  MOVWF  xD9
0DDE8:  MOVLB  0
0DDEA:  CALL   501E
....................     
....................    write16(ADDR_DET_TYPE,1); 
0DDEE:  MOVLW  26
0DDF0:  MOVLB  8
0DDF2:  MOVWF  xD8
0DDF4:  CLRF   xDA
0DDF6:  MOVLW  01
0DDF8:  MOVWF  xD9
0DDFA:  MOVLB  0
0DDFC:  CALL   501E
....................     
....................    init_nv_vars(); 
0DE00:  CALL   2B0C
0DE04:  GOTO   DE1E (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
0FFEA:  MOVLW  02
0FFEC:  MOVWF  FEA
0FFEE:  MOVLW  43
0FFF0:  MOVWF  FE9
0FFF2:  CLRF   00
0FFF4:  CLRF   02
0FFF6:  MOVLW  51
0FFF8:  MOVWF  01
0FFFA:  CALL   357A
0FFFE:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F690:  MOVLW  03
0F692:  MOVWF  FEA
0F694:  MOVLW  21
0F696:  MOVWF  FE9
0F698:  CLRF   00
0F69A:  CLRF   02
0F69C:  MOVLW  14
0F69E:  MOVWF  01
0F6A0:  CALL   357A
0F6A4:  GOTO   F6C4 (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
130D0:  MOVLB  8
130D2:  CLRF   xBE
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
130D4:  CLRF   FEA
130D6:  MOVLW  4E
130D8:  MOVWF  FE9
130DA:  CLRF   00
130DC:  CLRF   02
130DE:  MOVLW  14
130E0:  MOVWF  01
130E2:  MOVLB  0
130E4:  CALL   357A
....................  
....................    for(n=0; n<20; n++) { 
130E8:  MOVLB  8
130EA:  CLRF   xBF
130EC:  MOVF   xBF,W
130EE:  SUBLW  13
130F0:  BNC   13136
....................         c = data_buffer[string_pos];  
130F2:  CLRF   03
130F4:  MOVLB  2
130F6:  MOVF   x94,W
130F8:  ADDLW  63
130FA:  MOVWF  FE9
130FC:  MOVLW  00
130FE:  ADDWFC 03,W
13100:  MOVWF  FEA
13102:  MOVFF  FEF,8BE
....................         ++string_pos; 
13106:  INCF   x94,F
....................         if (c == '\0') return(1); // found end 
13108:  MOVLB  8
1310A:  MOVF   xBE,F
1310C:  BNZ   13114
1310E:  MOVLW  01
13110:  MOVWF  01
13112:  BRA    1313A
....................         if (c == ',')  return(0); // found seperator  
13114:  MOVF   xBE,W
13116:  SUBLW  2C
13118:  BNZ   13120
1311A:  MOVLW  00
1311C:  MOVWF  01
1311E:  BRA    1313A
....................         sub_string[n] = c; 
13120:  CLRF   03
13122:  MOVF   xBF,W
13124:  ADDLW  4E
13126:  MOVWF  FE9
13128:  MOVLW  00
1312A:  ADDWFC 03,W
1312C:  MOVWF  FEA
1312E:  MOVFF  8BE,FEF
13132:  INCF   xBF,F
13134:  BRA    130EC
....................    } 
....................     
....................    return(2); // failed = bad string 
13136:  MOVLW  02
13138:  MOVWF  01
1313A:  MOVLB  0
1313C:  GOTO   13466 (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
1337A:  MOVLW  26
1337C:  MOVWF  FF6
1337E:  MOVLW  1C
13380:  MOVWF  FF7
13382:  MOVLW  00
13384:  MOVWF  FF8
13386:  MOVLW  03
13388:  MOVWF  FEA
1338A:  MOVLW  39
1338C:  MOVWF  FE9
1338E:  CALL   FBD6
13392:  MOVF   01,W
13394:  BZ    133A8
13396:  XORLW  01
13398:  BZ    133C8
1339A:  XORLW  03
1339C:  BZ    133E8
1339E:  XORLW  01
133A0:  BZ    13408
133A2:  XORLW  07
133A4:  BZ    13428
133A6:  BRA    13446
....................       case "NO3" : NO3_array[read_i] = result; 
133A8:  BCF    FD8.0
133AA:  MOVLB  3
133AC:  RLCF   x46,W
133AE:  CLRF   03
133B0:  ADDLW  47
133B2:  MOVWF  FE9
133B4:  MOVLW  03
133B6:  ADDWFC 03,W
133B8:  MOVWF  FEA
133BA:  MOVFF  8BF,FEC
133BE:  MOVF   FED,F
133C0:  MOVFF  8BE,FEF
....................          break; 
133C4:  MOVLB  0
133C6:  BRA    13446
....................       case "NO2" : NO2_array[read_i] = result; 
133C8:  BCF    FD8.0
133CA:  MOVLB  3
133CC:  RLCF   x46,W
133CE:  CLRF   03
133D0:  ADDLW  59
133D2:  MOVWF  FE9
133D4:  MOVLW  03
133D6:  ADDWFC 03,W
133D8:  MOVWF  FEA
133DA:  MOVFF  8BF,FEC
133DE:  MOVF   FED,F
133E0:  MOVFF  8BE,FEF
....................          break;    
133E4:  MOVLB  0
133E6:  BRA    13446
....................       case "PO4" : PO4_array[read_i] = result; 
133E8:  BCF    FD8.0
133EA:  MOVLB  3
133EC:  RLCF   x46,W
133EE:  CLRF   03
133F0:  ADDLW  6B
133F2:  MOVWF  FE9
133F4:  MOVLW  03
133F6:  ADDWFC 03,W
133F8:  MOVWF  FEA
133FA:  MOVFF  8BF,FEC
133FE:  MOVF   FED,F
13400:  MOVFF  8BE,FEF
....................          break; 
13404:  MOVLB  0
13406:  BRA    13446
....................       case "NH4" : NH4_array[read_i] = result; 
13408:  BCF    FD8.0
1340A:  MOVLB  3
1340C:  RLCF   x46,W
1340E:  CLRF   03
13410:  ADDLW  7D
13412:  MOVWF  FE9
13414:  MOVLW  03
13416:  ADDWFC 03,W
13418:  MOVWF  FEA
1341A:  MOVFF  8BF,FEC
1341E:  MOVF   FED,F
13420:  MOVFF  8BE,FEF
....................          break; 
13424:  MOVLB  0
13426:  BRA    13446
....................       case "SiO" : SiO_array[read_i] = result; 
13428:  BCF    FD8.0
1342A:  MOVLB  3
1342C:  RLCF   x46,W
1342E:  CLRF   03
13430:  ADDLW  8F
13432:  MOVWF  FE9
13434:  MOVLW  03
13436:  ADDWFC 03,W
13438:  MOVWF  FEA
1343A:  MOVFF  8BF,FEC
1343E:  MOVF   FED,F
13440:  MOVFF  8BE,FEF
....................          break; 
13444:  MOVLB  0
....................    } 
13446:  GOTO   134BE (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
1344A:  MOVLB  8
1344C:  CLRF   xB9
1344E:  CLRF   xB8
13450:  CLRF   xBB
13452:  CLRF   xBA
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
13454:  MOVLB  2
13456:  CLRF   x94
....................     
....................    for (n=0; n<11; ++n){ 
13458:  MOVLB  8
1345A:  CLRF   xBC
1345C:  MOVF   xBC,W
1345E:  SUBLW  0A
13460:  BNC   134B2
....................       parsed = parse_string(); 
13462:  MOVLB  0
13464:  BRA    130D0
13466:  MOVFF  01,8BD
....................       if (parsed == 2) return(0); 
1346A:  MOVLB  8
1346C:  MOVF   xBD,W
1346E:  SUBLW  02
13470:  BNZ   1347A
13472:  MOVLW  00
13474:  MOVWF  01
13476:  MOVWF  02
13478:  BRA    134C8
....................       if (n==8) result = atol(sub_string); 
1347A:  MOVF   xBC,W
1347C:  SUBLW  08
1347E:  BNZ   13494
13480:  CLRF   xBF
13482:  MOVLW  4E
13484:  MOVWF  xBE
13486:  MOVLB  0
13488:  RCALL  13196
1348A:  MOVFF  02,8B9
1348E:  MOVFF  01,8B8
13492:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
13494:  MOVF   xBC,W
13496:  SUBLW  0A
13498:  BNZ   134AE
1349A:  CLRF   xBF
1349C:  MOVLW  4E
1349E:  MOVWF  xBE
134A0:  MOVLB  0
134A2:  RCALL  13196
134A4:  MOVFF  02,8BB
134A8:  MOVFF  01,8BA
134AC:  MOVLB  8
134AE:  INCF   xBC,F
134B0:  BRA    1345C
....................    } 
....................    load_parsed_data(result); 
134B2:  MOVFF  8B9,8BF
134B6:  MOVFF  8B8,8BE
134BA:  MOVLB  0
134BC:  BRA    1337A
....................    return (temp); 
134BE:  MOVLB  8
134C0:  MOVFF  8BA,01
134C4:  MOVFF  8BB,02
134C8:  MOVLB  0
134CA:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D2A0:  CLRF   FEA
0D2A2:  MOVLW  63
0D2A4:  MOVWF  FE9
0D2A6:  CLRF   00
0D2A8:  CLRF   02
0D2AA:  MOVLW  A0
0D2AC:  MOVWF  01
0D2AE:  CALL   357A
0D2B2:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F6A8:  MOVLW  03
0F6AA:  MOVWF  FEA
0F6AC:  MOVLW  39
0F6AE:  MOVWF  FE9
0F6B0:  MOVLW  00
0F6B2:  CALL   02E4
0F6B6:  TBLRD*-
0F6B8:  TBLRD*+
0F6BA:  MOVF   FF5,W
0F6BC:  MOVWF  FEE
0F6BE:  IORLW  00
0F6C0:  BNZ   F6B8
....................  
....................    clear_flag_str(); 
0F6C2:  BRA    F690
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F6C4:  MOVLW  08
0F6C6:  MOVWF  1E
0F6C8:  MOVLW  D7
0F6CA:  MOVWF  1D
0F6CC:  MOVLW  10
0F6CE:  MOVWF  FE9
0F6D0:  MOVFF  320,8E1
0F6D4:  MOVFF  31F,8E0
0F6D8:  CALL   AB28
....................  
....................    if (macro_flag < 100) { 
0F6DC:  MOVLB  3
0F6DE:  MOVF   x20,F
0F6E0:  BNZ   F6FA
0F6E2:  MOVF   x1F,W
0F6E4:  SUBLW  63
0F6E6:  BNC   F6FA
....................       temp_str[3] = '\0'; 
0F6E8:  MOVLB  8
0F6EA:  CLRF   xDA
....................       temp_str[2] = temp_str[1]; 
0F6EC:  MOVFF  8D8,8D9
....................       temp_str[1] = temp_str[0]; 
0F6F0:  MOVFF  8D7,8D8
....................       temp_str[0] = '0'; 
0F6F4:  MOVLW  30
0F6F6:  MOVWF  xD7
0F6F8:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F6FA:  MOVLB  8
0F6FC:  MOVF   xD7,W
0F6FE:  XORLW  30
0F700:  MOVLB  0
0F702:  BZ    F726
0F704:  XORLW  01
0F706:  BZ    F74C
0F708:  XORLW  03
0F70A:  BZ    F772
0F70C:  XORLW  01
0F70E:  BZ    F798
0F710:  XORLW  07
0F712:  BZ    F7BE
0F714:  XORLW  01
0F716:  BZ    F7E4
0F718:  XORLW  03
0F71A:  BTFSC  FD8.2
0F71C:  BRA    F80A
0F71E:  XORLW  01
0F720:  BTFSC  FD8.2
0F722:  BRA    F830
0F724:  BRA    F858
....................       case '0' : strcopy(chem,"NO3"); 
0F726:  MOVLW  03
0F728:  MOVWF  FEA
0F72A:  MOVLW  39
0F72C:  MOVWF  FE9
0F72E:  MOVLW  00
0F730:  CALL   02FC
0F734:  TBLRD*-
0F736:  TBLRD*+
0F738:  MOVF   FF5,W
0F73A:  MOVWF  FEE
0F73C:  IORLW  00
0F73E:  BNZ   F736
....................                  wave_l=543; 
0F740:  MOVLW  02
0F742:  MOVLB  8
0F744:  MOVWF  xD6
0F746:  MOVLW  1F
0F748:  MOVWF  xD5
....................          break; 
0F74A:  BRA    F87C
....................       case '1' : strcopy(chem,"PO4"); 
0F74C:  MOVLW  03
0F74E:  MOVWF  FEA
0F750:  MOVLW  39
0F752:  MOVWF  FE9
0F754:  MOVLW  00
0F756:  CALL   0314
0F75A:  TBLRD*-
0F75C:  TBLRD*+
0F75E:  MOVF   FF5,W
0F760:  MOVWF  FEE
0F762:  IORLW  00
0F764:  BNZ   F75C
....................                  wave_l=880;       
0F766:  MOVLW  03
0F768:  MOVLB  8
0F76A:  MOVWF  xD6
0F76C:  MOVLW  70
0F76E:  MOVWF  xD5
....................          break; 
0F770:  BRA    F87C
....................       case '2' : strcopy(chem,"NH4"); 
0F772:  MOVLW  03
0F774:  MOVWF  FEA
0F776:  MOVLW  39
0F778:  MOVWF  FE9
0F77A:  MOVLW  00
0F77C:  CALL   032C
0F780:  TBLRD*-
0F782:  TBLRD*+
0F784:  MOVF   FF5,W
0F786:  MOVWF  FEE
0F788:  IORLW  00
0F78A:  BNZ   F782
....................                  wave_l=660;       
0F78C:  MOVLW  02
0F78E:  MOVLB  8
0F790:  MOVWF  xD6
0F792:  MOVLW  94
0F794:  MOVWF  xD5
....................          break; 
0F796:  BRA    F87C
....................       case '3' : strcopy(chem,"SiO"); 
0F798:  MOVLW  03
0F79A:  MOVWF  FEA
0F79C:  MOVLW  39
0F79E:  MOVWF  FE9
0F7A0:  MOVLW  00
0F7A2:  CALL   0344
0F7A6:  TBLRD*-
0F7A8:  TBLRD*+
0F7AA:  MOVF   FF5,W
0F7AC:  MOVWF  FEE
0F7AE:  IORLW  00
0F7B0:  BNZ   F7A8
....................                  wave_l=810;       
0F7B2:  MOVLW  03
0F7B4:  MOVLB  8
0F7B6:  MOVWF  xD6
0F7B8:  MOVLW  2A
0F7BA:  MOVWF  xD5
....................          break; 
0F7BC:  BRA    F87C
....................       case '4' : strcopy(chem,"Ure"); 
0F7BE:  MOVLW  03
0F7C0:  MOVWF  FEA
0F7C2:  MOVLW  39
0F7C4:  MOVWF  FE9
0F7C6:  MOVLW  00
0F7C8:  CALL   035C
0F7CC:  TBLRD*-
0F7CE:  TBLRD*+
0F7D0:  MOVF   FF5,W
0F7D2:  MOVWF  FEE
0F7D4:  IORLW  00
0F7D6:  BNZ   F7CE
....................                  wave_l=525;       
0F7D8:  MOVLW  02
0F7DA:  MOVLB  8
0F7DC:  MOVWF  xD6
0F7DE:  MOVLW  0D
0F7E0:  MOVWF  xD5
....................          break; 
0F7E2:  BRA    F87C
....................       case '5' : strcopy(chem,"NO2"); 
0F7E4:  MOVLW  03
0F7E6:  MOVWF  FEA
0F7E8:  MOVLW  39
0F7EA:  MOVWF  FE9
0F7EC:  MOVLW  00
0F7EE:  CALL   0374
0F7F2:  TBLRD*-
0F7F4:  TBLRD*+
0F7F6:  MOVF   FF5,W
0F7F8:  MOVWF  FEE
0F7FA:  IORLW  00
0F7FC:  BNZ   F7F4
....................                  wave_l=543;       
0F7FE:  MOVLW  02
0F800:  MOVLB  8
0F802:  MOVWF  xD6
0F804:  MOVLW  1F
0F806:  MOVWF  xD5
....................          break; 
0F808:  BRA    F87C
....................       case '6' : strcopy(chem,"Fe_"); 
0F80A:  MOVLW  03
0F80C:  MOVWF  FEA
0F80E:  MOVLW  39
0F810:  MOVWF  FE9
0F812:  MOVLW  00
0F814:  CALL   038C
0F818:  TBLRD*-
0F81A:  TBLRD*+
0F81C:  MOVF   FF5,W
0F81E:  MOVWF  FEE
0F820:  IORLW  00
0F822:  BNZ   F81A
....................                  wave_l=543;       
0F824:  MOVLW  02
0F826:  MOVLB  8
0F828:  MOVWF  xD6
0F82A:  MOVLW  1F
0F82C:  MOVWF  xD5
....................          break; 
0F82E:  BRA    F87C
....................       case '7' : strcopy(chem,"Cl_"); 
0F830:  MOVLW  03
0F832:  MOVWF  FEA
0F834:  MOVLW  39
0F836:  MOVWF  FE9
0F838:  MOVLW  00
0F83A:  CALL   03A4
0F83E:  TBLRD*-
0F840:  TBLRD*+
0F842:  MOVF   FF5,W
0F844:  MOVWF  FEE
0F846:  IORLW  00
0F848:  BNZ   F840
....................                  wave_l=560;       
0F84A:  MOVLW  02
0F84C:  MOVLB  8
0F84E:  MOVWF  xD6
0F850:  MOVLW  30
0F852:  MOVWF  xD5
....................          break; 
0F854:  BRA    F87C
0F856:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0F858:  MOVLW  03
0F85A:  MOVWF  FEA
0F85C:  MOVLW  39
0F85E:  MOVWF  FE9
0F860:  MOVLW  00
0F862:  CALL   02E4
0F866:  TBLRD*-
0F868:  TBLRD*+
0F86A:  MOVF   FF5,W
0F86C:  MOVWF  FEE
0F86E:  IORLW  00
0F870:  BNZ   F868
....................                  wave_l=999;       
0F872:  MOVLW  03
0F874:  MOVLB  8
0F876:  MOVWF  xD6
0F878:  MOVLW  E7
0F87A:  MOVWF  xD5
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0F87C:  MOVF   xD8,W
0F87E:  XORLW  31
0F880:  MOVLB  0
0F882:  BZ    F8A2
0F884:  XORLW  03
0F886:  BZ    F8BE
0F888:  XORLW  01
0F88A:  BZ    F8DA
0F88C:  XORLW  07
0F88E:  BZ    F8F6
0F890:  XORLW  01
0F892:  BZ    F912
0F894:  XORLW  03
0F896:  BZ    F92E
0F898:  XORLW  01
0F89A:  BZ    F94A
0F89C:  XORLW  0F
0F89E:  BZ    F966
0F8A0:  BRA    F982
....................       case '1' : strcopy(anal,"Smp"); 
0F8A2:  MOVLW  03
0F8A4:  MOVWF  FEA
0F8A6:  MOVLW  3E
0F8A8:  MOVWF  FE9
0F8AA:  MOVLW  00
0F8AC:  CALL   03BC
0F8B0:  TBLRD*-
0F8B2:  TBLRD*+
0F8B4:  MOVF   FF5,W
0F8B6:  MOVWF  FEE
0F8B8:  IORLW  00
0F8BA:  BNZ   F8B2
....................          break; 
0F8BC:  BRA    F99C
....................       case '2' : strcopy(anal,"Std"); 
0F8BE:  MOVLW  03
0F8C0:  MOVWF  FEA
0F8C2:  MOVLW  3E
0F8C4:  MOVWF  FE9
0F8C6:  MOVLW  00
0F8C8:  CALL   03D4
0F8CC:  TBLRD*-
0F8CE:  TBLRD*+
0F8D0:  MOVF   FF5,W
0F8D2:  MOVWF  FEE
0F8D4:  IORLW  00
0F8D6:  BNZ   F8CE
....................          break; 
0F8D8:  BRA    F99C
....................       case '3' : strcopy(anal,"Cmb"); 
0F8DA:  MOVLW  03
0F8DC:  MOVWF  FEA
0F8DE:  MOVLW  3E
0F8E0:  MOVWF  FE9
0F8E2:  MOVLW  00
0F8E4:  CALL   03EC
0F8E8:  TBLRD*-
0F8EA:  TBLRD*+
0F8EC:  MOVF   FF5,W
0F8EE:  MOVWF  FEE
0F8F0:  IORLW  00
0F8F2:  BNZ   F8EA
....................          break; 
0F8F4:  BRA    F99C
....................       case '4' : strcopy(anal,"Tst"); 
0F8F6:  MOVLW  03
0F8F8:  MOVWF  FEA
0F8FA:  MOVLW  3E
0F8FC:  MOVWF  FE9
0F8FE:  MOVLW  00
0F900:  CALL   0404
0F904:  TBLRD*-
0F906:  TBLRD*+
0F908:  MOVF   FF5,W
0F90A:  MOVWF  FEE
0F90C:  IORLW  00
0F90E:  BNZ   F906
....................          break; 
0F910:  BRA    F99C
....................       case '5' : strcopy(anal,"Rbl"); 
0F912:  MOVLW  03
0F914:  MOVWF  FEA
0F916:  MOVLW  3E
0F918:  MOVWF  FE9
0F91A:  MOVLW  00
0F91C:  CALL   041C
0F920:  TBLRD*-
0F922:  TBLRD*+
0F924:  MOVF   FF5,W
0F926:  MOVWF  FEE
0F928:  IORLW  00
0F92A:  BNZ   F922
....................          break; 
0F92C:  BRA    F99C
....................       case '6' : strcopy(anal,"Cal"); 
0F92E:  MOVLW  03
0F930:  MOVWF  FEA
0F932:  MOVLW  3E
0F934:  MOVWF  FE9
0F936:  MOVLW  00
0F938:  CALL   0434
0F93C:  TBLRD*-
0F93E:  TBLRD*+
0F940:  MOVF   FF5,W
0F942:  MOVWF  FEE
0F944:  IORLW  00
0F946:  BNZ   F93E
....................          break; 
0F948:  BRA    F99C
....................       case '7' : strcopy(anal,"Fls"); 
0F94A:  MOVLW  03
0F94C:  MOVWF  FEA
0F94E:  MOVLW  3E
0F950:  MOVWF  FE9
0F952:  MOVLW  00
0F954:  CALL   044C
0F958:  TBLRD*-
0F95A:  TBLRD*+
0F95C:  MOVF   FF5,W
0F95E:  MOVWF  FEE
0F960:  IORLW  00
0F962:  BNZ   F95A
....................          break; 
0F964:  BRA    F99C
....................       case '8' : strcopy(anal,"Utl"); 
0F966:  MOVLW  03
0F968:  MOVWF  FEA
0F96A:  MOVLW  3E
0F96C:  MOVWF  FE9
0F96E:  MOVLW  00
0F970:  CALL   0464
0F974:  TBLRD*-
0F976:  TBLRD*+
0F978:  MOVF   FF5,W
0F97A:  MOVWF  FEE
0F97C:  IORLW  00
0F97E:  BNZ   F976
....................          break;     
0F980:  BRA    F99C
....................       default  : strcopy(anal,"XXX"); 
0F982:  MOVLW  03
0F984:  MOVWF  FEA
0F986:  MOVLW  3E
0F988:  MOVWF  FE9
0F98A:  MOVLW  00
0F98C:  CALL   02E4
0F990:  TBLRD*-
0F992:  TBLRD*+
0F994:  MOVF   FF5,W
0F996:  MOVWF  FEE
0F998:  IORLW  00
0F99A:  BNZ   F992
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0F99C:  MOVLB  8
0F99E:  MOVF   xD9,W
0F9A0:  XORLW  31
0F9A2:  MOVLB  0
0F9A4:  BZ    F9CE
0F9A6:  XORLW  03
0F9A8:  BZ    F9EE
0F9AA:  XORLW  01
0F9AC:  BZ    FA10
0F9AE:  XORLW  07
0F9B0:  BZ    FA32
0F9B2:  XORLW  01
0F9B4:  BZ    FA54
0F9B6:  XORLW  03
0F9B8:  BZ    FA76
0F9BA:  XORLW  01
0F9BC:  BTFSC  FD8.2
0F9BE:  BRA    FA98
0F9C0:  XORLW  0F
0F9C2:  BTFSC  FD8.2
0F9C4:  BRA    FABA
0F9C6:  XORLW  01
0F9C8:  BTFSC  FD8.2
0F9CA:  BRA    FADC
0F9CC:  BRA    FB00
....................       case '1' : strcopy(read_t,"I0s"); 
0F9CE:  MOVLW  03
0F9D0:  MOVWF  FEA
0F9D2:  MOVLW  42
0F9D4:  MOVWF  FE9
0F9D6:  MOVLW  00
0F9D8:  CALL   047C
0F9DC:  TBLRD*-
0F9DE:  TBLRD*+
0F9E0:  MOVF   FF5,W
0F9E2:  MOVWF  FEE
0F9E4:  IORLW  00
0F9E6:  BNZ   F9DE
....................                  read_i = 0; 
0F9E8:  MOVLB  3
0F9EA:  CLRF   x46
....................          break; 
0F9EC:  BRA    FB1E
....................       case '2' : strcopy(read_t,"I1s"); 
0F9EE:  MOVLW  03
0F9F0:  MOVWF  FEA
0F9F2:  MOVLW  42
0F9F4:  MOVWF  FE9
0F9F6:  MOVLW  00
0F9F8:  CALL   0494
0F9FC:  TBLRD*-
0F9FE:  TBLRD*+
0FA00:  MOVF   FF5,W
0FA02:  MOVWF  FEE
0FA04:  IORLW  00
0FA06:  BNZ   F9FE
....................                  read_i = 1;       
0FA08:  MOVLW  01
0FA0A:  MOVLB  3
0FA0C:  MOVWF  x46
....................          break; 
0FA0E:  BRA    FB1E
....................       case '3' : strcopy(read_t,"I0t"); 
0FA10:  MOVLW  03
0FA12:  MOVWF  FEA
0FA14:  MOVLW  42
0FA16:  MOVWF  FE9
0FA18:  MOVLW  00
0FA1A:  CALL   04AC
0FA1E:  TBLRD*-
0FA20:  TBLRD*+
0FA22:  MOVF   FF5,W
0FA24:  MOVWF  FEE
0FA26:  IORLW  00
0FA28:  BNZ   FA20
....................                  read_i = 2;       
0FA2A:  MOVLW  02
0FA2C:  MOVLB  3
0FA2E:  MOVWF  x46
....................          break; 
0FA30:  BRA    FB1E
....................       case '4' : strcopy(read_t,"I1t"); 
0FA32:  MOVLW  03
0FA34:  MOVWF  FEA
0FA36:  MOVLW  42
0FA38:  MOVWF  FE9
0FA3A:  MOVLW  00
0FA3C:  CALL   04C4
0FA40:  TBLRD*-
0FA42:  TBLRD*+
0FA44:  MOVF   FF5,W
0FA46:  MOVWF  FEE
0FA48:  IORLW  00
0FA4A:  BNZ   FA42
....................                  read_i = 3;       
0FA4C:  MOVLW  03
0FA4E:  MOVLB  3
0FA50:  MOVWF  x46
....................          break; 
0FA52:  BRA    FB1E
....................       case '5' : strcopy(read_t,"I0r"); 
0FA54:  MOVLW  03
0FA56:  MOVWF  FEA
0FA58:  MOVLW  42
0FA5A:  MOVWF  FE9
0FA5C:  MOVLW  00
0FA5E:  CALL   04DC
0FA62:  TBLRD*-
0FA64:  TBLRD*+
0FA66:  MOVF   FF5,W
0FA68:  MOVWF  FEE
0FA6A:  IORLW  00
0FA6C:  BNZ   FA64
....................                  read_i = 4;       
0FA6E:  MOVLW  04
0FA70:  MOVLB  3
0FA72:  MOVWF  x46
....................          break; 
0FA74:  BRA    FB1E
....................       case '6' : strcopy(read_t,"I1r"); 
0FA76:  MOVLW  03
0FA78:  MOVWF  FEA
0FA7A:  MOVLW  42
0FA7C:  MOVWF  FE9
0FA7E:  MOVLW  00
0FA80:  CALL   04F4
0FA84:  TBLRD*-
0FA86:  TBLRD*+
0FA88:  MOVF   FF5,W
0FA8A:  MOVWF  FEE
0FA8C:  IORLW  00
0FA8E:  BNZ   FA86
....................                  read_i = 5;       
0FA90:  MOVLW  05
0FA92:  MOVLB  3
0FA94:  MOVWF  x46
....................          break; 
0FA96:  BRA    FB1E
....................       case '7' : strcopy(read_t,"I0u"); 
0FA98:  MOVLW  03
0FA9A:  MOVWF  FEA
0FA9C:  MOVLW  42
0FA9E:  MOVWF  FE9
0FAA0:  MOVLW  00
0FAA2:  CALL   050C
0FAA6:  TBLRD*-
0FAA8:  TBLRD*+
0FAAA:  MOVF   FF5,W
0FAAC:  MOVWF  FEE
0FAAE:  IORLW  00
0FAB0:  BNZ   FAA8
....................                  read_i = 6;       
0FAB2:  MOVLW  06
0FAB4:  MOVLB  3
0FAB6:  MOVWF  x46
....................          break; 
0FAB8:  BRA    FB1E
....................       case '8' : strcopy(read_t,"I1u"); 
0FABA:  MOVLW  03
0FABC:  MOVWF  FEA
0FABE:  MOVLW  42
0FAC0:  MOVWF  FE9
0FAC2:  MOVLW  00
0FAC4:  CALL   0524
0FAC8:  TBLRD*-
0FACA:  TBLRD*+
0FACC:  MOVF   FF5,W
0FACE:  MOVWF  FEE
0FAD0:  IORLW  00
0FAD2:  BNZ   FACA
....................                  read_i = 7;       
0FAD4:  MOVLW  07
0FAD6:  MOVLB  3
0FAD8:  MOVWF  x46
....................          break; 
0FADA:  BRA    FB1E
....................       case '9' : strcopy(read_t,"Chk"); 
0FADC:  MOVLW  03
0FADE:  MOVWF  FEA
0FAE0:  MOVLW  42
0FAE2:  MOVWF  FE9
0FAE4:  MOVLW  00
0FAE6:  CALL   053C
0FAEA:  TBLRD*-
0FAEC:  TBLRD*+
0FAEE:  MOVF   FF5,W
0FAF0:  MOVWF  FEE
0FAF2:  IORLW  00
0FAF4:  BNZ   FAEC
....................                  read_i = 8;       
0FAF6:  MOVLW  08
0FAF8:  MOVLB  3
0FAFA:  MOVWF  x46
....................          break;        
0FAFC:  BRA    FB1E
0FAFE:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0FB00:  MOVLW  03
0FB02:  MOVWF  FEA
0FB04:  MOVLW  42
0FB06:  MOVWF  FE9
0FB08:  MOVLW  00
0FB0A:  CALL   0554
0FB0E:  TBLRD*-
0FB10:  TBLRD*+
0FB12:  MOVF   FF5,W
0FB14:  MOVWF  FEE
0FB16:  IORLW  00
0FB18:  BNZ   FB10
....................                  read_i = 0;       
0FB1A:  MOVLB  3
0FB1C:  CLRF   x46
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FB1E:  MOVLW  03
0FB20:  MOVLB  8
0FB22:  MOVWF  xE3
0FB24:  MOVLW  21
0FB26:  MOVWF  xE2
0FB28:  MOVLW  03
0FB2A:  MOVWF  xE5
0FB2C:  MOVLW  39
0FB2E:  MOVWF  xE4
0FB30:  MOVLB  0
0FB32:  CALL   5528
....................    strcat(flag_str, (char *)","); 
0FB36:  MOVLW  2C
0FB38:  MOVLB  8
0FB3A:  MOVWF  xDE
0FB3C:  CLRF   xDF
0FB3E:  MOVLW  03
0FB40:  MOVWF  xE3
0FB42:  MOVLW  21
0FB44:  MOVWF  xE2
0FB46:  MOVLW  08
0FB48:  MOVWF  xE5
0FB4A:  MOVLW  DE
0FB4C:  MOVWF  xE4
0FB4E:  MOVLB  0
0FB50:  CALL   5528
....................    strcat(flag_str, anal); 
0FB54:  MOVLW  03
0FB56:  MOVLB  8
0FB58:  MOVWF  xE3
0FB5A:  MOVLW  21
0FB5C:  MOVWF  xE2
0FB5E:  MOVLW  03
0FB60:  MOVWF  xE5
0FB62:  MOVLW  3E
0FB64:  MOVWF  xE4
0FB66:  MOVLB  0
0FB68:  CALL   5528
....................    strcat(flag_str, (char *)","); 
0FB6C:  MOVLW  2C
0FB6E:  MOVLB  8
0FB70:  MOVWF  xDE
0FB72:  CLRF   xDF
0FB74:  MOVLW  03
0FB76:  MOVWF  xE3
0FB78:  MOVLW  21
0FB7A:  MOVWF  xE2
0FB7C:  MOVLW  08
0FB7E:  MOVWF  xE5
0FB80:  MOVLW  DE
0FB82:  MOVWF  xE4
0FB84:  MOVLB  0
0FB86:  CALL   5528
....................    strcat(flag_str, read_t);   
0FB8A:  MOVLW  03
0FB8C:  MOVLB  8
0FB8E:  MOVWF  xE3
0FB90:  MOVLW  21
0FB92:  MOVWF  xE2
0FB94:  MOVLW  03
0FB96:  MOVWF  xE5
0FB98:  MOVLW  42
0FB9A:  MOVWF  xE4
0FB9C:  MOVLB  0
0FB9E:  CALL   5528
....................     
....................    return wave_l; 
0FBA2:  MOVLB  8
0FBA4:  MOVFF  8D5,01
0FBA8:  MOVFF  8D6,02
0FBAC:  MOVLB  0
0FBAE:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F176:  MOVF   43,W
0F178:  SUBLW  4B
0F17A:  BTFSC  FD8.2
0F17C:  MOVFF  44,2D2
....................    if (cmd=='L') detector_li = arg; 
0F180:  MOVF   43,W
0F182:  SUBLW  4C
0F184:  BNZ   F18E
0F186:  MOVFF  45,2D4
0F18A:  MOVFF  44,2D3
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F18E:  MOVF   1F,W
0F190:  SUBLW  04
0F192:  BNZ   F25C
0F194:  MOVF   20,F
0F196:  BNZ   F25C
0F198:  MOVLW  3C
0F19A:  MOVWF  FF6
0F19C:  MOVLW  1C
0F19E:  MOVWF  FF7
0F1A0:  MOVLW  00
0F1A2:  MOVWF  FF8
0F1A4:  CLRF   1B
0F1A6:  BTFSC  FF2.7
0F1A8:  BSF    1B.7
0F1AA:  BCF    FF2.7
0F1AC:  MOVLW  06
0F1AE:  MOVLB  A
0F1B0:  MOVWF  x25
0F1B2:  MOVLB  0
0F1B4:  CALL   1010
0F1B8:  BTFSC  1B.7
0F1BA:  BSF    FF2.7
0F1BC:  CLRF   1B
0F1BE:  BTFSC  FF2.7
0F1C0:  BSF    1B.7
0F1C2:  BCF    FF2.7
0F1C4:  MOVFF  2D1,A25
0F1C8:  MOVLW  1B
0F1CA:  MOVLB  A
0F1CC:  MOVWF  x26
0F1CE:  MOVLB  0
0F1D0:  CALL   0F92
0F1D4:  BTFSC  1B.7
0F1D6:  BSF    FF2.7
0F1D8:  MOVLW  5D
0F1DA:  BTFSS  F9E.4
0F1DC:  BRA    F1DA
0F1DE:  MOVWF  FAD
0F1E0:  MOVLW  5B
0F1E2:  BTFSS  F9E.4
0F1E4:  BRA    F1E2
0F1E6:  MOVWF  FAD
0F1E8:  MOVF   43,W
0F1EA:  BTFSS  F9E.4
0F1EC:  BRA    F1EA
0F1EE:  MOVWF  FAD
0F1F0:  MOVLW  48
0F1F2:  MOVWF  FF6
0F1F4:  MOVLW  1C
0F1F6:  MOVWF  FF7
0F1F8:  MOVLW  00
0F1FA:  MOVWF  FF8
0F1FC:  CLRF   1B
0F1FE:  BTFSC  FF2.7
0F200:  BSF    1B.7
0F202:  BCF    FF2.7
0F204:  MOVLW  05
0F206:  MOVLB  A
0F208:  MOVWF  x25
0F20A:  MOVLB  0
0F20C:  CALL   1010
0F210:  BTFSC  1B.7
0F212:  BSF    FF2.7
0F214:  MOVLW  41
0F216:  MOVWF  FE9
0F218:  CLRF   1B
0F21A:  BTFSC  FF2.7
0F21C:  BSF    1B.7
0F21E:  BCF    FF2.7
0F220:  MOVFF  47,A28
0F224:  MOVFF  46,A27
0F228:  MOVFF  45,A26
0F22C:  MOVFF  44,A25
0F230:  CALL   10D6
0F234:  BTFSC  1B.7
0F236:  BSF    FF2.7
0F238:  MOVLW  50
0F23A:  MOVWF  FF6
0F23C:  MOVLW  1C
0F23E:  MOVWF  FF7
0F240:  MOVLW  00
0F242:  MOVWF  FF8
0F244:  CLRF   1B
0F246:  BTFSC  FF2.7
0F248:  BSF    1B.7
0F24A:  BCF    FF2.7
0F24C:  MOVLW  03
0F24E:  MOVLB  A
0F250:  MOVWF  x25
0F252:  MOVLB  0
0F254:  CALL   1010
0F258:  BTFSC  1B.7
0F25A:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F25C:  CALL   D7F0
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F260:  MOVLW  2F
0F262:  BTFSS  FA4.4
0F264:  BRA    F262
0F266:  MOVLB  F
0F268:  MOVWF  x1C
0F26A:  MOVFF  2D1,8DD
0F26E:  MOVLW  1B
0F270:  MOVLB  8
0F272:  MOVWF  xDE
0F274:  MOVLB  0
0F276:  CALL   D838
0F27A:  MOVF   43,W
0F27C:  BTFSS  FA4.4
0F27E:  BRA    F27C
0F280:  MOVLB  F
0F282:  MOVWF  x1C
0F284:  MOVLW  41
0F286:  MOVWF  FE9
0F288:  MOVFF  47,8E0
0F28C:  MOVFF  46,8DF
0F290:  MOVFF  45,8DE
0F294:  MOVFF  44,8DD
0F298:  MOVLB  0
0F29A:  BRA    F096
0F29C:  MOVLW  0D
0F29E:  BTFSS  FA4.4
0F2A0:  BRA    F29E
0F2A2:  MOVLB  F
0F2A4:  MOVWF  x1C
0F2A6:  MOVLW  0A
0F2A8:  BTFSS  FA4.4
0F2AA:  BRA    F2A8
0F2AC:  MOVWF  x1C
....................    multidrop_off(); 
0F2AE:  MOVLB  0
0F2B0:  CALL   D8DC
0F2B4:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12BEC:  MOVLB  8
12BEE:  CLRF   xD6
12BF0:  BCF    xD7.0
12BF2:  CLRF   xD8
12BF4:  CLRF   xDC
12BF6:  CLRF   xDB
12BF8:  CLRF   xDA
12BFA:  CLRF   xD9
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12BFC:  MOVLW  02
12BFE:  MOVWF  FEA
12C00:  MOVLW  43
12C02:  MOVWF  FE9
12C04:  CLRF   00
12C06:  CLRF   02
12C08:  MOVLW  51
12C0A:  MOVWF  01
12C0C:  MOVLB  0
12C0E:  CALL   357A
....................  
....................    det_cmd(); 
12C12:  CALL   F176
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12C16:  CALL   559A
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12C1A:  MOVLB  8
12C1C:  MOVF   xD8,W
12C1E:  SUBLW  02
12C20:  BZ    12CB4
12C22:  MOVF   xD8,W
12C24:  SUBLW  03
12C26:  BZ    12CB4
12C28:  MOVF   xD6,W
12C2A:  SUBLW  50
12C2C:  BNC   12CB4
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12C2E:  BTFSS  FA4.5
12C30:  BRA    12C68
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12C32:  MOVLB  0
12C34:  RCALL  12BD2
12C36:  MOVFF  01,8D5
....................  
....................          if(startCharacterRcvd) 
12C3A:  MOVLB  8
12C3C:  BTFSS  xD7.0
12C3E:  BRA    12C60
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12C40:  MOVF   xD6,W
12C42:  INCF   xD6,F
12C44:  CLRF   03
12C46:  ADDLW  43
12C48:  MOVWF  FE9
12C4A:  MOVLW  02
12C4C:  ADDWFC 03,W
12C4E:  MOVWF  FEA
12C50:  MOVFF  8D5,FEF
....................             if (CARRIAGE_RET == c) 
12C54:  MOVF   xD5,W
12C56:  SUBLW  0D
12C58:  BNZ   12C5E
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12C5A:  MOVLW  02
12C5C:  MOVWF  xD8
....................             } 
....................          } 
12C5E:  BRA    12C68
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12C60:  MOVF   xD5,W
12C62:  SUBLW  40
12C64:  BNZ   12C68
....................             { 
....................                startCharacterRcvd = TRUE; 
12C66:  BSF    xD7.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12C68:  MOVLW  35
12C6A:  MOVWF  00
12C6C:  DECFSZ 00,F
12C6E:  BRA    12C6C
....................       if (tenMicroSecDelayCounter++ > 500000) 
12C70:  MOVFF  8DC,8E0
12C74:  MOVFF  8DB,8DF
12C78:  MOVFF  8DA,8DE
12C7C:  MOVFF  8D9,8DD
12C80:  MOVLW  01
12C82:  ADDWF  xD9,F
12C84:  BTFSC  FD8.0
12C86:  INCF   xDA,F
12C88:  BTFSC  FD8.2
12C8A:  INCF   xDB,F
12C8C:  BTFSC  FD8.2
12C8E:  INCF   xDC,F
12C90:  MOVF   xE0,F
12C92:  BNZ   12CAE
12C94:  MOVF   xDF,W
12C96:  SUBLW  06
12C98:  BC    12CB2
12C9A:  XORLW  FF
12C9C:  BNZ   12CAE
12C9E:  MOVF   xDE,W
12CA0:  SUBLW  A0
12CA2:  BC    12CB2
12CA4:  XORLW  FF
12CA6:  BNZ   12CAE
12CA8:  MOVF   xDD,W
12CAA:  SUBLW  20
12CAC:  BC    12CB2
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12CAE:  MOVLW  03
12CB0:  MOVWF  xD8
....................       } 
12CB2:  BRA    12C1C
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12CB4:  MOVF   xD6,W
12CB6:  SUBLW  50
12CB8:  BC    12CCA
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12CBA:  MOVF   xD8,W
12CBC:  SUBLW  03
12CBE:  BZ    12CCA
12CC0:  MOVF   xD8,W
12CC2:  SUBLW  02
12CC4:  BZ    12CCA
....................       { 
....................          rcvDataType = SOME_DATA; 
12CC6:  MOVLW  01
12CC8:  MOVWF  xD8
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12CCA:  MOVLB  0
12CCC:  CALL   55BA
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12CD0:  MOVLB  8
12CD2:  MOVFF  8D8,01
12CD6:  MOVLB  0
12CD8:  GOTO   12E54 (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
0FCDE:  MOVF   1F,F
0FCE0:  BNZ   FD00
0FCE2:  MOVF   20,F
0FCE4:  BNZ   FD00
0FCE6:  MOVLB  8
0FCE8:  DECFSZ xD6,W
0FCEA:  BRA    FCEE
0FCEC:  BRA    FCF2
0FCEE:  MOVLB  0
0FCF0:  BRA    FD00
0FCF2:  CLRF   FEA
0FCF4:  MOVLW  63
0FCF6:  MOVWF  FE9
0FCF8:  MOVLB  0
0FCFA:  CALL   79CE
0FCFE:  BRA    FD14
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
0FD00:  MOVF   20,F
0FD02:  BNZ   FD0A
0FD04:  MOVF   1F,W
0FD06:  SUBLW  03
0FD08:  BC    FD14
0FD0A:  CLRF   FEA
0FD0C:  MOVLW  63
0FD0E:  MOVWF  FE9
0FD10:  CALL   79CE
....................  
....................    if (store==TRUE && sd_status==0) { 
0FD14:  MOVLB  8
0FD16:  DECFSZ xD5,W
0FD18:  BRA    FD78
0FD1A:  MOVLB  2
0FD1C:  MOVF   xD8,F
0FD1E:  BTFSC  FD8.2
0FD20:  BRA    FD26
0FD22:  MOVLB  8
0FD24:  BRA    FD78
....................        
....................       buffer_select = 0; 
0FD26:  MOVLB  0
0FD28:  CLRF   x62
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FD2A:  MOVLB  8
0FD2C:  CLRF   xD7
0FD2E:  MOVLB  0
0FD30:  CALL   55CC
....................          append_data(file_ptr_raw_all); 
0FD34:  MOVLW  02
0FD36:  MOVLB  8
0FD38:  MOVWF  xD8
0FD3A:  MOVLW  D9
0FD3C:  MOVWF  xD7
0FD3E:  MOVLB  0
0FD40:  CALL   832A
....................       heartbeat(TRUE); 
0FD44:  MOVLW  01
0FD46:  MOVLB  8
0FD48:  MOVWF  xD7
0FD4A:  MOVLB  0
0FD4C:  CALL   55CC
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FD50:  MOVLB  8
0FD52:  CLRF   xD7
0FD54:  MOVLB  0
0FD56:  CALL   55CC
....................          append_data(file_ptr_raw_new); 
0FD5A:  MOVLW  02
0FD5C:  MOVLB  8
0FD5E:  MOVWF  xD8
0FD60:  MOVLW  E7
0FD62:  MOVWF  xD7
0FD64:  MOVLB  0
0FD66:  CALL   832A
....................       heartbeat(TRUE); 
0FD6A:  MOVLW  01
0FD6C:  MOVLB  8
0FD6E:  MOVWF  xD7
0FD70:  MOVLB  0
0FD72:  CALL   55CC
0FD76:  MOVLB  8
....................    } 
0FD78:  MOVLB  0
0FD7A:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12CE8:  CLRF   xCF
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12CDC:  MOVLW  0D
12CDE:  MOVLB  8
12CE0:  MOVWF  xB8
12CE2:  MOVLW  0A
12CE4:  MOVWF  xB9
12CE6:  CLRF   xBA
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12CEA:  MOVLB  0
12CEC:  CALL   FFEA
....................    clear_data_buffer(); 
12CF0:  CALL   D2A0
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12CF4:  MOVLW  08
12CF6:  MOVWF  FEA
12CF8:  MOVLW  BB
12CFA:  MOVWF  FE9
12CFC:  CLRF   00
12CFE:  CLRF   02
12D00:  MOVLW  14
12D02:  MOVWF  01
12D04:  CALL   357A
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12D08:  MOVLW  01
12D0A:  MOVWF  FEA
12D0C:  MOVLW  A3
12D0E:  MOVWF  FE9
12D10:  CLRF   00
12D12:  CLRF   02
12D14:  MOVLW  A0
12D16:  MOVWF  01
12D18:  CALL   357A
....................  
....................    time_stamp(); 
12D1C:  CALL   5464
....................    strcpy(data_buffer, time_stmp_str); 
12D20:  CLRF   FEA
12D22:  MOVLW  63
12D24:  MOVWF  FE9
12D26:  MOVLW  02
12D28:  MOVWF  FE2
12D2A:  MOVLW  95
12D2C:  MOVWF  FE1
12D2E:  MOVF   FE7,F
12D30:  MOVFF  FE6,FEE
12D34:  BNZ   12D2E
....................    strcat(data_buffer, (char *)","); 
12D36:  MOVLW  2C
12D38:  MOVLB  8
12D3A:  MOVWF  xD3
12D3C:  CLRF   xD4
12D3E:  CLRF   xE3
12D40:  MOVLW  63
12D42:  MOVWF  xE2
12D44:  MOVLW  08
12D46:  MOVWF  xE5
12D48:  MOVLW  D3
12D4A:  MOVWF  xE4
12D4C:  MOVLB  0
12D4E:  CALL   5528
....................  
....................    flag_mod=fmod(macro_flag,10); 
12D52:  MOVFF  320,902
12D56:  MOVFF  31F,901
12D5A:  CALL   C68E
12D5E:  MOVFF  03,8D8
12D62:  MOVFF  02,8D7
12D66:  MOVFF  01,8D6
12D6A:  MOVFF  00,8D5
12D6E:  MOVFF  03,8DC
12D72:  MOVFF  02,8DB
12D76:  MOVFF  01,8DA
12D7A:  MOVFF  00,8D9
12D7E:  MOVLB  8
12D80:  CLRF   xE0
12D82:  CLRF   xDF
12D84:  MOVLW  20
12D86:  MOVWF  xDE
12D88:  MOVLW  82
12D8A:  MOVWF  xDD
12D8C:  MOVLB  0
12D8E:  BRA    12992
12D90:  MOVFF  03,900
12D94:  MOVFF  02,8FF
12D98:  MOVFF  01,8FE
12D9C:  MOVFF  00,8FD
12DA0:  CALL   1259E
12DA4:  MOVFF  01,8D2
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
12DA8:  MOVLB  8
12DAA:  DECFSZ xD2,W
12DAC:  BRA    12DB0
12DAE:  BRA    12DB6
12DB0:  MOVF   xD2,W
12DB2:  SUBLW  03
12DB4:  BNZ   12DD4
....................    { 
....................       clear_proc_time_stmp_str(); 
12DB6:  MOVLB  0
12DB8:  BRA    12AFA
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
12DBA:  MOVLW  02
12DBC:  MOVWF  FEA
12DBE:  MOVLW  B3
12DC0:  MOVWF  FE9
12DC2:  MOVLW  02
12DC4:  MOVWF  FE2
12DC6:  MOVLW  95
12DC8:  MOVWF  FE1
12DCA:  MOVF   FE7,F
12DCC:  MOVFF  FE6,FEE
12DD0:  BNZ   12DCA
12DD2:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
12DD4:  MOVLB  0
12DD6:  CALL   F6A8
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12DDA:  MOVLB  8
12DDC:  CLRF   xD6
12DDE:  MOVLW  63
12DE0:  MOVWF  xD5
12DE2:  MOVLB  0
12DE4:  RCALL  12B12
12DE6:  MOVFF  02,03
12DEA:  MOVF   01,W
12DEC:  XORLW  FF
12DEE:  ADDLW  A1
12DF0:  MOVLB  8
12DF2:  MOVWF  xD5
12DF4:  MOVLW  00
12DF6:  SUBFWB 02,W
12DF8:  MOVWF  xD6
12DFA:  MOVLW  01
12DFC:  SUBWF  xD5,F
12DFE:  MOVLW  00
12E00:  SUBWFB xD6,F
12E02:  CLRF   xD8
12E04:  MOVLW  63
12E06:  MOVWF  xD7
12E08:  MOVLW  03
12E0A:  MOVWF  xDA
12E0C:  MOVLW  21
12E0E:  MOVWF  xD9
12E10:  MOVFF  8D6,8DC
12E14:  MOVFF  8D5,8DB
12E18:  MOVLB  0
12E1A:  RCALL  12B4E
....................    strcat(data_buffer, (char *)","); 
12E1C:  MOVLW  2C
12E1E:  MOVLB  8
12E20:  MOVWF  xD3
12E22:  CLRF   xD4
12E24:  CLRF   xE3
12E26:  MOVLW  63
12E28:  MOVWF  xE2
12E2A:  MOVLW  08
12E2C:  MOVWF  xE5
12E2E:  MOVLW  D3
12E30:  MOVWF  xE4
12E32:  MOVLB  0
12E34:  CALL   5528
....................     
....................    cmd = 'S'; 
12E38:  MOVLW  53
12E3A:  MOVWF  43
....................    arg = 1; 
12E3C:  CLRF   47
12E3E:  CLRF   46
12E40:  CLRF   45
12E42:  MOVLW  01
12E44:  MOVWF  44
....................  
....................    for(i = 0; i < 6; i++) 
12E46:  MOVLB  8
12E48:  CLRF   xD0
12E4A:  MOVF   xD0,W
12E4C:  SUBLW  05
12E4E:  BNC   12E66
....................    { 
....................       rcvdData = get_slave_data(); 
12E50:  MOVLB  0
12E52:  BRA    12BEC
12E54:  MOVFF  01,8CF
....................       if (DATA_COMPLETE == rcvdData) 
12E58:  MOVLB  8
12E5A:  MOVF   xCF,W
12E5C:  SUBLW  02
12E5E:  BNZ   12E62
....................       { 
....................          break; 
12E60:  BRA    12E66
....................       } 
12E62:  INCF   xD0,F
12E64:  BRA    12E4A
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12E66:  CLRF   xD6
12E68:  MOVLW  63
12E6A:  MOVWF  xD5
12E6C:  MOVLB  0
12E6E:  RCALL  12B12
12E70:  MOVFF  02,03
12E74:  MOVF   01,W
12E76:  XORLW  FF
12E78:  ADDLW  A1
12E7A:  MOVLB  8
12E7C:  MOVWF  xD5
12E7E:  MOVLW  00
12E80:  SUBFWB 02,W
12E82:  MOVWF  xD6
12E84:  MOVLW  01
12E86:  SUBWF  xD5,F
12E88:  MOVLW  00
12E8A:  SUBWFB xD6,F
12E8C:  CLRF   xD8
12E8E:  MOVLW  63
12E90:  MOVWF  xD7
12E92:  MOVLW  02
12E94:  MOVWF  xDA
12E96:  MOVLW  43
12E98:  MOVWF  xD9
12E9A:  MOVFF  8D6,8DC
12E9E:  MOVFF  8D5,8DB
12EA2:  MOVLB  0
12EA4:  RCALL  12B4E
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
12EA6:  MOVLW  02
12EA8:  MOVLB  8
12EAA:  MOVWF  xD6
12EAC:  MOVLW  43
12EAE:  MOVWF  xD5
12EB0:  MOVLB  0
12EB2:  RCALL  12B12
12EB4:  MOVFF  01,8D1
....................    if (rec_len > 0 && rec_len < 12) 
12EB8:  MOVLB  8
12EBA:  MOVF   xD1,F
12EBC:  BZ    12ECA
12EBE:  MOVF   xD1,W
12EC0:  SUBLW  0B
12EC2:  BNC   12ECA
....................    { 
....................       rcvdData = SHORT_DATA; 
12EC4:  MOVLW  04
12EC6:  MOVWF  xCF
....................    } 
12EC8:  BRA    12ED4
....................    else 
....................    { 
....................       if (rec_len > 30) 
12ECA:  MOVF   xD1,W
12ECC:  SUBLW  1E
12ECE:  BC    12ED4
....................       { 
....................          rcvdData = LONG_DATA; 
12ED0:  MOVLW  05
12ED2:  MOVWF  xCF
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
12ED4:  MOVLW  02
12ED6:  SUBWF  xCF,W
12ED8:  ADDLW  FC
12EDA:  BC    12F46
12EDC:  ADDLW  04
12EDE:  MOVLB  0
12EE0:  GOTO   130A8
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
12EE4:  MOVLB  8
12EE6:  BRA    12F46
12EE8:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
12EEA:  MOVLW  08
12EEC:  MOVWF  1E
12EEE:  MOVLW  BB
12EF0:  MOVWF  1D
12EF2:  MOVLW  54
12EF4:  MOVWF  FF6
12EF6:  MOVLW  1C
12EF8:  MOVWF  FF7
12EFA:  MOVLW  00
12EFC:  MOVWF  FF8
12EFE:  CALL   5108
....................          break; 
12F02:  MOVLB  8
12F04:  BRA    12F46
12F06:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
12F08:  MOVLW  08
12F0A:  MOVWF  1E
12F0C:  MOVLW  BB
12F0E:  MOVWF  1D
12F10:  MOVLW  5E
12F12:  MOVWF  FF6
12F14:  MOVLW  1C
12F16:  MOVWF  FF7
12F18:  MOVLW  00
12F1A:  MOVWF  FF8
12F1C:  CALL   5108
....................          break; 
12F20:  MOVLB  8
12F22:  BRA    12F46
12F24:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
12F26:  MOVLW  08
12F28:  MOVWF  1E
12F2A:  MOVLW  BB
12F2C:  MOVWF  1D
12F2E:  MOVLW  6E
12F30:  MOVWF  FF6
12F32:  MOVLW  1C
12F34:  MOVWF  FF7
12F36:  MOVLW  00
12F38:  MOVWF  FF8
12F3A:  CALL   5108
....................          break; 
12F3E:  MOVLB  8
12F40:  BRA    12F46
12F42:  MOVLB  0
12F44:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12F46:  CLRF   xD6
12F48:  MOVLW  63
12F4A:  MOVWF  xD5
12F4C:  MOVLB  0
12F4E:  RCALL  12B12
12F50:  MOVFF  02,03
12F54:  MOVF   01,W
12F56:  XORLW  FF
12F58:  ADDLW  A1
12F5A:  MOVLB  8
12F5C:  MOVWF  xD5
12F5E:  MOVLW  00
12F60:  SUBFWB 02,W
12F62:  MOVWF  xD6
12F64:  MOVLW  01
12F66:  SUBWF  xD5,F
12F68:  MOVLW  00
12F6A:  SUBWFB xD6,F
12F6C:  CLRF   xD8
12F6E:  MOVLW  63
12F70:  MOVWF  xD7
12F72:  MOVLW  08
12F74:  MOVWF  xDA
12F76:  MOVLW  BB
12F78:  MOVWF  xD9
12F7A:  MOVFF  8D6,8DC
12F7E:  MOVFF  8D5,8DB
12F82:  MOVLB  0
12F84:  RCALL  12B4E
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
12F86:  MOVLB  8
12F88:  CLRF   xD6
12F8A:  MOVLW  63
12F8C:  MOVWF  xD5
12F8E:  MOVLB  0
12F90:  RCALL  12B12
12F92:  MOVFF  02,03
12F96:  MOVF   01,W
12F98:  XORLW  FF
12F9A:  ADDLW  A1
12F9C:  MOVLB  8
12F9E:  MOVWF  xD5
12FA0:  MOVLW  00
12FA2:  SUBFWB 02,W
12FA4:  MOVWF  xD6
12FA6:  MOVLW  01
12FA8:  SUBWF  xD5,F
12FAA:  MOVLW  00
12FAC:  SUBWFB xD6,F
12FAE:  CLRF   xD8
12FB0:  MOVLW  63
12FB2:  MOVWF  xD7
12FB4:  MOVLW  08
12FB6:  MOVWF  xDA
12FB8:  MOVLW  B8
12FBA:  MOVWF  xD9
12FBC:  MOVFF  8D6,8DC
12FC0:  MOVFF  8D5,8DB
12FC4:  MOVLB  0
12FC6:  RCALL  12B4E
....................  
....................    if(DATA_COMPLETE != rcvdData) 
12FC8:  MOVLB  8
12FCA:  MOVF   xCF,W
12FCC:  SUBLW  02
12FCE:  BZ    1308A
....................    {    //housekeeping 
....................       time_stamp(); 
12FD0:  MOVLB  0
12FD2:  CALL   5464
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
12FD6:  MOVLW  01
12FD8:  MOVWF  1E
12FDA:  MOVLW  A3
12FDC:  MOVWF  1D
12FDE:  MOVLW  7E
12FE0:  MOVWF  FF6
12FE2:  MOVLW  1C
12FE4:  MOVWF  FF7
12FE6:  MOVLW  00
12FE8:  MOVWF  FF8
12FEA:  MOVLW  0A
12FEC:  MOVLB  8
12FEE:  MOVWF  xD5
12FF0:  MOVLB  0
12FF2:  CALL   AAF6
12FF6:  MOVFF  1E,FEA
12FFA:  MOVFF  1D,FE9
12FFE:  CLRF   FEF
13000:  MOVLW  08
13002:  MOVWF  FEA
13004:  MOVLW  BB
13006:  MOVWF  FE9
13008:  CALL   FBB0
1300C:  MOVLW  8A
1300E:  MOVWF  FF6
13010:  MOVLW  1C
13012:  MOVWF  FF7
13014:  MOVLW  00
13016:  MOVWF  FF8
13018:  MOVLW  06
1301A:  MOVLB  8
1301C:  MOVWF  xD5
1301E:  MOVLB  0
13020:  CALL   AAF6
13024:  MOVFF  8D1,8D7
13028:  MOVLW  1B
1302A:  MOVLB  8
1302C:  MOVWF  xD8
1302E:  MOVLB  0
13030:  CALL   52CA
13034:  MOVLW  5D
13036:  MOVLB  8
13038:  MOVWF  xE9
1303A:  MOVLB  0
1303C:  CALL   50E8
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
13040:  MOVLW  01
13042:  MOVLB  8
13044:  MOVWF  xD6
13046:  MOVLW  A3
13048:  MOVWF  xD5
1304A:  MOVLB  0
1304C:  RCALL  12B12
1304E:  MOVFF  02,03
13052:  MOVF   01,W
13054:  XORLW  FF
13056:  ADDLW  A1
13058:  MOVLB  8
1305A:  MOVWF  xD5
1305C:  MOVLW  00
1305E:  SUBFWB 02,W
13060:  MOVWF  xD6
13062:  MOVLW  01
13064:  SUBWF  xD5,F
13066:  MOVLW  00
13068:  SUBWFB xD6,F
1306A:  MOVLW  01
1306C:  MOVWF  xD8
1306E:  MOVLW  A3
13070:  MOVWF  xD7
13072:  CLRF   xDA
13074:  MOVLW  63
13076:  MOVWF  xD9
13078:  MOVFF  8D6,8DC
1307C:  MOVFF  8D5,8DB
13080:  MOVLB  0
13082:  RCALL  12B4E
....................       record_event(); 
13084:  CALL   850C
13088:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
1308A:  MOVFF  8B6,8D5
1308E:  MOVFF  8B7,8D6
13092:  MOVLB  0
13094:  CALL   FCDE
....................  
....................    return (rcvdData); 
13098:  CLRF   03
1309A:  MOVLB  8
1309C:  MOVFF  8CF,01
130A0:  MOVFF  03,02
130A4:  MOVLB  0
130A6:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
134CC:  MOVLB  8
134CE:  CLRF   xAE
134D0:  MOVF   xAE,W
134D2:  SUBLW  02
134D4:  BTFSS  FD8.0
134D6:  BRA    135EC
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
134D8:  MOVFF  8AC,8B6
134DC:  MOVFF  8AD,8B7
134E0:  MOVLB  0
134E2:  CALL   12CDC
134E6:  MOVFF  02,03
134EA:  MOVF   01,W
134EC:  SUBLW  02
134EE:  BNZ   134FC
134F0:  MOVF   03,F
134F2:  BNZ   134FC
....................       { 
....................          break; 
134F4:  MOVLB  8
134F6:  BRA    135EC
....................       } 
134F8:  BRA    135E8
134FA:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
134FC:  MOVLW  01
134FE:  MOVLB  8
13500:  ADDWF  xAE,W
13502:  MOVWF  xAF
13504:  MOVLW  94
13506:  MOVWF  FF6
13508:  MOVLW  1C
1350A:  MOVWF  FF7
1350C:  MOVLW  00
1350E:  MOVWF  FF8
13510:  CLRF   1B
13512:  BTFSC  FF2.7
13514:  BSF    1B.7
13516:  BCF    FF2.7
13518:  MOVLW  05
1351A:  MOVLB  A
1351C:  MOVWF  x25
1351E:  MOVLB  0
13520:  CALL   1010
13524:  BTFSC  1B.7
13526:  BSF    FF2.7
13528:  CLRF   1B
1352A:  BTFSC  FF2.7
1352C:  BSF    1B.7
1352E:  BCF    FF2.7
13530:  MOVFF  8AF,A25
13534:  MOVLW  1B
13536:  MOVLB  A
13538:  MOVWF  x26
1353A:  MOVLB  0
1353C:  CALL   0F92
13540:  BTFSC  1B.7
13542:  BSF    FF2.7
13544:  MOVLW  0D
13546:  BTFSS  F9E.4
13548:  BRA    13546
1354A:  MOVWF  FAD
1354C:  MOVLW  0A
1354E:  BTFSS  F9E.4
13550:  BRA    1354E
13552:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
13554:  BCF    F90.7
....................          delay_ms(1000); 
13556:  MOVLW  04
13558:  MOVLB  8
1355A:  MOVWF  xAF
1355C:  MOVLW  FA
1355E:  MOVLB  9
13560:  MOVWF  xD6
13562:  MOVLB  0
13564:  CALL   2964
13568:  MOVLB  8
1356A:  DECFSZ xAF,F
1356C:  BRA    1355C
....................          output_bit(VDET,ON); 
1356E:  BSF    F90.7
....................          delay_ms(1000); 
13570:  MOVLW  04
13572:  MOVWF  xAF
13574:  MOVLW  FA
13576:  MOVLB  9
13578:  MOVWF  xD6
1357A:  MOVLB  0
1357C:  CALL   2964
13580:  MOVLB  8
13582:  DECFSZ xAF,F
13584:  BRA    13574
....................          if (LightTargetFlag==0) 
13586:  MOVLB  2
13588:  MOVF   xD5,F
1358A:  BNZ   135D2
....................          { 
....................           cmd='K'; 
1358C:  MOVLW  4B
1358E:  MOVWF  43
....................           arg=detector_ch; 
13590:  CLRF   47
13592:  CLRF   46
13594:  CLRF   45
13596:  MOVFF  2D2,44
....................           det_cmd(); 
1359A:  MOVLB  0
1359C:  CALL   F176
....................           delay_ms(1000); 
135A0:  MOVLW  04
135A2:  MOVLB  8
135A4:  MOVWF  xAF
135A6:  MOVLW  FA
135A8:  MOVLB  9
135AA:  MOVWF  xD6
135AC:  MOVLB  0
135AE:  CALL   2964
135B2:  MOVLB  8
135B4:  DECFSZ xAF,F
135B6:  BRA    135A6
....................           cmd='L'; 
135B8:  MOVLW  4C
135BA:  MOVWF  43
....................           arg=detector_li; 
135BC:  CLRF   47
135BE:  CLRF   46
135C0:  MOVFF  2D4,45
135C4:  MOVFF  2D3,44
....................           det_cmd(); 
135C8:  MOVLB  0
135CA:  CALL   F176
....................          }  
135CE:  BRA    135E6
135D0:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
135D2:  MOVLW  6C
135D4:  MOVWF  43
....................           arg=1; 
135D6:  CLRF   47
135D8:  CLRF   46
135DA:  CLRF   45
135DC:  MOVLW  01
135DE:  MOVWF  44
....................           det_cmd(); 
135E0:  MOVLB  0
135E2:  CALL   F176
135E6:  MOVLB  8
....................          }  
....................       } 
135E8:  INCF   xAE,F
135EA:  BRA    134D0
....................    } 
....................  
....................    parse_data(); 
135EC:  MOVLB  0
135EE:  RCALL  1344A
....................    data_available = TRUE; 
135F0:  MOVLW  01
135F2:  MOVLB  3
135F4:  MOVWF  x37
....................    macro_flag = 900; 
135F6:  MOVLW  03
135F8:  MOVWF  x20
135FA:  MOVLW  84
135FC:  MOVWF  x1F
....................  
....................    return; 
135FE:  MOVLB  0
13600:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
1396C:  MOVLB  8
1396E:  CLRF   xB7
13970:  CLRF   xB6
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
13972:  MOVLB  0
13974:  RCALL  1344A
13976:  MOVFF  02,8B7
1397A:  MOVFF  01,8B6
....................    return (temp); 
1397E:  MOVLB  8
13980:  MOVFF  8B6,01
13984:  MOVFF  8B7,02
13988:  MOVLB  0
1398A:  GOTO   13A9C (RETURN)
.................... } 
....................  
.................... void det_temp() 
1398E:  MOVLB  8
13990:  CLRF   xB3
13992:  CLRF   xB2
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
13994:  MOVLB  2
13996:  MOVF   xD1,W
13998:  XORLW  01
1399A:  MOVLB  0
1399C:  BZ    139A4
1399E:  XORLW  03
139A0:  BZ    139AE
139A2:  BRA    139B8
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
139A4:  MOVFF  3E,8B5
139A8:  MOVFF  3D,8B4
....................          break; 
139AC:  BRA    139C4
....................       case 2 : target_temp = nv_d2_temp; 
139AE:  MOVFF  40,8B5
139B2:  MOVFF  3F,8B4
....................          break; 
139B6:  BRA    139C4
....................       default : target_temp = 20000; 
139B8:  MOVLW  4E
139BA:  MOVLB  8
139BC:  MOVWF  xB5
139BE:  MOVLW  20
139C0:  MOVWF  xB4
....................          break; 
139C2:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
139C4:  MOVLB  8
139C6:  CLRF   xB1
139C8:  MOVLW  3C
139CA:  MOVWF  xB0
....................    n = 0; 
139CC:  CLRF   xAF
139CE:  CLRF   xAE
....................    store=FALSE; 
139D0:  CLRF   xAC
....................    display=FALSE; 
139D2:  CLRF   xAD
....................  
....................    time_stamp(); 
139D4:  MOVLB  0
139D6:  CALL   5464
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
139DA:  MOVLW  01
139DC:  MOVWF  1E
139DE:  MOVLW  A3
139E0:  MOVWF  1D
139E2:  MOVLW  9E
139E4:  MOVWF  FF6
139E6:  MOVLW  1C
139E8:  MOVWF  FF7
139EA:  MOVLW  00
139EC:  MOVWF  FF8
139EE:  MOVLW  16
139F0:  MOVLB  8
139F2:  MOVWF  xD5
139F4:  MOVLB  0
139F6:  CALL   AAF6
139FA:  MOVLW  10
139FC:  MOVWF  FE9
139FE:  MOVFF  8B5,8E1
13A02:  MOVFF  8B4,8E0
13A06:  CALL   AB28
13A0A:  MOVLW  B7
13A0C:  MOVWF  FF6
13A0E:  MOVLW  1C
13A10:  MOVWF  FF7
13A12:  MOVLW  00
13A14:  MOVWF  FF8
13A16:  MOVLW  09
13A18:  MOVLB  8
13A1A:  MOVWF  xD5
13A1C:  MOVLB  0
13A1E:  CALL   AAF6
13A22:  MOVLW  10
13A24:  MOVWF  FE9
13A26:  MOVFF  8B3,8E1
13A2A:  MOVFF  8B2,8E0
13A2E:  CALL   AB28
13A32:  MOVLW  C3
13A34:  MOVWF  FF6
13A36:  MOVLW  1C
13A38:  MOVWF  FF7
13A3A:  MOVLW  00
13A3C:  MOVWF  FF8
13A3E:  MOVLW  0B
13A40:  MOVLB  8
13A42:  MOVWF  xD5
13A44:  MOVLB  0
13A46:  CALL   AAF6
13A4A:  MOVLW  10
13A4C:  MOVWF  FE9
13A4E:  MOVFF  8AF,8E1
13A52:  MOVFF  8AE,8E0
13A56:  CALL   AB28
13A5A:  MOVLW  D1
13A5C:  MOVWF  FF6
13A5E:  MOVLW  1C
13A60:  MOVWF  FF7
13A62:  MOVLW  00
13A64:  MOVWF  FF8
13A66:  MOVLW  03
13A68:  MOVLB  8
13A6A:  MOVWF  xD5
13A6C:  MOVLB  0
13A6E:  CALL   AAF6
....................    record_event(); 
13A72:  CALL   850C
....................  
....................    for (n=1; n<t; ++n) 
13A76:  MOVLB  8
13A78:  CLRF   xAF
13A7A:  MOVLW  01
13A7C:  MOVWF  xAE
13A7E:  MOVF   xAF,W
13A80:  SUBWF  xB1,W
13A82:  BNC   13ADE
13A84:  BNZ   13A8C
13A86:  MOVF   xB0,W
13A88:  SUBWF  xAE,W
13A8A:  BC    13ADE
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
13A8C:  MOVFF  8AC,8B6
13A90:  MOVFF  8AD,8B7
13A94:  MOVLB  0
13A96:  CALL   12CDC
....................       current_temp=parse_temp(); 
13A9A:  BRA    1396C
13A9C:  MOVFF  02,8B3
13AA0:  MOVFF  01,8B2
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
13AA4:  MOVLB  8
13AA6:  MOVF   xB5,W
13AA8:  SUBWF  xB3,W
13AAA:  BNC   13AB4
13AAC:  BNZ   13ABC
13AAE:  MOVF   xB4,W
13AB0:  SUBWF  xB2,W
13AB2:  BC    13ABC
13AB4:  MOVF   xB2,F
13AB6:  BNZ   13AC0
13AB8:  MOVF   xB3,F
13ABA:  BNZ   13AC0
13ABC:  BRA    13ADE
13ABE:  BRA    13AD6
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13AC0:  MOVLW  0A
13AC2:  MOVWF  xB6
13AC4:  MOVLW  FA
13AC6:  MOVLB  9
13AC8:  MOVWF  xD6
13ACA:  MOVLB  0
13ACC:  CALL   2964
13AD0:  MOVLB  8
13AD2:  DECFSZ xB6,F
13AD4:  BRA    13AC4
13AD6:  INCF   xAE,F
13AD8:  BTFSC  FD8.2
13ADA:  INCF   xAF,F
13ADC:  BRA    13A7E
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13ADE:  MOVLW  01
13AE0:  MOVWF  1E
13AE2:  MOVLW  A3
13AE4:  MOVWF  1D
13AE6:  MOVLW  D6
13AE8:  MOVWF  FF6
13AEA:  MOVLW  1C
13AEC:  MOVWF  FF7
13AEE:  MOVLW  00
13AF0:  MOVWF  FF8
13AF2:  MOVLW  14
13AF4:  MOVWF  xD5
13AF6:  MOVLB  0
13AF8:  CALL   AAF6
13AFC:  MOVLW  10
13AFE:  MOVWF  FE9
13B00:  MOVFF  8B5,8E1
13B04:  MOVFF  8B4,8E0
13B08:  CALL   AB28
13B0C:  MOVLW  ED
13B0E:  MOVWF  FF6
13B10:  MOVLW  1C
13B12:  MOVWF  FF7
13B14:  MOVLW  00
13B16:  MOVWF  FF8
13B18:  MOVLW  09
13B1A:  MOVLB  8
13B1C:  MOVWF  xD5
13B1E:  MOVLB  0
13B20:  CALL   AAF6
13B24:  MOVLW  10
13B26:  MOVWF  FE9
13B28:  MOVFF  8B3,8E1
13B2C:  MOVFF  8B2,8E0
13B30:  CALL   AB28
13B34:  MOVLW  F9
13B36:  MOVWF  FF6
13B38:  MOVLW  1C
13B3A:  MOVWF  FF7
13B3C:  MOVLW  00
13B3E:  MOVWF  FF8
13B40:  MOVLW  0B
13B42:  MOVLB  8
13B44:  MOVWF  xD5
13B46:  MOVLB  0
13B48:  CALL   AAF6
13B4C:  MOVLW  10
13B4E:  MOVWF  FE9
13B50:  MOVFF  8AF,8E1
13B54:  MOVFF  8AE,8E0
13B58:  CALL   AB28
13B5C:  MOVLW  07
13B5E:  MOVWF  FF6
13B60:  MOVLW  1D
13B62:  MOVWF  FF7
13B64:  MOVLW  00
13B66:  MOVWF  FF8
13B68:  MOVLW  03
13B6A:  MOVLB  8
13B6C:  MOVWF  xD5
13B6E:  MOVLB  0
13B70:  CALL   AAF6
....................    record_event();    
13B74:  CALL   850C
13B78:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
13644:  MOVLB  8
13646:  CLRF   xBF
13648:  CLRF   xBE
1364A:  CLRF   xBD
1364C:  CLRF   xBC
....................    set_adc_channel(1,VSS); 
1364E:  MOVLW  04
13650:  MOVWF  01
13652:  MOVF   FC2,W
13654:  ANDLW  83
13656:  IORWF  01,W
13658:  MOVWF  FC2
1365A:  MOVLW  00
1365C:  MOVWF  01
1365E:  MOVF   FC1,W
13660:  ANDLW  F8
13662:  IORWF  01,W
13664:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
13666:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
13668:  MOVLW  01
1366A:  MOVWF  xB9
1366C:  MOVF   xB9,W
1366E:  SUBLW  32
13670:  BNC   13696
....................       reading=read_adc(); 
13672:  BSF    FC2.1
13674:  BTFSC  FC2.1
13676:  BRA    13674
13678:  MOVFF  FC3,8C0
1367C:  MOVFF  FC4,8C1
13680:  CLRF   xC2
13682:  CLRF   xC3
....................       delay_ms(5); 
13684:  MOVLW  05
13686:  MOVLB  9
13688:  MOVWF  xD6
1368A:  MOVLB  0
1368C:  CALL   2964
13690:  MOVLB  8
13692:  INCF   xB9,F
13694:  BRA    1366C
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
13696:  MOVLW  01
13698:  MOVWF  xB9
1369A:  MOVF   xB9,W
1369C:  SUBLW  64
1369E:  BNC   1374C
....................       reading=read_adc(); 
136A0:  BSF    FC2.1
136A2:  BTFSC  FC2.1
136A4:  BRA    136A2
136A6:  MOVFF  FC3,8C0
136AA:  MOVFF  FC4,8C1
136AE:  CLRF   xC2
136B0:  CLRF   xC3
....................       result=(((result*(i-1))+reading)/i); 
136B2:  MOVLW  01
136B4:  SUBWF  xB9,W
136B6:  MOVWF  xC4
136B8:  MOVFF  8BF,9E3
136BC:  MOVFF  8BE,9E2
136C0:  MOVFF  8BD,9E1
136C4:  MOVFF  8BC,9E0
136C8:  MOVLB  9
136CA:  CLRF   xE7
136CC:  CLRF   xE6
136CE:  CLRF   xE5
136D0:  MOVWF  xE4
136D2:  MOVLB  0
136D4:  CALL   4844
136D8:  MOVFF  03,8C7
136DC:  MOVFF  02,8C6
136E0:  MOVFF  01,8C5
136E4:  MOVFF  00,8C4
136E8:  MOVLB  8
136EA:  MOVF   xC0,W
136EC:  ADDWF  xC4,F
136EE:  MOVF   xC1,W
136F0:  ADDWFC xC5,F
136F2:  MOVF   xC2,W
136F4:  ADDWFC xC6,F
136F6:  MOVF   xC3,W
136F8:  ADDWFC xC7,F
136FA:  BCF    FD8.1
136FC:  CLRF   1B
136FE:  BTFSC  FF2.7
13700:  BSF    1B.7
13702:  BCF    FF2.7
13704:  MOVFF  8C7,A34
13708:  MOVFF  8C6,A33
1370C:  MOVFF  8C5,A32
13710:  MOVFF  8C4,A31
13714:  MOVLB  A
13716:  CLRF   x38
13718:  CLRF   x37
1371A:  CLRF   x36
1371C:  MOVFF  8B9,A35
13720:  MOVLB  0
13722:  CALL   1042
13726:  BTFSC  1B.7
13728:  BSF    FF2.7
1372A:  MOVFF  03,8BF
1372E:  MOVFF  02,8BE
13732:  MOVFF  01,8BD
13736:  MOVFF  00,8BC
....................       delay_ms(5); 
1373A:  MOVLW  05
1373C:  MOVLB  9
1373E:  MOVWF  xD6
13740:  MOVLB  0
13742:  CALL   2964
13746:  MOVLB  8
13748:  INCF   xB9,F
1374A:  BRA    1369A
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
1374C:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
1374E:  MOVFF  8BF,9E3
13752:  MOVFF  8BE,9E2
13756:  MOVFF  8BD,9E1
1375A:  MOVFF  8BC,9E0
1375E:  MOVLB  9
13760:  CLRF   xE7
13762:  CLRF   xE6
13764:  MOVLW  10
13766:  MOVWF  xE5
13768:  MOVLW  25
1376A:  MOVWF  xE4
1376C:  MOVLB  0
1376E:  CALL   4844
13772:  MOVFF  03,8C7
13776:  MOVFF  02,8C6
1377A:  MOVFF  01,8C5
1377E:  MOVFF  00,8C4
13782:  BCF    FD8.1
13784:  CLRF   1B
13786:  BTFSC  FF2.7
13788:  BSF    1B.7
1378A:  BCF    FF2.7
1378C:  MOVFF  03,A34
13790:  MOVFF  02,A33
13794:  MOVFF  01,A32
13798:  MOVFF  00,A31
1379C:  MOVLB  A
1379E:  CLRF   x38
137A0:  CLRF   x37
137A2:  CLRF   x36
137A4:  MOVLW  64
137A6:  MOVWF  x35
137A8:  MOVLB  0
137AA:  CALL   1042
137AE:  BTFSC  1B.7
137B0:  BSF    FF2.7
137B2:  MOVLW  21
137B4:  MOVLB  8
137B6:  SUBWF  00,W
137B8:  MOVWF  xBA
137BA:  MOVLW  50
137BC:  SUBWFB 01,W
137BE:  MOVWF  xBB
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
137C0:  MOVFF  8BA,01
137C4:  MOVFF  8BB,02
137C8:  MOVLB  0
137CA:  GOTO   13830 (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
137DA:  CLRF   xB2
137DC:  CLRF   xB1
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
137CE:  MOVLW  0D
137D0:  MOVLB  8
137D2:  MOVWF  xAE
137D4:  MOVLW  0A
137D6:  MOVWF  xAF
137D8:  CLRF   xB0
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
137DE:  MOVLB  0
137E0:  CALL   FFEA
....................    clear_data_buffer(); 
137E4:  CALL   D2A0
....................  
....................    time_stamp(); 
137E8:  CALL   5464
....................    strcpy(data_buffer, time_stmp_str); 
137EC:  CLRF   FEA
137EE:  MOVLW  63
137F0:  MOVWF  FE9
137F2:  MOVLW  02
137F4:  MOVWF  FE2
137F6:  MOVLW  95
137F8:  MOVWF  FE1
137FA:  MOVF   FE7,F
137FC:  MOVFF  FE6,FEE
13800:  BNZ   137FA
....................    strcat(data_buffer, (char *)",Tmp,"); 
13802:  MOVLW  2C
13804:  MOVLB  8
13806:  MOVWF  xB3
13808:  MOVLW  54
1380A:  MOVWF  xB4
1380C:  MOVLW  6D
1380E:  MOVWF  xB5
13810:  MOVLW  70
13812:  MOVWF  xB6
13814:  MOVLW  2C
13816:  MOVWF  xB7
13818:  CLRF   xB8
1381A:  CLRF   xE3
1381C:  MOVLW  63
1381E:  MOVWF  xE2
13820:  MOVLW  08
13822:  MOVWF  xE5
13824:  MOVLW  B3
13826:  MOVWF  xE4
13828:  MOVLB  0
1382A:  CALL   5528
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
1382E:  BRA    13644
13830:  MOVFF  02,8B2
13834:  MOVFF  01,8B1
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
13838:  MOVLW  02
1383A:  MOVWF  1E
1383C:  MOVLW  43
1383E:  MOVWF  1D
13840:  MOVLW  45
13842:  MOVWF  FE9
13844:  MOVLB  8
13846:  CLRF   xDA
13848:  CLRF   xD9
1384A:  MOVFF  8B2,8D8
1384E:  MOVFF  8B1,8D7
13852:  MOVLW  03
13854:  MOVWF  xDB
13856:  MOVLB  0
13858:  CALL   5364
....................  
....................    strcat(slave_reply, endofline); 
1385C:  MOVLW  02
1385E:  MOVLB  8
13860:  MOVWF  xE3
13862:  MOVLW  43
13864:  MOVWF  xE2
13866:  MOVLW  08
13868:  MOVWF  xE5
1386A:  MOVLW  AE
1386C:  MOVWF  xE4
1386E:  MOVLB  0
13870:  CALL   5528
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13874:  MOVLB  8
13876:  CLRF   xD6
13878:  MOVLW  63
1387A:  MOVWF  xD5
1387C:  MOVLB  0
1387E:  CALL   12B12
13882:  MOVFF  02,03
13886:  MOVF   01,W
13888:  XORLW  FF
1388A:  ADDLW  A1
1388C:  MOVLB  8
1388E:  MOVWF  xB9
13890:  MOVLW  00
13892:  SUBFWB 02,W
13894:  MOVWF  xBA
13896:  MOVLW  01
13898:  SUBWF  xB9,F
1389A:  MOVLW  00
1389C:  SUBWFB xBA,F
1389E:  CLRF   xD8
138A0:  MOVLW  63
138A2:  MOVWF  xD7
138A4:  MOVLW  02
138A6:  MOVWF  xDA
138A8:  MOVLW  43
138AA:  MOVWF  xD9
138AC:  MOVFF  8BA,8DC
138B0:  MOVFF  8B9,8DB
138B4:  MOVLB  0
138B6:  CALL   12B4E
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
138BA:  MOVF   1F,F
138BC:  BNZ   138DC
138BE:  MOVF   20,F
138C0:  BNZ   138DC
138C2:  MOVLB  8
138C4:  DECFSZ xAD,W
138C6:  BRA    138CA
138C8:  BRA    138CE
138CA:  MOVLB  0
138CC:  BRA    138DC
138CE:  CLRF   FEA
138D0:  MOVLW  63
138D2:  MOVWF  FE9
138D4:  MOVLB  0
138D6:  CALL   79CE
138DA:  BRA    138F0
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
138DC:  MOVF   20,F
138DE:  BNZ   138E6
138E0:  MOVF   1F,W
138E2:  SUBLW  03
138E4:  BC    138F0
138E6:  CLRF   FEA
138E8:  MOVLW  63
138EA:  MOVWF  FE9
138EC:  CALL   79CE
....................  
....................    if (store == TRUE && sd_status==0) { 
138F0:  MOVLB  8
138F2:  DECFSZ xAC,W
138F4:  BRA    13954
138F6:  MOVLB  2
138F8:  MOVF   xD8,F
138FA:  BTFSC  FD8.2
138FC:  BRA    13902
138FE:  MOVLB  8
13900:  BRA    13954
....................       buffer_select = 0; 
13902:  MOVLB  0
13904:  CLRF   x62
....................       
....................       heartbeat(FALSE); 
13906:  MOVLB  8
13908:  CLRF   xD7
1390A:  MOVLB  0
1390C:  CALL   55CC
....................          append_data(file_ptr_raw_all); 
13910:  MOVLW  02
13912:  MOVLB  8
13914:  MOVWF  xD8
13916:  MOVLW  D9
13918:  MOVWF  xD7
1391A:  MOVLB  0
1391C:  CALL   832A
....................       heartbeat(TRUE); 
13920:  MOVLW  01
13922:  MOVLB  8
13924:  MOVWF  xD7
13926:  MOVLB  0
13928:  CALL   55CC
....................        
....................       heartbeat(FALSE); 
1392C:  MOVLB  8
1392E:  CLRF   xD7
13930:  MOVLB  0
13932:  CALL   55CC
....................          append_data(file_ptr_raw_new); 
13936:  MOVLW  02
13938:  MOVLB  8
1393A:  MOVWF  xD8
1393C:  MOVLW  E7
1393E:  MOVWF  xD7
13940:  MOVLB  0
13942:  CALL   832A
....................       heartbeat(TRUE); 
13946:  MOVLW  01
13948:  MOVLB  8
1394A:  MOVWF  xD7
1394C:  MOVLB  0
1394E:  CALL   55CC
13952:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
13954:  MOVLW  03
13956:  MOVLB  3
13958:  MOVWF  x20
1395A:  MOVLW  84
1395C:  MOVWF  x1F
....................     
....................    return (temp); 
1395E:  MOVLB  8
13960:  MOVFF  8B1,01
13964:  MOVFF  8B2,02
13968:  MOVLB  0
1396A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
124B0:  MOVLB  8
124B2:  MOVF   xAF,W
124B4:  ADDLW  FC
124B6:  BC    124F4
124B8:  ADDLW  04
124BA:  MOVLB  0
124BC:  GOTO   124FC
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
124C0:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
124C2:  BCF    F8C.1
....................          break; 
124C4:  MOVLB  8
124C6:  BRA    124F4
....................       case 1 :  
....................             output_bit(HSW1, ON); 
124C8:  BSF    F8C.0
....................          break; 
124CA:  MOVLB  8
124CC:  BRA    124F4
....................       case 2 :  
....................             output_bit(HSW2, ON); 
124CE:  BSF    F8C.1
....................          break;  
124D0:  MOVLB  8
124D2:  BRA    124F4
....................       case 3 :  
....................             output_bit(HSW1, ON); 
124D4:  BSF    F8C.0
....................             delay_ms(500); 
124D6:  MOVLW  02
124D8:  MOVLB  8
124DA:  MOVWF  xB0
124DC:  MOVLW  FA
124DE:  MOVLB  9
124E0:  MOVWF  xD6
124E2:  MOVLB  0
124E4:  CALL   2964
124E8:  MOVLB  8
124EA:  DECFSZ xB0,F
124EC:  BRA    124DC
....................             output_bit(HSW2, ON); 
124EE:  BSF    F8C.1
....................          break;             
124F0:  BRA    124F4
124F2:  MOVLB  8
....................    } 
....................    heater_stat=set; 
124F4:  MOVFF  8AF,4B1
124F8:  MOVLB  0
124FA:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F59E:  MOVLW  08
0F5A0:  MOVLB  8
0F5A2:  MOVWF  xB6
0F5A4:  CLRF   xB5
....................    LED_level_change=2048; 
0F5A6:  MOVWF  xB8
0F5A8:  CLRF   xB7
....................     
....................    for (i=0; i<12; i++){ 
0F5AA:  CLRF   xB4
0F5AC:  MOVF   xB4,W
0F5AE:  SUBLW  0B
0F5B0:  BNC   F628
....................       DAC_set(1,LED_level); 
0F5B2:  MOVLW  01
0F5B4:  MOVWF  xBD
0F5B6:  MOVFF  8B6,8BF
0F5BA:  MOVFF  8B5,8BE
0F5BE:  MOVLB  0
0F5C0:  RCALL  F2EC
....................       LED_level_change = LED_level_change/2; 
0F5C2:  BCF    FD8.0
0F5C4:  MOVLB  8
0F5C6:  RRCF   xB8,F
0F5C8:  RRCF   xB7,F
....................       ADC_average(200); 
0F5CA:  CLRF   xBE
0F5CC:  MOVLW  C8
0F5CE:  MOVWF  xBD
0F5D0:  MOVLB  0
0F5D2:  RCALL  F394
....................       output = ADC_val[2]; 
0F5D4:  MOVFF  4A6,8BA
0F5D8:  MOVFF  4A5,8B9
....................       temp = ADC_val[3]; 
0F5DC:  MOVFF  4A8,8BC
0F5E0:  MOVFF  4A7,8BB
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F5E4:  MOVLB  8
0F5E6:  MOVF   xB3,W
0F5E8:  SUBWF  xBA,W
0F5EA:  BNC   F5FE
0F5EC:  BNZ   F5F4
0F5EE:  MOVF   xB9,W
0F5F0:  SUBWF  xB2,W
0F5F2:  BC    F5FE
....................          LED_level=LED_level-LED_level_change; 
0F5F4:  MOVF   xB7,W
0F5F6:  SUBWF  xB5,F
0F5F8:  MOVF   xB8,W
0F5FA:  SUBWFB xB6,F
....................       } 
0F5FC:  BRA    F624
....................       else if(output<intensity){ 
0F5FE:  MOVF   xBA,W
0F600:  SUBWF  xB3,W
0F602:  BNC   F616
0F604:  BNZ   F60C
0F606:  MOVF   xB2,W
0F608:  SUBWF  xB9,W
0F60A:  BC    F616
....................          LED_level=LED_level+LED_level_change; 
0F60C:  MOVF   xB7,W
0F60E:  ADDWF  xB5,F
0F610:  MOVF   xB8,W
0F612:  ADDWFC xB6,F
....................       } 
0F614:  BRA    F624
....................       else if(output==intensity) break; 
0F616:  MOVF   xB2,W
0F618:  SUBWF  xB9,W
0F61A:  BNZ   F624
0F61C:  MOVF   xB3,W
0F61E:  SUBWF  xBA,W
0F620:  BTFSC  FD8.2
0F622:  BRA    F628
0F624:  INCF   xB4,F
0F626:  BRA    F5AC
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F628:  MOVLW  01
0F62A:  MOVWF  xBD
0F62C:  MOVFF  8B6,8BF
0F630:  MOVFF  8B5,8BE
0F634:  MOVLB  0
0F636:  RCALL  F2EC
0F638:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F63A:  MOVLW  01
0F63C:  MOVLB  8
0F63E:  MOVWF  xB1
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F640:  MOVF   xAF,F
0F642:  BNZ   F648
0F644:  MOVF   xB0,F
0F646:  BZ    F65C
0F648:  MOVF   xB0,W
0F64A:  SUBLW  0F
0F64C:  BNC   F65C
0F64E:  MOVFF  8B0,8B3
0F652:  MOVFF  8AF,8B2
0F656:  MOVLB  0
0F658:  RCALL  F59E
0F65A:  MOVLB  8
....................   if(intensity == 0) { 
0F65C:  MOVF   xAF,F
0F65E:  BNZ   F682
0F660:  MOVF   xB0,F
0F662:  BNZ   F682
....................       DAC_set(1, 0); 
0F664:  MOVLW  01
0F666:  MOVWF  xBD
0F668:  CLRF   xBF
0F66A:  CLRF   xBE
0F66C:  MOVLB  0
0F66E:  RCALL  F2EC
....................       DAC_set(2, 0); 
0F670:  MOVLW  02
0F672:  MOVLB  8
0F674:  MOVWF  xBD
0F676:  CLRF   xBF
0F678:  CLRF   xBE
0F67A:  MOVLB  0
0F67C:  RCALL  F2EC
....................    } 
0F67E:  BRA    F686
0F680:  MOVLB  8
....................    else valid=FALSE; 
0F682:  CLRF   xB1
0F684:  MOVLB  0
....................    return(valid); 
0F686:  MOVLB  8
0F688:  MOVFF  8B1,01
0F68C:  MOVLB  0
0F68E:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FC10:  MOVLW  0C
0FC12:  MOVWF  FF6
0FC14:  MOVLW  1D
0FC16:  MOVWF  FF7
0FC18:  MOVLW  00
0FC1A:  MOVWF  FF8
0FC1C:  MOVLW  03
0FC1E:  MOVWF  FEA
0FC20:  MOVLW  39
0FC22:  MOVWF  FE9
0FC24:  RCALL  FBD6
0FC26:  MOVF   01,W
0FC28:  BZ    FC3C
0FC2A:  XORLW  01
0FC2C:  BZ    FC5C
0FC2E:  XORLW  03
0FC30:  BZ    FC7C
0FC32:  XORLW  01
0FC34:  BZ    FC9C
0FC36:  XORLW  07
0FC38:  BZ    FCBC
0FC3A:  BRA    FCDA
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FC3C:  BCF    FD8.0
0FC3E:  MOVLB  3
0FC40:  RLCF   x46,W
0FC42:  CLRF   03
0FC44:  ADDLW  47
0FC46:  MOVWF  FE9
0FC48:  MOVLW  03
0FC4A:  ADDWFC 03,W
0FC4C:  MOVWF  FEA
0FC4E:  MOVFF  4A4,FEC
0FC52:  MOVF   FED,F
0FC54:  MOVFF  4A3,FEF
....................          break; 
0FC58:  MOVLB  0
0FC5A:  BRA    FCDA
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FC5C:  BCF    FD8.0
0FC5E:  MOVLB  3
0FC60:  RLCF   x46,W
0FC62:  CLRF   03
0FC64:  ADDLW  59
0FC66:  MOVWF  FE9
0FC68:  MOVLW  03
0FC6A:  ADDWFC 03,W
0FC6C:  MOVWF  FEA
0FC6E:  MOVFF  4A4,FEC
0FC72:  MOVF   FED,F
0FC74:  MOVFF  4A3,FEF
....................          break;    
0FC78:  MOVLB  0
0FC7A:  BRA    FCDA
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FC7C:  BCF    FD8.0
0FC7E:  MOVLB  3
0FC80:  RLCF   x46,W
0FC82:  CLRF   03
0FC84:  ADDLW  6B
0FC86:  MOVWF  FE9
0FC88:  MOVLW  03
0FC8A:  ADDWFC 03,W
0FC8C:  MOVWF  FEA
0FC8E:  MOVFF  4A4,FEC
0FC92:  MOVF   FED,F
0FC94:  MOVFF  4A3,FEF
....................          break; 
0FC98:  MOVLB  0
0FC9A:  BRA    FCDA
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FC9C:  BCF    FD8.0
0FC9E:  MOVLB  3
0FCA0:  RLCF   x46,W
0FCA2:  CLRF   03
0FCA4:  ADDLW  7D
0FCA6:  MOVWF  FE9
0FCA8:  MOVLW  03
0FCAA:  ADDWFC 03,W
0FCAC:  MOVWF  FEA
0FCAE:  MOVFF  4A4,FEC
0FCB2:  MOVF   FED,F
0FCB4:  MOVFF  4A3,FEF
....................          break; 
0FCB8:  MOVLB  0
0FCBA:  BRA    FCDA
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FCBC:  BCF    FD8.0
0FCBE:  MOVLB  3
0FCC0:  RLCF   x46,W
0FCC2:  CLRF   03
0FCC4:  ADDLW  8F
0FCC6:  MOVWF  FE9
0FCC8:  MOVLW  03
0FCCA:  ADDWFC 03,W
0FCCC:  MOVWF  FEA
0FCCE:  MOVFF  4A4,FEC
0FCD2:  MOVF   FED,F
0FCD4:  MOVFF  4A3,FEF
....................          break; 
0FCD8:  MOVLB  0
....................    } 
0FCDA:  GOTO   FFBE (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
0FD7C:  MOVFF  8AD,8BE
0FD80:  MOVFF  8AC,8BD
0FD84:  CALL   F394
....................     
....................    v_supply = read_supply(); 
0FD88:  CALL   5146
0FD8C:  MOVFF  02,8B2
0FD90:  MOVFF  01,8B1
....................        
....................    RTC_reset_HT(); 
0FD94:  CALL   3506
....................    RTC_read(); 
0FD98:  CALL   3398
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
0FD9C:  RCALL  F6A8
0FD9E:  MOVFF  02,8B4
0FDA2:  MOVFF  01,8B3
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
0FDA6:  MOVLB  8
0FDA8:  DECFSZ xB0,W
0FDAA:  BRA    FDD4
0FDAC:  MOVLW  10
0FDAE:  MOVWF  FE9
0FDB0:  CLRF   1B
0FDB2:  BTFSC  FF2.7
0FDB4:  BSF    1B.7
0FDB6:  BCF    FF2.7
0FDB8:  MOVFF  4A6,A26
0FDBC:  MOVFF  4A5,A25
0FDC0:  MOVLB  0
0FDC2:  CALL   1192
0FDC6:  BTFSC  1B.7
0FDC8:  BSF    FF2.7
0FDCA:  MOVLW  2C
0FDCC:  BTFSS  F9E.4
0FDCE:  BRA    FDCC
0FDD0:  MOVWF  FAD
0FDD2:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
0FDD4:  CLRF   1E
0FDD6:  MOVLW  63
0FDD8:  MOVWF  1D
0FDDA:  MOVFF  726,8D7
0FDDE:  MOVLW  01
0FDE0:  MOVWF  xD8
0FDE2:  MOVLB  0
0FDE4:  CALL   52CA
0FDE8:  MOVLW  2F
0FDEA:  MOVLB  8
0FDEC:  MOVWF  xE9
0FDEE:  MOVLB  0
0FDF0:  CALL   50E8
0FDF4:  MOVFF  725,8D7
0FDF8:  MOVLW  01
0FDFA:  MOVLB  8
0FDFC:  MOVWF  xD8
0FDFE:  MOVLB  0
0FE00:  CALL   52CA
0FE04:  MOVLW  2F
0FE06:  MOVLB  8
0FE08:  MOVWF  xE9
0FE0A:  MOVLB  0
0FE0C:  CALL   50E8
0FE10:  MOVFF  727,8D7
0FE14:  MOVLW  01
0FE16:  MOVLB  8
0FE18:  MOVWF  xD8
0FE1A:  MOVLB  0
0FE1C:  CALL   52CA
0FE20:  MOVLW  20
0FE22:  MOVLB  8
0FE24:  MOVWF  xE9
0FE26:  MOVLB  0
0FE28:  CALL   50E8
0FE2C:  MOVFF  723,8D7
0FE30:  MOVLW  01
0FE32:  MOVLB  8
0FE34:  MOVWF  xD8
0FE36:  MOVLB  0
0FE38:  CALL   52CA
0FE3C:  MOVLW  3A
0FE3E:  MOVLB  8
0FE40:  MOVWF  xE9
0FE42:  MOVLB  0
0FE44:  CALL   50E8
0FE48:  MOVFF  722,8D7
0FE4C:  MOVLW  01
0FE4E:  MOVLB  8
0FE50:  MOVWF  xD8
0FE52:  MOVLB  0
0FE54:  CALL   52CA
0FE58:  MOVLW  3A
0FE5A:  MOVLB  8
0FE5C:  MOVWF  xE9
0FE5E:  MOVLB  0
0FE60:  CALL   50E8
0FE64:  MOVFF  721,8D7
0FE68:  MOVLW  01
0FE6A:  MOVLB  8
0FE6C:  MOVWF  xD8
0FE6E:  MOVLB  0
0FE70:  CALL   52CA
0FE74:  MOVLW  2C
0FE76:  MOVLB  8
0FE78:  MOVWF  xE9
0FE7A:  MOVLB  0
0FE7C:  CALL   50E8
0FE80:  MOVLW  04
0FE82:  MOVWF  FE9
0FE84:  MOVLB  8
0FE86:  CLRF   xDA
0FE88:  CLRF   xD9
0FE8A:  MOVFF  8B2,8D8
0FE8E:  MOVFF  8B1,8D7
0FE92:  MOVLW  02
0FE94:  MOVWF  xDB
0FE96:  MOVLB  0
0FE98:  CALL   5364
0FE9C:  MOVLW  2C
0FE9E:  MOVLB  8
0FEA0:  MOVWF  xE9
0FEA2:  MOVLB  0
0FEA4:  CALL   50E8
0FEA8:  MOVFF  1E,FEA
0FEAC:  MOVFF  1D,FE9
0FEB0:  CLRF   FEF
0FEB2:  MOVLW  03
0FEB4:  MOVWF  FEA
0FEB6:  MOVLW  39
0FEB8:  MOVWF  FE9
0FEBA:  RCALL  FBB0
0FEBC:  MOVLW  2C
0FEBE:  MOVLB  8
0FEC0:  MOVWF  xE9
0FEC2:  MOVLB  0
0FEC4:  CALL   50E8
0FEC8:  MOVFF  1E,FEA
0FECC:  MOVFF  1D,FE9
0FED0:  CLRF   FEF
0FED2:  MOVLW  03
0FED4:  MOVWF  FEA
0FED6:  MOVLW  3E
0FED8:  MOVWF  FE9
0FEDA:  RCALL  FBB0
0FEDC:  MOVLW  2C
0FEDE:  MOVLB  8
0FEE0:  MOVWF  xE9
0FEE2:  MOVLB  0
0FEE4:  CALL   50E8
0FEE8:  MOVFF  1E,FEA
0FEEC:  MOVFF  1D,FE9
0FEF0:  CLRF   FEF
0FEF2:  MOVLW  03
0FEF4:  MOVWF  FEA
0FEF6:  MOVLW  42
0FEF8:  MOVWF  FE9
0FEFA:  RCALL  FBB0
0FEFC:  MOVLW  2C
0FEFE:  MOVLB  8
0FF00:  MOVWF  xE9
0FF02:  MOVLB  0
0FF04:  CALL   50E8
0FF08:  MOVLW  10
0FF0A:  MOVWF  FE9
0FF0C:  MOVFF  26,8E1
0FF10:  MOVFF  25,8E0
0FF14:  CALL   AB28
0FF18:  MOVLW  2C
0FF1A:  MOVLB  8
0FF1C:  MOVWF  xE9
0FF1E:  MOVLB  0
0FF20:  CALL   50E8
0FF24:  MOVLW  10
0FF26:  MOVWF  FE9
0FF28:  MOVFF  8B4,8E1
0FF2C:  MOVFF  8B3,8E0
0FF30:  CALL   AB28
0FF34:  MOVLW  2C
0FF36:  MOVLB  8
0FF38:  MOVWF  xE9
0FF3A:  MOVLB  0
0FF3C:  CALL   50E8
0FF40:  MOVFF  4B1,8D7
0FF44:  MOVLW  1B
0FF46:  MOVLB  8
0FF48:  MOVWF  xD8
0FF4A:  MOVLB  0
0FF4C:  CALL   52CA
0FF50:  MOVLW  2C
0FF52:  MOVLB  8
0FF54:  MOVWF  xE9
0FF56:  MOVLB  0
0FF58:  CALL   50E8
0FF5C:  MOVLW  10
0FF5E:  MOVWF  FE9
0FF60:  MOVFF  4A4,8E1
0FF64:  MOVFF  4A3,8E0
0FF68:  CALL   AB28
0FF6C:  MOVLW  2C
0FF6E:  MOVLB  8
0FF70:  MOVWF  xE9
0FF72:  MOVLB  0
0FF74:  CALL   50E8
0FF78:  MOVLW  10
0FF7A:  MOVWF  FE9
0FF7C:  MOVFF  4AA,8E1
0FF80:  MOVFF  4A9,8E0
0FF84:  CALL   AB28
0FF88:  MOVLW  2C
0FF8A:  MOVLB  8
0FF8C:  MOVWF  xE9
0FF8E:  MOVLB  0
0FF90:  CALL   50E8
0FF94:  MOVLW  10
0FF96:  MOVWF  FE9
0FF98:  MOVFF  4A8,8E1
0FF9C:  MOVFF  4A7,8E0
0FFA0:  CALL   AB28
0FFA4:  MOVLW  0D
0FFA6:  MOVLB  8
0FFA8:  MOVWF  xE9
0FFAA:  MOVLB  0
0FFAC:  CALL   50E8
0FFB0:  MOVLW  0A
0FFB2:  MOVLB  8
0FFB4:  MOVWF  xE9
0FFB6:  MOVLB  0
0FFB8:  CALL   50E8
....................  
....................    load_scanned_data();  
0FFBC:  BRA    FC10
....................  
....................    display_rec(store, display); 
0FFBE:  MOVFF  8AE,8D5
0FFC2:  MOVFF  8AF,8D6
0FFC6:  RCALL  FCDE
....................     
....................    data_available = TRUE; 
0FFC8:  MOVLW  01
0FFCA:  MOVLB  3
0FFCC:  MOVWF  x37
....................    macro_flag = 900; 
0FFCE:  MOVLW  03
0FFD0:  MOVWF  x20
0FFD2:  MOVLW  84
0FFD4:  MOVWF  x1F
0FFD6:  MOVLB  0
0FFD8:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
*
10000:  MOVLB  8
10002:  CLRF   x75
10004:  CLRF   x74
....................    channel=channel-20000; 
10006:  MOVLW  20
10008:  SUBWF  x71,F
1000A:  MOVLW  4E
1000C:  SUBWFB x72,F
....................     
....................    for (i=0; i<9; i++){ 
1000E:  CLRF   x73
10010:  MOVF   x73,W
10012:  SUBLW  08
10014:  BTFSS  FD8.0
10016:  GOTO   100C2
....................       DAC_set(channel, setting); 
1001A:  MOVFF  871,8BD
1001E:  MOVFF  875,8BF
10022:  MOVFF  874,8BE
10026:  MOVLB  0
10028:  CALL   F2EC
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
1002C:  MOVLW  22
1002E:  MOVWF  FF6
10030:  MOVLW  1D
10032:  MOVWF  FF7
10034:  MOVLW  00
10036:  MOVWF  FF8
10038:  CLRF   1B
1003A:  BTFSC  FF2.7
1003C:  BSF    1B.7
1003E:  BCF    FF2.7
10040:  MOVLW  05
10042:  MOVLB  A
10044:  MOVWF  x25
10046:  MOVLB  0
10048:  CALL   1010
1004C:  BTFSC  1B.7
1004E:  BSF    FF2.7
10050:  MOVLW  10
10052:  MOVWF  FE9
10054:  CLRF   1B
10056:  BTFSC  FF2.7
10058:  BSF    1B.7
1005A:  BCF    FF2.7
1005C:  MOVFF  872,A26
10060:  MOVFF  871,A25
10064:  CALL   1192
10068:  BTFSC  1B.7
1006A:  BSF    FF2.7
1006C:  MOVLW  2C
1006E:  BTFSS  F9E.4
10070:  GOTO   1006E
10074:  MOVWF  FAD
10076:  MOVLW  10
10078:  MOVWF  FE9
1007A:  CLRF   1B
1007C:  BTFSC  FF2.7
1007E:  BSF    1B.7
10080:  BCF    FF2.7
10082:  MOVFF  875,A26
10086:  MOVFF  874,A25
1008A:  CALL   1192
1008E:  BTFSC  1B.7
10090:  BSF    FF2.7
10092:  MOVLW  2C
10094:  BTFSS  F9E.4
10096:  GOTO   10094
1009A:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
1009C:  MOVLB  8
1009E:  CLRF   xAD
100A0:  MOVLW  C8
100A2:  MOVWF  xAC
100A4:  CLRF   xAE
100A6:  MOVLW  01
100A8:  MOVWF  xAF
100AA:  MOVWF  xB0
100AC:  MOVLB  0
100AE:  CALL   FD7C
....................       setting = setting+500; 
100B2:  MOVLW  F4
100B4:  MOVLB  8
100B6:  ADDWF  x74,F
100B8:  MOVLW  01
100BA:  ADDWFC x75,F
100BC:  INCF   x73,F
100BE:  GOTO   10010
....................    } 
100C2:  MOVLB  0
100C4:  GOTO   10220 (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
100C8:  MOVLB  8
100CA:  CLRF   x71
100CC:  CLRF   x70
....................     
....................    for (i=0; i<9; i++){ 
100CE:  CLRF   x6F
100D0:  MOVF   x6F,W
100D2:  SUBLW  08
100D4:  BNC   1014E
....................       LED_SAR(intensity); 
100D6:  MOVFF  871,8B3
100DA:  MOVFF  870,8B2
100DE:  MOVLB  0
100E0:  CALL   F59E
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
100E4:  MOVLW  30
100E6:  MOVWF  FF6
100E8:  MOVLW  1D
100EA:  MOVWF  FF7
100EC:  MOVLW  00
100EE:  MOVWF  FF8
100F0:  CLRF   1B
100F2:  BTFSC  FF2.7
100F4:  BSF    1B.7
100F6:  BCF    FF2.7
100F8:  MOVLW  07
100FA:  MOVLB  A
100FC:  MOVWF  x25
100FE:  MOVLB  0
10100:  CALL   1010
10104:  BTFSC  1B.7
10106:  BSF    FF2.7
10108:  MOVLW  10
1010A:  MOVWF  FE9
1010C:  CLRF   1B
1010E:  BTFSC  FF2.7
10110:  BSF    1B.7
10112:  BCF    FF2.7
10114:  MOVFF  871,A26
10118:  MOVFF  870,A25
1011C:  CALL   1192
10120:  BTFSC  1B.7
10122:  BSF    FF2.7
10124:  MOVLW  2C
10126:  BTFSS  F9E.4
10128:  BRA    10126
1012A:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
1012C:  MOVLB  8
1012E:  CLRF   xAD
10130:  MOVLW  C8
10132:  MOVWF  xAC
10134:  CLRF   xAE
10136:  MOVLW  01
10138:  MOVWF  xAF
1013A:  MOVWF  xB0
1013C:  MOVLB  0
1013E:  RCALL  FD7C
....................       intensity = intensity+500; 
10140:  MOVLW  F4
10142:  MOVLB  8
10144:  ADDWF  x70,F
10146:  MOVLW  01
10148:  ADDWFC x71,F
1014A:  INCF   x6F,F
1014C:  BRA    100D0
....................    } 
1014E:  MOVLB  0
10150:  GOTO   10220 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
0310E:  MOVLB  8
03110:  CLRF   xA0
03112:  MOVF   xA0,W
03114:  SUBLW  20
03116:  BNC   312C
03118:  CLRF   03
0311A:  MOVF   xA0,W
0311C:  ADDLW  B3
0311E:  MOVWF  FE9
03120:  MOVLW  04
03122:  ADDWFC 03,W
03124:  MOVWF  FEA
03126:  CLRF   FEF
03128:  INCF   xA0,F
0312A:  BRA    3112
0312C:  MOVLB  0
0312E:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
03130:  MOVF   2F,W
03132:  SUBLW  02
03134:  BNZ   313E
03136:  MOVF   30,F
03138:  BNZ   313E
0313A:  MOVLW  00
0313C:  MOVWF  F99
....................    init_valve_status(); 
0313E:  RCALL  310E
....................    bus_pwr_status=0; 
03140:  MOVLB  4
03142:  CLRF   xB2
03144:  MOVLB  0
03146:  GOTO   1B29C (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0EADA:  MOVLW  3C
0EADC:  MOVWF  FF6
0EADE:  MOVLW  1D
0EAE0:  MOVWF  FF7
0EAE2:  MOVLW  00
0EAE4:  MOVWF  FF8
0EAE6:  CLRF   1B
0EAE8:  BTFSC  FF2.7
0EAEA:  BSF    1B.7
0EAEC:  BCF    FF2.7
0EAEE:  CALL   0E3A
0EAF2:  BTFSC  1B.7
0EAF4:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EAF6:  MOVLW  01
0EAF8:  MOVLB  8
0EAFA:  MOVWF  xA0
0EAFC:  MOVF   xA0,W
0EAFE:  SUBLW  08
0EB00:  BNC   EB6A
0EB02:  CLRF   03
0EB04:  MOVF   xA0,W
0EB06:  ADDLW  B3
0EB08:  MOVWF  FE9
0EB0A:  MOVLW  04
0EB0C:  ADDWFC 03,W
0EB0E:  MOVWF  FEA
0EB10:  MOVFF  FEF,8A1
0EB14:  CLRF   1B
0EB16:  BTFSC  FF2.7
0EB18:  BSF    1B.7
0EB1A:  BCF    FF2.7
0EB1C:  MOVFF  8A0,A25
0EB20:  MOVLW  01
0EB22:  MOVLB  A
0EB24:  MOVWF  x26
0EB26:  MOVLB  0
0EB28:  CALL   0F92
0EB2C:  BTFSC  1B.7
0EB2E:  BSF    FF2.7
0EB30:  MOVLW  5B
0EB32:  BTFSS  F9E.4
0EB34:  BRA    EB32
0EB36:  MOVWF  FAD
0EB38:  CLRF   1B
0EB3A:  BTFSC  FF2.7
0EB3C:  BSF    1B.7
0EB3E:  BCF    FF2.7
0EB40:  MOVFF  8A1,A25
0EB44:  MOVLW  1B
0EB46:  MOVLB  A
0EB48:  MOVWF  x26
0EB4A:  MOVLB  0
0EB4C:  CALL   0F92
0EB50:  BTFSC  1B.7
0EB52:  BSF    FF2.7
0EB54:  MOVLW  5D
0EB56:  BTFSS  F9E.4
0EB58:  BRA    EB56
0EB5A:  MOVWF  FAD
0EB5C:  MOVLW  20
0EB5E:  BTFSS  F9E.4
0EB60:  BRA    EB5E
0EB62:  MOVWF  FAD
0EB64:  MOVLB  8
0EB66:  INCF   xA0,F
0EB68:  BRA    EAFC
....................    fprintf(COM_A, "\r\n"); 
0EB6A:  MOVLW  0D
0EB6C:  BTFSS  F9E.4
0EB6E:  BRA    EB6C
0EB70:  MOVWF  FAD
0EB72:  MOVLW  0A
0EB74:  BTFSS  F9E.4
0EB76:  BRA    EB74
0EB78:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EB7A:  MOVLW  42
0EB7C:  MOVWF  FF6
0EB7E:  MOVLW  1D
0EB80:  MOVWF  FF7
0EB82:  MOVLW  00
0EB84:  MOVWF  FF8
0EB86:  CLRF   1B
0EB88:  BTFSC  FF2.7
0EB8A:  BSF    1B.7
0EB8C:  BCF    FF2.7
0EB8E:  MOVLB  0
0EB90:  CALL   0E3A
0EB94:  BTFSC  1B.7
0EB96:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EB98:  MOVLW  09
0EB9A:  MOVLB  8
0EB9C:  MOVWF  xA0
0EB9E:  MOVF   xA0,W
0EBA0:  SUBLW  10
0EBA2:  BNC   EC0C
0EBA4:  CLRF   03
0EBA6:  MOVF   xA0,W
0EBA8:  ADDLW  B3
0EBAA:  MOVWF  FE9
0EBAC:  MOVLW  04
0EBAE:  ADDWFC 03,W
0EBB0:  MOVWF  FEA
0EBB2:  MOVFF  FEF,8A1
0EBB6:  CLRF   1B
0EBB8:  BTFSC  FF2.7
0EBBA:  BSF    1B.7
0EBBC:  BCF    FF2.7
0EBBE:  MOVFF  8A0,A25
0EBC2:  MOVLW  01
0EBC4:  MOVLB  A
0EBC6:  MOVWF  x26
0EBC8:  MOVLB  0
0EBCA:  CALL   0F92
0EBCE:  BTFSC  1B.7
0EBD0:  BSF    FF2.7
0EBD2:  MOVLW  5B
0EBD4:  BTFSS  F9E.4
0EBD6:  BRA    EBD4
0EBD8:  MOVWF  FAD
0EBDA:  CLRF   1B
0EBDC:  BTFSC  FF2.7
0EBDE:  BSF    1B.7
0EBE0:  BCF    FF2.7
0EBE2:  MOVFF  8A1,A25
0EBE6:  MOVLW  1B
0EBE8:  MOVLB  A
0EBEA:  MOVWF  x26
0EBEC:  MOVLB  0
0EBEE:  CALL   0F92
0EBF2:  BTFSC  1B.7
0EBF4:  BSF    FF2.7
0EBF6:  MOVLW  5D
0EBF8:  BTFSS  F9E.4
0EBFA:  BRA    EBF8
0EBFC:  MOVWF  FAD
0EBFE:  MOVLW  20
0EC00:  BTFSS  F9E.4
0EC02:  BRA    EC00
0EC04:  MOVWF  FAD
0EC06:  MOVLB  8
0EC08:  INCF   xA0,F
0EC0A:  BRA    EB9E
....................    fprintf(COM_A, "\r\n"); 
0EC0C:  MOVLW  0D
0EC0E:  BTFSS  F9E.4
0EC10:  BRA    EC0E
0EC12:  MOVWF  FAD
0EC14:  MOVLW  0A
0EC16:  BTFSS  F9E.4
0EC18:  BRA    EC16
0EC1A:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EC1C:  MOVLW  48
0EC1E:  MOVWF  FF6
0EC20:  MOVLW  1D
0EC22:  MOVWF  FF7
0EC24:  MOVLW  00
0EC26:  MOVWF  FF8
0EC28:  CLRF   1B
0EC2A:  BTFSC  FF2.7
0EC2C:  BSF    1B.7
0EC2E:  BCF    FF2.7
0EC30:  MOVLB  0
0EC32:  CALL   0E3A
0EC36:  BTFSC  1B.7
0EC38:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EC3A:  MOVLW  11
0EC3C:  MOVLB  8
0EC3E:  MOVWF  xA0
0EC40:  MOVF   xA0,W
0EC42:  SUBLW  18
0EC44:  BNC   ECAE
0EC46:  CLRF   03
0EC48:  MOVF   xA0,W
0EC4A:  ADDLW  B3
0EC4C:  MOVWF  FE9
0EC4E:  MOVLW  04
0EC50:  ADDWFC 03,W
0EC52:  MOVWF  FEA
0EC54:  MOVFF  FEF,8A1
0EC58:  CLRF   1B
0EC5A:  BTFSC  FF2.7
0EC5C:  BSF    1B.7
0EC5E:  BCF    FF2.7
0EC60:  MOVFF  8A0,A25
0EC64:  MOVLW  01
0EC66:  MOVLB  A
0EC68:  MOVWF  x26
0EC6A:  MOVLB  0
0EC6C:  CALL   0F92
0EC70:  BTFSC  1B.7
0EC72:  BSF    FF2.7
0EC74:  MOVLW  5B
0EC76:  BTFSS  F9E.4
0EC78:  BRA    EC76
0EC7A:  MOVWF  FAD
0EC7C:  CLRF   1B
0EC7E:  BTFSC  FF2.7
0EC80:  BSF    1B.7
0EC82:  BCF    FF2.7
0EC84:  MOVFF  8A1,A25
0EC88:  MOVLW  1B
0EC8A:  MOVLB  A
0EC8C:  MOVWF  x26
0EC8E:  MOVLB  0
0EC90:  CALL   0F92
0EC94:  BTFSC  1B.7
0EC96:  BSF    FF2.7
0EC98:  MOVLW  5D
0EC9A:  BTFSS  F9E.4
0EC9C:  BRA    EC9A
0EC9E:  MOVWF  FAD
0ECA0:  MOVLW  20
0ECA2:  BTFSS  F9E.4
0ECA4:  BRA    ECA2
0ECA6:  MOVWF  FAD
0ECA8:  MOVLB  8
0ECAA:  INCF   xA0,F
0ECAC:  BRA    EC40
....................    fprintf(COM_A, "\r\n"); 
0ECAE:  MOVLW  0D
0ECB0:  BTFSS  F9E.4
0ECB2:  BRA    ECB0
0ECB4:  MOVWF  FAD
0ECB6:  MOVLW  0A
0ECB8:  BTFSS  F9E.4
0ECBA:  BRA    ECB8
0ECBC:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0ECBE:  MOVLW  4E
0ECC0:  MOVWF  FF6
0ECC2:  MOVLW  1D
0ECC4:  MOVWF  FF7
0ECC6:  MOVLW  00
0ECC8:  MOVWF  FF8
0ECCA:  CLRF   1B
0ECCC:  BTFSC  FF2.7
0ECCE:  BSF    1B.7
0ECD0:  BCF    FF2.7
0ECD2:  MOVLB  0
0ECD4:  CALL   0E3A
0ECD8:  BTFSC  1B.7
0ECDA:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0ECDC:  MOVLW  19
0ECDE:  MOVLB  8
0ECE0:  MOVWF  xA0
0ECE2:  MOVF   xA0,W
0ECE4:  SUBLW  20
0ECE6:  BNC   ED50
0ECE8:  CLRF   03
0ECEA:  MOVF   xA0,W
0ECEC:  ADDLW  B3
0ECEE:  MOVWF  FE9
0ECF0:  MOVLW  04
0ECF2:  ADDWFC 03,W
0ECF4:  MOVWF  FEA
0ECF6:  MOVFF  FEF,8A1
0ECFA:  CLRF   1B
0ECFC:  BTFSC  FF2.7
0ECFE:  BSF    1B.7
0ED00:  BCF    FF2.7
0ED02:  MOVFF  8A0,A25
0ED06:  MOVLW  01
0ED08:  MOVLB  A
0ED0A:  MOVWF  x26
0ED0C:  MOVLB  0
0ED0E:  CALL   0F92
0ED12:  BTFSC  1B.7
0ED14:  BSF    FF2.7
0ED16:  MOVLW  5B
0ED18:  BTFSS  F9E.4
0ED1A:  BRA    ED18
0ED1C:  MOVWF  FAD
0ED1E:  CLRF   1B
0ED20:  BTFSC  FF2.7
0ED22:  BSF    1B.7
0ED24:  BCF    FF2.7
0ED26:  MOVFF  8A1,A25
0ED2A:  MOVLW  1B
0ED2C:  MOVLB  A
0ED2E:  MOVWF  x26
0ED30:  MOVLB  0
0ED32:  CALL   0F92
0ED36:  BTFSC  1B.7
0ED38:  BSF    FF2.7
0ED3A:  MOVLW  5D
0ED3C:  BTFSS  F9E.4
0ED3E:  BRA    ED3C
0ED40:  MOVWF  FAD
0ED42:  MOVLW  20
0ED44:  BTFSS  F9E.4
0ED46:  BRA    ED44
0ED48:  MOVWF  FAD
0ED4A:  MOVLB  8
0ED4C:  INCF   xA0,F
0ED4E:  BRA    ECE2
....................    fprintf(COM_A, "\r\n");    
0ED50:  MOVLW  0D
0ED52:  BTFSS  F9E.4
0ED54:  BRA    ED52
0ED56:  MOVWF  FAD
0ED58:  MOVLW  0A
0ED5A:  BTFSS  F9E.4
0ED5C:  BRA    ED5A
0ED5E:  MOVWF  FAD
0ED60:  MOVLB  0
0ED62:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
140D4:  MOVF   1F,W
140D6:  SUBLW  04
140D8:  BNZ   14142
140DA:  MOVF   20,F
140DC:  BNZ   14142
140DE:  MOVLW  54
140E0:  MOVWF  FF6
140E2:  MOVLW  1D
140E4:  MOVWF  FF7
140E6:  MOVLW  00
140E8:  MOVWF  FF8
140EA:  CLRF   1B
140EC:  BTFSC  FF2.7
140EE:  BSF    1B.7
140F0:  BCF    FF2.7
140F2:  MOVLW  0C
140F4:  MOVLB  A
140F6:  MOVWF  x25
140F8:  MOVLB  0
140FA:  CALL   1010
140FE:  BTFSC  1B.7
14100:  BSF    FF2.7
14102:  MOVLW  10
14104:  MOVWF  FE9
14106:  CLRF   1B
14108:  BTFSC  FF2.7
1410A:  BSF    1B.7
1410C:  BCF    FF2.7
1410E:  MOVFF  8A1,A26
14112:  MOVFF  8A0,A25
14116:  CALL   1192
1411A:  BTFSC  1B.7
1411C:  BSF    FF2.7
1411E:  MOVLW  63
14120:  MOVWF  FF6
14122:  MOVLW  1D
14124:  MOVWF  FF7
14126:  MOVLW  00
14128:  MOVWF  FF8
1412A:  CLRF   1B
1412C:  BTFSC  FF2.7
1412E:  BSF    1B.7
14130:  BCF    FF2.7
14132:  MOVLW  03
14134:  MOVLB  A
14136:  MOVWF  x25
14138:  MOVLB  0
1413A:  CALL   1010
1413E:  BTFSC  1B.7
14140:  BSF    FF2.7
....................  
....................    multidrop_on(); 
14142:  CALL   D7F0
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
14146:  MOVLW  68
14148:  MOVWF  FF6
1414A:  MOVLW  1D
1414C:  MOVWF  FF7
1414E:  MOVLW  00
14150:  MOVWF  FF8
14152:  MOVLW  03
14154:  MOVLB  8
14156:  MOVWF  xA2
14158:  MOVLB  0
1415A:  CALL   D804
1415E:  MOVLW  10
14160:  MOVWF  FE9
14162:  MOVFF  8A1,8A3
14166:  MOVFF  8A0,8A2
1416A:  BRA    1401A
1416C:  MOVLW  0D
1416E:  BTFSS  FA4.4
14170:  BRA    1416E
14172:  MOVLB  F
14174:  MOVWF  x1C
....................    multidrop_off(); 
14176:  MOVLB  0
14178:  CALL   D8DC
....................  
....................    delay_ms(100); 
1417C:  MOVLW  64
1417E:  MOVLB  9
14180:  MOVWF  xD6
14182:  MOVLB  0
14184:  CALL   2964
14188:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0D92E:  MOVF   1F,W
0D930:  SUBLW  04
0D932:  BNZ   D99C
0D934:  MOVF   20,F
0D936:  BNZ   D99C
0D938:  MOVLW  70
0D93A:  MOVWF  FF6
0D93C:  MOVLW  1D
0D93E:  MOVWF  FF7
0D940:  MOVLW  00
0D942:  MOVWF  FF8
0D944:  CLRF   1B
0D946:  BTFSC  FF2.7
0D948:  BSF    1B.7
0D94A:  BCF    FF2.7
0D94C:  MOVLW  0C
0D94E:  MOVLB  A
0D950:  MOVWF  x25
0D952:  MOVLB  0
0D954:  CALL   1010
0D958:  BTFSC  1B.7
0D95A:  BSF    FF2.7
0D95C:  CLRF   1B
0D95E:  BTFSC  FF2.7
0D960:  BSF    1B.7
0D962:  BCF    FF2.7
0D964:  MOVFF  8A0,A25
0D968:  MOVLW  1B
0D96A:  MOVLB  A
0D96C:  MOVWF  x26
0D96E:  MOVLB  0
0D970:  CALL   0F92
0D974:  BTFSC  1B.7
0D976:  BSF    FF2.7
0D978:  MOVLW  7E
0D97A:  MOVWF  FF6
0D97C:  MOVLW  1D
0D97E:  MOVWF  FF7
0D980:  MOVLW  00
0D982:  MOVWF  FF8
0D984:  CLRF   1B
0D986:  BTFSC  FF2.7
0D988:  BSF    1B.7
0D98A:  BCF    FF2.7
0D98C:  MOVLW  03
0D98E:  MOVLB  A
0D990:  MOVWF  x25
0D992:  MOVLB  0
0D994:  CALL   1010
0D998:  BTFSC  1B.7
0D99A:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0D99C:  RCALL  D7F0
....................       fprintf(COM_B, "/1c%u\r",chip); 
0D99E:  MOVLW  82
0D9A0:  MOVWF  FF6
0D9A2:  MOVLW  1D
0D9A4:  MOVWF  FF7
0D9A6:  MOVLW  00
0D9A8:  MOVWF  FF8
0D9AA:  MOVLW  03
0D9AC:  MOVLB  8
0D9AE:  MOVWF  xA2
0D9B0:  MOVLB  0
0D9B2:  RCALL  D804
0D9B4:  MOVFF  8A0,8DD
0D9B8:  MOVLW  1B
0D9BA:  MOVLB  8
0D9BC:  MOVWF  xDE
0D9BE:  MOVLB  0
0D9C0:  RCALL  D838
0D9C2:  MOVLW  0D
0D9C4:  BTFSS  FA4.4
0D9C6:  BRA    D9C4
0D9C8:  MOVLB  F
0D9CA:  MOVWF  x1C
....................    multidrop_off(); 
0D9CC:  MOVLB  0
0D9CE:  RCALL  D8DC
....................    delay_ms(100); 
0D9D0:  MOVLW  64
0D9D2:  MOVLB  9
0D9D4:  MOVWF  xD6
0D9D6:  MOVLB  0
0D9D8:  CALL   2964
....................  
....................    multidrop_on(); 
0D9DC:  RCALL  D7F0
....................      fprintf(COM_B, "/1s256\r"); 
0D9DE:  MOVLW  8A
0D9E0:  MOVWF  FF6
0D9E2:  MOVLW  1D
0D9E4:  MOVWF  FF7
0D9E6:  MOVLW  00
0D9E8:  MOVWF  FF8
0D9EA:  BRA    D8FE
....................    multidrop_off();  
0D9EC:  RCALL  D8DC
....................    delay_ms(100); 
0D9EE:  MOVLW  64
0D9F0:  MOVLB  9
0D9F2:  MOVWF  xD6
0D9F4:  MOVLB  0
0D9F6:  CALL   2964
0D9FA:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
1418A:  MOVLB  8
1418C:  MOVF   x9F,W
1418E:  ADDLW  DF
14190:  BTFSC  FD8.0
14192:  BRA    1457E
14194:  ADDLW  21
14196:  MOVLB  0
14198:  GOTO   145B0
....................       case 0 : sol_chip_cmd(1); 
1419C:  MOVLW  01
1419E:  MOVLB  8
141A0:  MOVWF  xA0
141A2:  MOVLB  0
141A4:  CALL   D92E
....................                sol_switch_cmd(0); 
141A8:  MOVLB  8
141AA:  CLRF   xA1
141AC:  CLRF   xA0
141AE:  MOVLB  0
141B0:  RCALL  140D4
....................                sol_chip_cmd(2); 
141B2:  MOVLW  02
141B4:  MOVLB  8
141B6:  MOVWF  xA0
141B8:  MOVLB  0
141BA:  CALL   D92E
....................                sol_switch_cmd(0); 
141BE:  MOVLB  8
141C0:  CLRF   xA1
141C2:  CLRF   xA0
141C4:  MOVLB  0
141C6:  RCALL  140D4
....................                sol_chip_cmd(3); 
141C8:  MOVLW  03
141CA:  MOVLB  8
141CC:  MOVWF  xA0
141CE:  MOVLB  0
141D0:  CALL   D92E
....................                sol_switch_cmd(0); 
141D4:  MOVLB  8
141D6:  CLRF   xA1
141D8:  CLRF   xA0
141DA:  MOVLB  0
141DC:  RCALL  140D4
....................                sol_chip_cmd(4); 
141DE:  MOVLW  04
141E0:  MOVLB  8
141E2:  MOVWF  xA0
141E4:  MOVLB  0
141E6:  CALL   D92E
....................                sol_switch_cmd(0); 
141EA:  MOVLB  8
141EC:  CLRF   xA1
141EE:  CLRF   xA0
141F0:  MOVLB  0
141F2:  RCALL  140D4
....................                init_valve_status(); 
141F4:  CALL   310E
....................          break; 
141F8:  MOVLB  8
141FA:  BRA    1457E
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
141FC:  MOVLW  01
141FE:  MOVLB  8
14200:  MOVWF  xA0
14202:  MOVLB  0
14204:  CALL   D92E
....................                sol_switch_cmd(1); 
14208:  MOVLB  8
1420A:  CLRF   xA1
1420C:  MOVLW  01
1420E:  MOVWF  xA0
14210:  MOVLB  0
14212:  RCALL  140D4
....................          break;     
14214:  MOVLB  8
14216:  BRA    1457E
....................       case 2 : sol_chip_cmd(1); 
14218:  MOVLW  01
1421A:  MOVLB  8
1421C:  MOVWF  xA0
1421E:  MOVLB  0
14220:  CALL   D92E
....................                sol_switch_cmd(2); 
14224:  MOVLB  8
14226:  CLRF   xA1
14228:  MOVLW  02
1422A:  MOVWF  xA0
1422C:  MOVLB  0
1422E:  RCALL  140D4
....................          break;           
14230:  MOVLB  8
14232:  BRA    1457E
....................       case 3 : sol_chip_cmd(1); 
14234:  MOVLW  01
14236:  MOVLB  8
14238:  MOVWF  xA0
1423A:  MOVLB  0
1423C:  CALL   D92E
....................                sol_switch_cmd(4); 
14240:  MOVLB  8
14242:  CLRF   xA1
14244:  MOVLW  04
14246:  MOVWF  xA0
14248:  MOVLB  0
1424A:  RCALL  140D4
....................          break;  
1424C:  MOVLB  8
1424E:  BRA    1457E
....................       case 4 : sol_chip_cmd(1); 
14250:  MOVLW  01
14252:  MOVLB  8
14254:  MOVWF  xA0
14256:  MOVLB  0
14258:  CALL   D92E
....................                sol_switch_cmd(8); 
1425C:  MOVLB  8
1425E:  CLRF   xA1
14260:  MOVLW  08
14262:  MOVWF  xA0
14264:  MOVLB  0
14266:  RCALL  140D4
....................          break;  
14268:  MOVLB  8
1426A:  BRA    1457E
....................       case 5 : sol_chip_cmd(1); 
1426C:  MOVLW  01
1426E:  MOVLB  8
14270:  MOVWF  xA0
14272:  MOVLB  0
14274:  CALL   D92E
....................                sol_switch_cmd(16); 
14278:  MOVLB  8
1427A:  CLRF   xA1
1427C:  MOVLW  10
1427E:  MOVWF  xA0
14280:  MOVLB  0
14282:  RCALL  140D4
....................          break;  
14284:  MOVLB  8
14286:  BRA    1457E
....................       case 6 : sol_chip_cmd(1); 
14288:  MOVLW  01
1428A:  MOVLB  8
1428C:  MOVWF  xA0
1428E:  MOVLB  0
14290:  CALL   D92E
....................                sol_switch_cmd(32); 
14294:  MOVLB  8
14296:  CLRF   xA1
14298:  MOVLW  20
1429A:  MOVWF  xA0
1429C:  MOVLB  0
1429E:  RCALL  140D4
....................          break;  
142A0:  MOVLB  8
142A2:  BRA    1457E
....................       case 7 : sol_chip_cmd(1); 
142A4:  MOVLW  01
142A6:  MOVLB  8
142A8:  MOVWF  xA0
142AA:  MOVLB  0
142AC:  CALL   D92E
....................                sol_switch_cmd(64); 
142B0:  MOVLB  8
142B2:  CLRF   xA1
142B4:  MOVLW  40
142B6:  MOVWF  xA0
142B8:  MOVLB  0
142BA:  RCALL  140D4
....................          break;  
142BC:  MOVLB  8
142BE:  BRA    1457E
....................       case 8 : sol_chip_cmd(1); 
142C0:  MOVLW  01
142C2:  MOVLB  8
142C4:  MOVWF  xA0
142C6:  MOVLB  0
142C8:  CALL   D92E
....................                sol_switch_cmd(128); 
142CC:  MOVLB  8
142CE:  CLRF   xA1
142D0:  MOVLW  80
142D2:  MOVWF  xA0
142D4:  MOVLB  0
142D6:  RCALL  140D4
....................          break;   
142D8:  MOVLB  8
142DA:  BRA    1457E
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
142DC:  MOVLW  02
142DE:  MOVLB  8
142E0:  MOVWF  xA0
142E2:  MOVLB  0
142E4:  CALL   D92E
....................                sol_switch_cmd(1); 
142E8:  MOVLB  8
142EA:  CLRF   xA1
142EC:  MOVLW  01
142EE:  MOVWF  xA0
142F0:  MOVLB  0
142F2:  RCALL  140D4
....................          break;     
142F4:  MOVLB  8
142F6:  BRA    1457E
....................       case 10 : sol_chip_cmd(2); 
142F8:  MOVLW  02
142FA:  MOVLB  8
142FC:  MOVWF  xA0
142FE:  MOVLB  0
14300:  CALL   D92E
....................                sol_switch_cmd(2); 
14304:  MOVLB  8
14306:  CLRF   xA1
14308:  MOVLW  02
1430A:  MOVWF  xA0
1430C:  MOVLB  0
1430E:  RCALL  140D4
....................          break;           
14310:  MOVLB  8
14312:  BRA    1457E
....................       case 11 : sol_chip_cmd(2); 
14314:  MOVLW  02
14316:  MOVLB  8
14318:  MOVWF  xA0
1431A:  MOVLB  0
1431C:  CALL   D92E
....................                sol_switch_cmd(4); 
14320:  MOVLB  8
14322:  CLRF   xA1
14324:  MOVLW  04
14326:  MOVWF  xA0
14328:  MOVLB  0
1432A:  RCALL  140D4
....................          break;  
1432C:  MOVLB  8
1432E:  BRA    1457E
....................       case 12 : sol_chip_cmd(2); 
14330:  MOVLW  02
14332:  MOVLB  8
14334:  MOVWF  xA0
14336:  MOVLB  0
14338:  CALL   D92E
....................                sol_switch_cmd(8); 
1433C:  MOVLB  8
1433E:  CLRF   xA1
14340:  MOVLW  08
14342:  MOVWF  xA0
14344:  MOVLB  0
14346:  RCALL  140D4
....................          break;  
14348:  MOVLB  8
1434A:  BRA    1457E
....................       case 13 : sol_chip_cmd(2); 
1434C:  MOVLW  02
1434E:  MOVLB  8
14350:  MOVWF  xA0
14352:  MOVLB  0
14354:  CALL   D92E
....................                sol_switch_cmd(16); 
14358:  MOVLB  8
1435A:  CLRF   xA1
1435C:  MOVLW  10
1435E:  MOVWF  xA0
14360:  MOVLB  0
14362:  RCALL  140D4
....................          break;  
14364:  MOVLB  8
14366:  BRA    1457E
....................       case 14 : sol_chip_cmd(2); 
14368:  MOVLW  02
1436A:  MOVLB  8
1436C:  MOVWF  xA0
1436E:  MOVLB  0
14370:  CALL   D92E
....................                sol_switch_cmd(32); 
14374:  MOVLB  8
14376:  CLRF   xA1
14378:  MOVLW  20
1437A:  MOVWF  xA0
1437C:  MOVLB  0
1437E:  RCALL  140D4
....................          break;  
14380:  MOVLB  8
14382:  BRA    1457E
....................       case 15 : sol_chip_cmd(2); 
14384:  MOVLW  02
14386:  MOVLB  8
14388:  MOVWF  xA0
1438A:  MOVLB  0
1438C:  CALL   D92E
....................                sol_switch_cmd(64); 
14390:  MOVLB  8
14392:  CLRF   xA1
14394:  MOVLW  40
14396:  MOVWF  xA0
14398:  MOVLB  0
1439A:  RCALL  140D4
....................          break;  
1439C:  MOVLB  8
1439E:  BRA    1457E
....................       case 16 : sol_chip_cmd(2); 
143A0:  MOVLW  02
143A2:  MOVLB  8
143A4:  MOVWF  xA0
143A6:  MOVLB  0
143A8:  CALL   D92E
....................                sol_switch_cmd(128); 
143AC:  MOVLB  8
143AE:  CLRF   xA1
143B0:  MOVLW  80
143B2:  MOVWF  xA0
143B4:  MOVLB  0
143B6:  RCALL  140D4
....................          break;   
143B8:  MOVLB  8
143BA:  BRA    1457E
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
143BC:  MOVLW  03
143BE:  MOVLB  8
143C0:  MOVWF  xA0
143C2:  MOVLB  0
143C4:  CALL   D92E
....................                sol_switch_cmd(1); 
143C8:  MOVLB  8
143CA:  CLRF   xA1
143CC:  MOVLW  01
143CE:  MOVWF  xA0
143D0:  MOVLB  0
143D2:  RCALL  140D4
....................          break;     
143D4:  MOVLB  8
143D6:  BRA    1457E
....................       case 18 : sol_chip_cmd(3); 
143D8:  MOVLW  03
143DA:  MOVLB  8
143DC:  MOVWF  xA0
143DE:  MOVLB  0
143E0:  CALL   D92E
....................                sol_switch_cmd(2); 
143E4:  MOVLB  8
143E6:  CLRF   xA1
143E8:  MOVLW  02
143EA:  MOVWF  xA0
143EC:  MOVLB  0
143EE:  RCALL  140D4
....................          break;           
143F0:  MOVLB  8
143F2:  BRA    1457E
....................       case 19 : sol_chip_cmd(3); 
143F4:  MOVLW  03
143F6:  MOVLB  8
143F8:  MOVWF  xA0
143FA:  MOVLB  0
143FC:  CALL   D92E
....................                sol_switch_cmd(4); 
14400:  MOVLB  8
14402:  CLRF   xA1
14404:  MOVLW  04
14406:  MOVWF  xA0
14408:  MOVLB  0
1440A:  RCALL  140D4
....................          break;  
1440C:  MOVLB  8
1440E:  BRA    1457E
....................       case 20 : sol_chip_cmd(3); 
14410:  MOVLW  03
14412:  MOVLB  8
14414:  MOVWF  xA0
14416:  MOVLB  0
14418:  CALL   D92E
....................                sol_switch_cmd(8); 
1441C:  MOVLB  8
1441E:  CLRF   xA1
14420:  MOVLW  08
14422:  MOVWF  xA0
14424:  MOVLB  0
14426:  RCALL  140D4
....................          break;  
14428:  MOVLB  8
1442A:  BRA    1457E
....................       case 21 : sol_chip_cmd(3); 
1442C:  MOVLW  03
1442E:  MOVLB  8
14430:  MOVWF  xA0
14432:  MOVLB  0
14434:  CALL   D92E
....................                sol_switch_cmd(16); 
14438:  MOVLB  8
1443A:  CLRF   xA1
1443C:  MOVLW  10
1443E:  MOVWF  xA0
14440:  MOVLB  0
14442:  RCALL  140D4
....................          break;  
14444:  MOVLB  8
14446:  BRA    1457E
....................       case 22 : sol_chip_cmd(3); 
14448:  MOVLW  03
1444A:  MOVLB  8
1444C:  MOVWF  xA0
1444E:  MOVLB  0
14450:  CALL   D92E
....................                sol_switch_cmd(32); 
14454:  MOVLB  8
14456:  CLRF   xA1
14458:  MOVLW  20
1445A:  MOVWF  xA0
1445C:  MOVLB  0
1445E:  RCALL  140D4
....................          break;  
14460:  MOVLB  8
14462:  BRA    1457E
....................       case 23 : sol_chip_cmd(3); 
14464:  MOVLW  03
14466:  MOVLB  8
14468:  MOVWF  xA0
1446A:  MOVLB  0
1446C:  CALL   D92E
....................                sol_switch_cmd(64); 
14470:  MOVLB  8
14472:  CLRF   xA1
14474:  MOVLW  40
14476:  MOVWF  xA0
14478:  MOVLB  0
1447A:  RCALL  140D4
....................          break;  
1447C:  MOVLB  8
1447E:  BRA    1457E
....................       case 24 : sol_chip_cmd(3); 
14480:  MOVLW  03
14482:  MOVLB  8
14484:  MOVWF  xA0
14486:  MOVLB  0
14488:  CALL   D92E
....................                sol_switch_cmd(128); 
1448C:  MOVLB  8
1448E:  CLRF   xA1
14490:  MOVLW  80
14492:  MOVWF  xA0
14494:  MOVLB  0
14496:  RCALL  140D4
....................          break;      
14498:  MOVLB  8
1449A:  BRA    1457E
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
1449C:  MOVLW  04
1449E:  MOVLB  8
144A0:  MOVWF  xA0
144A2:  MOVLB  0
144A4:  CALL   D92E
....................                sol_switch_cmd(1); 
144A8:  MOVLB  8
144AA:  CLRF   xA1
144AC:  MOVLW  01
144AE:  MOVWF  xA0
144B0:  MOVLB  0
144B2:  RCALL  140D4
....................          break;     
144B4:  MOVLB  8
144B6:  BRA    1457E
....................       case 26 : sol_chip_cmd(4); 
144B8:  MOVLW  04
144BA:  MOVLB  8
144BC:  MOVWF  xA0
144BE:  MOVLB  0
144C0:  CALL   D92E
....................                sol_switch_cmd(2); 
144C4:  MOVLB  8
144C6:  CLRF   xA1
144C8:  MOVLW  02
144CA:  MOVWF  xA0
144CC:  MOVLB  0
144CE:  RCALL  140D4
....................          break;           
144D0:  MOVLB  8
144D2:  BRA    1457E
....................       case 27 : sol_chip_cmd(4); 
144D4:  MOVLW  04
144D6:  MOVLB  8
144D8:  MOVWF  xA0
144DA:  MOVLB  0
144DC:  CALL   D92E
....................                sol_switch_cmd(4); 
144E0:  MOVLB  8
144E2:  CLRF   xA1
144E4:  MOVLW  04
144E6:  MOVWF  xA0
144E8:  MOVLB  0
144EA:  RCALL  140D4
....................          break;  
144EC:  MOVLB  8
144EE:  BRA    1457E
....................       case 28 : sol_chip_cmd(4); 
144F0:  MOVLW  04
144F2:  MOVLB  8
144F4:  MOVWF  xA0
144F6:  MOVLB  0
144F8:  CALL   D92E
....................                sol_switch_cmd(8); 
144FC:  MOVLB  8
144FE:  CLRF   xA1
14500:  MOVLW  08
14502:  MOVWF  xA0
14504:  MOVLB  0
14506:  RCALL  140D4
....................          break;  
14508:  MOVLB  8
1450A:  BRA    1457E
....................       case 29 : sol_chip_cmd(4); 
1450C:  MOVLW  04
1450E:  MOVLB  8
14510:  MOVWF  xA0
14512:  MOVLB  0
14514:  CALL   D92E
....................                sol_switch_cmd(16); 
14518:  MOVLB  8
1451A:  CLRF   xA1
1451C:  MOVLW  10
1451E:  MOVWF  xA0
14520:  MOVLB  0
14522:  RCALL  140D4
....................          break;  
14524:  MOVLB  8
14526:  BRA    1457E
....................       case 30 : sol_chip_cmd(4); 
14528:  MOVLW  04
1452A:  MOVLB  8
1452C:  MOVWF  xA0
1452E:  MOVLB  0
14530:  CALL   D92E
....................                sol_switch_cmd(32); 
14534:  MOVLB  8
14536:  CLRF   xA1
14538:  MOVLW  20
1453A:  MOVWF  xA0
1453C:  MOVLB  0
1453E:  RCALL  140D4
....................          break;  
14540:  MOVLB  8
14542:  BRA    1457E
....................       case 31 : sol_chip_cmd(4); 
14544:  MOVLW  04
14546:  MOVLB  8
14548:  MOVWF  xA0
1454A:  MOVLB  0
1454C:  CALL   D92E
....................                sol_switch_cmd(64); 
14550:  MOVLB  8
14552:  CLRF   xA1
14554:  MOVLW  40
14556:  MOVWF  xA0
14558:  MOVLB  0
1455A:  RCALL  140D4
....................          break;  
1455C:  MOVLB  8
1455E:  BRA    1457E
....................       case 32 : sol_chip_cmd(4); 
14560:  MOVLW  04
14562:  MOVLB  8
14564:  MOVWF  xA0
14566:  MOVLB  0
14568:  CALL   D92E
....................                sol_switch_cmd(128); 
1456C:  MOVLB  8
1456E:  CLRF   xA1
14570:  MOVLW  80
14572:  MOVWF  xA0
14574:  MOVLB  0
14576:  RCALL  140D4
....................          break; 
14578:  MOVLB  8
1457A:  BRA    1457E
1457C:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
1457E:  MOVF   x9F,F
14580:  BZ    1459A
14582:  MOVF   x9F,W
14584:  SUBLW  20
14586:  BNC   1459A
14588:  CLRF   03
1458A:  MOVF   x9F,W
1458C:  ADDLW  B3
1458E:  MOVWF  FE9
14590:  MOVLW  04
14592:  ADDWFC 03,W
14594:  MOVWF  FEA
14596:  MOVLW  01
14598:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
1459A:  MOVF   1F,W
1459C:  SUBLW  04
1459E:  BNZ   145AC
145A0:  MOVF   20,F
145A2:  BNZ   145AC
145A4:  MOVLB  0
145A6:  CALL   EADA
145AA:  MOVLB  8
145AC:  MOVLB  0
145AE:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
1028E:  MOVLB  8
10290:  CLRF   x87
10292:  MOVF   x87,W
10294:  SUBLW  07
10296:  BNC   102B2
10298:  BCF    FD8.0
1029A:  RLCF   x87,W
1029C:  CLRF   03
1029E:  ADDLW  47
102A0:  MOVWF  FE9
102A2:  MOVLW  03
102A4:  ADDWFC 03,W
102A6:  MOVWF  FEA
102A8:  CLRF   FEC
102AA:  MOVF   FED,F
102AC:  CLRF   FEF
102AE:  INCF   x87,F
102B0:  BRA    10292
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
102B2:  CLRF   x87
102B4:  MOVF   x87,W
102B6:  SUBLW  07
102B8:  BNC   102D4
102BA:  BCF    FD8.0
102BC:  RLCF   x87,W
102BE:  CLRF   03
102C0:  ADDLW  59
102C2:  MOVWF  FE9
102C4:  MOVLW  03
102C6:  ADDWFC 03,W
102C8:  MOVWF  FEA
102CA:  CLRF   FEC
102CC:  MOVF   FED,F
102CE:  CLRF   FEF
102D0:  INCF   x87,F
102D2:  BRA    102B4
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
102D4:  CLRF   x87
102D6:  MOVF   x87,W
102D8:  SUBLW  07
102DA:  BNC   102F6
102DC:  BCF    FD8.0
102DE:  RLCF   x87,W
102E0:  CLRF   03
102E2:  ADDLW  6B
102E4:  MOVWF  FE9
102E6:  MOVLW  03
102E8:  ADDWFC 03,W
102EA:  MOVWF  FEA
102EC:  CLRF   FEC
102EE:  MOVF   FED,F
102F0:  CLRF   FEF
102F2:  INCF   x87,F
102F4:  BRA    102D6
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
102F6:  CLRF   x87
102F8:  MOVF   x87,W
102FA:  SUBLW  07
102FC:  BNC   10318
102FE:  BCF    FD8.0
10300:  RLCF   x87,W
10302:  CLRF   03
10304:  ADDLW  7D
10306:  MOVWF  FE9
10308:  MOVLW  03
1030A:  ADDWFC 03,W
1030C:  MOVWF  FEA
1030E:  CLRF   FEC
10310:  MOVF   FED,F
10312:  CLRF   FEF
10314:  INCF   x87,F
10316:  BRA    102F8
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
10318:  CLRF   x87
1031A:  MOVF   x87,W
1031C:  SUBLW  07
1031E:  BNC   1033A
10320:  BCF    FD8.0
10322:  RLCF   x87,W
10324:  CLRF   03
10326:  ADDLW  8F
10328:  MOVWF  FE9
1032A:  MOVLW  03
1032C:  ADDWFC 03,W
1032E:  MOVWF  FEA
10330:  CLRF   FEC
10332:  MOVF   FED,F
10334:  CLRF   FEF
10336:  INCF   x87,F
10338:  BRA    1031A
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
1033A:  MOVLW  04
1033C:  MOVWF  FEA
1033E:  MOVLW  21
10340:  MOVWF  FE9
10342:  CLRF   00
10344:  CLRF   02
10346:  MOVLW  44
10348:  MOVWF  01
1034A:  MOVLB  0
1034C:  CALL   357A
10350:  GOTO   14FD0 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10BFC:  MOVLB  8
10BFE:  CLRF   xAC
10C00:  MOVF   xAC,W
10C02:  SUBLW  03
10C04:  BNC   10C24
10C06:  MOVF   xAC,W
10C08:  MULLW  04
10C0A:  MOVF   FF3,W
10C0C:  CLRF   03
10C0E:  ADDLW  A1
10C10:  MOVWF  FE9
10C12:  MOVLW  03
10C14:  ADDWFC 03,W
10C16:  MOVWF  FEA
10C18:  CLRF   FEF
10C1A:  CLRF   FEC
10C1C:  CLRF   FEC
10C1E:  CLRF   FEC
10C20:  INCF   xAC,F
10C22:  BRA    10C00
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10C24:  MOVLB  3
10C26:  MOVF   x47,F
10C28:  BTFSS  FD8.2
10C2A:  BRA    10C30
10C2C:  MOVF   x48,F
10C2E:  BZ    10CCA
10C30:  MOVF   x49,F
10C32:  BNZ   10C38
10C34:  MOVF   x4A,F
10C36:  BZ    10CCA
....................       blank = NO3_array[0]; 
10C38:  MOVFF  348,902
10C3C:  MOVFF  347,901
10C40:  MOVLB  0
10C42:  CALL   C68E
10C46:  MOVFF  03,8B0
10C4A:  MOVFF  02,8AF
10C4E:  MOVFF  01,8AE
10C52:  MOVFF  00,8AD
....................       react = NO3_array[1]; 
10C56:  MOVFF  34A,902
10C5A:  MOVFF  349,901
10C5E:  CALL   C68E
10C62:  MOVFF  03,8B4
10C66:  MOVFF  02,8B3
10C6A:  MOVFF  01,8B2
10C6E:  MOVFF  00,8B1
....................       ratio = blank / react; 
10C72:  MOVFF  8B0,8E8
10C76:  MOVFF  8AF,8E7
10C7A:  MOVFF  8AE,8E6
10C7E:  MOVFF  8AD,8E5
10C82:  MOVFF  8B4,8EC
10C86:  MOVFF  8B3,8EB
10C8A:  MOVFF  8B2,8EA
10C8E:  MOVFF  8B1,8E9
10C92:  CALL   C6C4
10C96:  MOVFF  03,8B8
10C9A:  MOVFF  02,8B7
10C9E:  MOVFF  01,8B6
10CA2:  MOVFF  00,8B5
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10CA6:  MOVFF  8B8,8BC
10CAA:  MOVFF  8B7,8BB
10CAE:  MOVFF  8B6,8BA
10CB2:  MOVFF  8B5,8B9
10CB6:  RCALL  1097A
10CB8:  MOVFF  03,3A4
10CBC:  MOVFF  02,3A3
10CC0:  MOVFF  01,3A2
10CC4:  MOVFF  00,3A1
10CC8:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10CCA:  MOVF   x4B,F
10CCC:  BNZ   10CD2
10CCE:  MOVF   x4C,F
10CD0:  BZ    10D6C
10CD2:  MOVF   x4D,F
10CD4:  BNZ   10CDA
10CD6:  MOVF   x4E,F
10CD8:  BZ    10D6C
....................       blank = NO3_array[2]; 
10CDA:  MOVFF  34C,902
10CDE:  MOVFF  34B,901
10CE2:  MOVLB  0
10CE4:  CALL   C68E
10CE8:  MOVFF  03,8B0
10CEC:  MOVFF  02,8AF
10CF0:  MOVFF  01,8AE
10CF4:  MOVFF  00,8AD
....................       react = NO3_array[3]; 
10CF8:  MOVFF  34E,902
10CFC:  MOVFF  34D,901
10D00:  CALL   C68E
10D04:  MOVFF  03,8B4
10D08:  MOVFF  02,8B3
10D0C:  MOVFF  01,8B2
10D10:  MOVFF  00,8B1
....................       ratio = blank / react;    
10D14:  MOVFF  8B0,8E8
10D18:  MOVFF  8AF,8E7
10D1C:  MOVFF  8AE,8E6
10D20:  MOVFF  8AD,8E5
10D24:  MOVFF  8B4,8EC
10D28:  MOVFF  8B3,8EB
10D2C:  MOVFF  8B2,8EA
10D30:  MOVFF  8B1,8E9
10D34:  CALL   C6C4
10D38:  MOVFF  03,8B8
10D3C:  MOVFF  02,8B7
10D40:  MOVFF  01,8B6
10D44:  MOVFF  00,8B5
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10D48:  MOVFF  8B8,8BC
10D4C:  MOVFF  8B7,8BB
10D50:  MOVFF  8B6,8BA
10D54:  MOVFF  8B5,8B9
10D58:  RCALL  1097A
10D5A:  MOVFF  03,3A8
10D5E:  MOVFF  02,3A7
10D62:  MOVFF  01,3A6
10D66:  MOVFF  00,3A5
10D6A:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
10D6C:  MOVF   x4F,F
10D6E:  BNZ   10D74
10D70:  MOVF   x50,F
10D72:  BZ    10E0E
10D74:  MOVF   x51,F
10D76:  BNZ   10D7C
10D78:  MOVF   x52,F
10D7A:  BZ    10E0E
....................       blank = NO3_array[4]; 
10D7C:  MOVFF  350,902
10D80:  MOVFF  34F,901
10D84:  MOVLB  0
10D86:  CALL   C68E
10D8A:  MOVFF  03,8B0
10D8E:  MOVFF  02,8AF
10D92:  MOVFF  01,8AE
10D96:  MOVFF  00,8AD
....................       react = NO3_array[5]; 
10D9A:  MOVFF  352,902
10D9E:  MOVFF  351,901
10DA2:  CALL   C68E
10DA6:  MOVFF  03,8B4
10DAA:  MOVFF  02,8B3
10DAE:  MOVFF  01,8B2
10DB2:  MOVFF  00,8B1
....................       ratio = blank / react; 
10DB6:  MOVFF  8B0,8E8
10DBA:  MOVFF  8AF,8E7
10DBE:  MOVFF  8AE,8E6
10DC2:  MOVFF  8AD,8E5
10DC6:  MOVFF  8B4,8EC
10DCA:  MOVFF  8B3,8EB
10DCE:  MOVFF  8B2,8EA
10DD2:  MOVFF  8B1,8E9
10DD6:  CALL   C6C4
10DDA:  MOVFF  03,8B8
10DDE:  MOVFF  02,8B7
10DE2:  MOVFF  01,8B6
10DE6:  MOVFF  00,8B5
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
10DEA:  MOVFF  8B8,8BC
10DEE:  MOVFF  8B7,8BB
10DF2:  MOVFF  8B6,8BA
10DF6:  MOVFF  8B5,8B9
10DFA:  RCALL  1097A
10DFC:  MOVFF  03,3AC
10E00:  MOVFF  02,3AB
10E04:  MOVFF  01,3AA
10E08:  MOVFF  00,3A9
10E0C:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
10E0E:  MOVF   x53,F
10E10:  BNZ   10E16
10E12:  MOVF   x54,F
10E14:  BZ    10EB0
10E16:  MOVF   x55,F
10E18:  BNZ   10E1E
10E1A:  MOVF   x56,F
10E1C:  BZ    10EB0
....................       blank = NO3_array[6]; 
10E1E:  MOVFF  354,902
10E22:  MOVFF  353,901
10E26:  MOVLB  0
10E28:  CALL   C68E
10E2C:  MOVFF  03,8B0
10E30:  MOVFF  02,8AF
10E34:  MOVFF  01,8AE
10E38:  MOVFF  00,8AD
....................       react = NO3_array[7]; 
10E3C:  MOVFF  356,902
10E40:  MOVFF  355,901
10E44:  CALL   C68E
10E48:  MOVFF  03,8B4
10E4C:  MOVFF  02,8B3
10E50:  MOVFF  01,8B2
10E54:  MOVFF  00,8B1
....................       ratio = blank / react; 
10E58:  MOVFF  8B0,8E8
10E5C:  MOVFF  8AF,8E7
10E60:  MOVFF  8AE,8E6
10E64:  MOVFF  8AD,8E5
10E68:  MOVFF  8B4,8EC
10E6C:  MOVFF  8B3,8EB
10E70:  MOVFF  8B2,8EA
10E74:  MOVFF  8B1,8E9
10E78:  CALL   C6C4
10E7C:  MOVFF  03,8B8
10E80:  MOVFF  02,8B7
10E84:  MOVFF  01,8B6
10E88:  MOVFF  00,8B5
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
10E8C:  MOVFF  8B8,8BC
10E90:  MOVFF  8B7,8BB
10E94:  MOVFF  8B6,8BA
10E98:  MOVFF  8B5,8B9
10E9C:  RCALL  1097A
10E9E:  MOVFF  03,3B0
10EA2:  MOVFF  02,3AF
10EA6:  MOVFF  01,3AE
10EAA:  MOVFF  00,3AD
10EAE:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
10EB0:  MOVLW  04
10EB2:  MOVWF  1E
10EB4:  MOVLW  21
10EB6:  MOVWF  1D
10EB8:  MOVLW  92
10EBA:  MOVWF  FF6
10EBC:  MOVLW  1D
10EBE:  MOVWF  FF7
10EC0:  MOVLW  00
10EC2:  MOVWF  FF8
10EC4:  MOVLW  06
10EC6:  MOVLB  8
10EC8:  MOVWF  xD5
10ECA:  MOVLB  0
10ECC:  CALL   AAF6
10ED0:  MOVLW  10
10ED2:  MOVWF  FE9
10ED4:  MOVFF  348,8E1
10ED8:  MOVFF  347,8E0
10EDC:  CALL   AB28
10EE0:  MOVLW  9B
10EE2:  MOVWF  FF6
10EE4:  MOVLW  1D
10EE6:  MOVWF  FF7
10EE8:  MOVLW  00
10EEA:  MOVWF  FF8
10EEC:  MOVLW  07
10EEE:  MOVLB  8
10EF0:  MOVWF  xD5
10EF2:  MOVLB  0
10EF4:  CALL   AAF6
10EF8:  MOVLW  10
10EFA:  MOVWF  FE9
10EFC:  MOVFF  34A,8E1
10F00:  MOVFF  349,8E0
10F04:  CALL   AB28
10F08:  MOVLW  A5
10F0A:  MOVWF  FF6
10F0C:  MOVLW  1D
10F0E:  MOVWF  FF7
10F10:  MOVLW  00
10F12:  MOVWF  FF8
10F14:  MOVLW  09
10F16:  MOVLB  8
10F18:  MOVWF  xD5
10F1A:  MOVLB  0
10F1C:  CALL   AAF6
10F20:  MOVLW  89
10F22:  MOVWF  FE9
10F24:  MOVFF  3A4,8BC
10F28:  MOVFF  3A3,8BB
10F2C:  MOVFF  3A2,8BA
10F30:  MOVFF  3A1,8B9
10F34:  MOVLW  04
10F36:  MOVLB  8
10F38:  MOVWF  xBD
10F3A:  MOVLB  0
10F3C:  RCALL  109E6
10F3E:  MOVLW  B3
10F40:  MOVWF  FF6
10F42:  MOVLW  1D
10F44:  MOVWF  FF7
10F46:  MOVLW  00
10F48:  MOVWF  FF8
10F4A:  MOVLW  07
10F4C:  MOVLB  8
10F4E:  MOVWF  xD5
10F50:  MOVLB  0
10F52:  CALL   AAF6
10F56:  MOVLW  10
10F58:  MOVWF  FE9
10F5A:  MOVFF  34C,8E1
10F5E:  MOVFF  34B,8E0
10F62:  CALL   AB28
10F66:  MOVLW  BD
10F68:  MOVWF  FF6
10F6A:  MOVLW  1D
10F6C:  MOVWF  FF7
10F6E:  MOVLW  00
10F70:  MOVWF  FF8
10F72:  MOVLW  07
10F74:  MOVLB  8
10F76:  MOVWF  xD5
10F78:  MOVLB  0
10F7A:  CALL   AAF6
10F7E:  MOVLW  10
10F80:  MOVWF  FE9
10F82:  MOVFF  34E,8E1
10F86:  MOVFF  34D,8E0
10F8A:  CALL   AB28
10F8E:  MOVLW  C7
10F90:  MOVWF  FF6
10F92:  MOVLW  1D
10F94:  MOVWF  FF7
10F96:  MOVLW  00
10F98:  MOVWF  FF8
10F9A:  MOVLW  09
10F9C:  MOVLB  8
10F9E:  MOVWF  xD5
10FA0:  MOVLB  0
10FA2:  CALL   AAF6
10FA6:  MOVLW  89
10FA8:  MOVWF  FE9
10FAA:  MOVFF  3A8,8BC
10FAE:  MOVFF  3A7,8BB
10FB2:  MOVFF  3A6,8BA
10FB6:  MOVFF  3A5,8B9
10FBA:  MOVLW  04
10FBC:  MOVLB  8
10FBE:  MOVWF  xBD
10FC0:  MOVLB  0
10FC2:  RCALL  109E6
10FC4:  MOVLW  D5
10FC6:  MOVWF  FF6
10FC8:  MOVLW  1D
10FCA:  MOVWF  FF7
10FCC:  MOVLW  00
10FCE:  MOVWF  FF8
10FD0:  MOVLW  07
10FD2:  MOVLB  8
10FD4:  MOVWF  xD5
10FD6:  MOVLB  0
10FD8:  CALL   AAF6
10FDC:  MOVLW  10
10FDE:  MOVWF  FE9
10FE0:  MOVFF  350,8E1
10FE4:  MOVFF  34F,8E0
10FE8:  CALL   AB28
10FEC:  MOVLW  DF
10FEE:  MOVWF  FF6
10FF0:  MOVLW  1D
10FF2:  MOVWF  FF7
10FF4:  MOVLW  00
10FF6:  MOVWF  FF8
10FF8:  MOVLW  07
10FFA:  MOVLB  8
10FFC:  MOVWF  xD5
10FFE:  MOVLB  0
11000:  CALL   AAF6
11004:  MOVLW  10
11006:  MOVWF  FE9
11008:  MOVFF  352,8E1
1100C:  MOVFF  351,8E0
11010:  CALL   AB28
11014:  MOVLW  E9
11016:  MOVWF  FF6
11018:  MOVLW  1D
1101A:  MOVWF  FF7
1101C:  MOVLW  00
1101E:  MOVWF  FF8
11020:  MOVLW  09
11022:  MOVLB  8
11024:  MOVWF  xD5
11026:  MOVLB  0
11028:  CALL   AAF6
1102C:  MOVLW  89
1102E:  MOVWF  FE9
11030:  MOVFF  3AC,8BC
11034:  MOVFF  3AB,8BB
11038:  MOVFF  3AA,8BA
1103C:  MOVFF  3A9,8B9
11040:  MOVLW  04
11042:  MOVLB  8
11044:  MOVWF  xBD
11046:  MOVLB  0
11048:  RCALL  109E6
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
1104A:  MOVF   1F,W
1104C:  SUBLW  02
1104E:  BNZ   11054
11050:  MOVF   20,F
11052:  BZ    11094
11054:  MOVLW  F8
11056:  MOVWF  FF6
11058:  MOVLW  1D
1105A:  MOVWF  FF7
1105C:  MOVLW  00
1105E:  MOVWF  FF8
11060:  CLRF   1B
11062:  BTFSC  FF2.7
11064:  BSF    1B.7
11066:  BCF    FF2.7
11068:  MOVLW  09
1106A:  MOVLB  A
1106C:  MOVWF  x25
1106E:  MOVLB  0
11070:  CALL   1010
11074:  BTFSC  1B.7
11076:  BSF    FF2.7
11078:  MOVLW  04
1107A:  MOVWF  FEA
1107C:  MOVLW  21
1107E:  MOVWF  FE9
11080:  CALL   79CE
11084:  MOVLW  0D
11086:  BTFSS  F9E.4
11088:  BRA    11086
1108A:  MOVWF  FAD
1108C:  MOVLW  0A
1108E:  BTFSS  F9E.4
11090:  BRA    1108E
11092:  MOVWF  FAD
11094:  GOTO   123A0 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
11098:  MOVLB  8
1109A:  CLRF   xAC
1109C:  MOVF   xAC,W
1109E:  SUBLW  03
110A0:  BNC   110C0
110A2:  MOVF   xAC,W
110A4:  MULLW  04
110A6:  MOVF   FF3,W
110A8:  CLRF   03
110AA:  ADDLW  B1
110AC:  MOVWF  FE9
110AE:  MOVLW  03
110B0:  ADDWFC 03,W
110B2:  MOVWF  FEA
110B4:  CLRF   FEF
110B6:  CLRF   FEC
110B8:  CLRF   FEC
110BA:  CLRF   FEC
110BC:  INCF   xAC,F
110BE:  BRA    1109C
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
110C0:  MOVLB  3
110C2:  MOVF   x59,F
110C4:  BTFSS  FD8.2
110C6:  BRA    110CC
110C8:  MOVF   x5A,F
110CA:  BZ    11166
110CC:  MOVF   x5B,F
110CE:  BNZ   110D4
110D0:  MOVF   x5C,F
110D2:  BZ    11166
....................       blank = NO2_array[0]; 
110D4:  MOVFF  35A,902
110D8:  MOVFF  359,901
110DC:  MOVLB  0
110DE:  CALL   C68E
110E2:  MOVFF  03,8B0
110E6:  MOVFF  02,8AF
110EA:  MOVFF  01,8AE
110EE:  MOVFF  00,8AD
....................       react = NO2_array[1]; 
110F2:  MOVFF  35C,902
110F6:  MOVFF  35B,901
110FA:  CALL   C68E
110FE:  MOVFF  03,8B4
11102:  MOVFF  02,8B3
11106:  MOVFF  01,8B2
1110A:  MOVFF  00,8B1
....................       ratio = blank / react; 
1110E:  MOVFF  8B0,8E8
11112:  MOVFF  8AF,8E7
11116:  MOVFF  8AE,8E6
1111A:  MOVFF  8AD,8E5
1111E:  MOVFF  8B4,8EC
11122:  MOVFF  8B3,8EB
11126:  MOVFF  8B2,8EA
1112A:  MOVFF  8B1,8E9
1112E:  CALL   C6C4
11132:  MOVFF  03,8B8
11136:  MOVFF  02,8B7
1113A:  MOVFF  01,8B6
1113E:  MOVFF  00,8B5
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
11142:  MOVFF  8B8,8BC
11146:  MOVFF  8B7,8BB
1114A:  MOVFF  8B6,8BA
1114E:  MOVFF  8B5,8B9
11152:  RCALL  1097A
11154:  MOVFF  03,3B4
11158:  MOVFF  02,3B3
1115C:  MOVFF  01,3B2
11160:  MOVFF  00,3B1
11164:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
11166:  MOVF   x5D,F
11168:  BNZ   1116E
1116A:  MOVF   x5E,F
1116C:  BZ    1120A
1116E:  MOVF   x5F,F
11170:  BNZ   11176
11172:  MOVF   x60,F
11174:  BZ    1120A
....................       blank = NO2_array[2]; 
11176:  MOVFF  35E,902
1117A:  MOVFF  35D,901
1117E:  MOVLB  0
11180:  CALL   C68E
11184:  MOVFF  03,8B0
11188:  MOVFF  02,8AF
1118C:  MOVFF  01,8AE
11190:  MOVFF  00,8AD
....................       react = NO2_array[3]; 
11194:  MOVFF  360,902
11198:  MOVFF  35F,901
1119C:  CALL   C68E
111A0:  MOVFF  03,8B4
111A4:  MOVFF  02,8B3
111A8:  MOVFF  01,8B2
111AC:  MOVFF  00,8B1
....................       ratio = blank / react;    
111B0:  MOVFF  8B0,8E8
111B4:  MOVFF  8AF,8E7
111B8:  MOVFF  8AE,8E6
111BC:  MOVFF  8AD,8E5
111C0:  MOVFF  8B4,8EC
111C4:  MOVFF  8B3,8EB
111C8:  MOVFF  8B2,8EA
111CC:  MOVFF  8B1,8E9
111D0:  CALL   C6C4
111D4:  MOVFF  03,8B8
111D8:  MOVFF  02,8B7
111DC:  MOVFF  01,8B6
111E0:  MOVFF  00,8B5
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
111E4:  MOVFF  8B8,8BC
111E8:  MOVFF  8B7,8BB
111EC:  MOVFF  8B6,8BA
111F0:  MOVFF  8B5,8B9
111F4:  CALL   1097A
111F8:  MOVFF  03,3B8
111FC:  MOVFF  02,3B7
11200:  MOVFF  01,3B6
11204:  MOVFF  00,3B5
11208:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
1120A:  MOVF   x61,F
1120C:  BNZ   11212
1120E:  MOVF   x62,F
11210:  BZ    112AE
11212:  MOVF   x63,F
11214:  BNZ   1121A
11216:  MOVF   x64,F
11218:  BZ    112AE
....................       blank = NO2_array[4]; 
1121A:  MOVFF  362,902
1121E:  MOVFF  361,901
11222:  MOVLB  0
11224:  CALL   C68E
11228:  MOVFF  03,8B0
1122C:  MOVFF  02,8AF
11230:  MOVFF  01,8AE
11234:  MOVFF  00,8AD
....................       react = NO2_array[5]; 
11238:  MOVFF  364,902
1123C:  MOVFF  363,901
11240:  CALL   C68E
11244:  MOVFF  03,8B4
11248:  MOVFF  02,8B3
1124C:  MOVFF  01,8B2
11250:  MOVFF  00,8B1
....................       ratio = blank / react; 
11254:  MOVFF  8B0,8E8
11258:  MOVFF  8AF,8E7
1125C:  MOVFF  8AE,8E6
11260:  MOVFF  8AD,8E5
11264:  MOVFF  8B4,8EC
11268:  MOVFF  8B3,8EB
1126C:  MOVFF  8B2,8EA
11270:  MOVFF  8B1,8E9
11274:  CALL   C6C4
11278:  MOVFF  03,8B8
1127C:  MOVFF  02,8B7
11280:  MOVFF  01,8B6
11284:  MOVFF  00,8B5
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
11288:  MOVFF  8B8,8BC
1128C:  MOVFF  8B7,8BB
11290:  MOVFF  8B6,8BA
11294:  MOVFF  8B5,8B9
11298:  CALL   1097A
1129C:  MOVFF  03,3BC
112A0:  MOVFF  02,3BB
112A4:  MOVFF  01,3BA
112A8:  MOVFF  00,3B9
112AC:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
112AE:  MOVF   x65,F
112B0:  BNZ   112B6
112B2:  MOVF   x66,F
112B4:  BZ    11352
112B6:  MOVF   x67,F
112B8:  BNZ   112BE
112BA:  MOVF   x68,F
112BC:  BZ    11352
....................       blank = NO2_array[6]; 
112BE:  MOVFF  366,902
112C2:  MOVFF  365,901
112C6:  MOVLB  0
112C8:  CALL   C68E
112CC:  MOVFF  03,8B0
112D0:  MOVFF  02,8AF
112D4:  MOVFF  01,8AE
112D8:  MOVFF  00,8AD
....................       react = NO2_array[7]; 
112DC:  MOVFF  368,902
112E0:  MOVFF  367,901
112E4:  CALL   C68E
112E8:  MOVFF  03,8B4
112EC:  MOVFF  02,8B3
112F0:  MOVFF  01,8B2
112F4:  MOVFF  00,8B1
....................       ratio = blank / react; 
112F8:  MOVFF  8B0,8E8
112FC:  MOVFF  8AF,8E7
11300:  MOVFF  8AE,8E6
11304:  MOVFF  8AD,8E5
11308:  MOVFF  8B4,8EC
1130C:  MOVFF  8B3,8EB
11310:  MOVFF  8B2,8EA
11314:  MOVFF  8B1,8E9
11318:  CALL   C6C4
1131C:  MOVFF  03,8B8
11320:  MOVFF  02,8B7
11324:  MOVFF  01,8B6
11328:  MOVFF  00,8B5
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
1132C:  MOVFF  8B8,8BC
11330:  MOVFF  8B7,8BB
11334:  MOVFF  8B6,8BA
11338:  MOVFF  8B5,8B9
1133C:  CALL   1097A
11340:  MOVFF  03,3C0
11344:  MOVFF  02,3BF
11348:  MOVFF  01,3BE
1134C:  MOVFF  00,3BD
11350:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
11352:  MOVLW  04
11354:  MOVWF  1E
11356:  MOVLW  21
11358:  MOVWF  1D
1135A:  MOVLW  06
1135C:  MOVWF  FF6
1135E:  MOVLW  1E
11360:  MOVWF  FF7
11362:  MOVLW  00
11364:  MOVWF  FF8
11366:  MOVLW  06
11368:  MOVLB  8
1136A:  MOVWF  xD5
1136C:  MOVLB  0
1136E:  CALL   AAF6
11372:  MOVLW  10
11374:  MOVWF  FE9
11376:  MOVFF  35A,8E1
1137A:  MOVFF  359,8E0
1137E:  CALL   AB28
11382:  MOVLW  0F
11384:  MOVWF  FF6
11386:  MOVLW  1E
11388:  MOVWF  FF7
1138A:  MOVLW  00
1138C:  MOVWF  FF8
1138E:  MOVLW  07
11390:  MOVLB  8
11392:  MOVWF  xD5
11394:  MOVLB  0
11396:  CALL   AAF6
1139A:  MOVLW  10
1139C:  MOVWF  FE9
1139E:  MOVFF  35C,8E1
113A2:  MOVFF  35B,8E0
113A6:  CALL   AB28
113AA:  MOVLW  19
113AC:  MOVWF  FF6
113AE:  MOVLW  1E
113B0:  MOVWF  FF7
113B2:  MOVLW  00
113B4:  MOVWF  FF8
113B6:  MOVLW  09
113B8:  MOVLB  8
113BA:  MOVWF  xD5
113BC:  MOVLB  0
113BE:  CALL   AAF6
113C2:  MOVLW  89
113C4:  MOVWF  FE9
113C6:  MOVFF  3B4,8BC
113CA:  MOVFF  3B3,8BB
113CE:  MOVFF  3B2,8BA
113D2:  MOVFF  3B1,8B9
113D6:  MOVLW  04
113D8:  MOVLB  8
113DA:  MOVWF  xBD
113DC:  MOVLB  0
113DE:  CALL   109E6
113E2:  MOVLW  27
113E4:  MOVWF  FF6
113E6:  MOVLW  1E
113E8:  MOVWF  FF7
113EA:  MOVLW  00
113EC:  MOVWF  FF8
113EE:  MOVLW  07
113F0:  MOVLB  8
113F2:  MOVWF  xD5
113F4:  MOVLB  0
113F6:  CALL   AAF6
113FA:  MOVLW  10
113FC:  MOVWF  FE9
113FE:  MOVFF  35E,8E1
11402:  MOVFF  35D,8E0
11406:  CALL   AB28
1140A:  MOVLW  31
1140C:  MOVWF  FF6
1140E:  MOVLW  1E
11410:  MOVWF  FF7
11412:  MOVLW  00
11414:  MOVWF  FF8
11416:  MOVLW  07
11418:  MOVLB  8
1141A:  MOVWF  xD5
1141C:  MOVLB  0
1141E:  CALL   AAF6
11422:  MOVLW  10
11424:  MOVWF  FE9
11426:  MOVFF  360,8E1
1142A:  MOVFF  35F,8E0
1142E:  CALL   AB28
11432:  MOVLW  3B
11434:  MOVWF  FF6
11436:  MOVLW  1E
11438:  MOVWF  FF7
1143A:  MOVLW  00
1143C:  MOVWF  FF8
1143E:  MOVLW  09
11440:  MOVLB  8
11442:  MOVWF  xD5
11444:  MOVLB  0
11446:  CALL   AAF6
1144A:  MOVLW  89
1144C:  MOVWF  FE9
1144E:  MOVFF  3B8,8BC
11452:  MOVFF  3B7,8BB
11456:  MOVFF  3B6,8BA
1145A:  MOVFF  3B5,8B9
1145E:  MOVLW  04
11460:  MOVLB  8
11462:  MOVWF  xBD
11464:  MOVLB  0
11466:  CALL   109E6
1146A:  MOVLW  49
1146C:  MOVWF  FF6
1146E:  MOVLW  1E
11470:  MOVWF  FF7
11472:  MOVLW  00
11474:  MOVWF  FF8
11476:  MOVLW  07
11478:  MOVLB  8
1147A:  MOVWF  xD5
1147C:  MOVLB  0
1147E:  CALL   AAF6
11482:  MOVLW  10
11484:  MOVWF  FE9
11486:  MOVFF  362,8E1
1148A:  MOVFF  361,8E0
1148E:  CALL   AB28
11492:  MOVLW  53
11494:  MOVWF  FF6
11496:  MOVLW  1E
11498:  MOVWF  FF7
1149A:  MOVLW  00
1149C:  MOVWF  FF8
1149E:  MOVLW  07
114A0:  MOVLB  8
114A2:  MOVWF  xD5
114A4:  MOVLB  0
114A6:  CALL   AAF6
114AA:  MOVLW  10
114AC:  MOVWF  FE9
114AE:  MOVFF  364,8E1
114B2:  MOVFF  363,8E0
114B6:  CALL   AB28
114BA:  MOVLW  5D
114BC:  MOVWF  FF6
114BE:  MOVLW  1E
114C0:  MOVWF  FF7
114C2:  MOVLW  00
114C4:  MOVWF  FF8
114C6:  MOVLW  09
114C8:  MOVLB  8
114CA:  MOVWF  xD5
114CC:  MOVLB  0
114CE:  CALL   AAF6
114D2:  MOVLW  89
114D4:  MOVWF  FE9
114D6:  MOVFF  3BC,8BC
114DA:  MOVFF  3BB,8BB
114DE:  MOVFF  3BA,8BA
114E2:  MOVFF  3B9,8B9
114E6:  MOVLW  04
114E8:  MOVLB  8
114EA:  MOVWF  xBD
114EC:  MOVLB  0
114EE:  CALL   109E6
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
114F2:  MOVF   1F,W
114F4:  SUBLW  02
114F6:  BNZ   114FC
114F8:  MOVF   20,F
114FA:  BZ    1153C
114FC:  MOVLW  6C
114FE:  MOVWF  FF6
11500:  MOVLW  1E
11502:  MOVWF  FF7
11504:  MOVLW  00
11506:  MOVWF  FF8
11508:  CLRF   1B
1150A:  BTFSC  FF2.7
1150C:  BSF    1B.7
1150E:  BCF    FF2.7
11510:  MOVLW  09
11512:  MOVLB  A
11514:  MOVWF  x25
11516:  MOVLB  0
11518:  CALL   1010
1151C:  BTFSC  1B.7
1151E:  BSF    FF2.7
11520:  MOVLW  04
11522:  MOVWF  FEA
11524:  MOVLW  21
11526:  MOVWF  FE9
11528:  CALL   79CE
1152C:  MOVLW  0D
1152E:  BTFSS  F9E.4
11530:  BRA    1152E
11532:  MOVWF  FAD
11534:  MOVLW  0A
11536:  BTFSS  F9E.4
11538:  BRA    11536
1153A:  MOVWF  FAD
1153C:  GOTO   123A0 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
11540:  MOVLB  8
11542:  CLRF   xAC
11544:  MOVF   xAC,W
11546:  SUBLW  03
11548:  BNC   11568
1154A:  MOVF   xAC,W
1154C:  MULLW  04
1154E:  MOVF   FF3,W
11550:  CLRF   03
11552:  ADDLW  C1
11554:  MOVWF  FE9
11556:  MOVLW  03
11558:  ADDWFC 03,W
1155A:  MOVWF  FEA
1155C:  CLRF   FEF
1155E:  CLRF   FEC
11560:  CLRF   FEC
11562:  CLRF   FEC
11564:  INCF   xAC,F
11566:  BRA    11544
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
11568:  MOVLB  3
1156A:  MOVF   x6B,F
1156C:  BTFSS  FD8.2
1156E:  BRA    11574
11570:  MOVF   x6C,F
11572:  BZ    11610
11574:  MOVF   x6D,F
11576:  BNZ   1157C
11578:  MOVF   x6E,F
1157A:  BZ    11610
....................       blank = PO4_array[0]; 
1157C:  MOVFF  36C,902
11580:  MOVFF  36B,901
11584:  MOVLB  0
11586:  CALL   C68E
1158A:  MOVFF  03,8B0
1158E:  MOVFF  02,8AF
11592:  MOVFF  01,8AE
11596:  MOVFF  00,8AD
....................       react = PO4_array[1]; 
1159A:  MOVFF  36E,902
1159E:  MOVFF  36D,901
115A2:  CALL   C68E
115A6:  MOVFF  03,8B4
115AA:  MOVFF  02,8B3
115AE:  MOVFF  01,8B2
115B2:  MOVFF  00,8B1
....................       ratio = blank / react; 
115B6:  MOVFF  8B0,8E8
115BA:  MOVFF  8AF,8E7
115BE:  MOVFF  8AE,8E6
115C2:  MOVFF  8AD,8E5
115C6:  MOVFF  8B4,8EC
115CA:  MOVFF  8B3,8EB
115CE:  MOVFF  8B2,8EA
115D2:  MOVFF  8B1,8E9
115D6:  CALL   C6C4
115DA:  MOVFF  03,8B8
115DE:  MOVFF  02,8B7
115E2:  MOVFF  01,8B6
115E6:  MOVFF  00,8B5
....................       PO4_abs_array[0] = log10(ratio); 
115EA:  MOVFF  8B8,8BC
115EE:  MOVFF  8B7,8BB
115F2:  MOVFF  8B6,8BA
115F6:  MOVFF  8B5,8B9
115FA:  CALL   1097A
115FE:  MOVFF  03,3C4
11602:  MOVFF  02,3C3
11606:  MOVFF  01,3C2
1160A:  MOVFF  00,3C1
1160E:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
11610:  MOVF   x6F,F
11612:  BNZ   11618
11614:  MOVF   x70,F
11616:  BZ    116B4
11618:  MOVF   x71,F
1161A:  BNZ   11620
1161C:  MOVF   x72,F
1161E:  BZ    116B4
....................       blank = PO4_array[2]; 
11620:  MOVFF  370,902
11624:  MOVFF  36F,901
11628:  MOVLB  0
1162A:  CALL   C68E
1162E:  MOVFF  03,8B0
11632:  MOVFF  02,8AF
11636:  MOVFF  01,8AE
1163A:  MOVFF  00,8AD
....................       react = PO4_array[3]; 
1163E:  MOVFF  372,902
11642:  MOVFF  371,901
11646:  CALL   C68E
1164A:  MOVFF  03,8B4
1164E:  MOVFF  02,8B3
11652:  MOVFF  01,8B2
11656:  MOVFF  00,8B1
....................       ratio = blank / react;    
1165A:  MOVFF  8B0,8E8
1165E:  MOVFF  8AF,8E7
11662:  MOVFF  8AE,8E6
11666:  MOVFF  8AD,8E5
1166A:  MOVFF  8B4,8EC
1166E:  MOVFF  8B3,8EB
11672:  MOVFF  8B2,8EA
11676:  MOVFF  8B1,8E9
1167A:  CALL   C6C4
1167E:  MOVFF  03,8B8
11682:  MOVFF  02,8B7
11686:  MOVFF  01,8B6
1168A:  MOVFF  00,8B5
....................       PO4_abs_array[1] = log10(ratio); 
1168E:  MOVFF  8B8,8BC
11692:  MOVFF  8B7,8BB
11696:  MOVFF  8B6,8BA
1169A:  MOVFF  8B5,8B9
1169E:  CALL   1097A
116A2:  MOVFF  03,3C8
116A6:  MOVFF  02,3C7
116AA:  MOVFF  01,3C6
116AE:  MOVFF  00,3C5
116B2:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
116B4:  MOVF   x73,F
116B6:  BNZ   116BC
116B8:  MOVF   x74,F
116BA:  BZ    11758
116BC:  MOVF   x75,F
116BE:  BNZ   116C4
116C0:  MOVF   x76,F
116C2:  BZ    11758
....................       blank = PO4_array[4]; 
116C4:  MOVFF  374,902
116C8:  MOVFF  373,901
116CC:  MOVLB  0
116CE:  CALL   C68E
116D2:  MOVFF  03,8B0
116D6:  MOVFF  02,8AF
116DA:  MOVFF  01,8AE
116DE:  MOVFF  00,8AD
....................       react = PO4_array[5]; 
116E2:  MOVFF  376,902
116E6:  MOVFF  375,901
116EA:  CALL   C68E
116EE:  MOVFF  03,8B4
116F2:  MOVFF  02,8B3
116F6:  MOVFF  01,8B2
116FA:  MOVFF  00,8B1
....................       ratio = blank / react; 
116FE:  MOVFF  8B0,8E8
11702:  MOVFF  8AF,8E7
11706:  MOVFF  8AE,8E6
1170A:  MOVFF  8AD,8E5
1170E:  MOVFF  8B4,8EC
11712:  MOVFF  8B3,8EB
11716:  MOVFF  8B2,8EA
1171A:  MOVFF  8B1,8E9
1171E:  CALL   C6C4
11722:  MOVFF  03,8B8
11726:  MOVFF  02,8B7
1172A:  MOVFF  01,8B6
1172E:  MOVFF  00,8B5
....................       PO4_abs_array[2] = log10(ratio); 
11732:  MOVFF  8B8,8BC
11736:  MOVFF  8B7,8BB
1173A:  MOVFF  8B6,8BA
1173E:  MOVFF  8B5,8B9
11742:  CALL   1097A
11746:  MOVFF  03,3CC
1174A:  MOVFF  02,3CB
1174E:  MOVFF  01,3CA
11752:  MOVFF  00,3C9
11756:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
11758:  MOVF   x77,F
1175A:  BNZ   11760
1175C:  MOVF   x78,F
1175E:  BZ    117FC
11760:  MOVF   x79,F
11762:  BNZ   11768
11764:  MOVF   x7A,F
11766:  BZ    117FC
....................       blank = PO4_array[6]; 
11768:  MOVFF  378,902
1176C:  MOVFF  377,901
11770:  MOVLB  0
11772:  CALL   C68E
11776:  MOVFF  03,8B0
1177A:  MOVFF  02,8AF
1177E:  MOVFF  01,8AE
11782:  MOVFF  00,8AD
....................       react = PO4_array[7]; 
11786:  MOVFF  37A,902
1178A:  MOVFF  379,901
1178E:  CALL   C68E
11792:  MOVFF  03,8B4
11796:  MOVFF  02,8B3
1179A:  MOVFF  01,8B2
1179E:  MOVFF  00,8B1
....................       ratio = blank / react; 
117A2:  MOVFF  8B0,8E8
117A6:  MOVFF  8AF,8E7
117AA:  MOVFF  8AE,8E6
117AE:  MOVFF  8AD,8E5
117B2:  MOVFF  8B4,8EC
117B6:  MOVFF  8B3,8EB
117BA:  MOVFF  8B2,8EA
117BE:  MOVFF  8B1,8E9
117C2:  CALL   C6C4
117C6:  MOVFF  03,8B8
117CA:  MOVFF  02,8B7
117CE:  MOVFF  01,8B6
117D2:  MOVFF  00,8B5
....................       PO4_abs_array[3] = log10(ratio); 
117D6:  MOVFF  8B8,8BC
117DA:  MOVFF  8B7,8BB
117DE:  MOVFF  8B6,8BA
117E2:  MOVFF  8B5,8B9
117E6:  CALL   1097A
117EA:  MOVFF  03,3D0
117EE:  MOVFF  02,3CF
117F2:  MOVFF  01,3CE
117F6:  MOVFF  00,3CD
117FA:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
117FC:  MOVLW  04
117FE:  MOVWF  1E
11800:  MOVLW  21
11802:  MOVWF  1D
11804:  MOVLW  7A
11806:  MOVWF  FF6
11808:  MOVLW  1E
1180A:  MOVWF  FF7
1180C:  MOVLW  00
1180E:  MOVWF  FF8
11810:  MOVLW  06
11812:  MOVLB  8
11814:  MOVWF  xD5
11816:  MOVLB  0
11818:  CALL   AAF6
1181C:  MOVLW  10
1181E:  MOVWF  FE9
11820:  MOVFF  36C,8E1
11824:  MOVFF  36B,8E0
11828:  CALL   AB28
1182C:  MOVLW  83
1182E:  MOVWF  FF6
11830:  MOVLW  1E
11832:  MOVWF  FF7
11834:  MOVLW  00
11836:  MOVWF  FF8
11838:  MOVLW  07
1183A:  MOVLB  8
1183C:  MOVWF  xD5
1183E:  MOVLB  0
11840:  CALL   AAF6
11844:  MOVLW  10
11846:  MOVWF  FE9
11848:  MOVFF  36E,8E1
1184C:  MOVFF  36D,8E0
11850:  CALL   AB28
11854:  MOVLW  8D
11856:  MOVWF  FF6
11858:  MOVLW  1E
1185A:  MOVWF  FF7
1185C:  MOVLW  00
1185E:  MOVWF  FF8
11860:  MOVLW  09
11862:  MOVLB  8
11864:  MOVWF  xD5
11866:  MOVLB  0
11868:  CALL   AAF6
1186C:  MOVLW  89
1186E:  MOVWF  FE9
11870:  MOVFF  3C4,8BC
11874:  MOVFF  3C3,8BB
11878:  MOVFF  3C2,8BA
1187C:  MOVFF  3C1,8B9
11880:  MOVLW  04
11882:  MOVLB  8
11884:  MOVWF  xBD
11886:  MOVLB  0
11888:  CALL   109E6
1188C:  MOVLW  9B
1188E:  MOVWF  FF6
11890:  MOVLW  1E
11892:  MOVWF  FF7
11894:  MOVLW  00
11896:  MOVWF  FF8
11898:  MOVLW  07
1189A:  MOVLB  8
1189C:  MOVWF  xD5
1189E:  MOVLB  0
118A0:  CALL   AAF6
118A4:  MOVLW  10
118A6:  MOVWF  FE9
118A8:  MOVFF  370,8E1
118AC:  MOVFF  36F,8E0
118B0:  CALL   AB28
118B4:  MOVLW  A5
118B6:  MOVWF  FF6
118B8:  MOVLW  1E
118BA:  MOVWF  FF7
118BC:  MOVLW  00
118BE:  MOVWF  FF8
118C0:  MOVLW  07
118C2:  MOVLB  8
118C4:  MOVWF  xD5
118C6:  MOVLB  0
118C8:  CALL   AAF6
118CC:  MOVLW  10
118CE:  MOVWF  FE9
118D0:  MOVFF  372,8E1
118D4:  MOVFF  371,8E0
118D8:  CALL   AB28
118DC:  MOVLW  AF
118DE:  MOVWF  FF6
118E0:  MOVLW  1E
118E2:  MOVWF  FF7
118E4:  MOVLW  00
118E6:  MOVWF  FF8
118E8:  MOVLW  09
118EA:  MOVLB  8
118EC:  MOVWF  xD5
118EE:  MOVLB  0
118F0:  CALL   AAF6
118F4:  MOVLW  89
118F6:  MOVWF  FE9
118F8:  MOVFF  3C8,8BC
118FC:  MOVFF  3C7,8BB
11900:  MOVFF  3C6,8BA
11904:  MOVFF  3C5,8B9
11908:  MOVLW  04
1190A:  MOVLB  8
1190C:  MOVWF  xBD
1190E:  MOVLB  0
11910:  CALL   109E6
11914:  MOVLW  BD
11916:  MOVWF  FF6
11918:  MOVLW  1E
1191A:  MOVWF  FF7
1191C:  MOVLW  00
1191E:  MOVWF  FF8
11920:  MOVLW  07
11922:  MOVLB  8
11924:  MOVWF  xD5
11926:  MOVLB  0
11928:  CALL   AAF6
1192C:  MOVLW  10
1192E:  MOVWF  FE9
11930:  MOVFF  374,8E1
11934:  MOVFF  373,8E0
11938:  CALL   AB28
1193C:  MOVLW  C7
1193E:  MOVWF  FF6
11940:  MOVLW  1E
11942:  MOVWF  FF7
11944:  MOVLW  00
11946:  MOVWF  FF8
11948:  MOVLW  07
1194A:  MOVLB  8
1194C:  MOVWF  xD5
1194E:  MOVLB  0
11950:  CALL   AAF6
11954:  MOVLW  10
11956:  MOVWF  FE9
11958:  MOVFF  376,8E1
1195C:  MOVFF  375,8E0
11960:  CALL   AB28
11964:  MOVLW  D1
11966:  MOVWF  FF6
11968:  MOVLW  1E
1196A:  MOVWF  FF7
1196C:  MOVLW  00
1196E:  MOVWF  FF8
11970:  MOVLW  09
11972:  MOVLB  8
11974:  MOVWF  xD5
11976:  MOVLB  0
11978:  CALL   AAF6
1197C:  MOVLW  89
1197E:  MOVWF  FE9
11980:  MOVFF  3CC,8BC
11984:  MOVFF  3CB,8BB
11988:  MOVFF  3CA,8BA
1198C:  MOVFF  3C9,8B9
11990:  MOVLW  04
11992:  MOVLB  8
11994:  MOVWF  xBD
11996:  MOVLB  0
11998:  CALL   109E6
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
1199C:  MOVF   1F,W
1199E:  SUBLW  02
119A0:  BNZ   119A6
119A2:  MOVF   20,F
119A4:  BZ    119E6
119A6:  MOVLW  E0
119A8:  MOVWF  FF6
119AA:  MOVLW  1E
119AC:  MOVWF  FF7
119AE:  MOVLW  00
119B0:  MOVWF  FF8
119B2:  CLRF   1B
119B4:  BTFSC  FF2.7
119B6:  BSF    1B.7
119B8:  BCF    FF2.7
119BA:  MOVLW  09
119BC:  MOVLB  A
119BE:  MOVWF  x25
119C0:  MOVLB  0
119C2:  CALL   1010
119C6:  BTFSC  1B.7
119C8:  BSF    FF2.7
119CA:  MOVLW  04
119CC:  MOVWF  FEA
119CE:  MOVLW  21
119D0:  MOVWF  FE9
119D2:  CALL   79CE
119D6:  MOVLW  0D
119D8:  BTFSS  F9E.4
119DA:  BRA    119D8
119DC:  MOVWF  FAD
119DE:  MOVLW  0A
119E0:  BTFSS  F9E.4
119E2:  BRA    119E0
119E4:  MOVWF  FAD
119E6:  GOTO   123A0 (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
119EA:  MOVLB  8
119EC:  CLRF   xAC
119EE:  MOVF   xAC,W
119F0:  SUBLW  03
119F2:  BNC   11A12
119F4:  MOVF   xAC,W
119F6:  MULLW  04
119F8:  MOVF   FF3,W
119FA:  CLRF   03
119FC:  ADDLW  D1
119FE:  MOVWF  FE9
11A00:  MOVLW  03
11A02:  ADDWFC 03,W
11A04:  MOVWF  FEA
11A06:  CLRF   FEF
11A08:  CLRF   FEC
11A0A:  CLRF   FEC
11A0C:  CLRF   FEC
11A0E:  INCF   xAC,F
11A10:  BRA    119EE
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
11A12:  MOVLB  3
11A14:  MOVF   x7D,F
11A16:  BTFSS  FD8.2
11A18:  BRA    11A1E
11A1A:  MOVF   x7E,F
11A1C:  BZ    11ABA
11A1E:  MOVF   x7F,F
11A20:  BNZ   11A26
11A22:  MOVF   x80,F
11A24:  BZ    11ABA
....................       blank = NH4_array[0]; 
11A26:  MOVFF  37E,902
11A2A:  MOVFF  37D,901
11A2E:  MOVLB  0
11A30:  CALL   C68E
11A34:  MOVFF  03,8B0
11A38:  MOVFF  02,8AF
11A3C:  MOVFF  01,8AE
11A40:  MOVFF  00,8AD
....................       react = NH4_array[1]; 
11A44:  MOVFF  380,902
11A48:  MOVFF  37F,901
11A4C:  CALL   C68E
11A50:  MOVFF  03,8B4
11A54:  MOVFF  02,8B3
11A58:  MOVFF  01,8B2
11A5C:  MOVFF  00,8B1
....................       ratio = blank / react; 
11A60:  MOVFF  8B0,8E8
11A64:  MOVFF  8AF,8E7
11A68:  MOVFF  8AE,8E6
11A6C:  MOVFF  8AD,8E5
11A70:  MOVFF  8B4,8EC
11A74:  MOVFF  8B3,8EB
11A78:  MOVFF  8B2,8EA
11A7C:  MOVFF  8B1,8E9
11A80:  CALL   C6C4
11A84:  MOVFF  03,8B8
11A88:  MOVFF  02,8B7
11A8C:  MOVFF  01,8B6
11A90:  MOVFF  00,8B5
....................       NH4_abs_array[0] = log10(ratio); 
11A94:  MOVFF  8B8,8BC
11A98:  MOVFF  8B7,8BB
11A9C:  MOVFF  8B6,8BA
11AA0:  MOVFF  8B5,8B9
11AA4:  CALL   1097A
11AA8:  MOVFF  03,3D4
11AAC:  MOVFF  02,3D3
11AB0:  MOVFF  01,3D2
11AB4:  MOVFF  00,3D1
11AB8:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
11ABA:  MOVF   x81,F
11ABC:  BNZ   11AC2
11ABE:  MOVF   x82,F
11AC0:  BZ    11B5E
11AC2:  MOVF   x83,F
11AC4:  BNZ   11ACA
11AC6:  MOVF   x84,F
11AC8:  BZ    11B5E
....................       blank = NH4_array[2]; 
11ACA:  MOVFF  382,902
11ACE:  MOVFF  381,901
11AD2:  MOVLB  0
11AD4:  CALL   C68E
11AD8:  MOVFF  03,8B0
11ADC:  MOVFF  02,8AF
11AE0:  MOVFF  01,8AE
11AE4:  MOVFF  00,8AD
....................       react = NH4_array[3]; 
11AE8:  MOVFF  384,902
11AEC:  MOVFF  383,901
11AF0:  CALL   C68E
11AF4:  MOVFF  03,8B4
11AF8:  MOVFF  02,8B3
11AFC:  MOVFF  01,8B2
11B00:  MOVFF  00,8B1
....................       ratio = blank / react;    
11B04:  MOVFF  8B0,8E8
11B08:  MOVFF  8AF,8E7
11B0C:  MOVFF  8AE,8E6
11B10:  MOVFF  8AD,8E5
11B14:  MOVFF  8B4,8EC
11B18:  MOVFF  8B3,8EB
11B1C:  MOVFF  8B2,8EA
11B20:  MOVFF  8B1,8E9
11B24:  CALL   C6C4
11B28:  MOVFF  03,8B8
11B2C:  MOVFF  02,8B7
11B30:  MOVFF  01,8B6
11B34:  MOVFF  00,8B5
....................       NH4_abs_array[1] = log10(ratio); 
11B38:  MOVFF  8B8,8BC
11B3C:  MOVFF  8B7,8BB
11B40:  MOVFF  8B6,8BA
11B44:  MOVFF  8B5,8B9
11B48:  CALL   1097A
11B4C:  MOVFF  03,3D8
11B50:  MOVFF  02,3D7
11B54:  MOVFF  01,3D6
11B58:  MOVFF  00,3D5
11B5C:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
11B5E:  MOVF   x85,F
11B60:  BNZ   11B66
11B62:  MOVF   x86,F
11B64:  BZ    11C02
11B66:  MOVF   x87,F
11B68:  BNZ   11B6E
11B6A:  MOVF   x88,F
11B6C:  BZ    11C02
....................       blank = NH4_array[4]; 
11B6E:  MOVFF  386,902
11B72:  MOVFF  385,901
11B76:  MOVLB  0
11B78:  CALL   C68E
11B7C:  MOVFF  03,8B0
11B80:  MOVFF  02,8AF
11B84:  MOVFF  01,8AE
11B88:  MOVFF  00,8AD
....................       react = NH4_array[5]; 
11B8C:  MOVFF  388,902
11B90:  MOVFF  387,901
11B94:  CALL   C68E
11B98:  MOVFF  03,8B4
11B9C:  MOVFF  02,8B3
11BA0:  MOVFF  01,8B2
11BA4:  MOVFF  00,8B1
....................       ratio = blank / react; 
11BA8:  MOVFF  8B0,8E8
11BAC:  MOVFF  8AF,8E7
11BB0:  MOVFF  8AE,8E6
11BB4:  MOVFF  8AD,8E5
11BB8:  MOVFF  8B4,8EC
11BBC:  MOVFF  8B3,8EB
11BC0:  MOVFF  8B2,8EA
11BC4:  MOVFF  8B1,8E9
11BC8:  CALL   C6C4
11BCC:  MOVFF  03,8B8
11BD0:  MOVFF  02,8B7
11BD4:  MOVFF  01,8B6
11BD8:  MOVFF  00,8B5
....................       NH4_abs_array[2] = log10(ratio); 
11BDC:  MOVFF  8B8,8BC
11BE0:  MOVFF  8B7,8BB
11BE4:  MOVFF  8B6,8BA
11BE8:  MOVFF  8B5,8B9
11BEC:  CALL   1097A
11BF0:  MOVFF  03,3DC
11BF4:  MOVFF  02,3DB
11BF8:  MOVFF  01,3DA
11BFC:  MOVFF  00,3D9
11C00:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11C02:  MOVF   x89,F
11C04:  BNZ   11C0A
11C06:  MOVF   x8A,F
11C08:  BZ    11CA6
11C0A:  MOVF   x8B,F
11C0C:  BNZ   11C12
11C0E:  MOVF   x8C,F
11C10:  BZ    11CA6
....................       blank = NH4_array[6]; 
11C12:  MOVFF  38A,902
11C16:  MOVFF  389,901
11C1A:  MOVLB  0
11C1C:  CALL   C68E
11C20:  MOVFF  03,8B0
11C24:  MOVFF  02,8AF
11C28:  MOVFF  01,8AE
11C2C:  MOVFF  00,8AD
....................       react = NH4_array[7]; 
11C30:  MOVFF  38C,902
11C34:  MOVFF  38B,901
11C38:  CALL   C68E
11C3C:  MOVFF  03,8B4
11C40:  MOVFF  02,8B3
11C44:  MOVFF  01,8B2
11C48:  MOVFF  00,8B1
....................       ratio = blank / react; 
11C4C:  MOVFF  8B0,8E8
11C50:  MOVFF  8AF,8E7
11C54:  MOVFF  8AE,8E6
11C58:  MOVFF  8AD,8E5
11C5C:  MOVFF  8B4,8EC
11C60:  MOVFF  8B3,8EB
11C64:  MOVFF  8B2,8EA
11C68:  MOVFF  8B1,8E9
11C6C:  CALL   C6C4
11C70:  MOVFF  03,8B8
11C74:  MOVFF  02,8B7
11C78:  MOVFF  01,8B6
11C7C:  MOVFF  00,8B5
....................       NH4_abs_array[3] = log10(ratio); 
11C80:  MOVFF  8B8,8BC
11C84:  MOVFF  8B7,8BB
11C88:  MOVFF  8B6,8BA
11C8C:  MOVFF  8B5,8B9
11C90:  CALL   1097A
11C94:  MOVFF  03,3E0
11C98:  MOVFF  02,3DF
11C9C:  MOVFF  01,3DE
11CA0:  MOVFF  00,3DD
11CA4:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11CA6:  MOVLW  04
11CA8:  MOVWF  1E
11CAA:  MOVLW  21
11CAC:  MOVWF  1D
11CAE:  MOVLW  EE
11CB0:  MOVWF  FF6
11CB2:  MOVLW  1E
11CB4:  MOVWF  FF7
11CB6:  MOVLW  00
11CB8:  MOVWF  FF8
11CBA:  MOVLW  06
11CBC:  MOVLB  8
11CBE:  MOVWF  xD5
11CC0:  MOVLB  0
11CC2:  CALL   AAF6
11CC6:  MOVLW  10
11CC8:  MOVWF  FE9
11CCA:  MOVFF  37E,8E1
11CCE:  MOVFF  37D,8E0
11CD2:  CALL   AB28
11CD6:  MOVLW  F7
11CD8:  MOVWF  FF6
11CDA:  MOVLW  1E
11CDC:  MOVWF  FF7
11CDE:  MOVLW  00
11CE0:  MOVWF  FF8
11CE2:  MOVLW  07
11CE4:  MOVLB  8
11CE6:  MOVWF  xD5
11CE8:  MOVLB  0
11CEA:  CALL   AAF6
11CEE:  MOVLW  10
11CF0:  MOVWF  FE9
11CF2:  MOVFF  380,8E1
11CF6:  MOVFF  37F,8E0
11CFA:  CALL   AB28
11CFE:  MOVLW  01
11D00:  MOVWF  FF6
11D02:  MOVLW  1F
11D04:  MOVWF  FF7
11D06:  MOVLW  00
11D08:  MOVWF  FF8
11D0A:  MOVLW  09
11D0C:  MOVLB  8
11D0E:  MOVWF  xD5
11D10:  MOVLB  0
11D12:  CALL   AAF6
11D16:  MOVLW  89
11D18:  MOVWF  FE9
11D1A:  MOVFF  3D4,8BC
11D1E:  MOVFF  3D3,8BB
11D22:  MOVFF  3D2,8BA
11D26:  MOVFF  3D1,8B9
11D2A:  MOVLW  04
11D2C:  MOVLB  8
11D2E:  MOVWF  xBD
11D30:  MOVLB  0
11D32:  CALL   109E6
11D36:  MOVLW  0F
11D38:  MOVWF  FF6
11D3A:  MOVLW  1F
11D3C:  MOVWF  FF7
11D3E:  MOVLW  00
11D40:  MOVWF  FF8
11D42:  MOVLW  07
11D44:  MOVLB  8
11D46:  MOVWF  xD5
11D48:  MOVLB  0
11D4A:  CALL   AAF6
11D4E:  MOVLW  10
11D50:  MOVWF  FE9
11D52:  MOVFF  382,8E1
11D56:  MOVFF  381,8E0
11D5A:  CALL   AB28
11D5E:  MOVLW  19
11D60:  MOVWF  FF6
11D62:  MOVLW  1F
11D64:  MOVWF  FF7
11D66:  MOVLW  00
11D68:  MOVWF  FF8
11D6A:  MOVLW  07
11D6C:  MOVLB  8
11D6E:  MOVWF  xD5
11D70:  MOVLB  0
11D72:  CALL   AAF6
11D76:  MOVLW  10
11D78:  MOVWF  FE9
11D7A:  MOVFF  384,8E1
11D7E:  MOVFF  383,8E0
11D82:  CALL   AB28
11D86:  MOVLW  23
11D88:  MOVWF  FF6
11D8A:  MOVLW  1F
11D8C:  MOVWF  FF7
11D8E:  MOVLW  00
11D90:  MOVWF  FF8
11D92:  MOVLW  09
11D94:  MOVLB  8
11D96:  MOVWF  xD5
11D98:  MOVLB  0
11D9A:  CALL   AAF6
11D9E:  MOVLW  89
11DA0:  MOVWF  FE9
11DA2:  MOVFF  3D8,8BC
11DA6:  MOVFF  3D7,8BB
11DAA:  MOVFF  3D6,8BA
11DAE:  MOVFF  3D5,8B9
11DB2:  MOVLW  04
11DB4:  MOVLB  8
11DB6:  MOVWF  xBD
11DB8:  MOVLB  0
11DBA:  CALL   109E6
11DBE:  MOVLW  31
11DC0:  MOVWF  FF6
11DC2:  MOVLW  1F
11DC4:  MOVWF  FF7
11DC6:  MOVLW  00
11DC8:  MOVWF  FF8
11DCA:  MOVLW  07
11DCC:  MOVLB  8
11DCE:  MOVWF  xD5
11DD0:  MOVLB  0
11DD2:  CALL   AAF6
11DD6:  MOVLW  10
11DD8:  MOVWF  FE9
11DDA:  MOVFF  386,8E1
11DDE:  MOVFF  385,8E0
11DE2:  CALL   AB28
11DE6:  MOVLW  3B
11DE8:  MOVWF  FF6
11DEA:  MOVLW  1F
11DEC:  MOVWF  FF7
11DEE:  MOVLW  00
11DF0:  MOVWF  FF8
11DF2:  MOVLW  07
11DF4:  MOVLB  8
11DF6:  MOVWF  xD5
11DF8:  MOVLB  0
11DFA:  CALL   AAF6
11DFE:  MOVLW  10
11E00:  MOVWF  FE9
11E02:  MOVFF  388,8E1
11E06:  MOVFF  387,8E0
11E0A:  CALL   AB28
11E0E:  MOVLW  45
11E10:  MOVWF  FF6
11E12:  MOVLW  1F
11E14:  MOVWF  FF7
11E16:  MOVLW  00
11E18:  MOVWF  FF8
11E1A:  MOVLW  09
11E1C:  MOVLB  8
11E1E:  MOVWF  xD5
11E20:  MOVLB  0
11E22:  CALL   AAF6
11E26:  MOVLW  89
11E28:  MOVWF  FE9
11E2A:  MOVFF  3DC,8BC
11E2E:  MOVFF  3DB,8BB
11E32:  MOVFF  3DA,8BA
11E36:  MOVFF  3D9,8B9
11E3A:  MOVLW  04
11E3C:  MOVLB  8
11E3E:  MOVWF  xBD
11E40:  MOVLB  0
11E42:  CALL   109E6
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
11E46:  MOVF   1F,W
11E48:  SUBLW  02
11E4A:  BNZ   11E50
11E4C:  MOVF   20,F
11E4E:  BZ    11E90
11E50:  MOVLW  54
11E52:  MOVWF  FF6
11E54:  MOVLW  1F
11E56:  MOVWF  FF7
11E58:  MOVLW  00
11E5A:  MOVWF  FF8
11E5C:  CLRF   1B
11E5E:  BTFSC  FF2.7
11E60:  BSF    1B.7
11E62:  BCF    FF2.7
11E64:  MOVLW  09
11E66:  MOVLB  A
11E68:  MOVWF  x25
11E6A:  MOVLB  0
11E6C:  CALL   1010
11E70:  BTFSC  1B.7
11E72:  BSF    FF2.7
11E74:  MOVLW  04
11E76:  MOVWF  FEA
11E78:  MOVLW  21
11E7A:  MOVWF  FE9
11E7C:  CALL   79CE
11E80:  MOVLW  0D
11E82:  BTFSS  F9E.4
11E84:  BRA    11E82
11E86:  MOVWF  FAD
11E88:  MOVLW  0A
11E8A:  BTFSS  F9E.4
11E8C:  BRA    11E8A
11E8E:  MOVWF  FAD
11E90:  GOTO   123A0 (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
11E94:  MOVLB  8
11E96:  CLRF   xAC
11E98:  MOVF   xAC,W
11E9A:  SUBLW  03
11E9C:  BNC   11EBC
11E9E:  MOVF   xAC,W
11EA0:  MULLW  04
11EA2:  MOVF   FF3,W
11EA4:  CLRF   03
11EA6:  ADDLW  E1
11EA8:  MOVWF  FE9
11EAA:  MOVLW  03
11EAC:  ADDWFC 03,W
11EAE:  MOVWF  FEA
11EB0:  CLRF   FEF
11EB2:  CLRF   FEC
11EB4:  CLRF   FEC
11EB6:  CLRF   FEC
11EB8:  INCF   xAC,F
11EBA:  BRA    11E98
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
11EBC:  MOVLB  3
11EBE:  MOVF   x8F,F
11EC0:  BTFSS  FD8.2
11EC2:  BRA    11EC8
11EC4:  MOVF   x90,F
11EC6:  BZ    11F64
11EC8:  MOVF   x91,F
11ECA:  BNZ   11ED0
11ECC:  MOVF   x92,F
11ECE:  BZ    11F64
....................       blank = SiO_array[0]; 
11ED0:  MOVFF  390,902
11ED4:  MOVFF  38F,901
11ED8:  MOVLB  0
11EDA:  CALL   C68E
11EDE:  MOVFF  03,8B0
11EE2:  MOVFF  02,8AF
11EE6:  MOVFF  01,8AE
11EEA:  MOVFF  00,8AD
....................       react = SiO_array[1]; 
11EEE:  MOVFF  392,902
11EF2:  MOVFF  391,901
11EF6:  CALL   C68E
11EFA:  MOVFF  03,8B4
11EFE:  MOVFF  02,8B3
11F02:  MOVFF  01,8B2
11F06:  MOVFF  00,8B1
....................       ratio = blank / react; 
11F0A:  MOVFF  8B0,8E8
11F0E:  MOVFF  8AF,8E7
11F12:  MOVFF  8AE,8E6
11F16:  MOVFF  8AD,8E5
11F1A:  MOVFF  8B4,8EC
11F1E:  MOVFF  8B3,8EB
11F22:  MOVFF  8B2,8EA
11F26:  MOVFF  8B1,8E9
11F2A:  CALL   C6C4
11F2E:  MOVFF  03,8B8
11F32:  MOVFF  02,8B7
11F36:  MOVFF  01,8B6
11F3A:  MOVFF  00,8B5
....................       SiO_abs_array[0] = log10(ratio); 
11F3E:  MOVFF  8B8,8BC
11F42:  MOVFF  8B7,8BB
11F46:  MOVFF  8B6,8BA
11F4A:  MOVFF  8B5,8B9
11F4E:  CALL   1097A
11F52:  MOVFF  03,3E4
11F56:  MOVFF  02,3E3
11F5A:  MOVFF  01,3E2
11F5E:  MOVFF  00,3E1
11F62:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
11F64:  MOVF   x93,F
11F66:  BNZ   11F6C
11F68:  MOVF   x94,F
11F6A:  BZ    12008
11F6C:  MOVF   x95,F
11F6E:  BNZ   11F74
11F70:  MOVF   x96,F
11F72:  BZ    12008
....................       blank = SiO_array[2]; 
11F74:  MOVFF  394,902
11F78:  MOVFF  393,901
11F7C:  MOVLB  0
11F7E:  CALL   C68E
11F82:  MOVFF  03,8B0
11F86:  MOVFF  02,8AF
11F8A:  MOVFF  01,8AE
11F8E:  MOVFF  00,8AD
....................       react = SiO_array[3]; 
11F92:  MOVFF  396,902
11F96:  MOVFF  395,901
11F9A:  CALL   C68E
11F9E:  MOVFF  03,8B4
11FA2:  MOVFF  02,8B3
11FA6:  MOVFF  01,8B2
11FAA:  MOVFF  00,8B1
....................       ratio = blank / react;    
11FAE:  MOVFF  8B0,8E8
11FB2:  MOVFF  8AF,8E7
11FB6:  MOVFF  8AE,8E6
11FBA:  MOVFF  8AD,8E5
11FBE:  MOVFF  8B4,8EC
11FC2:  MOVFF  8B3,8EB
11FC6:  MOVFF  8B2,8EA
11FCA:  MOVFF  8B1,8E9
11FCE:  CALL   C6C4
11FD2:  MOVFF  03,8B8
11FD6:  MOVFF  02,8B7
11FDA:  MOVFF  01,8B6
11FDE:  MOVFF  00,8B5
....................       SiO_abs_array[1] = log10(ratio); 
11FE2:  MOVFF  8B8,8BC
11FE6:  MOVFF  8B7,8BB
11FEA:  MOVFF  8B6,8BA
11FEE:  MOVFF  8B5,8B9
11FF2:  CALL   1097A
11FF6:  MOVFF  03,3E8
11FFA:  MOVFF  02,3E7
11FFE:  MOVFF  01,3E6
12002:  MOVFF  00,3E5
12006:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
12008:  MOVF   x97,F
1200A:  BNZ   12010
1200C:  MOVF   x98,F
1200E:  BZ    120AC
12010:  MOVF   x99,F
12012:  BNZ   12018
12014:  MOVF   x9A,F
12016:  BZ    120AC
....................       blank = SiO_array[4]; 
12018:  MOVFF  398,902
1201C:  MOVFF  397,901
12020:  MOVLB  0
12022:  CALL   C68E
12026:  MOVFF  03,8B0
1202A:  MOVFF  02,8AF
1202E:  MOVFF  01,8AE
12032:  MOVFF  00,8AD
....................       react = SiO_array[5]; 
12036:  MOVFF  39A,902
1203A:  MOVFF  399,901
1203E:  CALL   C68E
12042:  MOVFF  03,8B4
12046:  MOVFF  02,8B3
1204A:  MOVFF  01,8B2
1204E:  MOVFF  00,8B1
....................       ratio = blank / react; 
12052:  MOVFF  8B0,8E8
12056:  MOVFF  8AF,8E7
1205A:  MOVFF  8AE,8E6
1205E:  MOVFF  8AD,8E5
12062:  MOVFF  8B4,8EC
12066:  MOVFF  8B3,8EB
1206A:  MOVFF  8B2,8EA
1206E:  MOVFF  8B1,8E9
12072:  CALL   C6C4
12076:  MOVFF  03,8B8
1207A:  MOVFF  02,8B7
1207E:  MOVFF  01,8B6
12082:  MOVFF  00,8B5
....................       SiO_abs_array[2] = log10(ratio); 
12086:  MOVFF  8B8,8BC
1208A:  MOVFF  8B7,8BB
1208E:  MOVFF  8B6,8BA
12092:  MOVFF  8B5,8B9
12096:  CALL   1097A
1209A:  MOVFF  03,3EC
1209E:  MOVFF  02,3EB
120A2:  MOVFF  01,3EA
120A6:  MOVFF  00,3E9
120AA:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
120AC:  MOVF   x9B,F
120AE:  BNZ   120B4
120B0:  MOVF   x9C,F
120B2:  BZ    12150
120B4:  MOVF   x9D,F
120B6:  BNZ   120BC
120B8:  MOVF   x9E,F
120BA:  BZ    12150
....................       blank = SiO_array[6]; 
120BC:  MOVFF  39C,902
120C0:  MOVFF  39B,901
120C4:  MOVLB  0
120C6:  CALL   C68E
120CA:  MOVFF  03,8B0
120CE:  MOVFF  02,8AF
120D2:  MOVFF  01,8AE
120D6:  MOVFF  00,8AD
....................       react = SiO_array[7]; 
120DA:  MOVFF  39E,902
120DE:  MOVFF  39D,901
120E2:  CALL   C68E
120E6:  MOVFF  03,8B4
120EA:  MOVFF  02,8B3
120EE:  MOVFF  01,8B2
120F2:  MOVFF  00,8B1
....................       ratio = blank / react; 
120F6:  MOVFF  8B0,8E8
120FA:  MOVFF  8AF,8E7
120FE:  MOVFF  8AE,8E6
12102:  MOVFF  8AD,8E5
12106:  MOVFF  8B4,8EC
1210A:  MOVFF  8B3,8EB
1210E:  MOVFF  8B2,8EA
12112:  MOVFF  8B1,8E9
12116:  CALL   C6C4
1211A:  MOVFF  03,8B8
1211E:  MOVFF  02,8B7
12122:  MOVFF  01,8B6
12126:  MOVFF  00,8B5
....................       SiO_abs_array[3] = log10(ratio); 
1212A:  MOVFF  8B8,8BC
1212E:  MOVFF  8B7,8BB
12132:  MOVFF  8B6,8BA
12136:  MOVFF  8B5,8B9
1213A:  CALL   1097A
1213E:  MOVFF  03,3F0
12142:  MOVFF  02,3EF
12146:  MOVFF  01,3EE
1214A:  MOVFF  00,3ED
1214E:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
12150:  MOVLW  04
12152:  MOVWF  1E
12154:  MOVLW  21
12156:  MOVWF  1D
12158:  MOVLW  62
1215A:  MOVWF  FF6
1215C:  MOVLW  1F
1215E:  MOVWF  FF7
12160:  MOVLW  00
12162:  MOVWF  FF8
12164:  MOVLW  06
12166:  MOVLB  8
12168:  MOVWF  xD5
1216A:  MOVLB  0
1216C:  CALL   AAF6
12170:  MOVLW  10
12172:  MOVWF  FE9
12174:  MOVFF  390,8E1
12178:  MOVFF  38F,8E0
1217C:  CALL   AB28
12180:  MOVLW  6B
12182:  MOVWF  FF6
12184:  MOVLW  1F
12186:  MOVWF  FF7
12188:  MOVLW  00
1218A:  MOVWF  FF8
1218C:  MOVLW  07
1218E:  MOVLB  8
12190:  MOVWF  xD5
12192:  MOVLB  0
12194:  CALL   AAF6
12198:  MOVLW  10
1219A:  MOVWF  FE9
1219C:  MOVFF  392,8E1
121A0:  MOVFF  391,8E0
121A4:  CALL   AB28
121A8:  MOVLW  75
121AA:  MOVWF  FF6
121AC:  MOVLW  1F
121AE:  MOVWF  FF7
121B0:  MOVLW  00
121B2:  MOVWF  FF8
121B4:  MOVLW  09
121B6:  MOVLB  8
121B8:  MOVWF  xD5
121BA:  MOVLB  0
121BC:  CALL   AAF6
121C0:  MOVLW  89
121C2:  MOVWF  FE9
121C4:  MOVFF  3E4,8BC
121C8:  MOVFF  3E3,8BB
121CC:  MOVFF  3E2,8BA
121D0:  MOVFF  3E1,8B9
121D4:  MOVLW  04
121D6:  MOVLB  8
121D8:  MOVWF  xBD
121DA:  MOVLB  0
121DC:  CALL   109E6
121E0:  MOVLW  83
121E2:  MOVWF  FF6
121E4:  MOVLW  1F
121E6:  MOVWF  FF7
121E8:  MOVLW  00
121EA:  MOVWF  FF8
121EC:  MOVLW  07
121EE:  MOVLB  8
121F0:  MOVWF  xD5
121F2:  MOVLB  0
121F4:  CALL   AAF6
121F8:  MOVLW  10
121FA:  MOVWF  FE9
121FC:  MOVFF  394,8E1
12200:  MOVFF  393,8E0
12204:  CALL   AB28
12208:  MOVLW  8D
1220A:  MOVWF  FF6
1220C:  MOVLW  1F
1220E:  MOVWF  FF7
12210:  MOVLW  00
12212:  MOVWF  FF8
12214:  MOVLW  07
12216:  MOVLB  8
12218:  MOVWF  xD5
1221A:  MOVLB  0
1221C:  CALL   AAF6
12220:  MOVLW  10
12222:  MOVWF  FE9
12224:  MOVFF  396,8E1
12228:  MOVFF  395,8E0
1222C:  CALL   AB28
12230:  MOVLW  97
12232:  MOVWF  FF6
12234:  MOVLW  1F
12236:  MOVWF  FF7
12238:  MOVLW  00
1223A:  MOVWF  FF8
1223C:  MOVLW  09
1223E:  MOVLB  8
12240:  MOVWF  xD5
12242:  MOVLB  0
12244:  CALL   AAF6
12248:  MOVLW  89
1224A:  MOVWF  FE9
1224C:  MOVFF  3E8,8BC
12250:  MOVFF  3E7,8BB
12254:  MOVFF  3E6,8BA
12258:  MOVFF  3E5,8B9
1225C:  MOVLW  04
1225E:  MOVLB  8
12260:  MOVWF  xBD
12262:  MOVLB  0
12264:  CALL   109E6
12268:  MOVLW  A5
1226A:  MOVWF  FF6
1226C:  MOVLW  1F
1226E:  MOVWF  FF7
12270:  MOVLW  00
12272:  MOVWF  FF8
12274:  MOVLW  07
12276:  MOVLB  8
12278:  MOVWF  xD5
1227A:  MOVLB  0
1227C:  CALL   AAF6
12280:  MOVLW  10
12282:  MOVWF  FE9
12284:  MOVFF  398,8E1
12288:  MOVFF  397,8E0
1228C:  CALL   AB28
12290:  MOVLW  AF
12292:  MOVWF  FF6
12294:  MOVLW  1F
12296:  MOVWF  FF7
12298:  MOVLW  00
1229A:  MOVWF  FF8
1229C:  MOVLW  07
1229E:  MOVLB  8
122A0:  MOVWF  xD5
122A2:  MOVLB  0
122A4:  CALL   AAF6
122A8:  MOVLW  10
122AA:  MOVWF  FE9
122AC:  MOVFF  39A,8E1
122B0:  MOVFF  399,8E0
122B4:  CALL   AB28
122B8:  MOVLW  B9
122BA:  MOVWF  FF6
122BC:  MOVLW  1F
122BE:  MOVWF  FF7
122C0:  MOVLW  00
122C2:  MOVWF  FF8
122C4:  MOVLW  09
122C6:  MOVLB  8
122C8:  MOVWF  xD5
122CA:  MOVLB  0
122CC:  CALL   AAF6
122D0:  MOVLW  89
122D2:  MOVWF  FE9
122D4:  MOVFF  3EC,8BC
122D8:  MOVFF  3EB,8BB
122DC:  MOVFF  3EA,8BA
122E0:  MOVFF  3E9,8B9
122E4:  MOVLW  04
122E6:  MOVLB  8
122E8:  MOVWF  xBD
122EA:  MOVLB  0
122EC:  CALL   109E6
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
122F0:  MOVF   1F,W
122F2:  SUBLW  02
122F4:  BNZ   122FA
122F6:  MOVF   20,F
122F8:  BZ    1233A
122FA:  MOVLW  C8
122FC:  MOVWF  FF6
122FE:  MOVLW  1F
12300:  MOVWF  FF7
12302:  MOVLW  00
12304:  MOVWF  FF8
12306:  CLRF   1B
12308:  BTFSC  FF2.7
1230A:  BSF    1B.7
1230C:  BCF    FF2.7
1230E:  MOVLW  09
12310:  MOVLB  A
12312:  MOVWF  x25
12314:  MOVLB  0
12316:  CALL   1010
1231A:  BTFSC  1B.7
1231C:  BSF    FF2.7
1231E:  MOVLW  04
12320:  MOVWF  FEA
12322:  MOVLW  21
12324:  MOVWF  FE9
12326:  CALL   79CE
1232A:  MOVLW  0D
1232C:  BTFSS  F9E.4
1232E:  BRA    1232C
12330:  MOVWF  FAD
12332:  MOVLW  0A
12334:  BTFSS  F9E.4
12336:  BRA    12334
12338:  MOVWF  FAD
1233A:  GOTO   123A0 (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
1233E:  MOVLW  04
12340:  MOVWF  FEA
12342:  MOVLW  21
12344:  MOVWF  FE9
12346:  MOVLW  00
12348:  CALL   056C
1234C:  TBLRD*-
1234E:  TBLRD*+
12350:  MOVF   FF5,W
12352:  MOVWF  FEE
12354:  IORLW  00
12356:  BNZ   1234E
....................     
....................    switch (chem){ 
12358:  MOVLW  D6
1235A:  MOVWF  FF6
1235C:  MOVLW  1F
1235E:  MOVWF  FF7
12360:  MOVLW  00
12362:  MOVWF  FF8
12364:  MOVLW  03
12366:  MOVWF  FEA
12368:  MOVLW  39
1236A:  MOVWF  FE9
1236C:  CALL   FBD6
12370:  MOVF   01,W
12372:  BZ    12386
12374:  XORLW  01
12376:  BZ    1238C
12378:  XORLW  03
1237A:  BZ    12392
1237C:  XORLW  01
1237E:  BZ    12398
12380:  XORLW  07
12382:  BZ    1239E
12384:  BRA    123A0
....................       case "NO3" : calc_abs_NO3(); 
12386:  GOTO   10BFC
....................          break; 
1238A:  BRA    123A0
....................       case "NO2" : calc_abs_NO2 (); 
1238C:  GOTO   11098
....................          break;    
12390:  BRA    123A0
....................       case "PO4" : calc_abs_PO4(); 
12392:  GOTO   11540
....................          break; 
12396:  BRA    123A0
....................       case "NH4" : calc_abs_NH4(); 
12398:  GOTO   119EA
....................          break; 
1239C:  BRA    123A0
....................       case "SiO" : calc_abs_SiO(); 
1239E:  BRA    11E94
....................          break; 
....................    } 
123A0:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
123A2:  CALL   D2A0
....................     
....................    if (data_available == TRUE) { 
123A6:  MOVLB  3
123A8:  DECFSZ x37,W
123AA:  BRA    124AC
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
123AC:  MOVLB  8
123AE:  CLRF   xE3
123B0:  MOVLW  63
123B2:  MOVWF  xE2
123B4:  MOVLW  02
123B6:  MOVWF  xE5
123B8:  MOVLW  B3
123BA:  MOVWF  xE4
123BC:  MOVLB  0
123BE:  CALL   5528
....................       strcat(data_buffer, comma); 
123C2:  MOVLB  8
123C4:  CLRF   xE3
123C6:  MOVLW  63
123C8:  MOVWF  xE2
123CA:  MOVLW  03
123CC:  MOVWF  xE5
123CE:  MOVLW  35
123D0:  MOVWF  xE4
123D2:  MOVLB  0
123D4:  CALL   5528
....................       strcat(data_buffer, chem); 
123D8:  MOVLB  8
123DA:  CLRF   xE3
123DC:  MOVLW  63
123DE:  MOVWF  xE2
123E0:  MOVLW  03
123E2:  MOVWF  xE5
123E4:  MOVLW  39
123E6:  MOVWF  xE4
123E8:  MOVLB  0
123EA:  CALL   5528
....................       strcat(data_buffer, comma); 
123EE:  MOVLB  8
123F0:  CLRF   xE3
123F2:  MOVLW  63
123F4:  MOVWF  xE2
123F6:  MOVLW  03
123F8:  MOVWF  xE5
123FA:  MOVLW  35
123FC:  MOVWF  xE4
123FE:  MOVLB  0
12400:  CALL   5528
....................       strcat(data_buffer, abs_str); 
12404:  MOVLB  8
12406:  CLRF   xE3
12408:  MOVLW  63
1240A:  MOVWF  xE2
1240C:  MOVLW  04
1240E:  MOVWF  xE5
12410:  MOVLW  21
12412:  MOVWF  xE4
12414:  MOVLB  0
12416:  CALL   5528
....................       strcat(data_buffer, endofline); 
1241A:  MOVLB  8
1241C:  CLRF   xE3
1241E:  MOVLW  63
12420:  MOVWF  xE2
12422:  MOVLW  07
12424:  MOVWF  xE5
12426:  MOVLW  CA
12428:  MOVWF  xE4
1242A:  MOVLB  0
1242C:  CALL   5528
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
12430:  MOVF   1F,W
12432:  SUBLW  04
12434:  BNZ   12454
12436:  MOVF   20,F
12438:  BNZ   12454
1243A:  CLRF   FEA
1243C:  MOVLW  63
1243E:  MOVWF  FE9
12440:  CALL   79CE
12444:  MOVLW  0D
12446:  BTFSS  F9E.4
12448:  BRA    12446
1244A:  MOVWF  FAD
1244C:  MOVLW  0A
1244E:  BTFSS  F9E.4
12450:  BRA    1244E
12452:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
12454:  MOVLB  2
12456:  MOVF   xD8,F
12458:  BNZ   124AA
....................        
....................          buffer_select = 0; 
1245A:  MOVLB  0
1245C:  CLRF   x62
....................           
....................          heartbeat(FALSE); 
1245E:  MOVLB  8
12460:  CLRF   xD7
12462:  MOVLB  0
12464:  CALL   55CC
....................             append_data(file_ptr_rel_all); 
12468:  MOVLW  02
1246A:  MOVLB  8
1246C:  MOVWF  xD8
1246E:  MOVLW  F5
12470:  MOVWF  xD7
12472:  MOVLB  0
12474:  CALL   832A
....................          heartbeat(TRUE);          
12478:  MOVLW  01
1247A:  MOVLB  8
1247C:  MOVWF  xD7
1247E:  MOVLB  0
12480:  CALL   55CC
....................           
....................          heartbeat(FALSE); 
12484:  MOVLB  8
12486:  CLRF   xD7
12488:  MOVLB  0
1248A:  CALL   55CC
....................             append_data(file_ptr_rel_new);    
1248E:  MOVLW  03
12490:  MOVLB  8
12492:  MOVWF  xD8
12494:  MOVWF  xD7
12496:  MOVLB  0
12498:  CALL   832A
....................          heartbeat(TRUE); 
1249C:  MOVLW  01
1249E:  MOVLB  8
124A0:  MOVWF  xD7
124A2:  MOVLB  0
124A4:  CALL   55CC
124A8:  MOVLB  2
124AA:  MOVLB  3
....................       } 
....................    } 
124AC:  MOVLB  0
124AE:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D3B6:  MOVLW  2C
0D3B8:  MOVLB  8
0D3BA:  MOVWF  x88
0D3BC:  CLRF   x89
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D3BE:  MOVLW  0D
0D3C0:  MOVWF  x8A
0D3C2:  MOVLW  0A
0D3C4:  MOVWF  x8B
0D3C6:  CLRF   x8C
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D3C8:  MOVLB  0
0D3CA:  RCALL  D2A0
....................    time_stamp(); 
0D3CC:  CALL   5464
....................    strcat(data_buffer, time_stmp_str); 
0D3D0:  MOVLB  8
0D3D2:  CLRF   xE3
0D3D4:  MOVLW  63
0D3D6:  MOVWF  xE2
0D3D8:  MOVLW  02
0D3DA:  MOVWF  xE5
0D3DC:  MOVLW  95
0D3DE:  MOVWF  xE4
0D3E0:  MOVLB  0
0D3E2:  CALL   5528
....................    strcat(data_buffer, comma); 
0D3E6:  MOVLB  8
0D3E8:  CLRF   xE3
0D3EA:  MOVLW  63
0D3EC:  MOVWF  xE2
0D3EE:  MOVLW  08
0D3F0:  MOVWF  xE5
0D3F2:  MOVLW  88
0D3F4:  MOVWF  xE4
0D3F6:  MOVLB  0
0D3F8:  CALL   5528
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D3FC:  MOVLW  08
0D3FE:  MOVWF  1E
0D400:  MOVLW  8D
0D402:  MOVWF  1D
0D404:  MOVFF  887,8D7
0D408:  MOVLW  1B
0D40A:  MOVLB  8
0D40C:  MOVWF  xD8
0D40E:  MOVLB  0
0D410:  CALL   52CA
0D414:  MOVLW  2C
0D416:  MOVLB  8
0D418:  MOVWF  xE9
0D41A:  MOVLB  0
0D41C:  CALL   50E8
0D420:  MOVLW  10
0D422:  MOVWF  FE9
0D424:  MOVFF  2A,8E1
0D428:  MOVFF  29,8E0
0D42C:  CALL   AB28
0D430:  MOVLW  2C
0D432:  MOVLB  8
0D434:  MOVWF  xE9
0D436:  MOVLB  0
0D438:  CALL   50E8
0D43C:  MOVLW  10
0D43E:  MOVWF  FE9
0D440:  MOVFF  24,8E1
0D444:  MOVFF  23,8E0
0D448:  CALL   AB28
0D44C:  MOVLW  2C
0D44E:  MOVLB  8
0D450:  MOVWF  xE9
0D452:  MOVLB  0
0D454:  CALL   50E8
0D458:  MOVLW  10
0D45A:  MOVWF  FE9
0D45C:  MOVFF  2C,8E1
0D460:  MOVFF  2B,8E0
0D464:  CALL   AB28
0D468:  MOVLW  2C
0D46A:  MOVLB  8
0D46C:  MOVWF  xE9
0D46E:  MOVLB  0
0D470:  CALL   50E8
0D474:  MOVLW  10
0D476:  MOVWF  FE9
0D478:  MOVFF  2E,8E1
0D47C:  MOVFF  2D,8E0
0D480:  CALL   AB28
0D484:  MOVLW  2C
0D486:  MOVLB  8
0D488:  MOVWF  xE9
0D48A:  MOVLB  0
0D48C:  CALL   50E8
0D490:  MOVLW  10
0D492:  MOVWF  FE9
0D494:  MOVFF  22,8E1
0D498:  MOVFF  21,8E0
0D49C:  CALL   AB28
0D4A0:  MOVLW  2C
0D4A2:  MOVLB  8
0D4A4:  MOVWF  xE9
0D4A6:  MOVLB  0
0D4A8:  CALL   50E8
0D4AC:  MOVLW  10
0D4AE:  MOVWF  FE9
0D4B0:  MOVFF  7C4,8E1
0D4B4:  MOVFF  7C3,8E0
0D4B8:  CALL   AB28
0D4BC:  MOVLW  2C
0D4BE:  MOVLB  8
0D4C0:  MOVWF  xE9
0D4C2:  MOVLB  0
0D4C4:  CALL   50E8
0D4C8:  MOVLW  10
0D4CA:  MOVWF  FE9
0D4CC:  MOVFF  7B2,8AC
0D4D0:  MOVFF  7B1,8AB
0D4D4:  BRA    D2B4
....................    strcat(data_buffer, config_str); 
0D4D6:  MOVLB  8
0D4D8:  CLRF   xE3
0D4DA:  MOVLW  63
0D4DC:  MOVWF  xE2
0D4DE:  MOVLW  08
0D4E0:  MOVWF  xE5
0D4E2:  MOVLW  8D
0D4E4:  MOVWF  xE4
0D4E6:  MOVLB  0
0D4E8:  CALL   5528
....................    strcat(data_buffer, endofline); 
0D4EC:  MOVLB  8
0D4EE:  CLRF   xE3
0D4F0:  MOVLW  63
0D4F2:  MOVWF  xE2
0D4F4:  MOVLW  08
0D4F6:  MOVWF  xE5
0D4F8:  MOVLW  8A
0D4FA:  MOVWF  xE4
0D4FC:  MOVLB  0
0D4FE:  CALL   5528
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D502:  CLRF   FEA
0D504:  MOVLW  63
0D506:  MOVWF  FE9
0D508:  CALL   79CE
0D50C:  MOVLW  0D
0D50E:  BTFSS  F9E.4
0D510:  BRA    D50E
0D512:  MOVWF  FAD
0D514:  MOVLW  0A
0D516:  BTFSS  F9E.4
0D518:  BRA    D516
0D51A:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D51C:  MOVLB  2
0D51E:  MOVF   xD8,F
0D520:  BNZ   D574
....................     
....................       buffer_select = 0; 
0D522:  MOVLB  0
0D524:  CLRF   x62
....................        
....................       heartbeat(FALSE); 
0D526:  MOVLB  8
0D528:  CLRF   xD7
0D52A:  MOVLB  0
0D52C:  CALL   55CC
....................          append_data(file_ptr_raw_all); 
0D530:  MOVLW  02
0D532:  MOVLB  8
0D534:  MOVWF  xD8
0D536:  MOVLW  D9
0D538:  MOVWF  xD7
0D53A:  MOVLB  0
0D53C:  CALL   832A
....................       heartbeat(TRUE);          
0D540:  MOVLW  01
0D542:  MOVLB  8
0D544:  MOVWF  xD7
0D546:  MOVLB  0
0D548:  CALL   55CC
....................        
....................       heartbeat(FALSE); 
0D54C:  MOVLB  8
0D54E:  CLRF   xD7
0D550:  MOVLB  0
0D552:  CALL   55CC
....................          append_data(file_ptr_raw_new);    
0D556:  MOVLW  02
0D558:  MOVLB  8
0D55A:  MOVWF  xD8
0D55C:  MOVLW  E7
0D55E:  MOVWF  xD7
0D560:  MOVLB  0
0D562:  CALL   832A
....................       heartbeat(TRUE); 
0D566:  MOVLW  01
0D568:  MOVLB  8
0D56A:  MOVWF  xD7
0D56C:  MOVLB  0
0D56E:  CALL   55CC
0D572:  MOVLB  2
....................    } 
0D574:  MOVLB  0
0D576:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
14E96:  MOVLW  2C
14E98:  MOVLB  8
14E9A:  MOVWF  x8A
14E9C:  CLRF   x8B
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
14E9E:  MOVLW  0D
14EA0:  MOVWF  x8C
14EA2:  MOVLW  0A
14EA4:  MOVWF  x8D
14EA6:  CLRF   x8E
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
14EA8:  MOVLB  0
14EAA:  CALL   D2A0
....................    time_stamp(); 
14EAE:  CALL   5464
....................    strcat(data_buffer, time_stmp_str); 
14EB2:  MOVLB  8
14EB4:  CLRF   xE3
14EB6:  MOVLW  63
14EB8:  MOVWF  xE2
14EBA:  MOVLW  02
14EBC:  MOVWF  xE5
14EBE:  MOVLW  95
14EC0:  MOVWF  xE4
14EC2:  MOVLB  0
14EC4:  CALL   5528
....................    strcat(data_buffer, comma); 
14EC8:  MOVLB  8
14ECA:  CLRF   xE3
14ECC:  MOVLW  63
14ECE:  MOVWF  xE2
14ED0:  MOVLW  08
14ED2:  MOVWF  xE5
14ED4:  MOVLW  8A
14ED6:  MOVWF  xE4
14ED8:  MOVLB  0
14EDA:  CALL   5528
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
14EDE:  MOVLW  08
14EE0:  MOVWF  1E
14EE2:  MOVLW  8F
14EE4:  MOVWF  1D
14EE6:  MOVFF  887,8D7
14EEA:  MOVLW  1B
14EEC:  MOVLB  8
14EEE:  MOVWF  xD8
14EF0:  MOVLB  0
14EF2:  CALL   52CA
14EF6:  MOVLW  2C
14EF8:  MOVLB  8
14EFA:  MOVWF  xE9
14EFC:  MOVLB  0
14EFE:  CALL   50E8
14F02:  MOVLW  10
14F04:  MOVWF  FE9
14F06:  MOVFF  889,8E1
14F0A:  MOVFF  888,8E0
14F0E:  CALL   AB28
....................    strcat(data_buffer, config_str); 
14F12:  MOVLB  8
14F14:  CLRF   xE3
14F16:  MOVLW  63
14F18:  MOVWF  xE2
14F1A:  MOVLW  08
14F1C:  MOVWF  xE5
14F1E:  MOVLW  8F
14F20:  MOVWF  xE4
14F22:  MOVLB  0
14F24:  CALL   5528
....................    strcat(data_buffer, endofline); 
14F28:  MOVLB  8
14F2A:  CLRF   xE3
14F2C:  MOVLW  63
14F2E:  MOVWF  xE2
14F30:  MOVLW  08
14F32:  MOVWF  xE5
14F34:  MOVLW  8C
14F36:  MOVWF  xE4
14F38:  MOVLB  0
14F3A:  CALL   5528
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
14F3E:  MOVF   1F,W
14F40:  SUBLW  04
14F42:  BNZ   14F62
14F44:  MOVF   20,F
14F46:  BNZ   14F62
14F48:  CLRF   FEA
14F4A:  MOVLW  63
14F4C:  MOVWF  FE9
14F4E:  CALL   79CE
14F52:  MOVLW  0D
14F54:  BTFSS  F9E.4
14F56:  BRA    14F54
14F58:  MOVWF  FAD
14F5A:  MOVLW  0A
14F5C:  BTFSS  F9E.4
14F5E:  BRA    14F5C
14F60:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
14F62:  MOVLB  2
14F64:  MOVF   xD8,F
14F66:  BNZ   14FBA
....................     
....................       buffer_select = 0; 
14F68:  MOVLB  0
14F6A:  CLRF   x62
....................        
....................       heartbeat(FALSE); 
14F6C:  MOVLB  8
14F6E:  CLRF   xD7
14F70:  MOVLB  0
14F72:  CALL   55CC
....................          append_data(file_ptr_raw_all); 
14F76:  MOVLW  02
14F78:  MOVLB  8
14F7A:  MOVWF  xD8
14F7C:  MOVLW  D9
14F7E:  MOVWF  xD7
14F80:  MOVLB  0
14F82:  CALL   832A
....................       heartbeat(TRUE);          
14F86:  MOVLW  01
14F88:  MOVLB  8
14F8A:  MOVWF  xD7
14F8C:  MOVLB  0
14F8E:  CALL   55CC
....................        
....................       heartbeat(FALSE); 
14F92:  MOVLB  8
14F94:  CLRF   xD7
14F96:  MOVLB  0
14F98:  CALL   55CC
....................          append_data(file_ptr_raw_new);    
14F9C:  MOVLW  02
14F9E:  MOVLB  8
14FA0:  MOVWF  xD8
14FA2:  MOVLW  E7
14FA4:  MOVWF  xD7
14FA6:  MOVLB  0
14FA8:  CALL   832A
....................       heartbeat(TRUE); 
14FAC:  MOVLW  01
14FAE:  MOVLB  8
14FB0:  MOVWF  xD7
14FB2:  MOVLB  0
14FB4:  CALL   55CC
14FB8:  MOVLB  2
....................    } 
14FBA:  MOVLB  0
14FBC:  GOTO   15158 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0D0E8:  BSF    F90.7
....................    delay_ms(500); 
0D0EA:  MOVLW  02
0D0EC:  MOVLB  8
0D0EE:  MOVWF  xAC
0D0F0:  MOVLW  FA
0D0F2:  MOVLB  9
0D0F4:  MOVWF  xD6
0D0F6:  MOVLB  0
0D0F8:  CALL   2964
0D0FC:  MOVLB  8
0D0FE:  DECFSZ xAC,F
0D100:  BRA    D0F0
....................    bus_pwr_status=1; 
0D102:  MOVLW  01
0D104:  MOVLB  4
0D106:  MOVWF  xB2
0D108:  MOVLB  0
0D10A:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D10C:  BCF    F90.7
....................    delay_ms(100); 
0D10E:  MOVLW  64
0D110:  MOVLB  9
0D112:  MOVWF  xD6
0D114:  MOVLB  0
0D116:  CALL   2964
....................    bus_pwr_status=0; 
0D11A:  MOVLB  4
0D11C:  CLRF   xB2
0D11E:  MOVLB  0
0D120:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
17B6E:  MOVLB  8
17B70:  CLRF   x81
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
17B72:  CLRF   x81
17B74:  MOVF   x81,W
17B76:  SUBLW  31
17B78:  BNC   17B8E
....................       string_arg[i] = 0; 
17B7A:  CLRF   03
17B7C:  MOVF   x81,W
17B7E:  ADDLW  21
17B80:  MOVWF  FE9
17B82:  MOVLW  08
17B84:  ADDWFC 03,W
17B86:  MOVWF  FEA
17B88:  CLRF   FEF
17B8A:  INCF   x81,F
17B8C:  BRA    17B74
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
17B8E:  CLRF   x81
17B90:  MOVF   x81,W
17B92:  SUBLW  31
17B94:  BNC   17C0E
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
17B96:  CLRF   03
17B98:  MOVF   x81,W
17B9A:  ADDLW  21
17B9C:  MOVWF  FE9
17B9E:  MOVLW  08
17BA0:  ADDWFC 03,W
17BA2:  MOVWF  FEA
17BA4:  MOVFF  FEA,885
17BA8:  MOVFF  FE9,884
17BAC:  MOVLB  0
17BAE:  CALL   0E24
17BB2:  MOVFF  885,FEA
17BB6:  MOVFF  884,FE9
17BBA:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
17BBE:  DECFSZ 48,W
17BC0:  BRA    17BDE
....................       { 
....................          fputc(string_arg[i],COM_A); 
17BC2:  CLRF   03
17BC4:  MOVLB  8
17BC6:  MOVF   x81,W
17BC8:  ADDLW  21
17BCA:  MOVWF  FE9
17BCC:  MOVLW  08
17BCE:  ADDWFC 03,W
17BD0:  MOVWF  FEA
17BD2:  MOVFF  FEF,882
17BD6:  MOVF   x82,W
17BD8:  MOVLB  0
17BDA:  CALL   AEA6
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
17BDE:  CLRF   03
17BE0:  MOVLB  8
17BE2:  MOVF   x81,W
17BE4:  ADDLW  21
17BE6:  MOVWF  FE9
17BE8:  MOVLW  08
17BEA:  ADDWFC 03,W
17BEC:  MOVWF  FEA
17BEE:  MOVF   FEF,W
17BF0:  SUBLW  0D
17BF2:  BZ    17C08
17BF4:  CLRF   03
17BF6:  MOVF   x81,W
17BF8:  ADDLW  21
17BFA:  MOVWF  FE9
17BFC:  MOVLW  08
17BFE:  ADDWFC 03,W
17C00:  MOVWF  FEA
17C02:  MOVF   FEF,W
17C04:  SUBLW  0A
17C06:  BNZ   17C0A
....................       { 
....................          break; 
17C08:  BRA    17C0E
....................       } 
17C0A:  INCF   x81,F
17C0C:  BRA    17B90
....................    } 
17C0E:  MOVLB  0
17C10:  GOTO   17F38 (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
17DB6:  MOVLB  8
17DB8:  CLRF   x81
....................    macro_arg = 0; 
17DBA:  CLRF   x83
17DBC:  CLRF   x82
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
17DBE:  MOVF   x81,W
17DC0:  SUBLW  0D
17DC2:  BZ    17E4E
....................       number = fgetc(COM_A); 
17DC4:  MOVLB  0
17DC6:  CALL   0E24
17DCA:  MOVFF  01,881
....................       if (com_echo == TRUE) 
17DCE:  DECFSZ 48,W
17DD0:  BRA    17DE2
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
17DD2:  MOVLB  8
17DD4:  MOVF   x81,W
17DD6:  SUBLW  0D
17DD8:  BZ    17DE4
17DDA:  MOVF   x81,W
17DDC:  MOVLB  0
17DDE:  CALL   AEA6
17DE2:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
17DE4:  MOVF   x81,W
17DE6:  SUBLW  2F
17DE8:  BC    17E1E
17DEA:  MOVF   x81,W
17DEC:  SUBLW  39
17DEE:  BNC   17E1E
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
17DF0:  MOVLW  30
17DF2:  SUBWF  x81,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
17DF4:  MOVFF  883,9F7
17DF8:  MOVFF  882,9F6
17DFC:  MOVLB  9
17DFE:  CLRF   xF9
17E00:  MOVLW  0A
17E02:  MOVWF  xF8
17E04:  MOVLB  0
17E06:  CALL   5D06
17E0A:  MOVFF  02,883
17E0E:  MOVFF  01,882
....................          macro_arg = macro_arg + number;                // for each number 
17E12:  MOVLB  8
17E14:  MOVF   x81,W
17E16:  ADDWF  x82,F
17E18:  MOVLW  00
17E1A:  ADDWFC x83,F
....................       } 
17E1C:  BRA    17E4C
....................       else if (number == CARRIAGE_RET) 
17E1E:  MOVF   x81,W
17E20:  SUBLW  0D
17E22:  BNZ   17E44
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
17E24:  INCFSZ x82,W
17E26:  BRA    17E2E
17E28:  INCFSZ x83,W
17E2A:  BRA    17E2E
17E2C:  BRA    17E3A
17E2E:  MOVFF  882,01
17E32:  MOVFF  883,02
17E36:  BRA    17E4E
17E38:  BRA    17E42
....................          else return(65535); 
17E3A:  MOVLW  FF
17E3C:  MOVWF  01
17E3E:  MOVWF  02
17E40:  BRA    17E4E
....................       } 
17E42:  BRA    17E4C
....................       else 
....................       { 
....................          return(65535); 
17E44:  MOVLW  FF
17E46:  MOVWF  01
17E48:  MOVWF  02
17E4A:  BRA    17E4E
....................       } 
17E4C:  BRA    17DBE
....................    } 
17E4E:  MOVLB  0
17E50:  GOTO   17F62 (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
178FE:  MOVF   2F,W
17900:  MOVWF  00
17902:  MOVF   30,W
17904:  MOVWF  03
17906:  BNZ   1790C
17908:  MOVF   00,F
1790A:  BZ    17932
1790C:  MOVF   03,W
1790E:  BNZ   17918
17910:  MOVLW  03
17912:  SUBWF  00,W
17914:  BTFSC  FD8.2
17916:  BRA    179F0
17918:  MOVF   03,W
1791A:  BNZ   17924
1791C:  MOVLW  01
1791E:  SUBWF  00,W
17920:  BTFSC  FD8.2
17922:  BRA    179F0
17924:  MOVF   03,W
17926:  BNZ   17930
17928:  MOVLW  02
1792A:  SUBWF  00,W
1792C:  BTFSC  FD8.2
1792E:  BRA    17A66
17930:  BRA    17AD4
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
17932:  MOVLB  8
17934:  MOVF   x85,F
17936:  BNZ   17966
17938:  MOVF   x84,W
1793A:  SUBLW  23
1793C:  BZ    17960
1793E:  MOVF   x84,W
17940:  SUBLW  25
17942:  BZ    17960
17944:  MOVF   x84,W
17946:  SUBLW  3B
17948:  BZ    17960
1794A:  MOVF   x84,W
1794C:  SUBLW  4D
1794E:  BZ    17960
17950:  MOVF   x84,W
17952:  SUBLW  5A
17954:  BZ    17960
17956:  MOVF   x84,W
17958:  SUBLW  72
1795A:  BZ    17960
1795C:  MOVLW  00
1795E:  BRA    17962
17960:  MOVLW  01
17962:  MOVWF  x86
17964:  BRA    179EC
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
17966:  MOVF   x84,W
17968:  SUBLW  23
1796A:  BZ    179E8
1796C:  MOVF   x84,W
1796E:  SUBLW  25
17970:  BZ    179E8
17972:  MOVF   x84,W
17974:  SUBLW  2B
17976:  BZ    179E8
17978:  MOVF   x84,W
1797A:  SUBLW  2D
1797C:  BZ    179E8
1797E:  MOVF   x84,W
17980:  SUBLW  2F
17982:  BZ    179E8
17984:  MOVF   x84,W
17986:  SUBLW  3B
17988:  BZ    179E8
1798A:  MOVF   x84,W
1798C:  SUBLW  41
1798E:  BZ    179E8
17990:  MOVF   x84,W
17992:  SUBLW  42
17994:  BC    1799C
17996:  MOVF   x84,W
17998:  SUBLW  44
1799A:  BC    179E8
1799C:  MOVF   x84,W
1799E:  SUBLW  45
179A0:  BC    179A8
179A2:  MOVF   x84,W
179A4:  SUBLW  48
179A6:  BC    179E8
179A8:  MOVF   x84,W
179AA:  SUBLW  4A
179AC:  BC    179B4
179AE:  MOVF   x84,W
179B0:  SUBLW  4C
179B2:  BC    179E8
179B4:  MOVF   x84,W
179B6:  SUBLW  4F
179B8:  BC    179C0
179BA:  MOVF   x84,W
179BC:  SUBLW  55
179BE:  BC    179E8
179C0:  MOVF   x84,W
179C2:  SUBLW  59
179C4:  BZ    179E8
179C6:  MOVF   x84,W
179C8:  SUBLW  64
179CA:  BZ    179E8
179CC:  MOVF   x84,W
179CE:  SUBLW  69
179D0:  BZ    179E8
179D2:  MOVF   x84,W
179D4:  SUBLW  6C
179D6:  BZ    179E8
179D8:  MOVF   x84,W
179DA:  SUBLW  70
179DC:  BZ    179E8
179DE:  MOVF   x84,W
179E0:  SUBLW  72
179E2:  BZ    179E8
179E4:  MOVLW  00
179E6:  BRA    179EA
179E8:  MOVLW  01
179EA:  MOVWF  x86
....................          break; 
179EC:  MOVLB  0
179EE:  BRA    17AD4
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
179F0:  MOVLB  8
179F2:  MOVF   x85,F
179F4:  BNZ   17A1E
179F6:  MOVF   x84,W
179F8:  SUBLW  23
179FA:  BZ    17A18
179FC:  MOVF   x84,W
179FE:  SUBLW  3B
17A00:  BZ    17A18
17A02:  MOVF   x84,W
17A04:  SUBLW  4A
17A06:  BZ    17A18
17A08:  MOVF   x84,W
17A0A:  SUBLW  4D
17A0C:  BZ    17A18
17A0E:  MOVF   x84,W
17A10:  SUBLW  50
17A12:  BZ    17A18
17A14:  MOVLW  00
17A16:  BRA    17A1A
17A18:  MOVLW  01
17A1A:  MOVWF  x86
17A1C:  BRA    17A62
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
17A1E:  MOVF   x84,W
17A20:  SUBLW  23
17A22:  BZ    17A5E
17A24:  MOVF   x84,W
17A26:  SUBLW  2B
17A28:  BZ    17A5E
17A2A:  MOVF   x84,W
17A2C:  SUBLW  2D
17A2E:  BZ    17A5E
17A30:  MOVF   x84,W
17A32:  SUBLW  3B
17A34:  BZ    17A5E
17A36:  MOVF   x84,W
17A38:  SUBLW  42
17A3A:  BZ    17A5E
17A3C:  MOVF   x84,W
17A3E:  SUBLW  47
17A40:  BZ    17A5E
17A42:  MOVF   x84,W
17A44:  SUBLW  4F
17A46:  BC    17A4E
17A48:  MOVF   x84,W
17A4A:  SUBLW  52
17A4C:  BC    17A5E
17A4E:  MOVF   x84,W
17A50:  SUBLW  54
17A52:  BZ    17A5E
17A54:  MOVF   x84,W
17A56:  SUBLW  59
17A58:  BZ    17A5E
17A5A:  MOVLW  00
17A5C:  BRA    17A60
17A5E:  MOVLW  01
17A60:  MOVWF  x86
....................          break;   
17A62:  MOVLB  0
17A64:  BRA    17AD4
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
17A66:  MOVLB  8
17A68:  MOVF   x85,F
17A6A:  BNZ   17A8E
17A6C:  MOVF   x84,W
17A6E:  SUBLW  23
17A70:  BZ    17A88
17A72:  MOVF   x84,W
17A74:  SUBLW  3B
17A76:  BZ    17A88
17A78:  MOVF   x84,W
17A7A:  SUBLW  4D
17A7C:  BZ    17A88
17A7E:  MOVF   x84,W
17A80:  SUBLW  50
17A82:  BZ    17A88
17A84:  MOVLW  00
17A86:  BRA    17A8A
17A88:  MOVLW  01
17A8A:  MOVWF  x86
17A8C:  BRA    17AD2
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
17A8E:  MOVF   x84,W
17A90:  SUBLW  23
17A92:  BZ    17ACE
17A94:  MOVF   x84,W
17A96:  SUBLW  2B
17A98:  BZ    17ACE
17A9A:  MOVF   x84,W
17A9C:  SUBLW  2D
17A9E:  BZ    17ACE
17AA0:  MOVF   x84,W
17AA2:  SUBLW  3B
17AA4:  BZ    17ACE
17AA6:  MOVF   x84,W
17AA8:  SUBLW  42
17AAA:  BC    17AB2
17AAC:  MOVF   x84,W
17AAE:  SUBLW  44
17AB0:  BC    17ACE
17AB2:  MOVF   x84,W
17AB4:  SUBLW  4F
17AB6:  BC    17ABE
17AB8:  MOVF   x84,W
17ABA:  SUBLW  51
17ABC:  BC    17ACE
17ABE:  MOVF   x84,W
17AC0:  SUBLW  53
17AC2:  BZ    17ACE
17AC4:  MOVF   x84,W
17AC6:  SUBLW  59
17AC8:  BZ    17ACE
17ACA:  MOVLW  00
17ACC:  BRA    17AD0
17ACE:  MOVLW  01
17AD0:  MOVWF  x86
....................          break;   
17AD2:  MOVLB  0
....................    } 
....................    return(valid_macro); 
17AD4:  MOVLB  8
17AD6:  MOVFF  886,01
17ADA:  MOVLB  0
17ADC:  GOTO   17B08 (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
17AE0:  MOVLW  01
17AE2:  MOVLB  8
17AE4:  MOVWF  x83
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
17AE6:  MOVLB  0
17AE8:  CALL   0E24
17AEC:  MOVFF  01,882
....................       if (com_echo == TRUE) fputc(e,COM_A); 
17AF0:  DECFSZ 48,W
17AF2:  BRA    17AFE
17AF4:  MOVLB  8
17AF6:  MOVF   x82,W
17AF8:  MOVLB  0
17AFA:  CALL   AEA6
....................          valid_macro = check_macro(e, macro); 
17AFE:  MOVFF  882,884
17B02:  MOVFF  881,885
17B06:  BRA    178FE
17B08:  MOVFF  01,883
....................       if (valid_macro == TRUE) { 
17B0C:  MOVLB  8
17B0E:  DECFSZ x83,W
17B10:  BRA    17B1A
....................          return(e); 
17B12:  MOVFF  882,01
17B16:  BRA    17B26
....................       } 
17B18:  BRA    17B20
....................       else return(0); 
17B1A:  MOVLW  00
17B1C:  MOVWF  01
17B1E:  BRA    17B26
....................    } while (valid_macro == TRUE); 
17B20:  DECFSZ x83,W
17B22:  BRA    17B26
17B24:  BRA    17AE6
17B26:  MOVLB  0
17B28:  GOTO   17F1A (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
17EA0:  BCF    FD8.0
17EA2:  MOVLB  8
17EA4:  RLCF   x84,W
17EA6:  CLRF   03
17EA8:  ADDLW  CD
17EAA:  MOVWF  FE9
17EAC:  MOVLW  07
17EAE:  ADDWFC 03,W
17EB0:  MOVWF  FEA
17EB2:  MOVFF  FEC,88A
17EB6:  MOVF   FED,F
17EB8:  MOVFF  FEF,889
17EBC:  MOVFF  886,9F7
17EC0:  MOVFF  885,9F6
17EC4:  MOVLB  9
17EC6:  CLRF   xF9
17EC8:  MOVLW  03
17ECA:  MOVWF  xF8
17ECC:  MOVLB  0
17ECE:  CALL   5D06
17ED2:  MOVF   01,W
17ED4:  MOVLB  8
17ED6:  ADDWF  x89,W
17ED8:  MOVWF  x87
17EDA:  MOVF   02,W
17EDC:  ADDWFC x8A,W
17EDE:  MOVWF  x88
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
17EE0:  MOVFF  888,892
17EE4:  MOVFF  887,891
17EE8:  MOVFF  881,893
17EEC:  MOVLB  0
17EEE:  RCALL  17C14
....................     
....................    ++addr; 
17EF0:  MOVLB  8
17EF2:  INCF   x87,F
17EF4:  BTFSC  FD8.2
17EF6:  INCF   x88,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
17EF8:  MOVFF  888,88A
17EFC:  MOVFF  887,889
17F00:  MOVFF  883,88C
17F04:  MOVFF  882,88B
17F08:  MOVLB  0
17F0A:  BRA    17E54
17F0C:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
17C74:  BCF    FD8.0
17C76:  MOVLB  8
17C78:  RLCF   x82,W
17C7A:  CLRF   03
17C7C:  ADDLW  CD
17C7E:  MOVWF  FE9
17C80:  MOVLW  07
17C82:  ADDWFC 03,W
17C84:  MOVWF  FEA
17C86:  MOVFF  FEC,88B
17C8A:  MOVF   FED,F
17C8C:  MOVFF  FEF,88A
17C90:  MOVFF  884,9F7
17C94:  MOVFF  883,9F6
17C98:  MOVLB  9
17C9A:  CLRF   xF9
17C9C:  MOVLW  03
17C9E:  MOVWF  xF8
17CA0:  MOVLB  0
17CA2:  CALL   5D06
17CA6:  MOVF   01,W
17CA8:  MOVLB  8
17CAA:  ADDWF  x8A,W
17CAC:  MOVWF  x87
17CAE:  MOVF   02,W
17CB0:  ADDWFC x8B,W
17CB2:  MOVWF  x88
....................    write_ext_eeprom(addr, macro_cmd); 
17CB4:  MOVFF  888,892
17CB8:  MOVFF  887,891
17CBC:  MOVFF  881,893
17CC0:  MOVLB  0
17CC2:  RCALL  17C14
....................     
....................    int i = 0; 
17CC4:  MOVLB  8
17CC6:  CLRF   x89
....................    addr = string_address[macro] + (count*50); 
17CC8:  BCF    FD8.0
17CCA:  RLCF   x82,W
17CCC:  CLRF   03
17CCE:  ADDLW  F7
17CD0:  MOVWF  FE9
17CD2:  MOVLW  07
17CD4:  ADDWFC 03,W
17CD6:  MOVWF  FEA
17CD8:  MOVFF  FEC,88B
17CDC:  MOVF   FED,F
17CDE:  MOVFF  FEF,88A
17CE2:  MOVFF  886,9F7
17CE6:  MOVFF  885,9F6
17CEA:  MOVLB  9
17CEC:  CLRF   xF9
17CEE:  MOVLW  32
17CF0:  MOVWF  xF8
17CF2:  MOVLB  0
17CF4:  CALL   5D06
17CF8:  MOVF   01,W
17CFA:  MOVLB  8
17CFC:  ADDWF  x8A,W
17CFE:  MOVWF  x87
17D00:  MOVF   02,W
17D02:  ADDWFC x8B,W
17D04:  MOVWF  x88
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
17D06:  MOVF   x86,F
17D08:  BNZ   17D5E
17D0A:  MOVF   x85,W
17D0C:  SUBLW  14
17D0E:  BNC   17D5E
....................       for(i = 0; i<50; i++) { 
17D10:  CLRF   x89
17D12:  MOVF   x89,W
17D14:  SUBLW  31
17D16:  BNC   17D5C
....................          write_ext_eeprom(addr + i, string_arg[i]); 
17D18:  MOVF   x89,W
17D1A:  ADDWF  x87,W
17D1C:  MOVWF  x8A
17D1E:  MOVLW  00
17D20:  ADDWFC x88,W
17D22:  MOVWF  x8B
17D24:  CLRF   03
17D26:  MOVF   x89,W
17D28:  ADDLW  21
17D2A:  MOVWF  FE9
17D2C:  MOVLW  08
17D2E:  ADDWFC 03,W
17D30:  MOVWF  FEA
17D32:  MOVFF  FEF,893
17D36:  MOVFF  88B,892
17D3A:  MOVFF  88A,891
17D3E:  MOVLB  0
17D40:  RCALL  17C14
....................          if(string_arg[i] == 0){ 
17D42:  CLRF   03
17D44:  MOVLB  8
17D46:  MOVF   x89,W
17D48:  ADDLW  21
17D4A:  MOVWF  FE9
17D4C:  MOVLW  08
17D4E:  ADDWFC 03,W
17D50:  MOVWF  FEA
17D52:  MOVF   FEF,F
17D54:  BNZ   17D58
....................             break; 
17D56:  BRA    17D5C
....................          } 
17D58:  INCF   x89,F
17D5A:  BRA    17D12
....................       
....................       } 
....................    }else{ 
17D5C:  BRA    17DB0
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
17D5E:  MOVLW  BE
17D60:  MOVWF  FF6
17D62:  MOVLW  20
17D64:  MOVWF  FF7
17D66:  MOVLW  00
17D68:  MOVWF  FF8
17D6A:  CLRF   1B
17D6C:  BTFSC  FF2.7
17D6E:  BSF    1B.7
17D70:  BCF    FF2.7
17D72:  MOVLW  1E
17D74:  MOVLB  A
17D76:  MOVWF  x25
17D78:  MOVLB  0
17D7A:  CALL   1010
17D7E:  BTFSC  1B.7
17D80:  BSF    FF2.7
17D82:  MOVLW  10
17D84:  MOVWF  FE9
17D86:  CLRF   1B
17D88:  BTFSC  FF2.7
17D8A:  BSF    1B.7
17D8C:  BCF    FF2.7
17D8E:  MOVFF  884,A26
17D92:  MOVFF  883,A25
17D96:  CALL   1192
17D9A:  BTFSC  1B.7
17D9C:  BSF    FF2.7
17D9E:  MOVLW  0A
17DA0:  BTFSS  F9E.4
17DA2:  BRA    17DA0
17DA4:  MOVWF  FAD
17DA6:  MOVLW  0D
17DA8:  BTFSS  F9E.4
17DAA:  BRA    17DA8
17DAC:  MOVWF  FAD
17DAE:  MOVLB  8
....................    } 
17DB0:  MOVLB  0
17DB2:  GOTO   17F52 (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
180F2:  CALL   FFDA
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
180F6:  MOVLW  3B
180F8:  MOVLB  8
180FA:  MOVWF  x81
180FC:  CLRF   x83
180FE:  CLRF   x82
18100:  CLRF   x84
18102:  CLRF   x86
18104:  CLRF   x85
18106:  MOVLB  0
18108:  RCALL  17EA0
....................     
....................    write_macro_line(59, 0, 1, 0); 
1810A:  MOVLW  3B
1810C:  MOVLB  8
1810E:  MOVWF  x81
18110:  CLRF   x83
18112:  CLRF   x82
18114:  MOVLW  01
18116:  MOVWF  x84
18118:  CLRF   x86
1811A:  CLRF   x85
1811C:  MOVLB  0
1811E:  RCALL  17EA0
....................    write_macro_line(59, 0, 2, 0); 
18120:  MOVLW  3B
18122:  MOVLB  8
18124:  MOVWF  x81
18126:  CLRF   x83
18128:  CLRF   x82
1812A:  MOVLW  02
1812C:  MOVWF  x84
1812E:  CLRF   x86
18130:  CLRF   x85
18132:  MOVLB  0
18134:  RCALL  17EA0
....................    write_macro_line(59, 0, 3, 0); 
18136:  MOVLW  3B
18138:  MOVLB  8
1813A:  MOVWF  x81
1813C:  CLRF   x83
1813E:  CLRF   x82
18140:  MOVLW  03
18142:  MOVWF  x84
18144:  CLRF   x86
18146:  CLRF   x85
18148:  MOVLB  0
1814A:  RCALL  17EA0
....................    write_macro_line(59, 0, 4, 0); 
1814C:  MOVLW  3B
1814E:  MOVLB  8
18150:  MOVWF  x81
18152:  CLRF   x83
18154:  CLRF   x82
18156:  MOVLW  04
18158:  MOVWF  x84
1815A:  CLRF   x86
1815C:  CLRF   x85
1815E:  MOVLB  0
18160:  RCALL  17EA0
....................    write_macro_line(59, 0, 5, 0); 
18162:  MOVLW  3B
18164:  MOVLB  8
18166:  MOVWF  x81
18168:  CLRF   x83
1816A:  CLRF   x82
1816C:  MOVLW  05
1816E:  MOVWF  x84
18170:  CLRF   x86
18172:  CLRF   x85
18174:  MOVLB  0
18176:  RCALL  17EA0
....................    write_macro_line(59, 0, 6, 0); 
18178:  MOVLW  3B
1817A:  MOVLB  8
1817C:  MOVWF  x81
1817E:  CLRF   x83
18180:  CLRF   x82
18182:  MOVLW  06
18184:  MOVWF  x84
18186:  CLRF   x86
18188:  CLRF   x85
1818A:  MOVLB  0
1818C:  RCALL  17EA0
....................    write_macro_line(59, 0, 7, 0); 
1818E:  MOVLW  3B
18190:  MOVLB  8
18192:  MOVWF  x81
18194:  CLRF   x83
18196:  CLRF   x82
18198:  MOVLW  07
1819A:  MOVWF  x84
1819C:  CLRF   x86
1819E:  CLRF   x85
181A0:  MOVLB  0
181A2:  RCALL  17EA0
....................    write_macro_line(59, 0, 8, 0); 
181A4:  MOVLW  3B
181A6:  MOVLB  8
181A8:  MOVWF  x81
181AA:  CLRF   x83
181AC:  CLRF   x82
181AE:  MOVLW  08
181B0:  MOVWF  x84
181B2:  CLRF   x86
181B4:  CLRF   x85
181B6:  MOVLB  0
181B8:  RCALL  17EA0
....................     
....................    write_macro_line(59, 0, 9, 0); 
181BA:  MOVLW  3B
181BC:  MOVLB  8
181BE:  MOVWF  x81
181C0:  CLRF   x83
181C2:  CLRF   x82
181C4:  MOVLW  09
181C6:  MOVWF  x84
181C8:  CLRF   x86
181CA:  CLRF   x85
181CC:  MOVLB  0
181CE:  RCALL  17EA0
....................    write_macro_line(59, 0, 10, 0); 
181D0:  MOVLW  3B
181D2:  MOVLB  8
181D4:  MOVWF  x81
181D6:  CLRF   x83
181D8:  CLRF   x82
181DA:  MOVLW  0A
181DC:  MOVWF  x84
181DE:  CLRF   x86
181E0:  CLRF   x85
181E2:  MOVLB  0
181E4:  RCALL  17EA0
....................    write_macro_line(59, 0, 11, 0); 
181E6:  MOVLW  3B
181E8:  MOVLB  8
181EA:  MOVWF  x81
181EC:  CLRF   x83
181EE:  CLRF   x82
181F0:  MOVLW  0B
181F2:  MOVWF  x84
181F4:  CLRF   x86
181F6:  CLRF   x85
181F8:  MOVLB  0
181FA:  RCALL  17EA0
....................    write_macro_line(59, 0, 12, 0); 
181FC:  MOVLW  3B
181FE:  MOVLB  8
18200:  MOVWF  x81
18202:  CLRF   x83
18204:  CLRF   x82
18206:  MOVLW  0C
18208:  MOVWF  x84
1820A:  CLRF   x86
1820C:  CLRF   x85
1820E:  MOVLB  0
18210:  RCALL  17EA0
....................    write_macro_line(59, 0, 13, 0); 
18212:  MOVLW  3B
18214:  MOVLB  8
18216:  MOVWF  x81
18218:  CLRF   x83
1821A:  CLRF   x82
1821C:  MOVLW  0D
1821E:  MOVWF  x84
18220:  CLRF   x86
18222:  CLRF   x85
18224:  MOVLB  0
18226:  RCALL  17EA0
....................    write_macro_line(59, 0, 14, 0); 
18228:  MOVLW  3B
1822A:  MOVLB  8
1822C:  MOVWF  x81
1822E:  CLRF   x83
18230:  CLRF   x82
18232:  MOVLW  0E
18234:  MOVWF  x84
18236:  CLRF   x86
18238:  CLRF   x85
1823A:  MOVLB  0
1823C:  RCALL  17EA0
....................    write_macro_line(59, 0, 15, 0); 
1823E:  MOVLW  3B
18240:  MOVLB  8
18242:  MOVWF  x81
18244:  CLRF   x83
18246:  CLRF   x82
18248:  MOVLW  0F
1824A:  MOVWF  x84
1824C:  CLRF   x86
1824E:  CLRF   x85
18250:  MOVLB  0
18252:  RCALL  17EA0
....................    write_macro_line(59, 0, 16, 0); 
18254:  MOVLW  3B
18256:  MOVLB  8
18258:  MOVWF  x81
1825A:  CLRF   x83
1825C:  CLRF   x82
1825E:  MOVLW  10
18260:  MOVWF  x84
18262:  CLRF   x86
18264:  CLRF   x85
18266:  MOVLB  0
18268:  RCALL  17EA0
1826A:  GOTO   182A2 (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
17B2C:  MOVLB  8
17B2E:  CLRF   x81
....................     
....................    heartbeat(FALSE); 
17B30:  CLRF   xD7
17B32:  MOVLB  0
17B34:  CALL   55CC
....................     
....................    while(mcc != CARRIAGE_RET){ 
17B38:  MOVLB  8
17B3A:  MOVF   x81,W
17B3C:  SUBLW  0D
17B3E:  BZ    17B60
....................       if (kbhit(COM_A)) { 
17B40:  BTFSS  F9E.5
17B42:  BRA    17B5E
....................          mcc=fgetc(COM_A); 
17B44:  MOVLB  0
17B46:  CALL   0E24
17B4A:  MOVFF  01,881
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
17B4E:  DECFSZ 48,W
17B50:  BRA    17B5C
17B52:  MOVLB  8
17B54:  MOVF   x81,W
17B56:  MOVLB  0
17B58:  CALL   AEA6
17B5C:  MOVLB  8
....................       } 
17B5E:  BRA    17B3A
....................    } 
....................     
....................    heartbeat(TRUE); 
17B60:  MOVLW  01
17B62:  MOVWF  xD7
17B64:  MOVLB  0
17B66:  CALL   55CC
17B6A:  GOTO   17F2A (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
17F0E:  MOVLB  8
17F10:  CLRF   x80
....................     
....................    macro_cmd = get_cmd(macro); 
17F12:  MOVFF  878,881
17F16:  MOVLB  0
17F18:  BRA    17AE0
17F1A:  MOVFF  01,87D
....................    if (macro_cmd == 35){  
17F1E:  MOVLB  8
17F20:  MOVF   x7D,W
17F22:  SUBLW  23
17F24:  BNZ   17F2E
....................       macro_comment();        // # = 35 
17F26:  MOVLB  0
17F28:  BRA    17B2C
....................    }else if(macro_cmd == 112){// 112 is p 
17F2A:  BRA    17FB0
17F2C:  MOVLB  8
17F2E:  MOVF   x7D,W
17F30:  SUBLW  70
17F32:  BNZ   17F5A
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
17F34:  MOVLB  0
17F36:  BRA    17B6E
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
17F38:  MOVFF  87D,881
17F3C:  MOVFF  878,882
17F40:  MOVFF  87A,884
17F44:  MOVFF  879,883
17F48:  MOVFF  87C,886
17F4C:  MOVFF  87B,885
17F50:  BRA    17C74
....................       valid_macro = TRUE; 
17F52:  MOVLW  01
17F54:  MOVLB  8
17F56:  MOVWF  x80
....................    }else{ 
17F58:  BRA    17FAE
....................       if (macro_cmd != 0) { 
17F5A:  MOVF   x7D,F
17F5C:  BZ    17F84
....................          macro_arg = get_arg(); 
17F5E:  MOVLB  0
17F60:  BRA    17DB6
17F62:  MOVFF  02,87F
17F66:  MOVFF  01,87E
....................          if (macro_arg != 65535) valid_macro = TRUE; 
17F6A:  MOVLB  8
17F6C:  INCFSZ x7E,W
17F6E:  BRA    17F76
17F70:  INCFSZ x7F,W
17F72:  BRA    17F76
17F74:  BRA    17F7C
17F76:  MOVLW  01
17F78:  MOVWF  x80
17F7A:  BRA    17F82
....................          else return(macro_cmd); 
17F7C:  MOVFF  87D,01
17F80:  BRA    17FB6
....................       }else return(macro_cmd); 
17F82:  BRA    17F8A
17F84:  MOVFF  87D,01
17F88:  BRA    17FB6
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
17F8A:  MOVFF  87D,881
17F8E:  MOVFF  87F,883
17F92:  MOVFF  87E,882
17F96:  MOVFF  878,884
17F9A:  MOVFF  87A,886
17F9E:  MOVFF  879,885
17FA2:  MOVLB  0
17FA4:  RCALL  17EA0
....................       return(macro_cmd); 
17FA6:  MOVLB  8
17FA8:  MOVFF  87D,01
17FAC:  BRA    17FB6
17FAE:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
17FB0:  MOVLB  8
17FB2:  MOVFF  87D,01
17FB6:  MOVLB  0
17FB8:  GOTO   17FFE (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
17FBC:  MOVLB  8
17FBE:  CLRF   x77
17FC0:  CLRF   x76
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
17FC2:  CLRF   x72
17FC4:  CLRF   x71
....................    valid_macro = TRUE; 
17FC6:  MOVLW  01
17FC8:  MOVWF  x73
....................    macro_cmd = 1; 
17FCA:  MOVWF  x74
....................     
....................    init_ext_eeprom(); 
17FCC:  MOVLB  0
17FCE:  CALL   FFDA
....................     
....................    fprintf(COM_A, ":"); 
17FD2:  MOVLW  3A
17FD4:  BTFSS  F9E.4
17FD6:  BRA    17FD4
17FD8:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
17FDA:  MOVLB  8
17FDC:  MOVF   x74,W
17FDE:  SUBLW  3B
17FE0:  BZ    18044
17FE2:  MOVF   x74,F
17FE4:  BZ    18044
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
17FE6:  MOVFF  870,878
17FEA:  MOVFF  872,87A
17FEE:  MOVFF  871,879
17FF2:  MOVFF  877,87C
17FF6:  MOVFF  876,87B
17FFA:  MOVLB  0
17FFC:  BRA    17F0E
17FFE:  MOVFF  01,874
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
18002:  MOVLB  8
18004:  MOVF   x74,W
18006:  SUBLW  70
18008:  BNZ   18010
....................          count++; 
1800A:  INCF   x76,F
1800C:  BTFSC  FD8.2
1800E:  INCF   x77,F
....................       } 
....................       if (macro_cmd != 35) ++line; 
18010:  MOVF   x74,W
18012:  SUBLW  23
18014:  BZ    1801C
18016:  INCF   x71,F
18018:  BTFSC  FD8.2
1801A:  INCF   x72,F
....................       if (macro_cmd != 59) printf("\r\n:"); 
1801C:  MOVF   x74,W
1801E:  SUBLW  3B
18020:  BZ    18042
18022:  MOVLW  E2
18024:  MOVWF  FF6
18026:  MOVLW  20
18028:  MOVWF  FF7
1802A:  MOVLW  00
1802C:  MOVWF  FF8
1802E:  CLRF   1B
18030:  BTFSC  FF2.7
18032:  BSF    1B.7
18034:  BCF    FF2.7
18036:  MOVLB  0
18038:  CALL   0E3A
1803C:  BTFSC  1B.7
1803E:  BSF    FF2.7
18040:  MOVLB  8
18042:  BRA    17FDC
....................    }       
....................    if (macro_cmd == 0){ 
18044:  MOVF   x74,F
18046:  BNZ   180DC
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
18048:  MOVLW  E6
1804A:  MOVWF  FF6
1804C:  MOVLW  20
1804E:  MOVWF  FF7
18050:  MOVLW  00
18052:  MOVWF  FF8
18054:  CLRF   1B
18056:  BTFSC  FF2.7
18058:  BSF    1B.7
1805A:  BCF    FF2.7
1805C:  MOVLB  0
1805E:  CALL   0E3A
18062:  BTFSC  1B.7
18064:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
18066:  MOVLW  0E
18068:  MOVWF  FF6
1806A:  MOVLW  21
1806C:  MOVWF  FF7
1806E:  MOVLW  00
18070:  MOVWF  FF8
18072:  CLRF   1B
18074:  BTFSC  FF2.7
18076:  BSF    1B.7
18078:  BCF    FF2.7
1807A:  MOVLW  15
1807C:  MOVLB  A
1807E:  MOVWF  x25
18080:  MOVLB  0
18082:  CALL   1010
18086:  BTFSC  1B.7
18088:  BSF    FF2.7
1808A:  MOVLW  10
1808C:  MOVWF  FE9
1808E:  MOVFF  872,8DB
18092:  MOVFF  871,8DA
18096:  CALL   9016
1809A:  MOVLW  26
1809C:  MOVWF  FF6
1809E:  MOVLW  21
180A0:  MOVWF  FF7
180A2:  MOVLW  00
180A4:  MOVWF  FF8
180A6:  CLRF   1B
180A8:  BTFSC  FF2.7
180AA:  BSF    1B.7
180AC:  BCF    FF2.7
180AE:  MOVLW  03
180B0:  MOVLB  A
180B2:  MOVWF  x25
180B4:  MOVLB  0
180B6:  CALL   1010
180BA:  BTFSC  1B.7
180BC:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
180BE:  MOVLW  2A
180C0:  MOVWF  FF6
180C2:  MOVLW  21
180C4:  MOVWF  FF7
180C6:  MOVLW  00
180C8:  MOVWF  FF8
180CA:  CLRF   1B
180CC:  BTFSC  FF2.7
180CE:  BSF    1B.7
180D0:  BCF    FF2.7
180D2:  CALL   0E3A
180D6:  BTFSC  1B.7
180D8:  BSF    FF2.7
180DA:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
180DC:  MOVLW  0D
180DE:  BTFSS  F9E.4
180E0:  BRA    180DE
180E2:  MOVWF  FAD
180E4:  MOVLW  0A
180E6:  BTFSS  F9E.4
180E8:  BRA    180E6
180EA:  MOVWF  FAD
180EC:  MOVLB  0
180EE:  GOTO   1828A (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
182AC:  BCF    FD8.0
182AE:  MOVLB  8
182B0:  RLCF   x75,W
182B2:  CLRF   03
182B4:  ADDLW  CD
182B6:  MOVWF  FE9
182B8:  MOVLW  07
182BA:  ADDWFC 03,W
182BC:  MOVWF  FEA
182BE:  MOVFF  FEC,87E
182C2:  MOVF   FED,F
182C4:  MOVFF  FEF,87D
182C8:  MOVFF  877,9F7
182CC:  MOVFF  876,9F6
182D0:  MOVLB  9
182D2:  CLRF   xF9
182D4:  MOVLW  03
182D6:  MOVWF  xF8
182D8:  MOVLB  0
182DA:  CALL   5D06
182DE:  MOVF   01,W
182E0:  MOVLB  8
182E2:  ADDWF  x7D,W
182E4:  MOVWF  x78
182E6:  MOVF   02,W
182E8:  ADDWFC x7E,W
182EA:  MOVWF  x79
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
182EC:  MOVFF  879,8B6
182F0:  MOVFF  878,8B5
182F4:  MOVLB  0
182F6:  CALL   1037C
182FA:  MOVFF  01,87A
....................    ++addr; 
182FE:  MOVLB  8
18300:  INCF   x78,F
18302:  BTFSC  FD8.2
18304:  INCF   x79,F
....................    macro_arg = read16_ext_eeprom(addr); 
18306:  MOVFF  879,8AD
1830A:  MOVFF  878,8AC
1830E:  MOVLB  0
18310:  CALL   10490
18314:  MOVFF  02,87C
18318:  MOVFF  01,87B
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
1831C:  MOVLB  8
1831E:  MOVF   x7A,W
18320:  BTFSS  F9E.4
18322:  BRA    18320
18324:  MOVWF  FAD
18326:  MOVLW  10
18328:  MOVWF  FE9
1832A:  CLRF   1B
1832C:  BTFSC  FF2.7
1832E:  BSF    1B.7
18330:  BCF    FF2.7
18332:  MOVFF  87C,A26
18336:  MOVFF  87B,A25
1833A:  MOVLB  0
1833C:  CALL   1192
18340:  BTFSC  1B.7
18342:  BSF    FF2.7
18344:  MOVLW  0D
18346:  BTFSS  F9E.4
18348:  BRA    18346
1834A:  MOVWF  FAD
1834C:  MOVLW  0A
1834E:  BTFSS  F9E.4
18350:  BRA    1834E
18352:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
18354:  MOVLB  8
18356:  MOVFF  87A,01
1835A:  MOVLB  0
1835C:  GOTO   18390 (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
13F66:  BCF    FD8.0
13F68:  MOVLB  8
13F6A:  RLCF   xA1,W
13F6C:  CLRF   03
13F6E:  ADDLW  CD
13F70:  MOVWF  FE9
13F72:  MOVLW  07
13F74:  ADDWFC 03,W
13F76:  MOVWF  FEA
13F78:  MOVFF  FEC,8AA
13F7C:  MOVF   FED,F
13F7E:  MOVFF  FEF,8A9
13F82:  MOVFF  8A3,9F7
13F86:  MOVFF  8A2,9F6
13F8A:  MOVLB  9
13F8C:  CLRF   xF9
13F8E:  MOVLW  03
13F90:  MOVWF  xF8
13F92:  MOVLB  0
13F94:  CALL   5D06
13F98:  MOVF   01,W
13F9A:  MOVLB  8
13F9C:  ADDWF  xA9,W
13F9E:  MOVWF  xA4
13FA0:  MOVF   02,W
13FA2:  ADDWFC xAA,W
13FA4:  MOVWF  xA5
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
13FA6:  MOVFF  8A5,8B6
13FAA:  MOVFF  8A4,8B5
13FAE:  MOVLB  0
13FB0:  CALL   1037C
13FB4:  MOVFF  01,8A6
....................    ++addr; 
13FB8:  MOVLB  8
13FBA:  INCF   xA4,F
13FBC:  BTFSC  FD8.2
13FBE:  INCF   xA5,F
....................    macro_arg = read16_ext_eeprom(addr); 
13FC0:  MOVFF  8A5,8AD
13FC4:  MOVFF  8A4,8AC
13FC8:  MOVLB  0
13FCA:  CALL   10490
13FCE:  MOVFF  02,8A8
13FD2:  MOVFF  01,8A7
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
13FD6:  MOVLB  8
13FD8:  MOVF   xA6,W
13FDA:  BTFSS  F9E.4
13FDC:  BRA    13FDA
13FDE:  MOVWF  FAD
13FE0:  MOVLW  10
13FE2:  MOVWF  FE9
13FE4:  CLRF   1B
13FE6:  BTFSC  FF2.7
13FE8:  BSF    1B.7
13FEA:  BCF    FF2.7
13FEC:  MOVFF  8A8,A26
13FF0:  MOVFF  8A7,A25
13FF4:  MOVLB  0
13FF6:  CALL   1192
13FFA:  BTFSC  1B.7
13FFC:  BSF    FF2.7
13FFE:  MOVLW  0D
14000:  BTFSS  F9E.4
14002:  BRA    14000
14004:  MOVWF  FAD
14006:  MOVLW  0A
14008:  BTFSS  F9E.4
1400A:  BRA    14008
1400C:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
1400E:  MOVLB  8
14010:  MOVFF  8A6,01
14014:  MOVLB  0
14016:  GOTO   147EE (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
103D6:  BCF    FD8.0
103D8:  MOVLB  8
103DA:  RLCF   x9F,W
103DC:  CLRF   03
103DE:  ADDLW  F7
103E0:  MOVWF  FE9
103E2:  MOVLW  07
103E4:  ADDWFC 03,W
103E6:  MOVWF  FEA
103E8:  MOVFF  FEC,8A8
103EC:  MOVF   FED,F
103EE:  MOVFF  FEF,8A7
103F2:  MOVFF  8A3,9F7
103F6:  MOVFF  8A2,9F6
103FA:  MOVLB  9
103FC:  CLRF   xF9
103FE:  MOVLW  32
10400:  MOVWF  xF8
10402:  MOVLB  0
10404:  CALL   5D06
10408:  MOVF   01,W
1040A:  MOVLB  8
1040C:  ADDWF  xA7,W
1040E:  MOVWF  xA4
10410:  MOVF   02,W
10412:  ADDWFC xA8,W
10414:  MOVWF  xA5
....................     
....................    int i = 0; 
10416:  CLRF   xA6
....................    for(i = 0; i < 50; i++){ 
10418:  CLRF   xA6
1041A:  MOVF   xA6,W
1041C:  SUBLW  31
1041E:  BNC   10434
....................       string_arg[i] = 0; 
10420:  CLRF   03
10422:  MOVF   xA6,W
10424:  ADDLW  21
10426:  MOVWF  FE9
10428:  MOVLW  08
1042A:  ADDWFC 03,W
1042C:  MOVWF  FEA
1042E:  CLRF   FEF
10430:  INCF   xA6,F
10432:  BRA    1041A
....................    }  
....................    for(i = 0; i < 50; i++){ 
10434:  CLRF   xA6
10436:  MOVF   xA6,W
10438:  SUBLW  31
1043A:  BNC   1048C
....................       string_arg[i] = read_ext_eeprom(addr + i); 
1043C:  CLRF   03
1043E:  MOVF   xA6,W
10440:  ADDLW  21
10442:  MOVWF  01
10444:  MOVLW  08
10446:  ADDWFC 03,F
10448:  MOVFF  01,8A7
1044C:  MOVFF  03,8A8
10450:  MOVF   xA6,W
10452:  ADDWF  xA4,W
10454:  MOVWF  xA9
10456:  MOVLW  00
10458:  ADDWFC xA5,W
1045A:  MOVWF  xAA
1045C:  MOVWF  xB6
1045E:  MOVFF  8A9,8B5
10462:  MOVLB  0
10464:  RCALL  1037C
10466:  MOVFF  8A8,FEA
1046A:  MOVFF  8A7,FE9
1046E:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
10472:  CLRF   03
10474:  MOVLB  8
10476:  MOVF   xA6,W
10478:  ADDLW  21
1047A:  MOVWF  FE9
1047C:  MOVLW  08
1047E:  ADDWFC 03,W
10480:  MOVWF  FEA
10482:  MOVF   FEF,F
10484:  BNZ   10488
....................          break; 
10486:  BRA    1048C
....................       } 
10488:  INCF   xA6,F
1048A:  BRA    10436
....................    }   
1048C:  MOVLB  0
1048E:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
18360:  MOVLB  8
18362:  CLRF   x74
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
18364:  CLRF   x72
18366:  CLRF   x71
....................    macro_cmd = 1; 
18368:  MOVLW  01
1836A:  MOVWF  x73
....................     
....................    init_ext_eeprom(); 
1836C:  MOVLB  0
1836E:  CALL   FFDA
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
18372:  MOVLB  8
18374:  MOVF   x72,W
18376:  SUBLW  03
18378:  BNC   183C0
1837A:  MOVF   x73,W
1837C:  SUBLW  3B
1837E:  BZ    183C0
....................       macro_cmd = read_macro_line(macro, line); 
18380:  MOVFF  870,875
18384:  MOVFF  872,877
18388:  MOVFF  871,876
1838C:  MOVLB  0
1838E:  BRA    182AC
18390:  MOVFF  01,873
....................       if(macro_cmd == 'p'){ 
18394:  MOVLB  8
18396:  MOVF   x73,W
18398:  SUBLW  70
1839A:  BNZ   183B8
....................          read_macro_line_string(macro,line,count); 
1839C:  MOVFF  870,89F
183A0:  MOVFF  872,8A1
183A4:  MOVFF  871,8A0
183A8:  CLRF   xA3
183AA:  MOVFF  874,8A2
183AE:  MOVLB  0
183B0:  CALL   103D6
....................          count++; 
183B4:  MOVLB  8
183B6:  INCF   x74,F
....................       } 
....................       ++line; 
183B8:  INCF   x71,F
183BA:  BTFSC  FD8.2
183BC:  INCF   x72,F
183BE:  BRA    18374
....................    } 
183C0:  MOVLB  0
183C2:  GOTO   183E2 (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0D0B2:  MOVLB  8
0D0B4:  CLRF   xAF
0D0B6:  CLRF   xAE
0D0B8:  MOVF   xAF,W
0D0BA:  SUBWF  xAD,W
0D0BC:  BNC   D0E4
0D0BE:  BNZ   D0C6
0D0C0:  MOVF   xAC,W
0D0C2:  SUBWF  xAE,W
0D0C4:  BC    D0E4
....................       delay_ms(1000); 
0D0C6:  MOVLW  04
0D0C8:  MOVWF  xB0
0D0CA:  MOVLW  FA
0D0CC:  MOVLB  9
0D0CE:  MOVWF  xD6
0D0D0:  MOVLB  0
0D0D2:  CALL   2964
0D0D6:  MOVLB  8
0D0D8:  DECFSZ xB0,F
0D0DA:  BRA    D0CA
0D0DC:  INCF   xAE,F
0D0DE:  BTFSC  FD8.2
0D0E0:  INCF   xAF,F
0D0E2:  BRA    D0B8
....................    }  
0D0E4:  MOVLB  0
0D0E6:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0D07A:  BCF    FD8.0
0D07C:  MOVLB  7
0D07E:  RLCF   x3C,W
0D080:  CLRF   03
0D082:  ADDLW  92
0D084:  MOVWF  FE9
0D086:  MOVLW  07
0D088:  ADDWFC 03,W
0D08A:  MOVWF  FEA
0D08C:  MOVFF  FEC,8AE
0D090:  MOVF   FED,F
0D092:  MOVFF  FEF,8AD
0D096:  MOVLB  8
0D098:  DECFSZ xAD,W
0D09A:  BRA    D0A6
0D09C:  MOVF   xAE,F
0D09E:  BNZ   D0A6
....................    { 
....................       macro_status = 'e'; 
0D0A0:  MOVLW  65
0D0A2:  MOVWF  xAC
....................    } 
0D0A4:  BRA    D0AA
....................    else 
....................    { 
....................       macro_status = 'a'; 
0D0A6:  MOVLW  61
0D0A8:  MOVWF  xAC
....................    } 
....................    return(macro_status); 
0D0AA:  MOVFF  8AC,01
0D0AE:  MOVLB  0
0D0B0:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
13602:  DECFSZ 41,W
13604:  BRA    13618
13606:  MOVF   42,F
13608:  BNZ   13618
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
1360A:  MOVLW  01
1360C:  MOVLB  8
1360E:  MOVWF  xAC
13610:  MOVWF  xAD
13612:  MOVLB  0
13614:  RCALL  134CC
....................    } 
13616:  BRA    13642
....................    else if(nv_det_type==2 || nv_det_type==3) 
13618:  MOVF   41,W
1361A:  SUBLW  02
1361C:  BNZ   13622
1361E:  MOVF   42,F
13620:  BZ    1362C
13622:  MOVF   41,W
13624:  SUBLW  03
13626:  BNZ   13642
13628:  MOVF   42,F
1362A:  BNZ   13642
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
1362C:  MOVLB  8
1362E:  CLRF   xAD
13630:  MOVLW  C8
13632:  MOVWF  xAC
13634:  MOVLW  01
13636:  MOVWF  xAE
13638:  MOVWF  xAF
1363A:  CLRF   xB0
1363C:  MOVLB  0
1363E:  CALL   FD7C
....................    } 
13642:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
12524:  DECFSZ 41,W
12526:  BRA    12542
12528:  MOVF   42,F
1252A:  BNZ   12542
....................       cmd = macro_cmd; 
1252C:  MOVFF  8AC,43
....................       arg = macro_arg; 
12530:  CLRF   47
12532:  CLRF   46
12534:  MOVFF  8AE,45
12538:  MOVFF  8AD,44
....................       det_cmd(); 
1253C:  CALL   F176
....................    } 
12540:  BRA    1255C
....................    else if(nv_det_type==2 || nv_det_type==3) { 
12542:  MOVF   41,W
12544:  SUBLW  02
12546:  BNZ   1254C
12548:  MOVF   42,F
1254A:  BZ    12556
1254C:  MOVF   41,W
1254E:  SUBLW  03
12550:  BNZ   1255C
12552:  MOVF   42,F
12554:  BNZ   1255C
....................       set_heaters(macro_arg); 
12556:  MOVFF  8AD,8AF
1255A:  RCALL  124B0
....................    } 
1255C:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
1255E:  DECFSZ 41,W
12560:  BRA    1257C
12562:  MOVF   42,F
12564:  BNZ   1257C
....................       cmd = macro_cmd; 
12566:  MOVFF  8AC,43
....................       arg = macro_arg; 
1256A:  CLRF   47
1256C:  CLRF   46
1256E:  MOVFF  8AE,45
12572:  MOVFF  8AD,44
....................       det_cmd(); 
12576:  CALL   F176
....................    } 
1257A:  BRA    1259C
....................    else if(nv_det_type==2 || nv_det_type==3) { 
1257C:  MOVF   41,W
1257E:  SUBLW  02
12580:  BNZ   12586
12582:  MOVF   42,F
12584:  BZ    12590
12586:  MOVF   41,W
12588:  SUBLW  03
1258A:  BNZ   1259C
1258C:  MOVF   42,F
1258E:  BNZ   1259C
....................       set_LED(macro_arg); 
12590:  MOVFF  8AE,8B0
12594:  MOVFF  8AD,8AF
12598:  CALL   F63A
....................    } 
1259C:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13B7A:  MOVLW  65
13B7C:  MOVLB  8
13B7E:  MOVWF  xAB
....................     
....................    addr = macro_address[macro] + (line*3); 
13B80:  BCF    FD8.0
13B82:  RLCF   xA1,W
13B84:  CLRF   03
13B86:  ADDLW  CD
13B88:  MOVWF  FE9
13B8A:  MOVLW  07
13B8C:  ADDWFC 03,W
13B8E:  MOVWF  FEA
13B90:  MOVFF  FEC,8AD
13B94:  MOVF   FED,F
13B96:  MOVFF  FEF,8AC
13B9A:  MOVFF  8A3,9F7
13B9E:  MOVFF  8A2,9F6
13BA2:  MOVLB  9
13BA4:  CLRF   xF9
13BA6:  MOVLW  03
13BA8:  MOVWF  xF8
13BAA:  MOVLB  0
13BAC:  CALL   5D06
13BB0:  MOVF   01,W
13BB2:  MOVLB  8
13BB4:  ADDWF  xAC,W
13BB6:  MOVWF  xA6
13BB8:  MOVF   02,W
13BBA:  ADDWFC xAD,W
13BBC:  MOVWF  xA7
....................  
....................    init_ext_eeprom(); 
13BBE:  MOVLB  0
13BC0:  CALL   FFDA
....................    macro_cmd = read_ext_eeprom(addr); 
13BC4:  MOVFF  8A7,8B6
13BC8:  MOVFF  8A6,8B5
13BCC:  CALL   1037C
13BD0:  MOVFF  01,8A8
....................    ++addr; 
13BD4:  MOVLB  8
13BD6:  INCF   xA6,F
13BD8:  BTFSC  FD8.2
13BDA:  INCF   xA7,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13BDC:  MOVFF  8A7,8AD
13BE0:  MOVFF  8A6,8AC
13BE4:  MOVLB  0
13BE6:  CALL   10490
13BEA:  MOVFF  02,8AA
13BEE:  MOVFF  01,8A9
....................    //} 
....................    heartbeat(TRUE); 
13BF2:  MOVLW  01
13BF4:  MOVLB  8
13BF6:  MOVWF  xD7
13BF8:  MOVLB  0
13BFA:  CALL   55CC
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13BFE:  MOVF   2F,F
13C00:  BTFSS  FD8.2
13C02:  BRA    13EAE
13C04:  MOVF   30,F
13C06:  BTFSS  FD8.2
13C08:  BRA    13EAE
....................       switch(macro_cmd) 
13C0A:  MOVLW  2B
13C0C:  MOVLB  8
13C0E:  SUBWF  xA8,W
13C10:  ADDLW  BA
13C12:  BTFSC  FD8.0
13C14:  BRA    13EB0
13C16:  ADDLW  46
13C18:  MOVLB  0
13C1A:  GOTO   13EBA
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
13C1E:  CALL   1233E
....................             store_rel_data(); 
13C22:  CALL   123A2
....................             macro_status = 'a'; 
13C26:  MOVLW  61
13C28:  MOVLB  8
13C2A:  MOVWF  xAB
....................             break; 
13C2C:  BRA    13EB0
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
13C2E:  MOVLW  08
13C30:  MOVWF  FEA
13C32:  MOVLW  21
13C34:  MOVWF  FE9
13C36:  CALL   79CE
13C3A:  MOVLW  0D
13C3C:  BTFSS  F9E.4
13C3E:  BRA    13C3C
13C40:  MOVWF  FAD
13C42:  MOVLW  0A
13C44:  BTFSS  F9E.4
13C46:  BRA    13C44
13C48:  MOVWF  FAD
....................             macro_status = 'a'; 
13C4A:  MOVLW  61
13C4C:  MOVLB  8
13C4E:  MOVWF  xAB
....................             break; 
13C50:  BRA    13EB0
....................          case 'C' : 
....................             calc_abs_data(); 
13C52:  CALL   1233E
....................             break; 
13C56:  MOVLB  8
13C58:  BRA    13EB0
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
13C5A:  MOVFF  8AA,8AD
13C5E:  MOVFF  8A9,8AC
13C62:  CALL   D0B2
....................             macro_status = 'a'; 
13C66:  MOVLW  61
13C68:  MOVLB  8
13C6A:  MOVWF  xAB
....................             break; 
13C6C:  BRA    13EB0
....................          case 'F' : macro_flag = macro_arg; 
13C6E:  MOVFF  8AA,320
13C72:  MOVFF  8A9,31F
....................                     macro_status = 'a'; 
13C76:  MOVLW  61
13C78:  MOVLB  8
13C7A:  MOVWF  xAB
....................             break ; 
13C7C:  BRA    13EB0
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
13C7E:  MOVFF  8A9,2D1
....................                     macro_status = 'a'; 
13C82:  MOVLW  61
13C84:  MOVLB  8
13C86:  MOVWF  xAB
....................             break ; 
13C88:  BRA    13EB0
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
13C8A:  MOVFF  8A8,8AC
13C8E:  MOVFF  8AA,8AE
13C92:  MOVFF  8A9,8AD
13C96:  CALL   12524
....................                     macro_status = 'a'; 
13C9A:  MOVLW  61
13C9C:  MOVLB  8
13C9E:  MOVWF  xAB
....................             break; 
13CA0:  BRA    13EB0
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
13CA2:  MOVFF  8A8,8AC
13CA6:  MOVFF  8AA,8AE
13CAA:  MOVFF  8A9,8AD
13CAE:  CALL   12524
....................                     macro_status = 'a'; 
13CB2:  MOVLW  61
13CB4:  MOVLB  8
13CB6:  MOVWF  xAB
....................             break; 
13CB8:  BRA    13EB0
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
13CBA:  MOVFF  8AA,8C6
13CBE:  MOVFF  8A9,8C5
13CC2:  MOVLB  8
13CC4:  CLRF   xC8
13CC6:  MOVLW  64
13CC8:  MOVWF  xC7
13CCA:  MOVLB  0
13CCC:  CALL   2D28
13CD0:  MOVFF  02,749
13CD4:  MOVFF  01,748
....................                     macro_status = 'a'; 
13CD8:  MOVLW  61
13CDA:  MOVLB  8
13CDC:  MOVWF  xAB
....................             break;    
13CDE:  BRA    13EB0
....................          case 'l' : LightTargetFlag = 1; 
13CE0:  MOVLW  01
13CE2:  MOVLB  2
13CE4:  MOVWF  xD5
....................                     set_light(macro_cmd,macro_arg); 
13CE6:  MOVFF  8A8,8AC
13CEA:  MOVFF  8AA,8AE
13CEE:  MOVFF  8A9,8AD
13CF2:  MOVLB  0
13CF4:  CALL   1255E
....................                     delay_ms(10000); 
13CF8:  MOVLW  28
13CFA:  MOVLB  8
13CFC:  MOVWF  xAC
13CFE:  MOVLW  FA
13D00:  MOVLB  9
13D02:  MOVWF  xD6
13D04:  MOVLB  0
13D06:  CALL   2964
13D0A:  MOVLB  8
13D0C:  DECFSZ xAC,F
13D0E:  BRA    13CFE
....................                     macro_status = 'a'; 
13D10:  MOVLW  61
13D12:  MOVWF  xAB
....................             break;        
13D14:  BRA    13EB0
....................          case 'L' : LightTargetFlag = 0; 
13D16:  MOVLB  2
13D18:  CLRF   xD5
....................                     set_light(macro_cmd,macro_arg); 
13D1A:  MOVFF  8A8,8AC
13D1E:  MOVFF  8AA,8AE
13D22:  MOVFF  8A9,8AD
13D26:  MOVLB  0
13D28:  CALL   1255E
....................                     macro_status = 'a'; 
13D2C:  MOVLW  61
13D2E:  MOVLB  8
13D30:  MOVWF  xAB
....................             break; 
13D32:  BRA    13EB0
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
13D34:  MOVFF  8A8,43
....................                     arg = macro_arg; 
13D38:  CLRF   47
13D3A:  CLRF   46
13D3C:  MOVFF  8AA,45
13D40:  MOVFF  8A9,44
....................                     det_cmd(); 
13D44:  CALL   F176
....................                     macro_status = 'a'; 
13D48:  MOVLW  61
13D4A:  MOVLB  8
13D4C:  MOVWF  xAB
....................             break ; 
13D4E:  BRA    13EB0
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
13D50:  MOVLB  8
13D52:  DECFSZ xA9,W
13D54:  BRA    13D60
13D56:  MOVF   xAA,F
13D58:  BNZ   13D60
13D5A:  MOVLB  0
13D5C:  RCALL  13602
13D5E:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
13D60:  MOVF   xA9,W
13D62:  SUBLW  02
13D64:  BNZ   13D76
13D66:  MOVF   xAA,F
13D68:  BNZ   13D76
13D6A:  MOVLW  01
13D6C:  MOVWF  xAC
13D6E:  MOVWF  xAD
13D70:  MOVLB  0
13D72:  RCALL  137CE
13D74:  MOVLB  8
....................                     macro_status = 'a'; 
13D76:  MOVLW  61
13D78:  MOVWF  xAB
....................             break ;  
13D7A:  BRA    13EB0
....................          case 'T' : det_temp(); 
13D7C:  RCALL  1398E
....................                     macro_status = 'a'; 
13D7E:  MOVLW  61
13D80:  MOVLB  8
13D82:  MOVWF  xAB
....................             break; 
13D84:  BRA    13EB0
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
13D86:  MOVLW  01
13D88:  MOVLB  7
13D8A:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
13D8C:  MOVLB  8
13D8E:  CLRF   xB1
13D90:  CLRF   xB2
13D92:  CLRF   xB6
13D94:  CLRF   xB5
13D96:  MOVFF  8AA,8B4
13D9A:  MOVFF  8A9,8B3
13D9E:  MOVWF  xB7
13DA0:  MOVLB  0
13DA2:  CALL   9DAA
....................                     macro_status=step_err_status(); 
13DA6:  CALL   D07A
13DAA:  MOVFF  01,8AB
....................             break; 
13DAE:  MOVLB  8
13DB0:  BRA    13EB0
....................          case '-' : motor=1; 
13DB2:  MOVLW  01
13DB4:  MOVLB  7
13DB6:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
13DB8:  MOVLB  8
13DBA:  CLRF   xB1
13DBC:  MOVWF  xB2
13DBE:  CLRF   xB6
13DC0:  CLRF   xB5
13DC2:  MOVFF  8AA,8B4
13DC6:  MOVFF  8A9,8B3
13DCA:  MOVWF  xB7
13DCC:  MOVLB  0
13DCE:  CALL   9DAA
....................                     macro_status=step_err_status(); 
13DD2:  CALL   D07A
13DD6:  MOVFF  01,8AB
....................             break; 
13DDA:  MOVLB  8
13DDC:  BRA    13EB0
....................          case 'G' : motor=0; 
13DDE:  MOVLB  7
13DE0:  CLRF   x3C
....................                     align(0); 
13DE2:  MOVLB  8
13DE4:  CLRF   xAC
13DE6:  MOVLB  0
13DE8:  CALL   A8E6
....................                     macro_status=step_err_status(); 
13DEC:  CALL   D07A
13DF0:  MOVFF  01,8AB
....................             break ;           
13DF4:  MOVLB  8
13DF6:  BRA    13EB0
....................          case 'P' : motor=0; 
13DF8:  MOVLB  7
13DFA:  CLRF   x3C
....................                     move_motor(1,0,macro_arg,1);   
13DFC:  MOVLW  01
13DFE:  MOVLB  8
13E00:  MOVWF  xB1
13E02:  CLRF   xB2
13E04:  CLRF   xB6
13E06:  CLRF   xB5
13E08:  MOVFF  8AA,8B4
13E0C:  MOVFF  8A9,8B3
13E10:  MOVWF  xB7
13E12:  MOVLB  0
13E14:  CALL   9DAA
....................                     macro_status=step_err_status(); 
13E18:  CALL   D07A
13E1C:  MOVFF  01,8AB
....................             break; 
13E20:  MOVLB  8
13E22:  BRA    13EB0
....................          case 'Q' : motor=0; 
13E24:  MOVLB  7
13E26:  CLRF   x3C
....................                     move_motor(0,0,macro_arg,1); 
13E28:  MOVLB  8
13E2A:  CLRF   xB1
13E2C:  CLRF   xB2
13E2E:  CLRF   xB6
13E30:  CLRF   xB5
13E32:  MOVFF  8AA,8B4
13E36:  MOVFF  8A9,8B3
13E3A:  MOVLW  01
13E3C:  MOVWF  xB7
13E3E:  MOVLB  0
13E40:  CALL   9DAA
....................                     macro_status=step_err_status(); 
13E44:  CALL   D07A
13E48:  MOVFF  01,8AB
....................             break; 
13E4C:  MOVLB  8
13E4E:  BRA    13EB0
....................          case 'R' : motor=0; 
13E50:  MOVLB  7
13E52:  CLRF   x3C
....................                     move_motor(0,1,macro_arg,1); 
13E54:  MOVLB  8
13E56:  CLRF   xB1
13E58:  MOVLW  01
13E5A:  MOVWF  xB2
13E5C:  CLRF   xB6
13E5E:  CLRF   xB5
13E60:  MOVFF  8AA,8B4
13E64:  MOVFF  8A9,8B3
13E68:  MOVWF  xB7
13E6A:  MOVLB  0
13E6C:  CALL   9DAA
....................                     macro_status=step_err_status(); 
13E70:  CALL   D07A
13E74:  MOVFF  01,8AB
....................             break; 
13E78:  MOVLB  8
13E7A:  BRA    13EB0
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
13E7C:  MOVLB  8
13E7E:  DECFSZ xA9,W
13E80:  BRA    13E90
13E82:  MOVF   xAA,F
13E84:  BNZ   13E90
13E86:  MOVLB  0
13E88:  CALL   D0E8
13E8C:  BRA    13E9E
13E8E:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
13E90:  MOVF   xA9,F
13E92:  BNZ   13EA0
13E94:  MOVF   xAA,F
13E96:  BNZ   13EA0
13E98:  MOVLB  0
13E9A:  CALL   D10C
13E9E:  MOVLB  8
....................                     macro_status = 'a'; 
13EA0:  MOVLW  61
13EA2:  MOVWF  xAB
....................             break; 
13EA4:  BRA    13EB0
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
13EA6:  MOVLW  66
13EA8:  MOVLB  8
13EAA:  MOVWF  xAB
....................             break ; 
13EAC:  BRA    13EB0
13EAE:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
13EB0:  MOVFF  8AB,01
13EB4:  MOVLB  0
13EB6:  GOTO   147B6 (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
14612:  MOVLW  65
14614:  MOVLB  8
14616:  MOVWF  x91
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
14618:  BCF    FD8.0
1461A:  RLCF   x87,W
1461C:  CLRF   03
1461E:  ADDLW  CD
14620:  MOVWF  FE9
14622:  MOVLW  07
14624:  ADDWFC 03,W
14626:  MOVWF  FEA
14628:  MOVFF  FEC,8A0
1462C:  MOVF   FED,F
1462E:  MOVFF  FEF,89F
14632:  MOVFF  889,03
14636:  MOVFF  888,FE9
1463A:  MOVFF  889,FEA
1463E:  MOVFF  FEC,9F7
14642:  MOVF   FED,F
14644:  MOVFF  FEF,9F6
14648:  MOVLB  9
1464A:  CLRF   xF9
1464C:  MOVLW  03
1464E:  MOVWF  xF8
14650:  MOVLB  0
14652:  CALL   5D06
14656:  MOVF   01,W
14658:  MOVLB  8
1465A:  ADDWF  x9F,W
1465C:  MOVWF  x8C
1465E:  MOVF   02,W
14660:  ADDWFC xA0,W
14662:  MOVWF  x8D
....................  
....................    init_ext_eeprom(); 
14664:  MOVLB  0
14666:  CALL   FFDA
....................    macro_cmd = read_ext_eeprom(addr); 
1466A:  MOVFF  88D,8B6
1466E:  MOVFF  88C,8B5
14672:  CALL   1037C
14676:  MOVFF  01,88E
....................    ++addr; 
1467A:  MOVLB  8
1467C:  INCF   x8C,F
1467E:  BTFSC  FD8.2
14680:  INCF   x8D,F
....................    if(macro_cmd == 'p'){ 
14682:  MOVF   x8E,W
14684:  SUBLW  70
14686:  BNZ   146AC
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
14688:  MOVFF  887,89F
1468C:  MOVFF  889,8A1
14690:  MOVFF  888,8A0
14694:  MOVFF  854,8A3
14698:  MOVFF  853,8A2
1469C:  MOVLB  0
1469E:  CALL   103D6
....................       count1++; 
146A2:  MOVLB  8
146A4:  INCF   x53,F
146A6:  BTFSC  FD8.2
146A8:  INCF   x54,F
....................    }else{ 
146AA:  BRA    146C4
....................    macro_arg = read16_ext_eeprom(addr); 
146AC:  MOVFF  88D,8AD
146B0:  MOVFF  88C,8AC
146B4:  MOVLB  0
146B6:  CALL   10490
146BA:  MOVFF  02,890
146BE:  MOVFF  01,88F
146C2:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
146C4:  MOVLW  01
146C6:  MOVWF  xD7
146C8:  MOVLB  0
146CA:  CALL   55CC
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
146CE:  MOVF   2F,F
146D0:  BTFSS  FD8.2
146D2:  BRA    14B20
146D4:  MOVF   30,F
146D6:  BTFSS  FD8.2
146D8:  BRA    14B20
....................       switch(macro_cmd){ 
146DA:  MOVLW  2B
146DC:  MOVLB  8
146DE:  SUBWF  x8E,W
146E0:  ADDLW  B8
146E2:  BTFSC  FD8.0
146E4:  BRA    14B1C
146E6:  ADDLW  48
146E8:  MOVLB  0
146EA:  GOTO   14DE6
....................          case 'A' : 
....................             calc_abs_data(); 
146EE:  CALL   1233E
....................             store_rel_data(); 
146F2:  CALL   123A2
....................             macro_status = 'a'; 
146F6:  MOVLW  61
146F8:  MOVLB  8
146FA:  MOVWF  x91
....................             break; 
146FC:  BRA    14B1C
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
146FE:  MOVLW  08
14700:  MOVWF  FEA
14702:  MOVLW  21
14704:  MOVWF  FE9
14706:  CALL   79CE
1470A:  MOVLW  0D
1470C:  BTFSS  F9E.4
1470E:  BRA    1470C
14710:  MOVWF  FAD
14712:  MOVLW  0A
14714:  BTFSS  F9E.4
14716:  BRA    14714
14718:  MOVWF  FAD
....................             macro_status = 'a'; 
1471A:  MOVLW  61
1471C:  MOVLB  8
1471E:  MOVWF  x91
....................             break; 
14720:  BRA    14B1C
....................          case 'C' : 
....................             calc_abs_data(); 
14722:  CALL   1233E
....................             break; 
14726:  MOVLB  8
14728:  BRA    14B1C
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
1472A:  MOVLB  8
1472C:  CLRF   x95
1472E:  CLRF   x94
14730:  CLRF   x93
14732:  CLRF   x92
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
14734:  MOVFF  889,03
14738:  MOVFF  888,FE9
1473C:  MOVFF  889,FEA
14740:  MOVLW  01
14742:  ADDWF  FEE,F
14744:  BNC   14748
14746:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
14748:  MOVFF  888,FE9
1474C:  MOVFF  889,FEA
14750:  CLRF   x99
14752:  CLRF   x98
14754:  MOVFF  FEC,897
14758:  MOVF   FED,F
1475A:  MOVFF  FEF,896
1475E:  CLRF   x9D
14760:  CLRF   x9C
14762:  CLRF   x9B
14764:  CLRF   x9A
....................                    
....................                   while(count < macro_arg){ 
14766:  MOVF   x95,F
14768:  BTFSS  FD8.2
1476A:  BRA    148A6
1476C:  MOVF   x94,F
1476E:  BTFSS  FD8.2
14770:  BRA    148A6
14772:  MOVF   x93,W
14774:  SUBWF  x90,W
14776:  BTFSS  FD8.0
14778:  BRA    148A6
1477A:  BNZ   14784
1477C:  MOVF   x8F,W
1477E:  SUBWF  x92,W
14780:  BTFSC  FD8.0
14782:  BRA    148A6
....................                      char curr = 'A'; 
14784:  MOVLW  41
14786:  MOVWF  x9E
....................                      while(curr != '%'){ 
14788:  MOVF   x9E,W
1478A:  SUBLW  25
1478C:  BZ    147F8
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
1478E:  MOVFF  889,03
14792:  MOVFF  888,FE9
14796:  MOVFF  889,FEA
1479A:  MOVFF  FEC,8A3
1479E:  MOVF   FED,F
147A0:  MOVFF  FEF,8A2
147A4:  MOVFF  887,8A1
147A8:  MOVFF  88B,8A5
147AC:  MOVFF  88A,8A4
147B0:  MOVLB  0
147B2:  GOTO   13B7A
....................                         (*line)++; 
147B6:  MOVFF  889,03
147BA:  MOVLB  8
147BC:  MOVF   x88,W
147BE:  MOVWF  FE9
147C0:  MOVFF  03,FEA
147C4:  MOVLW  01
147C6:  ADDWF  FEE,F
147C8:  BNC   147CC
147CA:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
147CC:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
147CE:  MOVFF  889,03
147D2:  MOVFF  888,FE9
147D6:  MOVFF  889,FEA
147DA:  MOVFF  FEC,8A3
147DE:  MOVF   FED,F
147E0:  MOVFF  FEF,8A2
147E4:  MOVFF  887,8A1
147E8:  MOVLB  0
147EA:  GOTO   13F66
147EE:  MOVFF  01,89E
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
147F2:  BSF    F91.5
147F4:  MOVLB  8
147F6:  BRA    14788
....................                      } 
....................                      end_line = (*line); 
147F8:  MOVFF  888,FE9
147FC:  MOVFF  889,FEA
14800:  CLRF   x9D
14802:  CLRF   x9C
14804:  MOVFF  FEC,89B
14808:  MOVF   FED,F
1480A:  MOVFF  FEF,89A
....................                      count++; 
1480E:  MOVLW  01
14810:  ADDWF  x92,F
14812:  BTFSC  FD8.0
14814:  INCF   x93,F
14816:  BTFSC  FD8.2
14818:  INCF   x94,F
1481A:  BTFSC  FD8.2
1481C:  INCF   x95,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
1481E:  MOVF   x92,W
14820:  SUBWF  x8F,W
14822:  MOVWF  x9F
14824:  MOVF   x93,W
14826:  SUBWFB x90,W
14828:  MOVWF  xA0
1482A:  MOVLW  00
1482C:  SUBFWB x94,W
1482E:  MOVWF  xA1
14830:  MOVLW  00
14832:  SUBFWB x95,W
14834:  MOVWF  xA2
14836:  MOVLW  42
14838:  MOVWF  FF6
1483A:  MOVLW  21
1483C:  MOVWF  FF7
1483E:  MOVLW  00
14840:  MOVWF  FF8
14842:  CLRF   1B
14844:  BTFSC  FF2.7
14846:  BSF    1B.7
14848:  BCF    FF2.7
1484A:  MOVLW  11
1484C:  MOVLB  A
1484E:  MOVWF  x25
14850:  MOVLB  0
14852:  CALL   1010
14856:  BTFSC  1B.7
14858:  BSF    FF2.7
1485A:  MOVLW  41
1485C:  MOVWF  FE9
1485E:  CLRF   1B
14860:  BTFSC  FF2.7
14862:  BSF    1B.7
14864:  BCF    FF2.7
14866:  MOVFF  8A2,A28
1486A:  MOVFF  8A1,A27
1486E:  MOVFF  8A0,A26
14872:  MOVFF  89F,A25
14876:  CALL   10D6
1487A:  BTFSC  1B.7
1487C:  BSF    FF2.7
1487E:  MOVLW  0D
14880:  BTFSS  F9E.4
14882:  BRA    14880
14884:  MOVWF  FAD
14886:  MOVLW  0A
14888:  BTFSS  F9E.4
1488A:  BRA    14888
1488C:  MOVWF  FAD
....................                      (*line) = start_line; 
1488E:  MOVFF  889,03
14892:  MOVLB  8
14894:  MOVFF  888,FE9
14898:  MOVFF  889,FEA
1489C:  MOVFF  896,FEF
148A0:  MOVFF  897,FEC
148A4:  BRA    14766
....................                   } 
....................                   (*line) = end_line + 1; 
148A6:  MOVFF  888,FE9
148AA:  MOVFF  889,FEA
148AE:  MOVLW  01
148B0:  ADDWF  x9A,W
148B2:  MOVWF  FEF
148B4:  MOVLW  00
148B6:  ADDWFC x9B,W
148B8:  MOVWF  FEC
....................                   macro_status = 'a'; 
148BA:  MOVLW  61
148BC:  MOVWF  x91
....................             break; 
148BE:  BRA    14B1C
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
148C0:  MOVFF  890,8AD
148C4:  MOVFF  88F,8AC
148C8:  CALL   D0B2
....................                     macro_status = 'a'; 
148CC:  MOVLW  61
148CE:  MOVLB  8
148D0:  MOVWF  x91
....................             break; 
148D2:  BRA    14B1C
....................          case 'F' : macro_flag = macro_arg; 
148D4:  MOVFF  890,320
148D8:  MOVFF  88F,31F
....................                     macro_status = 'a'; 
148DC:  MOVLW  61
148DE:  MOVLB  8
148E0:  MOVWF  x91
....................             break ; 
148E2:  BRA    14B1C
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
148E4:  MOVFF  88F,2D1
....................                     macro_status = 'a'; 
148E8:  MOVLW  61
148EA:  MOVLB  8
148EC:  MOVWF  x91
....................             break ; 
148EE:  BRA    14B1C
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
148F0:  MOVFF  88E,8AC
148F4:  MOVFF  890,8AE
148F8:  MOVFF  88F,8AD
148FC:  CALL   12524
....................                     macro_status = 'a'; 
14900:  MOVLW  61
14902:  MOVLB  8
14904:  MOVWF  x91
....................             break; 
14906:  BRA    14B1C
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14908:  MOVFF  88E,8AC
1490C:  MOVFF  890,8AE
14910:  MOVFF  88F,8AD
14914:  CALL   12524
....................                     macro_status = 'a'; 
14918:  MOVLW  61
1491A:  MOVLB  8
1491C:  MOVWF  x91
....................             break; 
1491E:  BRA    14B1C
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14920:  MOVFF  890,8C6
14924:  MOVFF  88F,8C5
14928:  MOVLB  8
1492A:  CLRF   xC8
1492C:  MOVLW  64
1492E:  MOVWF  xC7
14930:  MOVLB  0
14932:  CALL   2D28
14936:  MOVFF  02,749
1493A:  MOVFF  01,748
....................                     macro_status = 'a'; 
1493E:  MOVLW  61
14940:  MOVLB  8
14942:  MOVWF  x91
....................             break;    
14944:  BRA    14B1C
....................          case 'l' : LightTargetFlag = 1; 
14946:  MOVLW  01
14948:  MOVLB  2
1494A:  MOVWF  xD5
....................                     set_light(macro_cmd,macro_arg); 
1494C:  MOVFF  88E,8AC
14950:  MOVFF  890,8AE
14954:  MOVFF  88F,8AD
14958:  MOVLB  0
1495A:  CALL   1255E
....................                     delay_ms(10000); 
1495E:  MOVLW  28
14960:  MOVLB  8
14962:  MOVWF  x9F
14964:  MOVLW  FA
14966:  MOVLB  9
14968:  MOVWF  xD6
1496A:  MOVLB  0
1496C:  CALL   2964
14970:  MOVLB  8
14972:  DECFSZ x9F,F
14974:  BRA    14964
....................                     macro_status = 'a'; 
14976:  MOVLW  61
14978:  MOVWF  x91
....................             break;        
1497A:  BRA    14B1C
....................          case 'L' : LightTargetFlag = 0; 
1497C:  MOVLB  2
1497E:  CLRF   xD5
....................                     set_light(macro_cmd,macro_arg); 
14980:  MOVFF  88E,8AC
14984:  MOVFF  890,8AE
14988:  MOVFF  88F,8AD
1498C:  MOVLB  0
1498E:  CALL   1255E
....................                     macro_status = 'a'; 
14992:  MOVLW  61
14994:  MOVLB  8
14996:  MOVWF  x91
....................             break; 
14998:  BRA    14B1C
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
1499A:  MOVFF  88E,43
....................                     arg = macro_arg; 
1499E:  CLRF   47
149A0:  CLRF   46
149A2:  MOVFF  890,45
149A6:  MOVFF  88F,44
....................                     det_cmd(); 
149AA:  CALL   F176
....................                     macro_status = 'a'; 
149AE:  MOVLW  61
149B0:  MOVLB  8
149B2:  MOVWF  x91
....................             break ; 
149B4:  BRA    14B1C
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
149B6:  MOVLB  8
149B8:  DECFSZ x8F,W
149BA:  BRA    149C8
149BC:  MOVF   x90,F
149BE:  BNZ   149C8
149C0:  MOVLB  0
149C2:  CALL   13602
149C6:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
149C8:  MOVF   x8F,W
149CA:  SUBLW  02
149CC:  BNZ   149E0
149CE:  MOVF   x90,F
149D0:  BNZ   149E0
149D2:  MOVLW  01
149D4:  MOVWF  xAC
149D6:  MOVWF  xAD
149D8:  MOVLB  0
149DA:  CALL   137CE
149DE:  MOVLB  8
....................                     macro_status = 'a'; 
149E0:  MOVLW  61
149E2:  MOVWF  x91
....................             break ;  
149E4:  BRA    14B1C
....................          case 'T' : det_temp(); 
149E6:  CALL   1398E
....................                     macro_status = 'a'; 
149EA:  MOVLW  61
149EC:  MOVLB  8
149EE:  MOVWF  x91
....................             break; 
149F0:  BRA    14B1C
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
149F2:  MOVLW  01
149F4:  MOVLB  7
149F6:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
149F8:  MOVLB  8
149FA:  CLRF   xB1
149FC:  CLRF   xB2
149FE:  CLRF   xB6
14A00:  CLRF   xB5
14A02:  MOVFF  890,8B4
14A06:  MOVFF  88F,8B3
14A0A:  MOVWF  xB7
14A0C:  MOVLB  0
14A0E:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14A12:  CALL   D07A
14A16:  MOVFF  01,891
....................             break; 
14A1A:  MOVLB  8
14A1C:  BRA    14B1C
....................          case '-' : motor=1; 
14A1E:  MOVLW  01
14A20:  MOVLB  7
14A22:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14A24:  MOVLB  8
14A26:  CLRF   xB1
14A28:  MOVWF  xB2
14A2A:  CLRF   xB6
14A2C:  CLRF   xB5
14A2E:  MOVFF  890,8B4
14A32:  MOVFF  88F,8B3
14A36:  MOVWF  xB7
14A38:  MOVLB  0
14A3A:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14A3E:  CALL   D07A
14A42:  MOVFF  01,891
....................             break; 
14A46:  MOVLB  8
14A48:  BRA    14B1C
....................          case 'G' : motor=0; 
14A4A:  MOVLB  7
14A4C:  CLRF   x3C
....................                     align(0); 
14A4E:  MOVLB  8
14A50:  CLRF   xAC
14A52:  MOVLB  0
14A54:  CALL   A8E6
....................                     macro_status=step_err_status(); 
14A58:  CALL   D07A
14A5C:  MOVFF  01,891
....................             break ;           
14A60:  MOVLB  8
14A62:  BRA    14B1C
....................          case 'P' : motor=0; 
14A64:  MOVLB  7
14A66:  CLRF   x3C
....................                     move_motor(1,0,macro_arg,1);   
14A68:  MOVLW  01
14A6A:  MOVLB  8
14A6C:  MOVWF  xB1
14A6E:  CLRF   xB2
14A70:  CLRF   xB6
14A72:  CLRF   xB5
14A74:  MOVFF  890,8B4
14A78:  MOVFF  88F,8B3
14A7C:  MOVWF  xB7
14A7E:  MOVLB  0
14A80:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14A84:  CALL   D07A
14A88:  MOVFF  01,891
....................             break; 
14A8C:  MOVLB  8
14A8E:  BRA    14B1C
....................          case 'Q' : motor=0; 
14A90:  MOVLB  7
14A92:  CLRF   x3C
....................                     move_motor(0,0,macro_arg,1); 
14A94:  MOVLB  8
14A96:  CLRF   xB1
14A98:  CLRF   xB2
14A9A:  CLRF   xB6
14A9C:  CLRF   xB5
14A9E:  MOVFF  890,8B4
14AA2:  MOVFF  88F,8B3
14AA6:  MOVLW  01
14AA8:  MOVWF  xB7
14AAA:  MOVLB  0
14AAC:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14AB0:  CALL   D07A
14AB4:  MOVFF  01,891
....................             break; 
14AB8:  MOVLB  8
14ABA:  BRA    14B1C
....................          case 'R' : motor=0; 
14ABC:  MOVLB  7
14ABE:  CLRF   x3C
....................                     move_motor(0,1,macro_arg,1); 
14AC0:  MOVLB  8
14AC2:  CLRF   xB1
14AC4:  MOVLW  01
14AC6:  MOVWF  xB2
14AC8:  CLRF   xB6
14ACA:  CLRF   xB5
14ACC:  MOVFF  890,8B4
14AD0:  MOVFF  88F,8B3
14AD4:  MOVWF  xB7
14AD6:  MOVLB  0
14AD8:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14ADC:  CALL   D07A
14AE0:  MOVFF  01,891
....................             break; 
14AE4:  MOVLB  8
14AE6:  BRA    14B1C
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14AE8:  MOVLB  8
14AEA:  DECFSZ x8F,W
14AEC:  BRA    14AFC
14AEE:  MOVF   x90,F
14AF0:  BNZ   14AFC
14AF2:  MOVLB  0
14AF4:  CALL   D0E8
14AF8:  BRA    14B0A
14AFA:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14AFC:  MOVF   x8F,F
14AFE:  BNZ   14B0C
14B00:  MOVF   x90,F
14B02:  BNZ   14B0C
14B04:  MOVLB  0
14B06:  CALL   D10C
14B0A:  MOVLB  8
....................                     macro_status = 'a'; 
14B0C:  MOVLW  61
14B0E:  MOVWF  x91
....................             break; 
14B10:  BRA    14B1C
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14B12:  MOVLW  66
14B14:  MOVLB  8
14B16:  MOVWF  x91
....................             break ; 
14B18:  BRA    14B1C
14B1A:  MOVLB  8
....................       } 
....................    } 
14B1C:  BRA    14DDC
14B1E:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14B20:  DECFSZ 2F,W
14B22:  BRA    14B28
14B24:  MOVF   30,F
14B26:  BZ    14B36
14B28:  MOVF   2F,W
14B2A:  SUBLW  03
14B2C:  BTFSS  FD8.2
14B2E:  BRA    14CB4
14B30:  MOVF   30,F
14B32:  BTFSS  FD8.2
14B34:  BRA    14CB4
....................       switch(macro_cmd){ 
14B36:  MOVLB  8
14B38:  MOVF   x8E,W
14B3A:  XORLW  2B
14B3C:  MOVLB  0
14B3E:  BZ    14B6C
14B40:  XORLW  06
14B42:  BZ    14B96
14B44:  XORLW  6F
14B46:  BZ    14BC0
14B48:  XORLW  05
14B4A:  BZ    14BD2
14B4C:  XORLW  17
14B4E:  BZ    14BEA
14B50:  XORLW  01
14B52:  BZ    14C14
14B54:  XORLW  03
14B56:  BZ    14C3E
14B58:  XORLW  06
14B5A:  BTFSC  FD8.2
14B5C:  BRA    14C68
14B5E:  XORLW  0D
14B60:  BTFSC  FD8.2
14B62:  BRA    14C7E
14B64:  XORLW  62
14B66:  BTFSC  FD8.2
14B68:  BRA    14CAA
14B6A:  BRA    14CB2
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14B6C:  MOVLW  01
14B6E:  MOVLB  7
14B70:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14B72:  MOVLB  8
14B74:  CLRF   xB1
14B76:  CLRF   xB2
14B78:  CLRF   xB6
14B7A:  CLRF   xB5
14B7C:  MOVFF  890,8B4
14B80:  MOVFF  88F,8B3
14B84:  MOVWF  xB7
14B86:  MOVLB  0
14B88:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14B8C:  CALL   D07A
14B90:  MOVFF  01,891
....................             break; 
14B94:  BRA    14CB2
....................          case '-' : motor=1; 
14B96:  MOVLW  01
14B98:  MOVLB  7
14B9A:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14B9C:  MOVLB  8
14B9E:  CLRF   xB1
14BA0:  MOVWF  xB2
14BA2:  CLRF   xB6
14BA4:  CLRF   xB5
14BA6:  MOVFF  890,8B4
14BAA:  MOVFF  88F,8B3
14BAE:  MOVWF  xB7
14BB0:  MOVLB  0
14BB2:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14BB6:  CALL   D07A
14BBA:  MOVFF  01,891
....................             break; 
14BBE:  BRA    14CB2
....................          case 'B' : h_bridge(macro_arg); 
14BC0:  MOVFF  88F,89F
14BC4:  CALL   BFB4
....................                     macro_status = 'a'; 
14BC8:  MOVLW  61
14BCA:  MOVLB  8
14BCC:  MOVWF  x91
....................             break;             
14BCE:  MOVLB  0
14BD0:  BRA    14CB2
....................          case 'G' : motor=0; 
14BD2:  MOVLB  7
14BD4:  CLRF   x3C
....................                     align(0); 
14BD6:  MOVLB  8
14BD8:  CLRF   xAC
14BDA:  MOVLB  0
14BDC:  CALL   A8E6
....................                     macro_status=step_err_status(); 
14BE0:  CALL   D07A
14BE4:  MOVFF  01,891
....................             break ;           
14BE8:  BRA    14CB2
....................          case 'P' : motor=0; 
14BEA:  MOVLB  7
14BEC:  CLRF   x3C
....................                     move_motor(0,0,mmacro_var,1);   
14BEE:  MOVLB  8
14BF0:  CLRF   xB1
14BF2:  CLRF   xB2
14BF4:  CLRF   xB6
14BF6:  CLRF   xB5
14BF8:  MOVFF  88B,8B4
14BFC:  MOVFF  88A,8B3
14C00:  MOVLW  01
14C02:  MOVWF  xB7
14C04:  MOVLB  0
14C06:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14C0A:  CALL   D07A
14C0E:  MOVFF  01,891
....................             break; 
14C12:  BRA    14CB2
....................          case 'Q' : motor=0; 
14C14:  MOVLB  7
14C16:  CLRF   x3C
....................                     move_motor(0,0,mmacro_var,1); 
14C18:  MOVLB  8
14C1A:  CLRF   xB1
14C1C:  CLRF   xB2
14C1E:  CLRF   xB6
14C20:  CLRF   xB5
14C22:  MOVFF  88B,8B4
14C26:  MOVFF  88A,8B3
14C2A:  MOVLW  01
14C2C:  MOVWF  xB7
14C2E:  MOVLB  0
14C30:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14C34:  CALL   D07A
14C38:  MOVFF  01,891
....................             break; 
14C3C:  BRA    14CB2
....................          case 'R' : motor=0; 
14C3E:  MOVLB  7
14C40:  CLRF   x3C
....................                     move_motor(0,1,mmacro_var,1); 
14C42:  MOVLB  8
14C44:  CLRF   xB1
14C46:  MOVLW  01
14C48:  MOVWF  xB2
14C4A:  CLRF   xB6
14C4C:  CLRF   xB5
14C4E:  MOVFF  88B,8B4
14C52:  MOVFF  88A,8B3
14C56:  MOVWF  xB7
14C58:  MOVLB  0
14C5A:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14C5E:  CALL   D07A
14C62:  MOVFF  01,891
....................             break; 
14C66:  BRA    14CB2
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
14C68:  MOVFF  890,8AD
14C6C:  MOVFF  88F,8AC
14C70:  CALL   D0B2
....................                     macro_status = 'a'; 
14C74:  MOVLW  61
14C76:  MOVLB  8
14C78:  MOVWF  x91
....................             break; 
14C7A:  MOVLB  0
14C7C:  BRA    14CB2
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
14C7E:  MOVLB  8
14C80:  DECFSZ x8F,W
14C82:  BRA    14C92
14C84:  MOVF   x90,F
14C86:  BNZ   14C92
14C88:  MOVLB  0
14C8A:  CALL   D0E8
14C8E:  BRA    14CA0
14C90:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14C92:  MOVF   x8F,F
14C94:  BNZ   14CA2
14C96:  MOVF   x90,F
14C98:  BNZ   14CA2
14C9A:  MOVLB  0
14C9C:  CALL   D10C
14CA0:  MOVLB  8
....................                     macro_status = 'a'; 
14CA2:  MOVLW  61
14CA4:  MOVWF  x91
....................             break; 
14CA6:  MOVLB  0
14CA8:  BRA    14CB2
....................          case ';' : macro_status = 'f'; 
14CAA:  MOVLW  66
14CAC:  MOVLB  8
14CAE:  MOVWF  x91
....................             break;            
14CB0:  MOVLB  0
....................       } 
....................    } 
14CB2:  BRA    14DDA
....................    else if (nv_product==AWS){ 
14CB4:  MOVF   2F,W
14CB6:  SUBLW  02
14CB8:  BTFSS  FD8.2
14CBA:  BRA    14DDA
14CBC:  MOVF   30,F
14CBE:  BTFSS  FD8.2
14CC0:  BRA    14DDA
....................       switch(macro_cmd){ 
14CC2:  MOVLB  8
14CC4:  MOVF   x8E,W
14CC6:  XORLW  2B
14CC8:  MOVLB  0
14CCA:  BZ    14CF0
14CCC:  XORLW  06
14CCE:  BZ    14D1A
14CD0:  XORLW  6E
14CD2:  BZ    14D44
14CD4:  XORLW  07
14CD6:  BZ    14D56
14CD8:  XORLW  14
14CDA:  BZ    14D6C
14CDC:  XORLW  01
14CDE:  BZ    14D7E
14CE0:  XORLW  02
14CE2:  BZ    14D90
14CE4:  XORLW  0A
14CE6:  BZ    14DA6
14CE8:  XORLW  62
14CEA:  BTFSC  FD8.2
14CEC:  BRA    14DD2
14CEE:  BRA    14DDA
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14CF0:  MOVLW  01
14CF2:  MOVLB  7
14CF4:  MOVWF  x3C
....................                     move_motor(0,0,macro_arg,1); 
14CF6:  MOVLB  8
14CF8:  CLRF   xB1
14CFA:  CLRF   xB2
14CFC:  CLRF   xB6
14CFE:  CLRF   xB5
14D00:  MOVFF  890,8B4
14D04:  MOVFF  88F,8B3
14D08:  MOVWF  xB7
14D0A:  MOVLB  0
14D0C:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14D10:  CALL   D07A
14D14:  MOVFF  01,891
....................             break; 
14D18:  BRA    14DDA
....................          case '-' : motor=1; 
14D1A:  MOVLW  01
14D1C:  MOVLB  7
14D1E:  MOVWF  x3C
....................                     move_motor(0,1,macro_arg,1); 
14D20:  MOVLB  8
14D22:  CLRF   xB1
14D24:  MOVWF  xB2
14D26:  CLRF   xB6
14D28:  CLRF   xB5
14D2A:  MOVFF  890,8B4
14D2E:  MOVFF  88F,8B3
14D32:  MOVWF  xB7
14D34:  MOVLB  0
14D36:  CALL   9DAA
....................                     macro_status=step_err_status(); 
14D3A:  CALL   D07A
14D3E:  MOVFF  01,891
....................             break; 
14D42:  BRA    14DDA
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
14D44:  MOVFF  88F,8A0
14D48:  CALL   D92E
....................                     macro_status = 'a';  
14D4C:  MOVLW  61
14D4E:  MOVLB  8
14D50:  MOVWF  x91
....................             break;          
14D52:  MOVLB  0
14D54:  BRA    14DDA
....................          case 'D' : delay_sec(macro_arg); 
14D56:  MOVFF  890,8AD
14D5A:  MOVFF  88F,8AC
14D5E:  CALL   D0B2
....................                     macro_status = 'a'; 
14D62:  MOVLW  61
14D64:  MOVLB  8
14D66:  MOVWF  x91
....................             break; 
14D68:  MOVLB  0
14D6A:  BRA    14DDA
....................          case 'P' : sol_switch(mmacro_var); 
14D6C:  MOVFF  88A,89F
14D70:  CALL   1418A
....................                     macro_status = 'a'; 
14D74:  MOVLW  61
14D76:  MOVLB  8
14D78:  MOVWF  x91
....................             break;              
14D7A:  MOVLB  0
14D7C:  BRA    14DDA
....................          case 'Q' : sol_switch(macro_arg); 
14D7E:  MOVFF  88F,89F
14D82:  CALL   1418A
....................                     macro_status = 'a'; 
14D86:  MOVLW  61
14D88:  MOVLB  8
14D8A:  MOVWF  x91
....................             break;             
14D8C:  MOVLB  0
14D8E:  BRA    14DDA
....................          case 'S' : sol_switch_cmd(macro_arg); 
14D90:  MOVFF  890,8A1
14D94:  MOVFF  88F,8A0
14D98:  CALL   140D4
....................                     macro_status = 'a'; 
14D9C:  MOVLW  61
14D9E:  MOVLB  8
14DA0:  MOVWF  x91
....................             break; 
14DA2:  MOVLB  0
14DA4:  BRA    14DDA
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14DA6:  MOVLB  8
14DA8:  DECFSZ x8F,W
14DAA:  BRA    14DBA
14DAC:  MOVF   x90,F
14DAE:  BNZ   14DBA
14DB0:  MOVLB  0
14DB2:  CALL   D0E8
14DB6:  BRA    14DC8
14DB8:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14DBA:  MOVF   x8F,F
14DBC:  BNZ   14DCA
14DBE:  MOVF   x90,F
14DC0:  BNZ   14DCA
14DC2:  MOVLB  0
14DC4:  CALL   D10C
14DC8:  MOVLB  8
....................                     macro_status = 'a'; 
14DCA:  MOVLW  61
14DCC:  MOVWF  x91
....................             break;               
14DCE:  MOVLB  0
14DD0:  BRA    14DDA
....................          case ';' : macro_status = 'f'; 
14DD2:  MOVLW  66
14DD4:  MOVLB  8
14DD6:  MOVWF  x91
....................             break;            
14DD8:  MOVLB  0
14DDA:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
14DDC:  MOVFF  891,01
14DE0:  MOVLB  0
14DE2:  GOTO   150F2 (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
14FC0:  MOVLB  8
14FC2:  CLRF   x54
14FC4:  CLRF   x53
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
14FC6:  MOVLB  0
14FC8:  CALL   5130
....................    clear_data_arrays(); 
14FCC:  GOTO   1028E
....................     
....................    line = 0;  
14FD0:  MOVLB  8
14FD2:  CLRF   x85
14FD4:  CLRF   x84
....................    macro_status = 'a'; 
14FD6:  MOVLW  61
14FD8:  MOVWF  x86
....................    data_available = FALSE; 
14FDA:  MOVLB  3
14FDC:  CLRF   x37
....................    macro_flag = 900; 
14FDE:  MOVLW  03
14FE0:  MOVWF  x20
14FE2:  MOVLW  84
14FE4:  MOVWF  x1F
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
14FE6:  MOVLW  01
14FE8:  MOVWF  1E
14FEA:  MOVLW  A3
14FEC:  MOVWF  1D
14FEE:  MOVLW  5A
14FF0:  MOVWF  FF6
14FF2:  MOVLW  21
14FF4:  MOVWF  FF7
14FF6:  MOVLW  00
14FF8:  MOVWF  FF8
14FFA:  MOVLW  07
14FFC:  MOVLB  8
14FFE:  MOVWF  xD5
15000:  MOVLB  0
15002:  CALL   AAF6
15006:  MOVFF  881,8D7
1500A:  MOVLW  1B
1500C:  MOVLB  8
1500E:  MOVWF  xD8
15010:  MOVLB  0
15012:  CALL   52CA
15016:  MOVLW  63
15018:  MOVWF  FF6
1501A:  MOVLW  21
1501C:  MOVWF  FF7
1501E:  MOVLW  00
15020:  MOVWF  FF8
15022:  MOVLW  09
15024:  MOVLB  8
15026:  MOVWF  xD5
15028:  MOVLB  0
1502A:  CALL   AAF6
....................    record_event();    
1502E:  CALL   850C
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
15032:  MOVLB  8
15034:  MOVF   x85,W
15036:  SUBLW  03
15038:  BNC   1510A
1503A:  MOVF   x86,W
1503C:  SUBLW  61
1503E:  BNZ   1510A
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
15040:  MOVF   1F,W
15042:  SUBLW  04
15044:  BNZ   150D8
15046:  MOVF   20,F
15048:  BNZ   150D8
....................                                                macro_status, (line + 1)); 
1504A:  MOVLW  01
1504C:  ADDWF  x84,W
1504E:  MOVWF  x87
15050:  MOVLW  00
15052:  ADDWFC x85,W
15054:  MOVWF  x88
15056:  MOVLW  6E
15058:  MOVWF  FF6
1505A:  MOVLW  21
1505C:  MOVWF  FF7
1505E:  MOVLW  00
15060:  MOVWF  FF8
15062:  CLRF   1B
15064:  BTFSC  FF2.7
15066:  BSF    1B.7
15068:  BCF    FF2.7
1506A:  MOVLW  05
1506C:  MOVLB  A
1506E:  MOVWF  x25
15070:  MOVLB  0
15072:  CALL   1010
15076:  BTFSC  1B.7
15078:  BSF    FF2.7
1507A:  MOVLB  8
1507C:  MOVF   x86,W
1507E:  BTFSS  F9E.4
15080:  BRA    1507E
15082:  MOVWF  FAD
15084:  MOVLW  5D
15086:  BTFSS  F9E.4
15088:  BRA    15086
1508A:  MOVWF  FAD
1508C:  MOVLW  5B
1508E:  BTFSS  F9E.4
15090:  BRA    1508E
15092:  MOVWF  FAD
15094:  MOVLW  10
15096:  MOVWF  FE9
15098:  CLRF   1B
1509A:  BTFSC  FF2.7
1509C:  BSF    1B.7
1509E:  BCF    FF2.7
150A0:  MOVFF  888,A26
150A4:  MOVFF  887,A25
150A8:  MOVLB  0
150AA:  CALL   1192
150AE:  BTFSC  1B.7
150B0:  BSF    FF2.7
150B2:  MOVLW  7A
150B4:  MOVWF  FF6
150B6:  MOVLW  21
150B8:  MOVWF  FF7
150BA:  MOVLW  00
150BC:  MOVWF  FF8
150BE:  CLRF   1B
150C0:  BTFSC  FF2.7
150C2:  BSF    1B.7
150C4:  BCF    FF2.7
150C6:  MOVLW  03
150C8:  MOVLB  A
150CA:  MOVWF  x25
150CC:  MOVLB  0
150CE:  CALL   1010
150D2:  BTFSC  1B.7
150D4:  BSF    FF2.7
150D6:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
150D8:  MOVFF  881,887
150DC:  MOVLW  08
150DE:  MOVWF  x89
150E0:  MOVLW  84
150E2:  MOVWF  x88
150E4:  MOVFF  883,88B
150E8:  MOVFF  882,88A
150EC:  MOVLB  0
150EE:  GOTO   14612
150F2:  MOVFF  01,886
....................       ++line; 
150F6:  MOVLB  8
150F8:  INCF   x84,F
150FA:  BTFSC  FD8.2
150FC:  INCF   x85,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
150FE:  DECFSZ 4C,W
15100:  BRA    15108
....................          macro_status = 'g'; 
15102:  MOVLW  67
15104:  MOVWF  x86
....................          break;    
15106:  BRA    1510A
....................       } 
15108:  BRA    15034
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
1510A:  MOVF   2F,W
1510C:  MOVWF  00
1510E:  MOVF   30,W
15110:  MOVWF  03
15112:  MOVF   03,W
15114:  BNZ   15120
15116:  MOVLW  01
15118:  SUBWF  00,W
1511A:  MOVLB  0
1511C:  BZ    1513E
1511E:  MOVLB  8
15120:  MOVF   03,W
15122:  BNZ   1512E
15124:  MOVLW  03
15126:  SUBWF  00,W
15128:  MOVLB  0
1512A:  BZ    1513E
1512C:  MOVLB  8
1512E:  MOVF   03,W
15130:  BNZ   1513C
15132:  MOVLW  02
15134:  SUBWF  00,W
15136:  MOVLB  0
15138:  BZ    1514A
1513A:  MOVLB  8
1513C:  BRA    1515A
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
1513E:  MOVFF  881,887
15142:  CALL   D3B6
....................          break; 
15146:  MOVLB  8
15148:  BRA    1515A
....................       case AWS : store_aws_data(macro,mmacro_var); 
1514A:  MOVFF  881,887
1514E:  MOVFF  883,889
15152:  MOVFF  882,888
15156:  BRA    14E96
....................          break; 
15158:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
1515A:  MOVLW  61
1515C:  SUBWF  x86,W
1515E:  ADDLW  F9
15160:  BC    1524C
15162:  ADDLW  07
15164:  MOVLB  0
15166:  GOTO   152F8
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
1516A:  MOVLW  7E
1516C:  MOVWF  FF6
1516E:  MOVLW  21
15170:  MOVWF  FF7
15172:  MOVLW  00
15174:  MOVWF  FF8
15176:  CLRF   1B
15178:  BTFSC  FF2.7
1517A:  BSF    1B.7
1517C:  BCF    FF2.7
1517E:  CALL   0E3A
15182:  BTFSC  1B.7
15184:  BSF    FF2.7
....................          break; 
15186:  MOVLB  8
15188:  BRA    1524C
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
1518A:  MOVLW  86
1518C:  MOVWF  FF6
1518E:  MOVLW  21
15190:  MOVWF  FF7
15192:  MOVLW  00
15194:  MOVWF  FF8
15196:  CLRF   1B
15198:  BTFSC  FF2.7
1519A:  BSF    1B.7
1519C:  BCF    FF2.7
1519E:  CALL   0E3A
151A2:  BTFSC  1B.7
151A4:  BSF    FF2.7
....................          break; 
151A6:  MOVLB  8
151A8:  BRA    1524C
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
151AA:  MOVLW  8E
151AC:  MOVWF  FF6
151AE:  MOVLW  21
151B0:  MOVWF  FF7
151B2:  MOVLW  00
151B4:  MOVWF  FF8
151B6:  CLRF   1B
151B8:  BTFSC  FF2.7
151BA:  BSF    1B.7
151BC:  BCF    FF2.7
151BE:  CALL   0E3A
151C2:  BTFSC  1B.7
151C4:  BSF    FF2.7
....................          break; 
151C6:  MOVLB  8
151C8:  BRA    1524C
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
151CA:  MOVLW  96
151CC:  MOVWF  FF6
151CE:  MOVLW  21
151D0:  MOVWF  FF7
151D2:  MOVLW  00
151D4:  MOVWF  FF8
151D6:  CLRF   1B
151D8:  BTFSC  FF2.7
151DA:  BSF    1B.7
151DC:  BCF    FF2.7
151DE:  CALL   0E3A
151E2:  BTFSC  1B.7
151E4:  BSF    FF2.7
....................          break; 
151E6:  MOVLB  8
151E8:  BRA    1524C
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
151EA:  MOVLW  9E
151EC:  MOVWF  FF6
151EE:  MOVLW  21
151F0:  MOVWF  FF7
151F2:  MOVLW  00
151F4:  MOVWF  FF8
151F6:  CLRF   1B
151F8:  BTFSC  FF2.7
151FA:  BSF    1B.7
151FC:  BCF    FF2.7
151FE:  CALL   0E3A
15202:  BTFSC  1B.7
15204:  BSF    FF2.7
....................          break;    
15206:  MOVLB  8
15208:  BRA    1524C
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
1520A:  MOVLW  A6
1520C:  MOVWF  FF6
1520E:  MOVLW  21
15210:  MOVWF  FF7
15212:  MOVLW  00
15214:  MOVWF  FF8
15216:  CLRF   1B
15218:  BTFSC  FF2.7
1521A:  BSF    1B.7
1521C:  BCF    FF2.7
1521E:  CALL   0E3A
15222:  BTFSC  1B.7
15224:  BSF    FF2.7
....................          break;    
15226:  MOVLB  8
15228:  BRA    1524C
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
1522A:  MOVLW  AE
1522C:  MOVWF  FF6
1522E:  MOVLW  21
15230:  MOVWF  FF7
15232:  MOVLW  00
15234:  MOVWF  FF8
15236:  CLRF   1B
15238:  BTFSC  FF2.7
1523A:  BSF    1B.7
1523C:  BCF    FF2.7
1523E:  CALL   0E3A
15242:  BTFSC  1B.7
15244:  BSF    FF2.7
....................          break;           
15246:  MOVLB  8
15248:  BRA    1524C
1524A:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
1524C:  MOVLW  01
1524E:  MOVWF  1E
15250:  MOVLW  A3
15252:  MOVWF  1D
15254:  MOVLW  B6
15256:  MOVWF  FF6
15258:  MOVLW  21
1525A:  MOVWF  FF7
1525C:  MOVLW  00
1525E:  MOVWF  FF8
15260:  MOVLW  07
15262:  MOVWF  xD5
15264:  MOVLB  0
15266:  CALL   AAF6
1526A:  MOVFF  881,8D7
1526E:  MOVLW  1B
15270:  MOVLB  8
15272:  MOVWF  xD8
15274:  MOVLB  0
15276:  CALL   52CA
1527A:  MOVLW  BF
1527C:  MOVWF  FF6
1527E:  MOVLW  21
15280:  MOVWF  FF7
15282:  MOVLW  00
15284:  MOVWF  FF8
15286:  MOVLW  09
15288:  MOVLB  8
1528A:  MOVWF  xD5
1528C:  MOVLB  0
1528E:  CALL   AAF6
15292:  MOVFF  886,8E9
15296:  CALL   50E8
1529A:  MOVLW  CA
1529C:  MOVWF  FF6
1529E:  MOVLW  21
152A0:  MOVWF  FF7
152A2:  MOVLW  00
152A4:  MOVWF  FF8
152A6:  MOVLW  07
152A8:  MOVLB  8
152AA:  MOVWF  xD5
152AC:  MOVLB  0
152AE:  CALL   AAF6
152B2:  MOVLW  10
152B4:  MOVWF  FE9
152B6:  MOVFF  885,8E1
152BA:  MOVFF  884,8E0
152BE:  CALL   AB28
152C2:  MOVLW  D4
152C4:  MOVWF  FF6
152C6:  MOVLW  21
152C8:  MOVWF  FF7
152CA:  MOVLW  00
152CC:  MOVWF  FF8
152CE:  MOVLW  03
152D0:  MOVLB  8
152D2:  MOVWF  xD5
152D4:  MOVLB  0
152D6:  CALL   AAF6
....................    record_event(); 
152DA:  CALL   850C
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
152DE:  MOVLB  8
152E0:  MOVF   x86,W
152E2:  SUBLW  66
152E4:  BZ    152F4
152E6:  MOVF   x86,W
152E8:  SUBLW  67
152EA:  BZ    152F4
152EC:  MOVLB  0
152EE:  CALL   AA8A
152F2:  MOVLB  8
152F4:  MOVLB  0
152F6:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15B88:  MOVLW  01
15B8A:  MOVLB  8
15B8C:  MOVWF  x79
....................    while (macro_batch == TRUE){ 
15B8E:  DECFSZ x79,W
15B90:  BRA    15E16
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15B92:  MOVFF  38,9F7
15B96:  MOVFF  37,9F6
15B9A:  MOVLB  9
15B9C:  CLRF   xF9
15B9E:  MOVLW  03
15BA0:  MOVWF  xF8
15BA2:  MOVLB  0
15BA4:  CALL   5D06
15BA8:  MOVF   01,W
15BAA:  MOVLB  7
15BAC:  ADDWF  xCD,W
15BAE:  MOVLB  8
15BB0:  MOVWF  x74
15BB2:  MOVF   02,W
15BB4:  MOVLB  7
15BB6:  ADDWFC xCE,W
15BB8:  MOVLB  8
15BBA:  MOVWF  x75
....................       init_ext_eeprom(); 
15BBC:  MOVLB  0
15BBE:  CALL   FFDA
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
15BC2:  MOVFF  875,8B6
15BC6:  MOVFF  874,8B5
15BCA:  CALL   1037C
15BCE:  MOVFF  01,876
....................       ++addr; 
15BD2:  MOVLB  8
15BD4:  INCF   x74,F
15BD6:  BTFSC  FD8.2
15BD8:  INCF   x75,F
....................       macro_arg = read16_ext_eeprom(addr); 
15BDA:  MOVFF  875,8AD
15BDE:  MOVFF  874,8AC
15BE2:  MOVLB  0
15BE4:  CALL   10490
15BE8:  MOVFF  02,878
15BEC:  MOVFF  01,877
....................       ++addr; 
15BF0:  MOVLB  8
15BF2:  INCF   x74,F
15BF4:  BTFSC  FD8.2
15BF6:  INCF   x75,F
....................       ++addr;      
15BF8:  INCF   x74,F
15BFA:  BTFSC  FD8.2
15BFC:  INCF   x75,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
15BFE:  MOVF   x76,W
15C00:  SUBLW  4D
15C02:  BTFSS  FD8.2
15C04:  BRA    15D2E
15C06:  MOVF   x77,F
15C08:  BNZ   15C10
15C0A:  MOVF   x78,F
15C0C:  BTFSC  FD8.2
15C0E:  BRA    15D2E
....................          { 
....................          RTC_reset_HT(); 
15C10:  MOVLB  0
15C12:  CALL   3506
....................          RTC_read(); 
15C16:  CALL   3398
....................          RTC_display(); 
15C1A:  CALL   DFFE
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
15C1E:  MOVLW  D8
15C20:  MOVWF  FF6
15C22:  MOVLW  21
15C24:  MOVWF  FF7
15C26:  MOVLW  00
15C28:  MOVWF  FF8
15C2A:  CLRF   1B
15C2C:  BTFSC  FF2.7
15C2E:  BSF    1B.7
15C30:  BCF    FF2.7
15C32:  MOVLW  09
15C34:  MOVLB  A
15C36:  MOVWF  x25
15C38:  MOVLB  0
15C3A:  CALL   1010
15C3E:  BTFSC  1B.7
15C40:  BSF    FF2.7
15C42:  MOVLB  8
15C44:  MOVF   x76,W
15C46:  BTFSS  F9E.4
15C48:  BRA    15C46
15C4A:  MOVWF  FAD
15C4C:  MOVLW  10
15C4E:  MOVWF  FE9
15C50:  CLRF   1B
15C52:  BTFSC  FF2.7
15C54:  BSF    1B.7
15C56:  BCF    FF2.7
15C58:  MOVFF  878,A26
15C5C:  MOVFF  877,A25
15C60:  MOVLB  0
15C62:  CALL   1192
15C66:  BTFSC  1B.7
15C68:  BSF    FF2.7
15C6A:  MOVLW  E6
15C6C:  MOVWF  FF6
15C6E:  MOVLW  21
15C70:  MOVWF  FF7
15C72:  MOVLW  00
15C74:  MOVWF  FF8
15C76:  CLRF   1B
15C78:  BTFSC  FF2.7
15C7A:  BSF    1B.7
15C7C:  BCF    FF2.7
15C7E:  MOVLW  03
15C80:  MOVLB  A
15C82:  MOVWF  x25
15C84:  MOVLB  0
15C86:  CALL   1010
15C8A:  BTFSC  1B.7
15C8C:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
15C8E:  MOVLW  01
15C90:  ADDWF  21,W
15C92:  MOVLB  8
15C94:  MOVWF  x7A
15C96:  MOVLW  00
15C98:  ADDWFC 22,W
15C9A:  MOVWF  x7B
15C9C:  MOVLW  EA
15C9E:  MOVWF  FF6
15CA0:  MOVLW  21
15CA2:  MOVWF  FF7
15CA4:  MOVLW  00
15CA6:  MOVWF  FF8
15CA8:  CLRF   1B
15CAA:  BTFSC  FF2.7
15CAC:  BSF    1B.7
15CAE:  BCF    FF2.7
15CB0:  MOVLW  07
15CB2:  MOVLB  A
15CB4:  MOVWF  x25
15CB6:  MOVLB  0
15CB8:  CALL   1010
15CBC:  BTFSC  1B.7
15CBE:  BSF    FF2.7
15CC0:  MOVLW  09
15CC2:  MOVWF  FE9
15CC4:  CLRF   1B
15CC6:  BTFSC  FF2.7
15CC8:  BSF    1B.7
15CCA:  BCF    FF2.7
15CCC:  MOVFF  87B,A26
15CD0:  MOVFF  87A,A25
15CD4:  CALL   1192
15CD8:  BTFSC  1B.7
15CDA:  BSF    FF2.7
15CDC:  MOVLW  F6
15CDE:  MOVWF  FF6
15CE0:  MOVLW  21
15CE2:  MOVWF  FF7
15CE4:  MOVLW  00
15CE6:  MOVWF  FF8
15CE8:  CLRF   1B
15CEA:  BTFSC  FF2.7
15CEC:  BSF    1B.7
15CEE:  BCF    FF2.7
15CF0:  MOVLW  04
15CF2:  MOVLB  A
15CF4:  MOVWF  x25
15CF6:  MOVLB  0
15CF8:  CALL   1010
15CFC:  BTFSC  1B.7
15CFE:  BSF    FF2.7
15D00:  MOVLW  09
15D02:  MOVWF  FE9
15D04:  CLRF   1B
15D06:  BTFSC  FF2.7
15D08:  BSF    1B.7
15D0A:  BCF    FF2.7
15D0C:  MOVFF  28,A26
15D10:  MOVFF  27,A25
15D14:  CALL   1192
15D18:  BTFSC  1B.7
15D1A:  BSF    FF2.7
15D1C:  MOVLW  0D
15D1E:  BTFSS  F9E.4
15D20:  BRA    15D1E
15D22:  MOVWF  FAD
15D24:  MOVLW  0A
15D26:  BTFSS  F9E.4
15D28:  BRA    15D26
15D2A:  MOVWF  FAD
15D2C:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
15D2E:  MOVF   28,W
15D30:  SUBWF  22,W
15D32:  BNC   15D40
15D34:  BNZ   15D3C
15D36:  MOVF   27,W
15D38:  SUBWF  21,W
15D3A:  BNC   15D40
....................          {macro_cmd = 'Z';} 
15D3C:  MOVLW  5A
15D3E:  MOVWF  x76
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
15D40:  MOVF   x76,W
15D42:  XORLW  72
15D44:  MOVLB  0
15D46:  BZ    15D5A
15D48:  XORLW  57
15D4A:  BZ    15D7C
15D4C:  XORLW  68
15D4E:  BZ    15DB2
15D50:  XORLW  17
15D52:  BZ    15DE8
15D54:  XORLW  61
15D56:  BZ    15DF4
15D58:  BRA    15DFE
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
15D5A:  INCF   37,F
15D5C:  BTFSC  FD8.2
15D5E:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
15D60:  MOVLB  8
15D62:  CLRF   x5C
15D64:  CLRF   x5B
15D66:  MOVFF  38,85A
15D6A:  MOVFF  37,859
....................                master_macro_loop_count = macro_arg; 
15D6E:  CLRF   x58
15D70:  CLRF   x57
15D72:  MOVFF  878,856
15D76:  MOVFF  877,855
....................             break; 
15D7A:  BRA    15E0A
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
15D7C:  MOVLB  8
15D7E:  MOVF   x58,F
15D80:  BNZ   15D90
15D82:  MOVF   x57,F
15D84:  BNZ   15D90
15D86:  MOVF   x56,F
15D88:  BNZ   15D90
15D8A:  MOVF   x55,W
15D8C:  SUBLW  01
15D8E:  BC    15DAA
....................                   nv_macro_step = master_macro_loop_start; 
15D90:  MOVFF  85A,38
15D94:  MOVFF  859,37
....................                   master_macro_loop_count--; 
15D98:  MOVLW  FF
15D9A:  ADDWF  x55,F
15D9C:  BTFSS  FD8.0
15D9E:  ADDWF  x56,F
15DA0:  BTFSS  FD8.0
15DA2:  ADDWF  x57,F
15DA4:  BTFSS  FD8.0
15DA6:  ADDWF  x58,F
....................                }else{ 
15DA8:  BRA    15DB0
....................                   nv_macro_step++; 
15DAA:  INCF   37,F
15DAC:  BTFSC  FD8.2
15DAE:  INCF   38,F
....................                } 
....................             break; 
15DB0:  BRA    15E0A
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
15DB2:  MOVLB  8
15DB4:  MOVF   x78,F
15DB6:  BNZ   15DE6
15DB8:  MOVF   x77,W
15DBA:  SUBLW  14
15DBC:  BNC   15DE6
....................                   play_macro(macro_arg,0);     // casts to int8 
15DBE:  MOVFF  877,881
15DC2:  CLRF   x83
15DC4:  CLRF   x82
15DC6:  MOVLB  0
15DC8:  CALL   14FC0
....................                   delay_ms(100); 
15DCC:  MOVLW  64
15DCE:  MOVLB  9
15DD0:  MOVWF  xD6
15DD2:  MOVLB  0
15DD4:  CALL   2964
....................                   ++nv_sample; 
15DD8:  INCF   21,F
15DDA:  BTFSC  FD8.2
15DDC:  INCF   22,F
....................                   ++nv_macro_step; 
15DDE:  INCF   37,F
15DE0:  BTFSC  FD8.2
15DE2:  INCF   38,F
15DE4:  MOVLB  8
....................                } 
....................                break; 
15DE6:  BRA    15E0A
....................             case 'Z' : ++nv_macro_step; 
15DE8:  INCF   37,F
15DEA:  BTFSC  FD8.2
15DEC:  INCF   38,F
....................                        macro_batch = FALSE; 
15DEE:  MOVLB  8
15DF0:  CLRF   x79
....................                break; 
15DF2:  BRA    15E0A
....................             case ';' : nv_macro_step = 0; 
15DF4:  CLRF   38
15DF6:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
15DF8:  MOVLB  8
15DFA:  BRA    15E0A
15DFC:  MOVLB  0
....................             default  : cmd_err(); 
15DFE:  CALL   BD24
....................                        macro_cmd = 'e'; 
15E02:  MOVLW  65
15E04:  MOVLB  8
15E06:  MOVWF  x76
....................                        macro_batch = FALSE; 
15E08:  CLRF   x79
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
15E0A:  DECFSZ 4C,W
15E0C:  BRA    15E14
....................             macro_cmd = ';'; 
15E0E:  MOVLW  3B
15E10:  MOVWF  x76
....................             break;         // 17 = CTRL-Q (quit) 
15E12:  BRA    15E16
....................          } 
15E14:  BRA    15B8E
....................    } 
....................    return (macro_cmd); 
15E16:  MOVFF  876,01
15E1A:  MOVLB  0
15E1C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D122:  MOVLB  8
0D124:  MOVF   x76,W
0D126:  XORLW  2B
0D128:  MOVLB  0
0D12A:  BZ    D15A
0D12C:  XORLW  06
0D12E:  BZ    D182
0D130:  XORLW  6F
0D132:  BZ    D1AA
0D134:  XORLW  05
0D136:  BZ    D1BC
0D138:  XORLW  17
0D13A:  BZ    D1D2
0D13C:  XORLW  01
0D13E:  BZ    D202
0D140:  XORLW  03
0D142:  BTFSC  FD8.2
0D144:  BRA    D22A
0D146:  XORLW  06
0D148:  BTFSC  FD8.2
0D14A:  BRA    D252
0D14C:  XORLW  0D
0D14E:  BTFSC  FD8.2
0D150:  BRA    D266
0D152:  XORLW  62
0D154:  BTFSC  FD8.2
0D156:  BRA    D28E
0D158:  BRA    D296
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D15A:  MOVLW  01
0D15C:  MOVLB  7
0D15E:  MOVWF  x3C
....................                  move_motor(0,0,macro_arg,1); 
0D160:  MOVLB  8
0D162:  CLRF   xB1
0D164:  CLRF   xB2
0D166:  CLRF   xB6
0D168:  CLRF   xB5
0D16A:  MOVFF  878,8B4
0D16E:  MOVFF  877,8B3
0D172:  MOVWF  xB7
0D174:  MOVLB  0
0D176:  CALL   9DAA
....................                  macro_status=step_err_status(); 
0D17A:  RCALL  D07A
0D17C:  MOVFF  01,879
....................          break; 
0D180:  BRA    D296
....................       case '-' : motor=1; 
0D182:  MOVLW  01
0D184:  MOVLB  7
0D186:  MOVWF  x3C
....................                  move_motor(0,1,macro_arg,1); 
0D188:  MOVLB  8
0D18A:  CLRF   xB1
0D18C:  MOVWF  xB2
0D18E:  CLRF   xB6
0D190:  CLRF   xB5
0D192:  MOVFF  878,8B4
0D196:  MOVFF  877,8B3
0D19A:  MOVWF  xB7
0D19C:  MOVLB  0
0D19E:  CALL   9DAA
....................                  macro_status=step_err_status(); 
0D1A2:  RCALL  D07A
0D1A4:  MOVFF  01,879
....................          break; 
0D1A8:  BRA    D296
....................       case 'B' : h_bridge(macro_arg); 
0D1AA:  MOVFF  877,89F
0D1AE:  CALL   BFB4
....................                  macro_status = 'a'; 
0D1B2:  MOVLW  61
0D1B4:  MOVLB  8
0D1B6:  MOVWF  x79
....................          break; 
0D1B8:  MOVLB  0
0D1BA:  BRA    D296
....................       case 'G' : motor=0; 
0D1BC:  MOVLB  7
0D1BE:  CLRF   x3C
....................                  align(0); 
0D1C0:  MOVLB  8
0D1C2:  CLRF   xAC
0D1C4:  MOVLB  0
0D1C6:  CALL   A8E6
....................                  macro_status=step_err_status(); 
0D1CA:  RCALL  D07A
0D1CC:  MOVFF  01,879
....................          break ;           
0D1D0:  BRA    D296
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D1D2:  MOVFF  878,2E
0D1D6:  MOVFF  877,2D
....................                  motor=0; 
0D1DA:  MOVLB  7
0D1DC:  CLRF   x3C
....................                  move_motor(0,0,macro_arg,1);   
0D1DE:  MOVLB  8
0D1E0:  CLRF   xB1
0D1E2:  CLRF   xB2
0D1E4:  CLRF   xB6
0D1E6:  CLRF   xB5
0D1E8:  MOVFF  878,8B4
0D1EC:  MOVFF  877,8B3
0D1F0:  MOVLW  01
0D1F2:  MOVWF  xB7
0D1F4:  MOVLB  0
0D1F6:  CALL   9DAA
....................                  macro_status=step_err_status(); 
0D1FA:  RCALL  D07A
0D1FC:  MOVFF  01,879
....................          break; 
0D200:  BRA    D296
....................       case 'Q' : motor=0; 
0D202:  MOVLB  7
0D204:  CLRF   x3C
....................                  move_motor(0,0,macro_arg,1); 
0D206:  MOVLB  8
0D208:  CLRF   xB1
0D20A:  CLRF   xB2
0D20C:  CLRF   xB6
0D20E:  CLRF   xB5
0D210:  MOVFF  878,8B4
0D214:  MOVFF  877,8B3
0D218:  MOVLW  01
0D21A:  MOVWF  xB7
0D21C:  MOVLB  0
0D21E:  CALL   9DAA
....................                  macro_status=step_err_status(); 
0D222:  RCALL  D07A
0D224:  MOVFF  01,879
....................          break; 
0D228:  BRA    D296
....................       case 'R' : motor=0; 
0D22A:  MOVLB  7
0D22C:  CLRF   x3C
....................                  move_motor(0,1,macro_arg,1); 
0D22E:  MOVLB  8
0D230:  CLRF   xB1
0D232:  MOVLW  01
0D234:  MOVWF  xB2
0D236:  CLRF   xB6
0D238:  CLRF   xB5
0D23A:  MOVFF  878,8B4
0D23E:  MOVFF  877,8B3
0D242:  MOVWF  xB7
0D244:  MOVLB  0
0D246:  CALL   9DAA
....................                  macro_status=step_err_status(); 
0D24A:  RCALL  D07A
0D24C:  MOVFF  01,879
....................          break; 
0D250:  BRA    D296
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D252:  MOVFF  878,8AD
0D256:  MOVFF  877,8AC
0D25A:  RCALL  D0B2
....................                  macro_status = 'a'; 
0D25C:  MOVLW  61
0D25E:  MOVLB  8
0D260:  MOVWF  x79
....................          break; 
0D262:  MOVLB  0
0D264:  BRA    D296
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D266:  MOVLB  8
0D268:  DECFSZ x77,W
0D26A:  BRA    D278
0D26C:  MOVF   x78,F
0D26E:  BNZ   D278
0D270:  MOVLB  0
0D272:  RCALL  D0E8
0D274:  BRA    D284
0D276:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D278:  MOVF   x77,F
0D27A:  BNZ   D286
0D27C:  MOVF   x78,F
0D27E:  BNZ   D286
0D280:  MOVLB  0
0D282:  RCALL  D10C
0D284:  MOVLB  8
....................                  macro_status = 'a'; 
0D286:  MOVLW  61
0D288:  MOVWF  x79
....................          break;           
0D28A:  MOVLB  0
0D28C:  BRA    D296
....................       case ';' : macro_status = 'f'; 
0D28E:  MOVLW  66
0D290:  MOVLB  8
0D292:  MOVWF  x79
....................          break;            
0D294:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D296:  MOVLB  8
0D298:  MOVFF  879,01
0D29C:  MOVLB  0
0D29E:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D578:  MOVF   2E,F
0D57A:  BNZ   D582
0D57C:  MOVF   2D,W
0D57E:  SUBLW  01
0D580:  BC    D594
0D582:  MOVF   2E,F
0D584:  BNZ   D594
0D586:  MOVF   2D,W
0D588:  SUBLW  30
0D58A:  BNC   D594
0D58C:  DECFSZ 2F,W
0D58E:  BRA    D594
0D590:  MOVF   30,F
0D592:  BZ    D5B2
0D594:  MOVF   2E,F
0D596:  BNZ   D59E
0D598:  MOVF   2D,W
0D59A:  SUBLW  01
0D59C:  BC    D5BC
0D59E:  MOVF   2E,F
0D5A0:  BNZ   D5BC
0D5A2:  MOVF   2D,W
0D5A4:  SUBLW  32
0D5A6:  BNC   D5BC
0D5A8:  MOVF   2F,W
0D5AA:  SUBLW  03
0D5AC:  BNZ   D5BC
0D5AE:  MOVF   30,F
0D5B0:  BNZ   D5BC
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D5B2:  MOVLW  61
0D5B4:  MOVLB  8
0D5B6:  MOVWF  x75
....................    } 
0D5B8:  BRA    D5C4
0D5BA:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D5BC:  MOVLW  65
0D5BE:  MOVLB  8
0D5C0:  MOVWF  x75
....................       goto end_macro;       
0D5C2:  BRA    D674
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D5C4:  MOVLW  59
0D5C6:  MOVWF  x76
0D5C8:  CLRF   x78
0D5CA:  MOVLW  01
0D5CC:  MOVWF  x77
0D5CE:  MOVLB  0
0D5D0:  RCALL  D122
0D5D2:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro; 
0D5D6:  MOVLB  8
0D5D8:  MOVF   x75,W
0D5DA:  SUBLW  61
0D5DC:  BTFSS  FD8.2
0D5DE:  BRA    D674
....................    macro_status = play_wms_macro_cmd('G',1); 
0D5E0:  MOVLW  47
0D5E2:  MOVWF  x76
0D5E4:  CLRF   x78
0D5E6:  MOVLW  01
0D5E8:  MOVWF  x77
0D5EA:  MOVLB  0
0D5EC:  RCALL  D122
0D5EE:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro; 
0D5F2:  MOVLB  8
0D5F4:  MOVF   x75,W
0D5F6:  SUBLW  61
0D5F8:  BTFSS  FD8.2
0D5FA:  BRA    D674
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D5FC:  MOVLW  2D
0D5FE:  MOVWF  x76
0D600:  MOVFF  2C,878
0D604:  MOVFF  2B,877
0D608:  MOVLB  0
0D60A:  RCALL  D122
0D60C:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro; 
0D610:  MOVLB  8
0D612:  MOVF   x75,W
0D614:  SUBLW  61
0D616:  BTFSS  FD8.2
0D618:  BRA    D674
....................    macro_status = play_wms_macro_cmd('P',port); 
0D61A:  MOVLW  50
0D61C:  MOVWF  x76
0D61E:  MOVFF  874,878
0D622:  MOVFF  873,877
0D626:  MOVLB  0
0D628:  RCALL  D122
0D62A:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro;    
0D62E:  MOVLB  8
0D630:  MOVF   x75,W
0D632:  SUBLW  61
0D634:  BTFSS  FD8.2
0D636:  BRA    D674
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D638:  MOVLW  2B
0D63A:  MOVWF  x76
0D63C:  MOVFF  2C,878
0D640:  MOVFF  2B,877
0D644:  MOVLB  0
0D646:  RCALL  D122
0D648:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro; 
0D64C:  MOVLB  8
0D64E:  MOVF   x75,W
0D650:  SUBLW  61
0D652:  BTFSS  FD8.2
0D654:  BRA    D674
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D656:  MOVLW  59
0D658:  MOVWF  x76
0D65A:  CLRF   x78
0D65C:  CLRF   x77
0D65E:  MOVLB  0
0D660:  RCALL  D122
0D662:  MOVFF  01,875
....................    if (macro_status != 'a') goto end_macro; 
0D666:  MOVLB  8
0D668:  MOVF   x75,W
0D66A:  SUBLW  61
0D66C:  BTFSS  FD8.2
0D66E:  BRA    D674
....................    macro_status='f';  
0D670:  MOVLW  66
0D672:  MOVWF  x75
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D674:  CLRF   x87
0D676:  MOVLB  0
0D678:  RCALL  D3B6
....................    
....................    switch(macro_status){ 
0D67A:  MOVLW  61
0D67C:  MOVLB  8
0D67E:  SUBWF  x75,W
0D680:  ADDLW  FA
0D682:  BC    D756
0D684:  ADDLW  06
0D686:  MOVLB  0
0D688:  GOTO   D75A
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D68C:  MOVF   1F,F
0D68E:  BNZ   D694
0D690:  MOVF   20,F
0D692:  BZ    D6B0
0D694:  MOVLW  02
0D696:  MOVWF  FF6
0D698:  MOVLW  22
0D69A:  MOVWF  FF7
0D69C:  MOVLW  00
0D69E:  MOVWF  FF8
0D6A0:  CLRF   1B
0D6A2:  BTFSC  FF2.7
0D6A4:  BSF    1B.7
0D6A6:  BCF    FF2.7
0D6A8:  CALL   0E3A
0D6AC:  BTFSC  1B.7
0D6AE:  BSF    FF2.7
....................          break; 
0D6B0:  MOVLB  8
0D6B2:  BRA    D756
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D6B4:  MOVLW  0A
0D6B6:  MOVWF  FF6
0D6B8:  MOVLW  22
0D6BA:  MOVWF  FF7
0D6BC:  MOVLW  00
0D6BE:  MOVWF  FF8
0D6C0:  CLRF   1B
0D6C2:  BTFSC  FF2.7
0D6C4:  BSF    1B.7
0D6C6:  BCF    FF2.7
0D6C8:  CALL   0E3A
0D6CC:  BTFSC  1B.7
0D6CE:  BSF    FF2.7
....................          break; 
0D6D0:  MOVLB  8
0D6D2:  BRA    D756
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D6D4:  MOVLW  12
0D6D6:  MOVWF  FF6
0D6D8:  MOVLW  22
0D6DA:  MOVWF  FF7
0D6DC:  MOVLW  00
0D6DE:  MOVWF  FF8
0D6E0:  CLRF   1B
0D6E2:  BTFSC  FF2.7
0D6E4:  BSF    1B.7
0D6E6:  BCF    FF2.7
0D6E8:  CALL   0E3A
0D6EC:  BTFSC  1B.7
0D6EE:  BSF    FF2.7
....................          break; 
0D6F0:  MOVLB  8
0D6F2:  BRA    D756
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D6F4:  MOVLW  1A
0D6F6:  MOVWF  FF6
0D6F8:  MOVLW  22
0D6FA:  MOVWF  FF7
0D6FC:  MOVLW  00
0D6FE:  MOVWF  FF8
0D700:  CLRF   1B
0D702:  BTFSC  FF2.7
0D704:  BSF    1B.7
0D706:  BCF    FF2.7
0D708:  CALL   0E3A
0D70C:  BTFSC  1B.7
0D70E:  BSF    FF2.7
....................          break; 
0D710:  MOVLB  8
0D712:  BRA    D756
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D714:  MOVLW  22
0D716:  MOVWF  FF6
0D718:  MOVLW  22
0D71A:  MOVWF  FF7
0D71C:  MOVLW  00
0D71E:  MOVWF  FF8
0D720:  CLRF   1B
0D722:  BTFSC  FF2.7
0D724:  BSF    1B.7
0D726:  BCF    FF2.7
0D728:  CALL   0E3A
0D72C:  BTFSC  1B.7
0D72E:  BSF    FF2.7
....................          break;    
0D730:  MOVLB  8
0D732:  BRA    D756
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D734:  MOVLW  2A
0D736:  MOVWF  FF6
0D738:  MOVLW  22
0D73A:  MOVWF  FF7
0D73C:  MOVLW  00
0D73E:  MOVWF  FF8
0D740:  CLRF   1B
0D742:  BTFSC  FF2.7
0D744:  BSF    1B.7
0D746:  BCF    FF2.7
0D748:  CALL   0E3A
0D74C:  BTFSC  1B.7
0D74E:  BSF    FF2.7
....................          break;           
0D750:  MOVLB  8
0D752:  BRA    D756
0D754:  MOVLB  8
....................    } 
0D756:  MOVLB  0
0D758:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
1605E:  MOVLB  8
16060:  MOVF   x72,W
16062:  BTFSC  FD8.2
16064:  DECF   x73,F
16066:  DECF   x72,F
....................    addr = macro_address[0] + (step*9); 
16068:  MOVFF  873,9F7
1606C:  MOVFF  872,9F6
16070:  MOVLB  9
16072:  CLRF   xF9
16074:  MOVLW  09
16076:  MOVWF  xF8
16078:  MOVLB  0
1607A:  CALL   5D06
1607E:  MOVF   01,W
16080:  MOVLB  7
16082:  ADDWF  xCD,W
16084:  MOVLB  8
16086:  MOVWF  x74
16088:  MOVF   02,W
1608A:  MOVLB  7
1608C:  ADDWFC xCE,W
1608E:  MOVLB  8
16090:  MOVWF  x75
....................     
....................    init_ext_eeprom(); 
16092:  MOVLB  0
16094:  CALL   FFDA
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
16098:  MOVFF  875,8B6
1609C:  MOVFF  874,8B5
160A0:  CALL   1037C
160A4:  MOVFF  01,876
....................    ++addr; 
160A8:  MOVLB  8
160AA:  INCF   x74,F
160AC:  BTFSC  FD8.2
160AE:  INCF   x75,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
160B0:  MOVFF  875,8AD
160B4:  MOVFF  874,8AC
160B8:  MOVLB  0
160BA:  CALL   10490
160BE:  MOVFF  02,87A
160C2:  MOVFF  01,879
....................    ++addr; 
160C6:  MOVLB  8
160C8:  INCF   x74,F
160CA:  BTFSC  FD8.2
160CC:  INCF   x75,F
....................    ++addr; 
160CE:  INCF   x74,F
160D0:  BTFSC  FD8.2
160D2:  INCF   x75,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
160D4:  MOVFF  875,8B6
160D8:  MOVFF  874,8B5
160DC:  MOVLB  0
160DE:  CALL   1037C
160E2:  MOVFF  01,877
....................    ++addr; 
160E6:  MOVLB  8
160E8:  INCF   x74,F
160EA:  BTFSC  FD8.2
160EC:  INCF   x75,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
160EE:  MOVFF  875,8AD
160F2:  MOVFF  874,8AC
160F6:  MOVLB  0
160F8:  CALL   10490
160FC:  MOVFF  02,87C
16100:  MOVFF  01,87B
....................    ++addr; 
16104:  MOVLB  8
16106:  INCF   x74,F
16108:  BTFSC  FD8.2
1610A:  INCF   x75,F
....................    ++addr; 
1610C:  INCF   x74,F
1610E:  BTFSC  FD8.2
16110:  INCF   x75,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
16112:  MOVFF  875,8B6
16116:  MOVFF  874,8B5
1611A:  MOVLB  0
1611C:  CALL   1037C
16120:  MOVFF  01,878
....................    ++addr; 
16124:  MOVLB  8
16126:  INCF   x74,F
16128:  BTFSC  FD8.2
1612A:  INCF   x75,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
1612C:  MOVFF  875,8AD
16130:  MOVFF  874,8AC
16134:  MOVLB  0
16136:  CALL   10490
1613A:  MOVFF  02,87E
1613E:  MOVFF  01,87D
....................    ++addr; 
16142:  MOVLB  8
16144:  INCF   x74,F
16146:  BTFSC  FD8.2
16148:  INCF   x75,F
....................    ++addr; 
1614A:  INCF   x74,F
1614C:  BTFSC  FD8.2
1614E:  INCF   x75,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16150:  MOVFF  875,8B6
16154:  MOVFF  874,8B5
16158:  MOVLB  0
1615A:  CALL   1037C
1615E:  MOVFF  01,87F
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
16162:  MOVLB  8
16164:  MOVF   x76,W
16166:  SUBLW  4A
16168:  BTFSS  FD8.2
1616A:  BRA    16240
1616C:  MOVF   x77,W
1616E:  SUBLW  50
16170:  BNZ   16240
16172:  MOVF   x78,W
16174:  SUBLW  4D
16176:  BNZ   16240
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
16178:  MOVF   x76,W
1617A:  BTFSS  F9E.4
1617C:  BRA    1617A
1617E:  MOVWF  FAD
16180:  MOVLW  10
16182:  MOVWF  FE9
16184:  CLRF   1B
16186:  BTFSC  FF2.7
16188:  BSF    1B.7
1618A:  BCF    FF2.7
1618C:  MOVFF  87A,A26
16190:  MOVFF  879,A25
16194:  MOVLB  0
16196:  CALL   1192
1619A:  BTFSC  1B.7
1619C:  BSF    FF2.7
1619E:  MOVLW  2C
161A0:  BTFSS  F9E.4
161A2:  BRA    161A0
161A4:  MOVWF  FAD
161A6:  MOVLB  8
161A8:  MOVF   x77,W
161AA:  BTFSS  F9E.4
161AC:  BRA    161AA
161AE:  MOVWF  FAD
161B0:  MOVLW  10
161B2:  MOVWF  FE9
161B4:  CLRF   1B
161B6:  BTFSC  FF2.7
161B8:  BSF    1B.7
161BA:  BCF    FF2.7
161BC:  MOVFF  87C,A26
161C0:  MOVFF  87B,A25
161C4:  MOVLB  0
161C6:  CALL   1192
161CA:  BTFSC  1B.7
161CC:  BSF    FF2.7
161CE:  MOVLW  2C
161D0:  BTFSS  F9E.4
161D2:  BRA    161D0
161D4:  MOVWF  FAD
161D6:  MOVLB  8
161D8:  MOVF   x78,W
161DA:  BTFSS  F9E.4
161DC:  BRA    161DA
161DE:  MOVWF  FAD
161E0:  MOVLW  10
161E2:  MOVWF  FE9
161E4:  CLRF   1B
161E6:  BTFSC  FF2.7
161E8:  BSF    1B.7
161EA:  BCF    FF2.7
161EC:  MOVFF  87E,A26
161F0:  MOVFF  87D,A25
161F4:  MOVLB  0
161F6:  CALL   1192
161FA:  BTFSC  1B.7
161FC:  BSF    FF2.7
161FE:  MOVLW  0D
16200:  BTFSS  F9E.4
16202:  BRA    16200
16204:  MOVWF  FAD
16206:  MOVLW  0A
16208:  BTFSS  F9E.4
1620A:  BRA    16208
1620C:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
1620E:  MOVFF  87A,24
16212:  MOVFF  879,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
16216:  MOVLB  8
16218:  MOVF   x7D,F
1621A:  BNZ   16220
1621C:  MOVF   x7E,F
1621E:  BZ    1623E
16220:  MOVF   x7E,F
16222:  BNZ   1623E
16224:  MOVF   x7D,W
16226:  SUBLW  10
16228:  BNC   1623E
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
1622A:  MOVFF  87D,881
1622E:  MOVFF  87C,883
16232:  MOVFF  87B,882
16236:  MOVLB  0
16238:  CALL   14FC0
1623C:  MOVLB  8
....................       } 
....................    } 
1623E:  BRA    1624C
....................    else { 
....................       cmd_err(); 
16240:  MOVLB  0
16242:  CALL   BD24
....................       macro_end = 59; 
16246:  MOVLW  3B
16248:  MOVLB  8
1624A:  MOVWF  x7F
....................    } 
....................     
....................    return (macro_end); 
1624C:  MOVFF  87F,01
16250:  MOVLB  0
16252:  GOTO   1633C (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
1643E:  MOVLB  8
16440:  MOVF   x76,W
16442:  BTFSC  FD8.2
16444:  DECF   x77,F
16446:  DECF   x76,F
....................    addr = macro_address[0] + (step*6); 
16448:  MOVFF  877,9F7
1644C:  MOVFF  876,9F6
16450:  MOVLB  9
16452:  CLRF   xF9
16454:  MOVLW  06
16456:  MOVWF  xF8
16458:  MOVLB  0
1645A:  CALL   5D06
1645E:  MOVF   01,W
16460:  MOVLB  7
16462:  ADDWF  xCD,W
16464:  MOVLB  8
16466:  MOVWF  x78
16468:  MOVF   02,W
1646A:  MOVLB  7
1646C:  ADDWFC xCE,W
1646E:  MOVLB  8
16470:  MOVWF  x79
....................     
....................    init_ext_eeprom(); 
16472:  MOVLB  0
16474:  CALL   FFDA
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
16478:  MOVFF  879,8B6
1647C:  MOVFF  878,8B5
16480:  CALL   1037C
16484:  MOVFF  01,87A
....................    ++addr; 
16488:  MOVLB  8
1648A:  INCF   x78,F
1648C:  BTFSC  FD8.2
1648E:  INCF   x79,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
16490:  MOVFF  879,8AD
16494:  MOVFF  878,8AC
16498:  MOVLB  0
1649A:  CALL   10490
1649E:  MOVFF  02,87D
164A2:  MOVFF  01,87C
....................    ++addr; 
164A6:  MOVLB  8
164A8:  INCF   x78,F
164AA:  BTFSC  FD8.2
164AC:  INCF   x79,F
....................    ++addr; 
164AE:  INCF   x78,F
164B0:  BTFSC  FD8.2
164B2:  INCF   x79,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
164B4:  MOVFF  879,8B6
164B8:  MOVFF  878,8B5
164BC:  MOVLB  0
164BE:  CALL   1037C
164C2:  MOVFF  01,87B
....................    ++addr; 
164C6:  MOVLB  8
164C8:  INCF   x78,F
164CA:  BTFSC  FD8.2
164CC:  INCF   x79,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
164CE:  MOVFF  879,8AD
164D2:  MOVFF  878,8AC
164D6:  MOVLB  0
164D8:  CALL   10490
164DC:  MOVFF  02,87F
164E0:  MOVFF  01,87E
....................    ++addr; 
164E4:  MOVLB  8
164E6:  INCF   x78,F
164E8:  BTFSC  FD8.2
164EA:  INCF   x79,F
....................    ++addr; 
164EC:  INCF   x78,F
164EE:  BTFSC  FD8.2
164F0:  INCF   x79,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
164F2:  MOVFF  879,8B6
164F6:  MOVFF  878,8B5
164FA:  MOVLB  0
164FC:  CALL   1037C
16500:  MOVFF  01,880
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
16504:  MOVLB  8
16506:  MOVF   x7A,W
16508:  SUBLW  50
1650A:  BNZ   165AE
1650C:  MOVF   x7B,W
1650E:  SUBLW  4D
16510:  BNZ   165AE
....................        
....................       RTC_read(); 
16512:  MOVLB  0
16514:  CALL   3398
....................       RTC_display(); 
16518:  CALL   DFFE
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
1651C:  MOVLB  8
1651E:  MOVF   x7A,W
16520:  BTFSS  F9E.4
16522:  BRA    16520
16524:  MOVWF  FAD
16526:  MOVLW  10
16528:  MOVWF  FE9
1652A:  CLRF   1B
1652C:  BTFSC  FF2.7
1652E:  BSF    1B.7
16530:  BCF    FF2.7
16532:  MOVFF  87D,A26
16536:  MOVFF  87C,A25
1653A:  MOVLB  0
1653C:  CALL   1192
16540:  BTFSC  1B.7
16542:  BSF    FF2.7
16544:  MOVLW  2C
16546:  BTFSS  F9E.4
16548:  BRA    16546
1654A:  MOVWF  FAD
1654C:  MOVLB  8
1654E:  MOVF   x7B,W
16550:  BTFSS  F9E.4
16552:  BRA    16550
16554:  MOVWF  FAD
16556:  MOVLW  10
16558:  MOVWF  FE9
1655A:  CLRF   1B
1655C:  BTFSC  FF2.7
1655E:  BSF    1B.7
16560:  BCF    FF2.7
16562:  MOVFF  87F,A26
16566:  MOVFF  87E,A25
1656A:  MOVLB  0
1656C:  CALL   1192
16570:  BTFSC  1B.7
16572:  BSF    FF2.7
16574:  MOVLW  0D
16576:  BTFSS  F9E.4
16578:  BRA    16576
1657A:  MOVWF  FAD
1657C:  MOVLW  0A
1657E:  BTFSS  F9E.4
16580:  BRA    1657E
16582:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
16584:  MOVLB  8
16586:  MOVF   x7E,F
16588:  BNZ   1658E
1658A:  MOVF   x7F,F
1658C:  BZ    165AC
1658E:  MOVF   x7F,F
16590:  BNZ   165AC
16592:  MOVF   x7E,W
16594:  SUBLW  10
16596:  BNC   165AC
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
16598:  MOVFF  87E,881
1659C:  MOVFF  87D,883
165A0:  MOVFF  87C,882
165A4:  MOVLB  0
165A6:  CALL   14FC0
165AA:  MOVLB  8
....................       } 
....................    } 
165AC:  BRA    165BA
....................    else { 
....................       cmd_err(); 
165AE:  MOVLB  0
165B0:  CALL   BD24
....................       macro_end = 59; 
165B4:  MOVLW  3B
165B6:  MOVLB  8
165B8:  MOVWF  x80
....................    } 
....................     
....................    return (macro_end); 
165BA:  MOVFF  880,01
165BE:  MOVLB  0
165C0:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
15E3C:  MOVF   24,W
15E3E:  SUBWF  36,W
15E40:  BTFSS  FD8.0
15E42:  BRA    1604A
15E44:  BNZ   15E4E
15E46:  MOVF   23,W
15E48:  SUBWF  35,W
15E4A:  BTFSS  FD8.0
15E4C:  BRA    1604A
15E4E:  MOVF   33,F
15E50:  BTFSS  FD8.2
15E52:  BRA    1604A
15E54:  MOVF   34,F
15E56:  BTFSS  FD8.2
15E58:  BRA    1604A
....................       { 
....................          nv_elapsed = 0; 
15E5A:  CLRF   36
15E5C:  CLRF   35
....................  
....................          init_hardware(); 
15E5E:  CALL   298E
....................          sd_status = init_sdcard(); 
15E62:  CALL   5084
15E66:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
15E6A:  MOVLB  2
15E6C:  MOVF   xD8,F
15E6E:  BZ    15E78
15E70:  MOVLB  0
15E72:  CALL   50CA
15E76:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
15E78:  MOVLW  01
15E7A:  MOVWF  1E
15E7C:  MOVLW  A3
15E7E:  MOVWF  1D
15E80:  MOVLW  32
15E82:  MOVWF  FF6
15E84:  MOVLW  22
15E86:  MOVWF  FF7
15E88:  MOVLW  00
15E8A:  MOVWF  FF8
15E8C:  MOVLW  14
15E8E:  MOVLB  8
15E90:  MOVWF  xD5
15E92:  MOVLB  0
15E94:  CALL   AAF6
15E98:  MOVLW  10
15E9A:  MOVWF  FE9
15E9C:  MOVFF  22,8E1
15EA0:  MOVFF  21,8E0
15EA4:  CALL   AB28
15EA8:  MOVLW  49
15EAA:  MOVWF  FF6
15EAC:  MOVLW  22
15EAE:  MOVWF  FF7
15EB0:  MOVLW  00
15EB2:  MOVWF  FF8
15EB4:  MOVLW  09
15EB6:  MOVLB  8
15EB8:  MOVWF  xD5
15EBA:  MOVLB  0
15EBC:  CALL   AAF6
....................          record_event();          
15EC0:  CALL   850C
....................              
....................          macro_cmd = master_macro_eco(); 
15EC4:  RCALL  15B88
15EC6:  MOVFF  01,871
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
15ECA:  MOVLW  16
15ECC:  MOVLB  8
15ECE:  MOVWF  xD8
15ED0:  MOVFF  22,8DA
15ED4:  MOVFF  21,8D9
15ED8:  MOVLB  0
15EDA:  CALL   501E
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
15EDE:  MOVLW  3A
15EE0:  MOVLB  8
15EE2:  MOVWF  xD8
15EE4:  MOVFF  38,8DA
15EE8:  MOVFF  37,8D9
15EEC:  MOVLB  0
15EEE:  CALL   501E
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
15EF2:  DECFSZ 4C,W
15EF4:  BRA    15F18
....................          { 
....................             disable_interrupts (INT_EXT); 
15EF6:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
15EF8:  CLRF   32
15EFA:  MOVLW  01
15EFC:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
15EFE:  MOVLW  02
15F00:  MOVLB  8
15F02:  MOVWF  x73
15F04:  MOVFF  31,874
15F08:  MOVLB  0
15F0A:  CALL   3466
....................             busy_clear(); 
15F0E:  CALL   AE9E
....................             return (user_quit); 
15F12:  MOVFF  4C,01
15F16:  BRA    1605A
....................          } 
....................  
....................          motor_sleep_rdy(); 
15F18:  CALL   29EC
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
15F1C:  MOVLW  01
15F1E:  MOVWF  1E
15F20:  MOVLW  A3
15F22:  MOVWF  1D
15F24:  MOVLW  54
15F26:  MOVWF  FF6
15F28:  MOVLW  22
15F2A:  MOVWF  FF7
15F2C:  MOVLW  00
15F2E:  MOVWF  FF8
15F30:  MOVLW  14
15F32:  MOVLB  8
15F34:  MOVWF  xD5
15F36:  MOVLB  0
15F38:  CALL   AAF6
15F3C:  MOVLW  10
15F3E:  MOVWF  FE9
15F40:  MOVFF  22,8E1
15F44:  MOVFF  21,8E0
15F48:  CALL   AB28
15F4C:  MOVLW  6B
15F4E:  MOVWF  FF6
15F50:  MOVLW  22
15F52:  MOVWF  FF7
15F54:  MOVLW  00
15F56:  MOVWF  FF8
15F58:  MOVLW  0C
15F5A:  MOVLB  8
15F5C:  MOVWF  xD5
15F5E:  MOVLB  0
15F60:  CALL   AAF6
....................          record_event();  
15F64:  CALL   850C
....................           
....................          if (macro_cmd == 'e') 
15F68:  MOVLB  8
15F6A:  MOVF   x71,W
15F6C:  SUBLW  65
15F6E:  BNZ   15FC2
....................          { 
....................             disable_interrupts (INT_EXT); 
15F70:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
15F72:  MOVLW  01
15F74:  MOVWF  1E
15F76:  MOVLW  A3
15F78:  MOVWF  1D
15F7A:  MOVLW  78
15F7C:  MOVWF  FF6
15F7E:  MOVLW  22
15F80:  MOVWF  FF7
15F82:  MOVLW  00
15F84:  MOVWF  FF8
15F86:  MOVLW  14
15F88:  MOVWF  xD5
15F8A:  MOVLB  0
15F8C:  CALL   AAF6
15F90:  MOVLW  10
15F92:  MOVWF  FE9
15F94:  MOVFF  22,8E1
15F98:  MOVFF  21,8E0
15F9C:  CALL   AB28
15FA0:  MOVLW  8F
15FA2:  MOVWF  FF6
15FA4:  MOVLW  22
15FA6:  MOVWF  FF7
15FA8:  MOVLW  00
15FAA:  MOVWF  FF8
15FAC:  MOVLW  09
15FAE:  MOVLB  8
15FB0:  MOVWF  xD5
15FB2:  MOVLB  0
15FB4:  CALL   AAF6
....................             record_event();  
15FB8:  CALL   850C
....................             cmd_err(); 
15FBC:  CALL   BD24
15FC0:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
15FC2:  MOVF   28,W
15FC4:  SUBWF  22,W
15FC6:  BNC   1604C
15FC8:  BNZ   15FD0
15FCA:  MOVF   27,W
15FCC:  SUBWF  21,W
15FCE:  BNC   1604C
....................          { 
....................             disable_interrupts (INT_EXT); 
15FD0:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
15FD2:  MOVLW  01
15FD4:  MOVWF  1E
15FD6:  MOVLW  A3
15FD8:  MOVWF  1D
15FDA:  MOVLW  9A
15FDC:  MOVWF  FF6
15FDE:  MOVLW  22
15FE0:  MOVWF  FF7
15FE2:  MOVLW  00
15FE4:  MOVWF  FF8
15FE6:  MOVLW  14
15FE8:  MOVWF  xD5
15FEA:  MOVLB  0
15FEC:  CALL   AAF6
15FF0:  MOVLW  10
15FF2:  MOVWF  FE9
15FF4:  MOVFF  22,8E1
15FF8:  MOVFF  21,8E0
15FFC:  CALL   AB28
16000:  MOVLW  B1
16002:  MOVWF  FF6
16004:  MOVLW  22
16006:  MOVWF  FF7
16008:  MOVLW  00
1600A:  MOVWF  FF8
1600C:  MOVLW  0F
1600E:  MOVLB  8
16010:  MOVWF  xD5
16012:  MOVLB  0
16014:  CALL   AAF6
....................             record_event();   
16018:  CALL   850C
....................             msg_max(); 
1601C:  RCALL  15E1E
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
1601E:  CLRF   34
16020:  MOVLW  01
16022:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
16024:  MOVLW  28
16026:  MOVLB  8
16028:  MOVWF  x73
1602A:  MOVFF  33,874
1602E:  MOVLB  0
16030:  CALL   3466
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
16034:  CLRF   32
16036:  MOVLW  01
16038:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
1603A:  MOVLW  02
1603C:  MOVLB  8
1603E:  MOVWF  x73
16040:  MOVFF  31,874
16044:  MOVLB  0
16046:  CALL   3466
1604A:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
1604C:  MOVLB  0
1604E:  RCALL  15AC2
16050:  BRA    15E3C
....................    } 
....................     
....................    busy_clear(); 
16052:  CALL   AE9E
....................    return (user_quit); 
16056:  MOVFF  4C,01
1605A:  GOTO   1697E (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
16256:  MOVF   24,W
16258:  SUBWF  36,W
1625A:  BTFSS  FD8.0
1625C:  BRA    1642C
1625E:  BNZ   16268
16260:  MOVF   23,W
16262:  SUBWF  35,W
16264:  BTFSS  FD8.0
16266:  BRA    1642C
....................       { 
....................          nv_elapsed = 0; 
16268:  CLRF   36
1626A:  CLRF   35
....................  
....................          init_hardware(); 
1626C:  CALL   298E
....................          sd_status = init_sdcard(); 
16270:  CALL   5084
16274:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
16278:  MOVLB  2
1627A:  MOVF   xD8,F
1627C:  BZ    16286
1627E:  MOVLB  0
16280:  CALL   50CA
16284:  MOVLB  2
....................  
....................          ++nv_sample; 
16286:  INCF   21,F
16288:  BTFSC  FD8.2
1628A:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
1628C:  MOVLW  40
1628E:  BTFSS  F9E.4
16290:  BRA    1628E
16292:  MOVWF  FAD
16294:  MOVLW  53
16296:  BTFSS  F9E.4
16298:  BRA    16296
1629A:  MOVWF  FAD
1629C:  MOVLW  09
1629E:  MOVWF  FE9
162A0:  CLRF   1B
162A2:  BTFSC  FF2.7
162A4:  BSF    1B.7
162A6:  BCF    FF2.7
162A8:  MOVFF  22,A26
162AC:  MOVFF  21,A25
162B0:  MOVLB  0
162B2:  CALL   1192
162B6:  BTFSC  1B.7
162B8:  BSF    FF2.7
162BA:  MOVLW  0D
162BC:  BTFSS  F9E.4
162BE:  BRA    162BC
162C0:  MOVWF  FAD
162C2:  MOVLW  0A
162C4:  BTFSS  F9E.4
162C6:  BRA    162C4
162C8:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
162CA:  MOVLW  01
162CC:  MOVWF  1E
162CE:  MOVLW  A3
162D0:  MOVWF  1D
162D2:  MOVLW  C2
162D4:  MOVWF  FF6
162D6:  MOVLW  22
162D8:  MOVWF  FF7
162DA:  MOVLW  00
162DC:  MOVWF  FF8
162DE:  MOVLW  14
162E0:  MOVLB  8
162E2:  MOVWF  xD5
162E4:  MOVLB  0
162E6:  CALL   AAF6
162EA:  MOVLW  10
162EC:  MOVWF  FE9
162EE:  MOVFF  22,8E1
162F2:  MOVFF  21,8E0
162F6:  CALL   AB28
162FA:  MOVLW  D9
162FC:  MOVWF  FF6
162FE:  MOVLW  22
16300:  MOVWF  FF7
16302:  MOVLW  00
16304:  MOVWF  FF8
16306:  MOVLW  09
16308:  MOVLB  8
1630A:  MOVWF  xD5
1630C:  MOVLB  0
1630E:  CALL   AAF6
....................          record_event();   
16312:  CALL   850C
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16316:  MOVLW  16
16318:  MOVLB  8
1631A:  MOVWF  xD8
1631C:  MOVFF  22,8DA
16320:  MOVFF  21,8D9
16324:  MOVLB  0
16326:  CALL   501E
....................  
....................          if (nv_macro_mode==TRUE) 
1632A:  DECFSZ 29,W
1632C:  BRA    16342
1632E:  MOVF   2A,F
16330:  BNZ   16342
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
16332:  MOVFF  22,873
16336:  MOVFF  21,872
1633A:  BRA    1605E
1633C:  MOVFF  01,871
....................          } 
16340:  BRA    163AA
....................          else 
....................          { 
....................             time_stamp(); 
16342:  CALL   5464
....................             play_wms_hard_macro(nv_port); 
16346:  MOVFF  2E,874
1634A:  MOVFF  2D,873
1634E:  CALL   D578
....................             ++nv_port; 
16352:  INCF   2D,F
16354:  BTFSC  FD8.2
16356:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
16358:  MOVF   2E,F
1635A:  BNZ   16362
1635C:  MOVF   2D,W
1635E:  SUBLW  01
16360:  BC    16374
16362:  MOVF   2E,F
16364:  BNZ   16374
16366:  MOVF   2D,W
16368:  SUBLW  30
1636A:  BNC   16374
1636C:  DECFSZ 2F,W
1636E:  BRA    16374
16370:  MOVF   30,F
16372:  BZ    16392
16374:  MOVF   2E,F
16376:  BNZ   1637E
16378:  MOVF   2D,W
1637A:  SUBLW  01
1637C:  BC    163A8
1637E:  MOVF   2E,F
16380:  BNZ   163A8
16382:  MOVF   2D,W
16384:  SUBLW  32
16386:  BNC   163A8
16388:  MOVF   2F,W
1638A:  SUBLW  03
1638C:  BNZ   163A8
1638E:  MOVF   30,F
16390:  BNZ   163A8
....................             { 
....................                write16(ADDR_PORT, nv_port);             
16392:  MOVLW  24
16394:  MOVLB  8
16396:  MOVWF  xD8
16398:  MOVFF  2E,8DA
1639C:  MOVFF  2D,8D9
163A0:  MOVLB  0
163A2:  CALL   501E
....................             } 
163A6:  BRA    163AA
....................             else disable_interrupts (INT_EXT); 
163A8:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
163AA:  DECFSZ 4C,W
163AC:  BRA    163D0
....................          { 
....................             disable_interrupts (INT_EXT); 
163AE:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
163B0:  CLRF   32
163B2:  MOVLW  01
163B4:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
163B6:  MOVLW  02
163B8:  MOVLB  8
163BA:  MOVWF  x73
163BC:  MOVFF  31,874
163C0:  MOVLB  0
163C2:  CALL   3466
....................             busy_clear(); 
163C6:  CALL   AE9E
....................             return (user_quit); 
163CA:  MOVFF  4C,01
163CE:  BRA    1643A
....................          } 
....................           
....................          motor_sleep_rdy(); 
163D0:  CALL   29EC
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
163D4:  MOVLW  01
163D6:  MOVWF  1E
163D8:  MOVLW  A3
163DA:  MOVWF  1D
163DC:  MOVLW  E4
163DE:  MOVWF  FF6
163E0:  MOVLW  22
163E2:  MOVWF  FF7
163E4:  MOVLW  00
163E6:  MOVWF  FF8
163E8:  MOVLW  14
163EA:  MOVLB  8
163EC:  MOVWF  xD5
163EE:  MOVLB  0
163F0:  CALL   AAF6
163F4:  MOVLW  10
163F6:  MOVWF  FE9
163F8:  MOVFF  22,8E1
163FC:  MOVFF  21,8E0
16400:  CALL   AB28
16404:  MOVLW  FB
16406:  MOVWF  FF6
16408:  MOVLW  22
1640A:  MOVWF  FF7
1640C:  MOVLW  00
1640E:  MOVWF  FF8
16410:  MOVLW  0C
16412:  MOVLB  8
16414:  MOVWF  xD5
16416:  MOVLB  0
16418:  CALL   AAF6
....................          record_event();  
1641C:  CALL   850C
....................           
....................          if (macro_end == ';') 
16420:  MOVLB  8
16422:  MOVF   x71,W
16424:  SUBLW  3B
16426:  BNZ   1642A
....................          { 
....................             disable_interrupts (INT_EXT); 
16428:  BCF    FF2.4
1642A:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
1642C:  CALL   15AC2
16430:  BRA    16256
....................    } 
....................    busy_clear(); 
16432:  CALL   AE9E
....................    return (user_quit); 
16436:  MOVFF  4C,01
1643A:  GOTO   16986 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
165C2:  MOVF   24,W
165C4:  SUBWF  36,W
165C6:  BTFSS  FD8.0
165C8:  BRA    16782
165CA:  BNZ   165D4
165CC:  MOVF   23,W
165CE:  SUBWF  35,W
165D0:  BTFSS  FD8.0
165D2:  BRA    16782
....................       { 
....................          nv_elapsed = 0; 
165D4:  CLRF   36
165D6:  CLRF   35
....................  
....................          init_hardware(); 
165D8:  CALL   298E
....................          sd_status = init_sdcard(); 
165DC:  CALL   5084
165E0:  MOVFF  01,2D8
....................          if(sd_status>0) msg_card_fail(); 
165E4:  MOVLB  2
165E6:  MOVF   xD8,F
165E8:  BZ    165F2
165EA:  MOVLB  0
165EC:  CALL   50CA
165F0:  MOVLB  2
....................  
....................          ++nv_sample; 
165F2:  INCF   21,F
165F4:  BTFSC  FD8.2
165F6:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
165F8:  MOVLW  40
165FA:  BTFSS  F9E.4
165FC:  BRA    165FA
165FE:  MOVWF  FAD
16600:  MOVLW  53
16602:  BTFSS  F9E.4
16604:  BRA    16602
16606:  MOVWF  FAD
16608:  MOVLW  09
1660A:  MOVWF  FE9
1660C:  CLRF   1B
1660E:  BTFSC  FF2.7
16610:  BSF    1B.7
16612:  BCF    FF2.7
16614:  MOVFF  22,A26
16618:  MOVFF  21,A25
1661C:  MOVLB  0
1661E:  CALL   1192
16622:  BTFSC  1B.7
16624:  BSF    FF2.7
16626:  MOVLW  0D
16628:  BTFSS  F9E.4
1662A:  BRA    16628
1662C:  MOVWF  FAD
1662E:  MOVLW  0A
16630:  BTFSS  F9E.4
16632:  BRA    16630
16634:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16636:  MOVLW  01
16638:  MOVWF  1E
1663A:  MOVLW  A3
1663C:  MOVWF  1D
1663E:  MOVLW  08
16640:  MOVWF  FF6
16642:  MOVLW  23
16644:  MOVWF  FF7
16646:  MOVLW  00
16648:  MOVWF  FF8
1664A:  MOVLW  14
1664C:  MOVLB  8
1664E:  MOVWF  xD5
16650:  MOVLB  0
16652:  CALL   AAF6
16656:  MOVLW  10
16658:  MOVWF  FE9
1665A:  MOVFF  22,8E1
1665E:  MOVFF  21,8E0
16662:  CALL   AB28
16666:  MOVLW  1F
16668:  MOVWF  FF6
1666A:  MOVLW  23
1666C:  MOVWF  FF7
1666E:  MOVLW  00
16670:  MOVWF  FF8
16672:  MOVLW  09
16674:  MOVLB  8
16676:  MOVWF  xD5
16678:  MOVLB  0
1667A:  CALL   AAF6
....................          record_event();   
1667E:  CALL   850C
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16682:  MOVLW  16
16684:  MOVLB  8
16686:  MOVWF  xD8
16688:  MOVFF  22,8DA
1668C:  MOVFF  21,8D9
16690:  MOVLB  0
16692:  CALL   501E
....................  
....................          macro_end = master_macro_aws(nv_sample); 
16696:  MOVFF  22,877
1669A:  MOVFF  21,876
1669E:  RCALL  1643E
166A0:  MOVFF  01,871
....................           
....................          if (user_quit == TRUE) 
166A4:  DECFSZ 4C,W
166A6:  BRA    166CA
....................          { 
....................             disable_interrupts (INT_EXT); 
166A8:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
166AA:  CLRF   32
166AC:  MOVLW  01
166AE:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
166B0:  MOVLW  02
166B2:  MOVLB  8
166B4:  MOVWF  x73
166B6:  MOVFF  31,874
166BA:  MOVLB  0
166BC:  CALL   3466
....................             busy_clear(); 
166C0:  CALL   AE9E
....................             return (user_quit); 
166C4:  MOVFF  4C,01
166C8:  BRA    16794
....................          } 
....................           
....................          motor_sleep_rdy(); 
166CA:  CALL   29EC
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
166CE:  MOVLW  01
166D0:  MOVWF  1E
166D2:  MOVLW  A3
166D4:  MOVWF  1D
166D6:  MOVLW  2A
166D8:  MOVWF  FF6
166DA:  MOVLW  23
166DC:  MOVWF  FF7
166DE:  MOVLW  00
166E0:  MOVWF  FF8
166E2:  MOVLW  14
166E4:  MOVLB  8
166E6:  MOVWF  xD5
166E8:  MOVLB  0
166EA:  CALL   AAF6
166EE:  MOVLW  10
166F0:  MOVWF  FE9
166F2:  MOVFF  22,8E1
166F6:  MOVFF  21,8E0
166FA:  CALL   AB28
166FE:  MOVLW  41
16700:  MOVWF  FF6
16702:  MOVLW  23
16704:  MOVWF  FF7
16706:  MOVLW  00
16708:  MOVWF  FF8
1670A:  MOVLW  0C
1670C:  MOVLB  8
1670E:  MOVWF  xD5
16710:  MOVLB  0
16712:  CALL   AAF6
....................          record_event();  
16716:  CALL   850C
....................           
....................          if (macro_end == ';') 
1671A:  MOVLB  8
1671C:  MOVF   x71,W
1671E:  SUBLW  3B
16720:  BNZ   16724
....................          { 
....................             disable_interrupts (INT_EXT); 
16722:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16724:  MOVF   28,W
16726:  SUBWF  22,W
16728:  BNC   16784
1672A:  BNZ   16732
1672C:  MOVF   27,W
1672E:  SUBWF  21,W
16730:  BNC   16784
....................          { 
....................             disable_interrupts (INT_EXT); 
16732:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16734:  MOVLW  01
16736:  MOVWF  1E
16738:  MOVLW  A3
1673A:  MOVWF  1D
1673C:  MOVLW  4E
1673E:  MOVWF  FF6
16740:  MOVLW  23
16742:  MOVWF  FF7
16744:  MOVLW  00
16746:  MOVWF  FF8
16748:  MOVLW  14
1674A:  MOVWF  xD5
1674C:  MOVLB  0
1674E:  CALL   AAF6
16752:  MOVLW  10
16754:  MOVWF  FE9
16756:  MOVFF  22,8E1
1675A:  MOVFF  21,8E0
1675E:  CALL   AB28
16762:  MOVLW  65
16764:  MOVWF  FF6
16766:  MOVLW  23
16768:  MOVWF  FF7
1676A:  MOVLW  00
1676C:  MOVWF  FF8
1676E:  MOVLW  0F
16770:  MOVLB  8
16772:  MOVWF  xD5
16774:  MOVLB  0
16776:  CALL   AAF6
....................             record_event();   
1677A:  CALL   850C
....................             msg_max(); 
1677E:  CALL   15E1E
16782:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
16784:  MOVLB  0
16786:  CALL   15AC2
1678A:  BRA    165C2
....................    } 
....................    busy_clear(); 
1678C:  CALL   AE9E
....................    return (user_quit); 
16790:  MOVFF  4C,01
16794:  GOTO   1698E (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
16798:  CALL   2A14
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
1679C:  MOVLW  01
1679E:  MOVWF  1E
167A0:  MOVLW  A3
167A2:  MOVWF  1D
167A4:  MOVLW  76
167A6:  MOVWF  FF6
167A8:  MOVLW  23
167AA:  MOVWF  FF7
167AC:  MOVLW  00
167AE:  MOVWF  FF8
167B0:  CALL   5108
....................    record_event(); 
167B4:  CALL   850C
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
167B8:  MOVLW  01
167BA:  MOVWF  1E
167BC:  MOVLW  A3
167BE:  MOVWF  1D
167C0:  MOVLW  90
167C2:  MOVWF  FF6
167C4:  MOVLW  23
167C6:  MOVWF  FF7
167C8:  MOVLW  00
167CA:  MOVWF  FF8
167CC:  MOVLW  0C
167CE:  MOVLB  8
167D0:  MOVWF  xD5
167D2:  MOVLB  0
167D4:  CALL   AAF6
167D8:  MOVLW  10
167DA:  MOVWF  FE9
167DC:  MOVFF  26,8E1
167E0:  MOVFF  25,8E0
167E4:  CALL   AB28
167E8:  MOVLW  9F
167EA:  MOVWF  FF6
167EC:  MOVLW  23
167EE:  MOVWF  FF7
167F0:  MOVLW  00
167F2:  MOVWF  FF8
167F4:  MOVLW  06
167F6:  MOVLB  8
167F8:  MOVWF  xD5
167FA:  MOVLB  0
167FC:  CALL   AAF6
16800:  MOVLW  10
16802:  MOVWF  FE9
16804:  MOVFF  24,8E1
16808:  MOVFF  23,8E0
1680C:  CALL   AB28
16810:  MOVLW  A8
16812:  MOVWF  FF6
16814:  MOVLW  23
16816:  MOVWF  FF7
16818:  MOVLW  00
1681A:  MOVWF  FF8
1681C:  MOVLW  06
1681E:  MOVLB  8
16820:  MOVWF  xD5
16822:  MOVLB  0
16824:  CALL   AAF6
16828:  MOVLW  10
1682A:  MOVWF  FE9
1682C:  MOVFF  28,8E1
16830:  MOVFF  27,8E0
16834:  CALL   AB28
16838:  MOVLW  B1
1683A:  MOVWF  FF6
1683C:  MOVLW  23
1683E:  MOVWF  FF7
16840:  MOVLW  00
16842:  MOVWF  FF8
16844:  MOVLW  03
16846:  MOVLB  8
16848:  MOVWF  xD5
1684A:  MOVLB  0
1684C:  CALL   AAF6
....................    record_event(); 
16850:  CALL   850C
....................     
....................    user_quit = FALSE; 
16854:  CLRF   4C
....................     
....................    nv_cmd_mode = FALSE; 
16856:  CLRF   32
16858:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1685A:  MOVLW  02
1685C:  MOVLB  8
1685E:  MOVWF  x73
16860:  MOVFF  31,874
16864:  MOVLB  0
16866:  CALL   3466
....................  
....................    RTC_set_AFE(); 
1686A:  GOTO   15326
....................    // check if start is earlier than now 
....................    RTC_late(); 
1686E:  CALL   1537E
....................    // show clock 
....................    RTC_display(); 
16872:  CALL   DFFE
....................    // show alarm 
....................    RTC_display_alarm(); 
16876:  CALL   E25E
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
1687A:  CALL   15838
....................  
....................    if (alarm_passed == FALSE){ 
1687E:  BTFSC  49.3
16880:  BRA    16882
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
16882:  MOVLW  00
16884:  BTFSC  49.3
16886:  MOVLW  01
16888:  MOVLB  8
1688A:  MOVWF  x71
1688C:  MOVLW  01
1688E:  MOVWF  1E
16890:  MOVLW  A3
16892:  MOVWF  1D
16894:  MOVLW  B6
16896:  MOVWF  FF6
16898:  MOVLW  23
1689A:  MOVWF  FF7
1689C:  MOVLW  00
1689E:  MOVWF  FF8
168A0:  MOVLW  14
168A2:  MOVWF  xD5
168A4:  MOVLB  0
168A6:  CALL   AAF6
168AA:  MOVLW  10
168AC:  MOVWF  FE9
168AE:  MOVFF  22,8E1
168B2:  MOVFF  21,8E0
168B6:  CALL   AB28
168BA:  MOVLW  CD
168BC:  MOVWF  FF6
168BE:  MOVLW  23
168C0:  MOVWF  FF7
168C2:  MOVLW  00
168C4:  MOVWF  FF8
168C6:  MOVLW  08
168C8:  MOVLB  8
168CA:  MOVWF  xD5
168CC:  MOVLB  0
168CE:  CALL   AAF6
168D2:  MOVFF  871,8D7
168D6:  MOVLW  1B
168D8:  MOVLB  8
168DA:  MOVWF  xD8
168DC:  MOVLB  0
168DE:  CALL   52CA
168E2:  MOVLW  D7
168E4:  MOVWF  FF6
168E6:  MOVLW  23
168E8:  MOVWF  FF7
168EA:  MOVLW  00
168EC:  MOVWF  FF8
168EE:  MOVLW  03
168F0:  MOVLB  8
168F2:  MOVWF  xD5
168F4:  MOVLB  0
168F6:  CALL   AAF6
....................    record_event();  
168FA:  CALL   850C
....................  
....................    while (TRUE == RTC_read_flags_running) 
168FE:  BTFSS  49.2
16900:  BRA    16904
....................    { 
....................       ; 
16902:  BRA    168FE
....................    } 
....................    RTC_read_flags_running = TRUE; 
16904:  BSF    49.2
16906:  CLRF   1B
16908:  BTFSC  FF2.7
1690A:  BSF    1B.7
1690C:  BCF    FF2.7
....................    RTC_read_flags(); 
1690E:  CALL   0DCC
16912:  BTFSC  1B.7
16914:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
16916:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
16918:  CALL   29EC
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
1691C:  BTFSC  49.3
1691E:  BRA    16940
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
16920:  MOVLW  01
16922:  MOVWF  1E
16924:  MOVLW  A3
16926:  MOVWF  1D
16928:  MOVLW  DC
1692A:  MOVWF  FF6
1692C:  MOVLW  23
1692E:  MOVWF  FF7
16930:  MOVLW  00
16932:  MOVWF  FF8
16934:  CALL   5108
....................       record_event(); 
16938:  CALL   850C
....................       go_to_sleep(); 
1693C:  CALL   15AC2
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
16940:  GOTO   15AD8
....................    nv_elapsed = nv_interval; 
16944:  MOVFF  24,36
16948:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
1694C:  MOVFF  2F,00
16950:  MOVF   30,W
16952:  MOVWF  03
16954:  BNZ   1695A
16956:  MOVF   00,F
16958:  BZ    1697A
1695A:  MOVF   03,W
1695C:  BNZ   16964
1695E:  MOVLW  01
16960:  SUBWF  00,W
16962:  BZ    16984
16964:  MOVF   03,W
16966:  BNZ   1696E
16968:  MOVLW  03
1696A:  SUBWF  00,W
1696C:  BZ    16984
1696E:  MOVF   03,W
16970:  BNZ   16978
16972:  MOVLW  02
16974:  SUBWF  00,W
16976:  BZ    1698C
16978:  BRA    16992
....................       case ECO: user_quit = auto_sample_eco(); 
1697A:  GOTO   15E3C
1697E:  MOVFF  01,4C
....................          break; 
16982:  BRA    16992
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
16984:  BRA    16256
16986:  MOVFF  01,4C
....................          break; 
1698A:  BRA    16992
....................       case AWS: user_quit = auto_sample_aws(); 
1698C:  BRA    165C2
1698E:  MOVFF  01,4C
....................          break;          
....................    } 
....................    return(user_quit); 
16992:  MOVFF  4C,01
16996:  GOTO   16A8A (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BCF4:  MOVF   44,F
0BCF6:  BNZ   BD04
0BCF8:  MOVF   45,F
0BCFA:  BNZ   BD04
0BCFC:  MOVF   46,F
0BCFE:  BNZ   BD04
0BD00:  MOVF   47,F
0BD02:  BZ    BD1C
0BD04:  MOVF   47,F
0BD06:  BNZ   BD1C
0BD08:  MOVF   46,F
0BD0A:  BNZ   BD1C
0BD0C:  MOVF   45,F
0BD0E:  BNZ   BD1C
0BD10:  MOVF   44,W
0BD12:  SUBLW  02
0BD14:  BNC   BD1C
....................       detector = arg; 
0BD16:  MOVFF  44,2D1
....................    } 
0BD1A:  BRA    BD20
....................    else cmd_arg(); 
0BD1C:  CALL   B062
0BD20:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0BD42:  MOVF   44,F
0BD44:  BNZ   BD52
0BD46:  MOVF   45,F
0BD48:  BNZ   BD52
0BD4A:  MOVF   46,F
0BD4C:  BNZ   BD52
0BD4E:  MOVF   47,F
0BD50:  BZ    BDAC
0BD52:  MOVF   47,F
0BD54:  BNZ   BDAC
0BD56:  MOVF   46,W
0BD58:  SUBLW  00
0BD5A:  BNC   BDAC
....................       switch (detector){ 
0BD5C:  MOVLB  2
0BD5E:  MOVF   xD1,W
0BD60:  XORLW  01
0BD62:  MOVLB  0
0BD64:  BZ    BD6C
0BD66:  XORLW  03
0BD68:  BZ    BD8A
0BD6A:  BRA    BDA8
....................          case 1 : nv_d1_temp = arg; 
0BD6C:  MOVFF  45,3E
0BD70:  MOVFF  44,3D
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0BD74:  MOVLW  40
0BD76:  MOVLB  8
0BD78:  MOVWF  xD8
0BD7A:  MOVFF  3E,8DA
0BD7E:  MOVFF  3D,8D9
0BD82:  MOVLB  0
0BD84:  CALL   501E
....................             break; 
0BD88:  BRA    BDAA
....................          case 2 : nv_d2_temp = arg; 
0BD8A:  MOVFF  45,40
0BD8E:  MOVFF  44,3F
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0BD92:  MOVLW  42
0BD94:  MOVLB  8
0BD96:  MOVWF  xD8
0BD98:  MOVFF  40,8DA
0BD9C:  MOVFF  3F,8D9
0BDA0:  MOVLB  0
0BDA2:  CALL   501E
....................             break; 
0BDA6:  BRA    BDAA
....................          default : cmd_err(); 
0BDA8:  RCALL  BD24
....................             break; 
....................       } 
....................    } 
0BDAA:  BRA    BE52
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0BDAC:  MOVF   44,F
0BDAE:  BNZ   BE4E
0BDB0:  MOVF   45,F
0BDB2:  BNZ   BE4E
0BDB4:  MOVF   46,F
0BDB6:  BNZ   BE4E
0BDB8:  MOVF   47,F
0BDBA:  BNZ   BE4E
0BDBC:  MOVLW  F2
0BDBE:  MOVWF  FF6
0BDC0:  MOVLW  23
0BDC2:  MOVWF  FF7
0BDC4:  MOVLW  00
0BDC6:  MOVWF  FF8
0BDC8:  CLRF   1B
0BDCA:  BTFSC  FF2.7
0BDCC:  BSF    1B.7
0BDCE:  BCF    FF2.7
0BDD0:  MOVLW  03
0BDD2:  MOVLB  A
0BDD4:  MOVWF  x25
0BDD6:  MOVLB  0
0BDD8:  CALL   1010
0BDDC:  BTFSC  1B.7
0BDDE:  BSF    FF2.7
0BDE0:  MOVLW  10
0BDE2:  MOVWF  FE9
0BDE4:  CLRF   1B
0BDE6:  BTFSC  FF2.7
0BDE8:  BSF    1B.7
0BDEA:  BCF    FF2.7
0BDEC:  MOVFF  3E,A26
0BDF0:  MOVFF  3D,A25
0BDF4:  CALL   1192
0BDF8:  BTFSC  1B.7
0BDFA:  BSF    FF2.7
0BDFC:  MOVLW  F8
0BDFE:  MOVWF  FF6
0BE00:  MOVLW  23
0BE02:  MOVWF  FF7
0BE04:  MOVLW  00
0BE06:  MOVWF  FF8
0BE08:  CLRF   1B
0BE0A:  BTFSC  FF2.7
0BE0C:  BSF    1B.7
0BE0E:  BCF    FF2.7
0BE10:  MOVLW  04
0BE12:  MOVLB  A
0BE14:  MOVWF  x25
0BE16:  MOVLB  0
0BE18:  CALL   1010
0BE1C:  BTFSC  1B.7
0BE1E:  BSF    FF2.7
0BE20:  MOVLW  10
0BE22:  MOVWF  FE9
0BE24:  CLRF   1B
0BE26:  BTFSC  FF2.7
0BE28:  BSF    1B.7
0BE2A:  BCF    FF2.7
0BE2C:  MOVFF  40,A26
0BE30:  MOVFF  3F,A25
0BE34:  CALL   1192
0BE38:  BTFSC  1B.7
0BE3A:  BSF    FF2.7
0BE3C:  MOVLW  0D
0BE3E:  BTFSS  F9E.4
0BE40:  BRA    BE3E
0BE42:  MOVWF  FAD
0BE44:  MOVLW  0A
0BE46:  BTFSS  F9E.4
0BE48:  BRA    BE46
0BE4A:  MOVWF  FAD
0BE4C:  BRA    BE52
....................    else cmd_arg(); 
0BE4E:  CALL   B062
0BE52:  GOTO   BEB8 (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0BE56:  MOVF   47,F
0BE58:  BNZ   BE86
0BE5A:  MOVF   46,F
0BE5C:  BNZ   BE86
0BE5E:  MOVF   45,F
0BE60:  BNZ   BE86
0BE62:  MOVF   44,W
0BE64:  SUBLW  01
0BE66:  BNC   BE86
....................       nv_macro_mode = arg; 
0BE68:  MOVFF  45,2A
0BE6C:  MOVFF  44,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0BE70:  MOVLW  20
0BE72:  MOVLB  8
0BE74:  MOVWF  xD8
0BE76:  MOVFF  2A,8DA
0BE7A:  MOVFF  29,8D9
0BE7E:  MOVLB  0
0BE80:  CALL   501E
....................    } 
0BE84:  BRA    BE8A
....................    else cmd_arg(); 
0BE86:  CALL   B062
0BE8A:  GOTO   BEB8 (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0BE8E:  MOVF   2F,W
0BE90:  MOVWF  00
0BE92:  MOVF   30,W
0BE94:  MOVWF  03
0BE96:  BNZ   BE9C
0BE98:  MOVF   00,F
0BE9A:  BZ    BEB2
0BE9C:  MOVF   03,W
0BE9E:  BNZ   BEA6
0BEA0:  MOVLW  01
0BEA2:  SUBWF  00,W
0BEA4:  BZ    BEB6
0BEA6:  MOVF   03,W
0BEA8:  BNZ   BEB0
0BEAA:  MOVLW  03
0BEAC:  SUBWF  00,W
0BEAE:  BZ    BEB6
0BEB0:  BRA    BEB8
....................       case ECO : commandAe(); 
0BEB2:  BRA    BD42
....................          break; 
0BEB4:  BRA    BEB8
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0BEB6:  BRA    BE56
....................          break; 
....................    } 
0BEB8:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0BEBC:  MOVF   44,F
0BEBE:  BNZ   BECC
0BEC0:  MOVF   45,F
0BEC2:  BNZ   BECC
0BEC4:  MOVF   46,F
0BEC6:  BNZ   BECC
0BEC8:  MOVF   47,F
0BECA:  BZ    BEFC
0BECC:  MOVF   47,F
0BECE:  BNZ   BEFC
0BED0:  MOVF   46,F
0BED2:  BNZ   BEFC
0BED4:  MOVF   45,F
0BED6:  BNZ   BEFC
0BED8:  MOVF   44,W
0BEDA:  SUBLW  03
0BEDC:  BNC   BEFC
....................       nv_det_type = arg; 
0BEDE:  MOVFF  45,42
0BEE2:  MOVFF  44,41
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0BEE6:  MOVLW  26
0BEE8:  MOVLB  8
0BEEA:  MOVWF  xD8
0BEEC:  MOVFF  42,8DA
0BEF0:  MOVFF  41,8D9
0BEF4:  MOVLB  0
0BEF6:  CALL   501E
....................    } 
0BEFA:  BRA    BF62
....................    else if(arg==0) { 
0BEFC:  MOVF   44,F
0BEFE:  BNZ   BF5E
0BF00:  MOVF   45,F
0BF02:  BNZ   BF5E
0BF04:  MOVF   46,F
0BF06:  BNZ   BF5E
0BF08:  MOVF   47,F
0BF0A:  BNZ   BF5E
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0BF0C:  MOVLW  02
0BF0E:  MOVWF  FF6
0BF10:  MOVLW  24
0BF12:  MOVWF  FF7
0BF14:  MOVLW  00
0BF16:  MOVWF  FF8
0BF18:  CLRF   1B
0BF1A:  BTFSC  FF2.7
0BF1C:  BSF    1B.7
0BF1E:  BCF    FF2.7
0BF20:  MOVLW  05
0BF22:  MOVLB  A
0BF24:  MOVWF  x25
0BF26:  MOVLB  0
0BF28:  CALL   1010
0BF2C:  BTFSC  1B.7
0BF2E:  BSF    FF2.7
0BF30:  MOVLW  10
0BF32:  MOVWF  FE9
0BF34:  CLRF   1B
0BF36:  BTFSC  FF2.7
0BF38:  BSF    1B.7
0BF3A:  BCF    FF2.7
0BF3C:  MOVFF  42,A26
0BF40:  MOVFF  41,A25
0BF44:  CALL   1192
0BF48:  BTFSC  1B.7
0BF4A:  BSF    FF2.7
0BF4C:  MOVLW  0D
0BF4E:  BTFSS  F9E.4
0BF50:  BRA    BF4E
0BF52:  MOVWF  FAD
0BF54:  MOVLW  0A
0BF56:  BTFSS  F9E.4
0BF58:  BRA    BF56
0BF5A:  MOVWF  FAD
....................    } 
0BF5C:  BRA    BF62
....................    else cmd_arg(); 
0BF5E:  CALL   B062
0BF62:  GOTO   C024 (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0BFD4:  MOVF   47,F
0BFD6:  BNZ   BFF2
0BFD8:  MOVF   46,F
0BFDA:  BNZ   BFF2
0BFDC:  MOVF   45,F
0BFDE:  BNZ   BFF2
0BFE0:  MOVF   44,W
0BFE2:  SUBLW  03
0BFE4:  BNC   BFF2
....................       hb_cmd=arg; 
0BFE6:  MOVFF  44,86F
....................       h_bridge(hb_cmd); 
0BFEA:  MOVFF  86F,89F
0BFEE:  RCALL  BFB4
....................    } 
0BFF0:  BRA    BFF6
....................    else cmd_arg(); 
0BFF2:  CALL   B062
0BFF6:  GOTO   C024 (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0BFFA:  MOVF   2F,W
0BFFC:  MOVWF  00
0BFFE:  MOVF   30,W
0C000:  MOVWF  03
0C002:  BNZ   C008
0C004:  MOVF   00,F
0C006:  BZ    C01E
0C008:  MOVF   03,W
0C00A:  BNZ   C012
0C00C:  MOVLW  01
0C00E:  SUBWF  00,W
0C010:  BZ    C022
0C012:  MOVF   03,W
0C014:  BNZ   C01C
0C016:  MOVLW  03
0C018:  SUBWF  00,W
0C01A:  BZ    C022
0C01C:  BRA    C024
....................       case ECO : commandBe(); 
0C01E:  BRA    BEBC
....................          break; 
0C020:  BRA    C024
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0C022:  BRA    BFD4
....................          break; 
....................    } 
0C024:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CB34:  MOVF   44,W
0CB36:  MOVWF  00
0CB38:  MOVF   45,W
0CB3A:  MOVWF  03
0CB3C:  BNZ   CB42
0CB3E:  MOVF   00,F
0CB40:  BZ    CBA4
0CB42:  MOVF   03,W
0CB44:  BNZ   CB4E
0CB46:  MOVLW  01
0CB48:  SUBWF  00,W
0CB4A:  BTFSC  FD8.2
0CB4C:  BRA    CD92
0CB4E:  MOVF   03,W
0CB50:  BNZ   CB5A
0CB52:  MOVLW  02
0CB54:  SUBWF  00,W
0CB56:  BTFSC  FD8.2
0CB58:  BRA    CDEE
0CB5A:  MOVF   03,W
0CB5C:  BNZ   CB66
0CB5E:  MOVLW  03
0CB60:  SUBWF  00,W
0CB62:  BTFSC  FD8.2
0CB64:  BRA    CE4A
0CB66:  MOVF   03,W
0CB68:  BNZ   CB72
0CB6A:  MOVLW  04
0CB6C:  SUBWF  00,W
0CB6E:  BTFSC  FD8.2
0CB70:  BRA    CEA6
0CB72:  MOVF   03,W
0CB74:  BNZ   CB7E
0CB76:  MOVLW  05
0CB78:  SUBWF  00,W
0CB7A:  BTFSC  FD8.2
0CB7C:  BRA    CF02
0CB7E:  MOVF   03,W
0CB80:  BNZ   CB8A
0CB82:  MOVLW  06
0CB84:  SUBWF  00,W
0CB86:  BTFSC  FD8.2
0CB88:  BRA    CF5E
0CB8A:  MOVF   03,W
0CB8C:  BNZ   CB96
0CB8E:  MOVLW  07
0CB90:  SUBWF  00,W
0CB92:  BTFSC  FD8.2
0CB94:  BRA    CFBA
0CB96:  MOVF   03,W
0CB98:  BNZ   CBA2
0CB9A:  MOVLW  08
0CB9C:  SUBWF  00,W
0CB9E:  BTFSC  FD8.2
0CBA0:  BRA    D016
0CBA2:  BRA    D072
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CBA4:  MOVLW  0E
0CBA6:  MOVWF  FF6
0CBA8:  MOVLW  24
0CBAA:  MOVWF  FF7
0CBAC:  MOVLW  00
0CBAE:  MOVWF  FF8
0CBB0:  CLRF   1B
0CBB2:  BTFSC  FF2.7
0CBB4:  BSF    1B.7
0CBB6:  BCF    FF2.7
0CBB8:  MOVLW  04
0CBBA:  MOVLB  A
0CBBC:  MOVWF  x25
0CBBE:  MOVLB  0
0CBC0:  CALL   1010
0CBC4:  BTFSC  1B.7
0CBC6:  BSF    FF2.7
0CBC8:  MOVLW  89
0CBCA:  MOVWF  FE9
0CBCC:  MOVFF  3F4,872
0CBD0:  MOVFF  3F3,871
0CBD4:  MOVFF  3F2,870
0CBD8:  MOVFF  3F1,86F
0CBDC:  MOVLW  05
0CBDE:  MOVLB  8
0CBE0:  MOVWF  x73
0CBE2:  MOVLB  0
0CBE4:  RCALL  C40C
0CBE6:  MOVLW  2C
0CBE8:  BTFSS  F9E.4
0CBEA:  BRA    CBE8
0CBEC:  MOVWF  FAD
0CBEE:  MOVLW  89
0CBF0:  MOVWF  FE9
0CBF2:  MOVFF  3F8,872
0CBF6:  MOVFF  3F7,871
0CBFA:  MOVFF  3F6,870
0CBFE:  MOVFF  3F5,86F
0CC02:  MOVLW  05
0CC04:  MOVLB  8
0CC06:  MOVWF  x73
0CC08:  MOVLB  0
0CC0A:  RCALL  C40C
0CC0C:  MOVLW  0D
0CC0E:  BTFSS  F9E.4
0CC10:  BRA    CC0E
0CC12:  MOVWF  FAD
0CC14:  MOVLW  0A
0CC16:  BTFSS  F9E.4
0CC18:  BRA    CC16
0CC1A:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CC1C:  MOVLW  20
0CC1E:  MOVWF  FF6
0CC20:  MOVLW  24
0CC22:  MOVWF  FF7
0CC24:  MOVLW  00
0CC26:  MOVWF  FF8
0CC28:  CLRF   1B
0CC2A:  BTFSC  FF2.7
0CC2C:  BSF    1B.7
0CC2E:  BCF    FF2.7
0CC30:  MOVLW  04
0CC32:  MOVLB  A
0CC34:  MOVWF  x25
0CC36:  MOVLB  0
0CC38:  CALL   1010
0CC3C:  BTFSC  1B.7
0CC3E:  BSF    FF2.7
0CC40:  MOVLW  89
0CC42:  MOVWF  FE9
0CC44:  MOVFF  3FC,872
0CC48:  MOVFF  3FB,871
0CC4C:  MOVFF  3FA,870
0CC50:  MOVFF  3F9,86F
0CC54:  MOVLW  05
0CC56:  MOVLB  8
0CC58:  MOVWF  x73
0CC5A:  MOVLB  0
0CC5C:  CALL   C40C
0CC60:  MOVLW  2C
0CC62:  BTFSS  F9E.4
0CC64:  BRA    CC62
0CC66:  MOVWF  FAD
0CC68:  MOVLW  89
0CC6A:  MOVWF  FE9
0CC6C:  MOVFF  400,872
0CC70:  MOVFF  3FF,871
0CC74:  MOVFF  3FE,870
0CC78:  MOVFF  3FD,86F
0CC7C:  MOVLW  05
0CC7E:  MOVLB  8
0CC80:  MOVWF  x73
0CC82:  MOVLB  0
0CC84:  CALL   C40C
0CC88:  MOVLW  0D
0CC8A:  BTFSS  F9E.4
0CC8C:  BRA    CC8A
0CC8E:  MOVWF  FAD
0CC90:  MOVLW  0A
0CC92:  BTFSS  F9E.4
0CC94:  BRA    CC92
0CC96:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CC98:  MOVLW  32
0CC9A:  MOVWF  FF6
0CC9C:  MOVLW  24
0CC9E:  MOVWF  FF7
0CCA0:  MOVLW  00
0CCA2:  MOVWF  FF8
0CCA4:  CLRF   1B
0CCA6:  BTFSC  FF2.7
0CCA8:  BSF    1B.7
0CCAA:  BCF    FF2.7
0CCAC:  MOVLW  04
0CCAE:  MOVLB  A
0CCB0:  MOVWF  x25
0CCB2:  MOVLB  0
0CCB4:  CALL   1010
0CCB8:  BTFSC  1B.7
0CCBA:  BSF    FF2.7
0CCBC:  MOVLW  89
0CCBE:  MOVWF  FE9
0CCC0:  MOVFF  404,872
0CCC4:  MOVFF  403,871
0CCC8:  MOVFF  402,870
0CCCC:  MOVFF  401,86F
0CCD0:  MOVLW  05
0CCD2:  MOVLB  8
0CCD4:  MOVWF  x73
0CCD6:  MOVLB  0
0CCD8:  CALL   C40C
0CCDC:  MOVLW  2C
0CCDE:  BTFSS  F9E.4
0CCE0:  BRA    CCDE
0CCE2:  MOVWF  FAD
0CCE4:  MOVLW  89
0CCE6:  MOVWF  FE9
0CCE8:  MOVFF  408,872
0CCEC:  MOVFF  407,871
0CCF0:  MOVFF  406,870
0CCF4:  MOVFF  405,86F
0CCF8:  MOVLW  05
0CCFA:  MOVLB  8
0CCFC:  MOVWF  x73
0CCFE:  MOVLB  0
0CD00:  CALL   C40C
0CD04:  MOVLW  0D
0CD06:  BTFSS  F9E.4
0CD08:  BRA    CD06
0CD0A:  MOVWF  FAD
0CD0C:  MOVLW  0A
0CD0E:  BTFSS  F9E.4
0CD10:  BRA    CD0E
0CD12:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CD14:  MOVLW  44
0CD16:  MOVWF  FF6
0CD18:  MOVLW  24
0CD1A:  MOVWF  FF7
0CD1C:  MOVLW  00
0CD1E:  MOVWF  FF8
0CD20:  CLRF   1B
0CD22:  BTFSC  FF2.7
0CD24:  BSF    1B.7
0CD26:  BCF    FF2.7
0CD28:  MOVLW  05
0CD2A:  MOVLB  A
0CD2C:  MOVWF  x25
0CD2E:  MOVLB  0
0CD30:  CALL   1010
0CD34:  BTFSC  1B.7
0CD36:  BSF    FF2.7
0CD38:  MOVLW  89
0CD3A:  MOVWF  FE9
0CD3C:  MOVFF  40C,872
0CD40:  MOVFF  40B,871
0CD44:  MOVFF  40A,870
0CD48:  MOVFF  409,86F
0CD4C:  MOVLW  05
0CD4E:  MOVLB  8
0CD50:  MOVWF  x73
0CD52:  MOVLB  0
0CD54:  CALL   C40C
0CD58:  MOVLW  2C
0CD5A:  BTFSS  F9E.4
0CD5C:  BRA    CD5A
0CD5E:  MOVWF  FAD
0CD60:  MOVLW  89
0CD62:  MOVWF  FE9
0CD64:  MOVFF  410,872
0CD68:  MOVFF  40F,871
0CD6C:  MOVFF  40E,870
0CD70:  MOVFF  40D,86F
0CD74:  MOVLW  05
0CD76:  MOVLB  8
0CD78:  MOVWF  x73
0CD7A:  MOVLB  0
0CD7C:  CALL   C40C
0CD80:  MOVLW  0D
0CD82:  BTFSS  F9E.4
0CD84:  BRA    CD82
0CD86:  MOVWF  FAD
0CD88:  MOVLW  0A
0CD8A:  BTFSS  F9E.4
0CD8C:  BRA    CD8A
0CD8E:  MOVWF  FAD
....................                   break; 
0CD90:  BRA    D076
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0CD92:  MOVLW  58
0CD94:  MOVWF  FF6
0CD96:  MOVLW  24
0CD98:  MOVWF  FF7
0CD9A:  MOVLW  00
0CD9C:  MOVWF  FF8
0CD9E:  CLRF   1B
0CDA0:  BTFSC  FF2.7
0CDA2:  BSF    1B.7
0CDA4:  BCF    FF2.7
0CDA6:  CALL   0E3A
0CDAA:  BTFSC  1B.7
0CDAC:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0CDAE:  RCALL  CA80
0CDB0:  MOVFF  03,3F4
0CDB4:  MOVFF  02,3F3
0CDB8:  MOVFF  01,3F2
0CDBC:  MOVFF  00,3F1
....................                fprintf(COM_A,"\r\n");   
0CDC0:  MOVLW  0D
0CDC2:  BTFSS  F9E.4
0CDC4:  BRA    CDC2
0CDC6:  MOVWF  FAD
0CDC8:  MOVLW  0A
0CDCA:  BTFSS  F9E.4
0CDCC:  BRA    CDCA
0CDCE:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0CDD0:  MOVLB  8
0CDD2:  CLRF   x70
0CDD4:  MOVLW  44
0CDD6:  MOVWF  x6F
0CDD8:  MOVFF  3F4,874
0CDDC:  MOVFF  3F3,873
0CDE0:  MOVFF  3F2,872
0CDE4:  MOVFF  3F1,871
0CDE8:  MOVLB  0
0CDEA:  RCALL  CAC6
....................          break; 
0CDEC:  BRA    D076
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0CDEE:  MOVLW  60
0CDF0:  MOVWF  FF6
0CDF2:  MOVLW  24
0CDF4:  MOVWF  FF7
0CDF6:  MOVLW  00
0CDF8:  MOVWF  FF8
0CDFA:  CLRF   1B
0CDFC:  BTFSC  FF2.7
0CDFE:  BSF    1B.7
0CE00:  BCF    FF2.7
0CE02:  CALL   0E3A
0CE06:  BTFSC  1B.7
0CE08:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0CE0A:  RCALL  CA80
0CE0C:  MOVFF  03,3F8
0CE10:  MOVFF  02,3F7
0CE14:  MOVFF  01,3F6
0CE18:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");  
0CE1C:  MOVLW  0D
0CE1E:  BTFSS  F9E.4
0CE20:  BRA    CE1E
0CE22:  MOVWF  FAD
0CE24:  MOVLW  0A
0CE26:  BTFSS  F9E.4
0CE28:  BRA    CE26
0CE2A:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0CE2C:  MOVLB  8
0CE2E:  CLRF   x70
0CE30:  MOVLW  48
0CE32:  MOVWF  x6F
0CE34:  MOVFF  3F8,874
0CE38:  MOVFF  3F7,873
0CE3C:  MOVFF  3F6,872
0CE40:  MOVFF  3F5,871
0CE44:  MOVLB  0
0CE46:  RCALL  CAC6
....................          break; 
0CE48:  BRA    D076
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0CE4A:  MOVLW  68
0CE4C:  MOVWF  FF6
0CE4E:  MOVLW  24
0CE50:  MOVWF  FF7
0CE52:  MOVLW  00
0CE54:  MOVWF  FF8
0CE56:  CLRF   1B
0CE58:  BTFSC  FF2.7
0CE5A:  BSF    1B.7
0CE5C:  BCF    FF2.7
0CE5E:  CALL   0E3A
0CE62:  BTFSC  1B.7
0CE64:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0CE66:  RCALL  CA80
0CE68:  MOVFF  03,3FC
0CE6C:  MOVFF  02,3FB
0CE70:  MOVFF  01,3FA
0CE74:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n"); 
0CE78:  MOVLW  0D
0CE7A:  BTFSS  F9E.4
0CE7C:  BRA    CE7A
0CE7E:  MOVWF  FAD
0CE80:  MOVLW  0A
0CE82:  BTFSS  F9E.4
0CE84:  BRA    CE82
0CE86:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0CE88:  MOVLB  8
0CE8A:  CLRF   x70
0CE8C:  MOVLW  4C
0CE8E:  MOVWF  x6F
0CE90:  MOVFF  3FC,874
0CE94:  MOVFF  3FB,873
0CE98:  MOVFF  3FA,872
0CE9C:  MOVFF  3F9,871
0CEA0:  MOVLB  0
0CEA2:  RCALL  CAC6
....................          break; 
0CEA4:  BRA    D076
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0CEA6:  MOVLW  70
0CEA8:  MOVWF  FF6
0CEAA:  MOVLW  24
0CEAC:  MOVWF  FF7
0CEAE:  MOVLW  00
0CEB0:  MOVWF  FF8
0CEB2:  CLRF   1B
0CEB4:  BTFSC  FF2.7
0CEB6:  BSF    1B.7
0CEB8:  BCF    FF2.7
0CEBA:  CALL   0E3A
0CEBE:  BTFSC  1B.7
0CEC0:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0CEC2:  RCALL  CA80
0CEC4:  MOVFF  03,400
0CEC8:  MOVFF  02,3FF
0CECC:  MOVFF  01,3FE
0CED0:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n");  
0CED4:  MOVLW  0D
0CED6:  BTFSS  F9E.4
0CED8:  BRA    CED6
0CEDA:  MOVWF  FAD
0CEDC:  MOVLW  0A
0CEDE:  BTFSS  F9E.4
0CEE0:  BRA    CEDE
0CEE2:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0CEE4:  MOVLB  8
0CEE6:  CLRF   x70
0CEE8:  MOVLW  52
0CEEA:  MOVWF  x6F
0CEEC:  MOVFF  3F8,874
0CEF0:  MOVFF  3F7,873
0CEF4:  MOVFF  3F6,872
0CEF8:  MOVFF  3F5,871
0CEFC:  MOVLB  0
0CEFE:  RCALL  CAC6
....................          break; 
0CF00:  BRA    D076
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0CF02:  MOVLW  78
0CF04:  MOVWF  FF6
0CF06:  MOVLW  24
0CF08:  MOVWF  FF7
0CF0A:  MOVLW  00
0CF0C:  MOVWF  FF8
0CF0E:  CLRF   1B
0CF10:  BTFSC  FF2.7
0CF12:  BSF    1B.7
0CF14:  BCF    FF2.7
0CF16:  CALL   0E3A
0CF1A:  BTFSC  1B.7
0CF1C:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0CF1E:  RCALL  CA80
0CF20:  MOVFF  03,404
0CF24:  MOVFF  02,403
0CF28:  MOVFF  01,402
0CF2C:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");   
0CF30:  MOVLW  0D
0CF32:  BTFSS  F9E.4
0CF34:  BRA    CF32
0CF36:  MOVWF  FAD
0CF38:  MOVLW  0A
0CF3A:  BTFSS  F9E.4
0CF3C:  BRA    CF3A
0CF3E:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0CF40:  MOVLB  8
0CF42:  CLRF   x70
0CF44:  MOVLW  56
0CF46:  MOVWF  x6F
0CF48:  MOVFF  404,874
0CF4C:  MOVFF  403,873
0CF50:  MOVFF  402,872
0CF54:  MOVFF  401,871
0CF58:  MOVLB  0
0CF5A:  RCALL  CAC6
....................          break; 
0CF5C:  BRA    D076
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0CF5E:  MOVLW  80
0CF60:  MOVWF  FF6
0CF62:  MOVLW  24
0CF64:  MOVWF  FF7
0CF66:  MOVLW  00
0CF68:  MOVWF  FF8
0CF6A:  CLRF   1B
0CF6C:  BTFSC  FF2.7
0CF6E:  BSF    1B.7
0CF70:  BCF    FF2.7
0CF72:  CALL   0E3A
0CF76:  BTFSC  1B.7
0CF78:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0CF7A:  RCALL  CA80
0CF7C:  MOVFF  03,408
0CF80:  MOVFF  02,407
0CF84:  MOVFF  01,406
0CF88:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");  
0CF8C:  MOVLW  0D
0CF8E:  BTFSS  F9E.4
0CF90:  BRA    CF8E
0CF92:  MOVWF  FAD
0CF94:  MOVLW  0A
0CF96:  BTFSS  F9E.4
0CF98:  BRA    CF96
0CF9A:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0CF9C:  MOVLB  8
0CF9E:  CLRF   x70
0CFA0:  MOVLW  5A
0CFA2:  MOVWF  x6F
0CFA4:  MOVFF  408,874
0CFA8:  MOVFF  407,873
0CFAC:  MOVFF  406,872
0CFB0:  MOVFF  405,871
0CFB4:  MOVLB  0
0CFB6:  RCALL  CAC6
....................          break; 
0CFB8:  BRA    D076
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0CFBA:  MOVLW  88
0CFBC:  MOVWF  FF6
0CFBE:  MOVLW  24
0CFC0:  MOVWF  FF7
0CFC2:  MOVLW  00
0CFC4:  MOVWF  FF8
0CFC6:  CLRF   1B
0CFC8:  BTFSC  FF2.7
0CFCA:  BSF    1B.7
0CFCC:  BCF    FF2.7
0CFCE:  CALL   0E3A
0CFD2:  BTFSC  1B.7
0CFD4:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0CFD6:  RCALL  CA80
0CFD8:  MOVFF  03,40C
0CFDC:  MOVFF  02,40B
0CFE0:  MOVFF  01,40A
0CFE4:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");   
0CFE8:  MOVLW  0D
0CFEA:  BTFSS  F9E.4
0CFEC:  BRA    CFEA
0CFEE:  MOVWF  FAD
0CFF0:  MOVLW  0A
0CFF2:  BTFSS  F9E.4
0CFF4:  BRA    CFF2
0CFF6:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0CFF8:  MOVLB  8
0CFFA:  CLRF   x70
0CFFC:  MOVLW  5E
0CFFE:  MOVWF  x6F
0D000:  MOVFF  40C,874
0D004:  MOVFF  40B,873
0D008:  MOVFF  40A,872
0D00C:  MOVFF  409,871
0D010:  MOVLB  0
0D012:  RCALL  CAC6
....................          break; 
0D014:  BRA    D076
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0D016:  MOVLW  92
0D018:  MOVWF  FF6
0D01A:  MOVLW  24
0D01C:  MOVWF  FF7
0D01E:  MOVLW  00
0D020:  MOVWF  FF8
0D022:  CLRF   1B
0D024:  BTFSC  FF2.7
0D026:  BSF    1B.7
0D028:  BCF    FF2.7
0D02A:  CALL   0E3A
0D02E:  BTFSC  1B.7
0D030:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0D032:  RCALL  CA80
0D034:  MOVFF  03,410
0D038:  MOVFF  02,40F
0D03C:  MOVFF  01,40E
0D040:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");  
0D044:  MOVLW  0D
0D046:  BTFSS  F9E.4
0D048:  BRA    D046
0D04A:  MOVWF  FAD
0D04C:  MOVLW  0A
0D04E:  BTFSS  F9E.4
0D050:  BRA    D04E
0D052:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0D054:  MOVLB  8
0D056:  CLRF   x70
0D058:  MOVLW  62
0D05A:  MOVWF  x6F
0D05C:  MOVFF  410,874
0D060:  MOVFF  40F,873
0D064:  MOVFF  40E,872
0D068:  MOVFF  40D,871
0D06C:  MOVLB  0
0D06E:  RCALL  CAC6
....................          break;         
0D070:  BRA    D076
....................       default: cmd_arg(); 
0D072:  CALL   B062
....................          break; 
....................    } 
0D076:  GOTO   DA6C (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0D786:  MOVF   47,F
0D788:  BNZ   D798
0D78A:  MOVF   46,F
0D78C:  BNZ   D798
0D78E:  MOVF   45,F
0D790:  BNZ   D798
0D792:  MOVF   44,W
0D794:  SUBLW  01
0D796:  BC    D7E8
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0D798:  MOVF   47,F
0D79A:  BNZ   D7B2
0D79C:  MOVF   46,F
0D79E:  BNZ   D7B2
0D7A0:  MOVF   45,F
0D7A2:  BNZ   D7B2
0D7A4:  MOVF   44,W
0D7A6:  SUBLW  30
0D7A8:  BNC   D7B2
0D7AA:  DECFSZ 2F,W
0D7AC:  BRA    D7B2
0D7AE:  MOVF   30,F
0D7B0:  BZ    D7CE
0D7B2:  MOVF   47,F
0D7B4:  BNZ   D7E2
0D7B6:  MOVF   46,F
0D7B8:  BNZ   D7E2
0D7BA:  MOVF   45,F
0D7BC:  BNZ   D7E2
0D7BE:  MOVF   44,W
0D7C0:  SUBLW  32
0D7C2:  BNC   D7E2
0D7C4:  MOVF   2F,W
0D7C6:  SUBLW  03
0D7C8:  BNZ   D7E2
0D7CA:  MOVF   30,F
0D7CC:  BNZ   D7E2
....................          port=arg; 
0D7CE:  MOVFF  45,870
0D7D2:  MOVFF  44,86F
....................          play_wms_hard_macro(port);    
0D7D6:  MOVFF  870,874
0D7DA:  MOVFF  86F,873
0D7DE:  RCALL  D578
....................       } 
0D7E0:  BRA    D7E6
....................       else cmd_arg(); 
0D7E2:  CALL   B062
....................    } 
0D7E6:  BRA    D7EC
....................    else cmd_arg(); 
0D7E8:  CALL   B062
0D7EC:  GOTO   DA6C (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0D9FC:  MOVF   44,F
0D9FE:  BNZ   DA0C
0DA00:  MOVF   45,F
0DA02:  BNZ   DA0C
0DA04:  MOVF   46,F
0DA06:  BNZ   DA0C
0DA08:  MOVF   47,F
0DA0A:  BZ    DA2A
0DA0C:  MOVF   47,F
0DA0E:  BNZ   DA2A
0DA10:  MOVF   46,F
0DA12:  BNZ   DA2A
0DA14:  MOVF   45,F
0DA16:  BNZ   DA2A
0DA18:  MOVF   44,W
0DA1A:  SUBLW  04
0DA1C:  BNC   DA2A
....................       chip=arg; 
0DA1E:  MOVFF  44,86F
....................       sol_chip_cmd(chip); 
0DA22:  MOVFF  86F,8A0
0DA26:  RCALL  D92E
....................    } 
0DA28:  BRA    DA2E
....................    else cmd_arg();    
0DA2A:  CALL   B062
0DA2E:  GOTO   DA6C (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0DA32:  MOVF   2F,W
0DA34:  MOVWF  00
0DA36:  MOVF   30,W
0DA38:  MOVWF  03
0DA3A:  BNZ   DA40
0DA3C:  MOVF   00,F
0DA3E:  BZ    DA60
0DA40:  MOVF   03,W
0DA42:  BNZ   DA4A
0DA44:  MOVLW  01
0DA46:  SUBWF  00,W
0DA48:  BZ    DA66
0DA4A:  MOVF   03,W
0DA4C:  BNZ   DA54
0DA4E:  MOVLW  03
0DA50:  SUBWF  00,W
0DA52:  BZ    DA66
0DA54:  MOVF   03,W
0DA56:  BNZ   DA5E
0DA58:  MOVLW  02
0DA5A:  SUBWF  00,W
0DA5C:  BZ    DA6A
0DA5E:  BRA    DA6C
....................       case ECO : commandCe(); 
0DA60:  GOTO   CB34
....................          break; 
0DA64:  BRA    DA6C
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0DA66:  BRA    D786
....................          break; 
0DA68:  BRA    DA6C
....................       case AWS : commandCa(); 
0DA6A:  BRA    D9FC
....................          break;          
....................    } 
0DA6C:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0DA70:  MOVF   44,W
0DA72:  MOVWF  00
0DA74:  MOVF   45,W
0DA76:  MOVWF  03
0DA78:  BNZ   DA7E
0DA7A:  MOVF   00,F
0DA7C:  BZ    DA9E
0DA7E:  MOVF   03,W
0DA80:  BNZ   DA88
0DA82:  MOVLW  01
0DA84:  SUBWF  00,W
0DA86:  BZ    DAB0
0DA88:  MOVF   03,W
0DA8A:  BNZ   DA92
0DA8C:  MOVLW  02
0DA8E:  SUBWF  00,W
0DA90:  BZ    DAD2
0DA92:  MOVF   03,W
0DA94:  BNZ   DA9C
0DA96:  MOVLW  03
0DA98:  SUBWF  00,W
0DA9A:  BZ    DAE4
0DA9C:  BRA    DB02
....................       case 0 : file_list(file_ptr_raw_all); 
0DA9E:  MOVLW  02
0DAA0:  MOVLB  8
0DAA2:  MOVWF  x74
0DAA4:  MOVLW  D9
0DAA6:  MOVWF  x73
0DAA8:  MOVLB  0
0DAAA:  CALL   B888
....................          break; 
0DAAE:  BRA    DB06
....................       case 1 : file_list(file_ptr_raw_new); 
0DAB0:  MOVLW  02
0DAB2:  MOVLB  8
0DAB4:  MOVWF  x74
0DAB6:  MOVLW  E7
0DAB8:  MOVWF  x73
0DABA:  MOVLB  0
0DABC:  CALL   B888
....................                f_unlink(file_ptr_raw_new); 
0DAC0:  MOVLW  02
0DAC2:  MOVLB  8
0DAC4:  MOVWF  x74
0DAC6:  MOVLW  E7
0DAC8:  MOVWF  x73
0DACA:  MOVLB  0
0DACC:  CALL   BA02
....................          break; 
0DAD0:  BRA    DB06
....................       case 2 : file_list(file_ptr_rel_all); 
0DAD2:  MOVLW  02
0DAD4:  MOVLB  8
0DAD6:  MOVWF  x74
0DAD8:  MOVLW  F5
0DADA:  MOVWF  x73
0DADC:  MOVLB  0
0DADE:  CALL   B888
....................          break; 
0DAE2:  BRA    DB06
....................       case 3 : file_list(file_ptr_rel_new); 
0DAE4:  MOVLW  03
0DAE6:  MOVLB  8
0DAE8:  MOVWF  x74
0DAEA:  MOVWF  x73
0DAEC:  MOVLB  0
0DAEE:  CALL   B888
....................                f_unlink(file_ptr_rel_new); 
0DAF2:  MOVLW  03
0DAF4:  MOVLB  8
0DAF6:  MOVWF  x74
0DAF8:  MOVWF  x73
0DAFA:  MOVLB  0
0DAFC:  CALL   BA02
....................          break;  
0DB00:  BRA    DB06
....................       default : cmd_arg(); 
0DB02:  CALL   B062
....................          break; 
....................    } 
0DB06:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DB0A:  MOVF   44,W
0DB0C:  MOVWF  00
0DB0E:  MOVF   45,W
0DB10:  MOVWF  03
0DB12:  BNZ   DB18
0DB14:  MOVF   00,F
0DB16:  BZ    DB24
0DB18:  MOVF   03,W
0DB1A:  BNZ   DB22
0DB1C:  MOVLW  02
0DB1E:  SUBWF  00,W
0DB20:  BZ    DB9E
0DB22:  BRA    DC18
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DB24:  MOVLW  9C
0DB26:  MOVWF  FF6
0DB28:  MOVLW  24
0DB2A:  MOVWF  FF7
0DB2C:  MOVLW  00
0DB2E:  MOVWF  FF8
0DB30:  CLRF   1B
0DB32:  BTFSC  FF2.7
0DB34:  BSF    1B.7
0DB36:  BCF    FF2.7
0DB38:  CALL   0E3A
0DB3C:  BTFSC  1B.7
0DB3E:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DB40:  CALL   0E24
0DB44:  MOVFF  01,86F
....................       if(result == 'Y'){ 
0DB48:  MOVLB  8
0DB4A:  MOVF   x6F,W
0DB4C:  SUBLW  59
0DB4E:  BNZ   DB7E
....................       f_unlink(file_ptr_raw_all); 
0DB50:  MOVLW  02
0DB52:  MOVWF  x74
0DB54:  MOVLW  D9
0DB56:  MOVWF  x73
0DB58:  MOVLB  0
0DB5A:  CALL   BA02
....................       printf("File deleted!\n\r"); 
0DB5E:  MOVLW  D8
0DB60:  MOVWF  FF6
0DB62:  MOVLW  24
0DB64:  MOVWF  FF7
0DB66:  MOVLW  00
0DB68:  MOVWF  FF8
0DB6A:  CLRF   1B
0DB6C:  BTFSC  FF2.7
0DB6E:  BSF    1B.7
0DB70:  BCF    FF2.7
0DB72:  CALL   0E3A
0DB76:  BTFSC  1B.7
0DB78:  BSF    FF2.7
....................       }else{ 
0DB7A:  BRA    DB9C
0DB7C:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DB7E:  MOVLW  E8
0DB80:  MOVWF  FF6
0DB82:  MOVLW  24
0DB84:  MOVWF  FF7
0DB86:  MOVLW  00
0DB88:  MOVWF  FF8
0DB8A:  CLRF   1B
0DB8C:  BTFSC  FF2.7
0DB8E:  BSF    1B.7
0DB90:  BCF    FF2.7
0DB92:  MOVLB  0
0DB94:  CALL   0E3A
0DB98:  BTFSC  1B.7
0DB9A:  BSF    FF2.7
....................       } 
....................          break; 
0DB9C:  BRA    DC1C
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DB9E:  MOVLW  FE
0DBA0:  MOVWF  FF6
0DBA2:  MOVLW  24
0DBA4:  MOVWF  FF7
0DBA6:  MOVLW  00
0DBA8:  MOVWF  FF8
0DBAA:  CLRF   1B
0DBAC:  BTFSC  FF2.7
0DBAE:  BSF    1B.7
0DBB0:  BCF    FF2.7
0DBB2:  CALL   0E3A
0DBB6:  BTFSC  1B.7
0DBB8:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DBBA:  CALL   0E24
0DBBE:  MOVFF  01,86F
....................          if(result == 'Y'){ 
0DBC2:  MOVLB  8
0DBC4:  MOVF   x6F,W
0DBC6:  SUBLW  59
0DBC8:  BNZ   DBF8
....................             f_unlink(file_ptr_rel_all); 
0DBCA:  MOVLW  02
0DBCC:  MOVWF  x74
0DBCE:  MOVLW  F5
0DBD0:  MOVWF  x73
0DBD2:  MOVLB  0
0DBD4:  CALL   BA02
....................             printf("File deleted!\n\r"); 
0DBD8:  MOVLW  42
0DBDA:  MOVWF  FF6
0DBDC:  MOVLW  25
0DBDE:  MOVWF  FF7
0DBE0:  MOVLW  00
0DBE2:  MOVWF  FF8
0DBE4:  CLRF   1B
0DBE6:  BTFSC  FF2.7
0DBE8:  BSF    1B.7
0DBEA:  BCF    FF2.7
0DBEC:  CALL   0E3A
0DBF0:  BTFSC  1B.7
0DBF2:  BSF    FF2.7
....................          }else{ 
0DBF4:  BRA    DC16
0DBF6:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DBF8:  MOVLW  52
0DBFA:  MOVWF  FF6
0DBFC:  MOVLW  25
0DBFE:  MOVWF  FF7
0DC00:  MOVLW  00
0DC02:  MOVWF  FF8
0DC04:  CLRF   1B
0DC06:  BTFSC  FF2.7
0DC08:  BSF    1B.7
0DC0A:  BCF    FF2.7
0DC0C:  MOVLB  0
0DC0E:  CALL   0E3A
0DC12:  BTFSC  1B.7
0DC14:  BSF    FF2.7
....................          } 
....................          break; 
0DC16:  BRA    DC1C
....................       default : cmd_arg(); 
0DC18:  CALL   B062
....................          break;          
....................    } 
0DC1C:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0DE08:  MOVF   44,W
0DE0A:  SUBLW  95
0DE0C:  BNZ   DE20
0DE0E:  MOVF   45,W
0DE10:  SUBLW  15
0DE12:  BNZ   DE20
0DE14:  MOVF   46,F
0DE16:  BNZ   DE20
0DE18:  MOVF   47,F
0DE1A:  BNZ   DE20
....................       reset_nv_vars(); 
0DE1C:  BRA    DC20
....................    } 
0DE1E:  BRA    DE24
....................    else cmd_arg(); 
0DE20:  CALL   B062
0DE24:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0DE72:  MOVF   2F,F
0DE74:  BNZ   DE7A
0DE76:  MOVF   30,F
0DE78:  BZ    DE8C
0DE7A:  DECFSZ 2F,W
0DE7C:  BRA    DE82
0DE7E:  MOVF   30,F
0DE80:  BZ    DE8C
0DE82:  MOVF   2F,W
0DE84:  SUBLW  03
0DE86:  BNZ   DEFE
0DE88:  MOVF   30,F
0DE8A:  BNZ   DEFE
....................    { 
....................       busy_set(); 
0DE8C:  CALL   2A14
....................  
....................       switch(arg) 
0DE90:  MOVFF  44,00
0DE94:  MOVF   45,W
0DE96:  MOVWF  03
0DE98:  BNZ   DEA0
0DE9A:  MOVLW  01
0DE9C:  SUBWF  00,W
0DE9E:  BZ    DEB6
0DEA0:  MOVF   03,W
0DEA2:  BNZ   DEAA
0DEA4:  MOVLW  02
0DEA6:  SUBWF  00,W
0DEA8:  BZ    DEC6
0DEAA:  MOVF   03,W
0DEAC:  BNZ   DEB4
0DEAE:  MOVLW  03
0DEB0:  SUBWF  00,W
0DEB2:  BZ    DEF0
0DEB4:  BRA    DEF6
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0DEB6:  MOVLB  7
0DEB8:  CLRF   x3C
....................             align(0); 
0DEBA:  MOVLB  8
0DEBC:  CLRF   xAC
0DEBE:  MOVLB  0
0DEC0:  CALL   A8E6
....................             break; 
0DEC4:  BRA    DEFA
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0DEC6:  MOVF   44,W
0DEC8:  SUBLW  02
0DECA:  BNZ   DEEE
0DECC:  MOVF   45,F
0DECE:  BNZ   DEEE
0DED0:  MOVF   46,F
0DED2:  BNZ   DEEE
0DED4:  MOVF   47,F
0DED6:  BNZ   DEEE
0DED8:  MOVF   1F,W
0DEDA:  SUBLW  04
0DEDC:  BNZ   DEEE
0DEDE:  MOVF   20,F
0DEE0:  BNZ   DEEE
....................             { 
....................                motor=0; 
0DEE2:  MOVLB  7
0DEE4:  CLRF   x3C
....................                cal_disk(0); 
0DEE6:  MOVLB  8
0DEE8:  CLRF   x6F
0DEEA:  MOVLB  0
0DEEC:  BRA    DE28
....................             } 
....................             break; 
0DEEE:  BRA    DEFA
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0DEF0:  CALL   AA8A
....................             break; 
0DEF4:  BRA    DEFA
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0DEF6:  CALL   B062
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0DEFA:  CALL   AE9E
....................    } 
0DEFE:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E3D8:  DECFSZ 44,W
0E3DA:  BRA    E7F8
0E3DC:  MOVF   45,F
0E3DE:  BTFSS  FD8.2
0E3E0:  BRA    E7F8
0E3E2:  MOVF   46,F
0E3E4:  BTFSS  FD8.2
0E3E6:  BRA    E7F8
0E3E8:  MOVF   47,F
0E3EA:  BTFSS  FD8.2
0E3EC:  BRA    E7F8
....................       v_supply = read_supply(); 
0E3EE:  CALL   5146
0E3F2:  MOVFF  02,870
0E3F6:  MOVFF  01,86F
....................        
....................       RTC_reset_HT(); 
0E3FA:  CALL   3506
....................       RTC_read(); 
0E3FE:  CALL   3398
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E402:  MOVLW  68
0E404:  MOVWF  FF6
0E406:  MOVLW  25
0E408:  MOVWF  FF7
0E40A:  MOVLW  00
0E40C:  MOVWF  FF8
0E40E:  CLRF   1B
0E410:  BTFSC  FF2.7
0E412:  BSF    1B.7
0E414:  BCF    FF2.7
0E416:  MOVLW  04
0E418:  MOVLB  A
0E41A:  MOVWF  x25
0E41C:  MOVLB  0
0E41E:  CALL   1010
0E422:  BTFSC  1B.7
0E424:  BSF    FF2.7
0E426:  MOVLW  10
0E428:  MOVWF  FE9
0E42A:  CLRF   1B
0E42C:  BTFSC  FF2.7
0E42E:  BSF    1B.7
0E430:  BCF    FF2.7
0E432:  MOVFF  26,A26
0E436:  MOVFF  25,A25
0E43A:  CALL   1192
0E43E:  BTFSC  1B.7
0E440:  BSF    FF2.7
0E442:  MOVLW  20
0E444:  BTFSS  F9E.4
0E446:  BRA    E444
0E448:  MOVWF  FAD
0E44A:  MOVLW  49
0E44C:  BTFSS  F9E.4
0E44E:  BRA    E44C
0E450:  MOVWF  FAD
0E452:  MOVLW  10
0E454:  MOVWF  FE9
0E456:  CLRF   1B
0E458:  BTFSC  FF2.7
0E45A:  BSF    1B.7
0E45C:  BCF    FF2.7
0E45E:  MOVFF  24,A26
0E462:  MOVFF  23,A25
0E466:  CALL   1192
0E46A:  BTFSC  1B.7
0E46C:  BSF    FF2.7
0E46E:  MOVLW  20
0E470:  BTFSS  F9E.4
0E472:  BRA    E470
0E474:  MOVWF  FAD
0E476:  MOVLW  4E
0E478:  BTFSS  F9E.4
0E47A:  BRA    E478
0E47C:  MOVWF  FAD
0E47E:  MOVLW  10
0E480:  MOVWF  FE9
0E482:  CLRF   1B
0E484:  BTFSC  FF2.7
0E486:  BSF    1B.7
0E488:  BCF    FF2.7
0E48A:  MOVFF  22,A26
0E48E:  MOVFF  21,A25
0E492:  CALL   1192
0E496:  BTFSC  1B.7
0E498:  BSF    FF2.7
0E49A:  MOVLW  2F
0E49C:  BTFSS  F9E.4
0E49E:  BRA    E49C
0E4A0:  MOVWF  FAD
0E4A2:  MOVLW  10
0E4A4:  MOVWF  FE9
0E4A6:  CLRF   1B
0E4A8:  BTFSC  FF2.7
0E4AA:  BSF    1B.7
0E4AC:  BCF    FF2.7
0E4AE:  MOVFF  28,A26
0E4B2:  MOVFF  27,A25
0E4B6:  CALL   1192
0E4BA:  BTFSC  1B.7
0E4BC:  BSF    FF2.7
0E4BE:  MOVLW  20
0E4C0:  BTFSS  F9E.4
0E4C2:  BRA    E4C0
0E4C4:  MOVWF  FAD
0E4C6:  MOVLW  58
0E4C8:  BTFSS  F9E.4
0E4CA:  BRA    E4C8
0E4CC:  MOVWF  FAD
0E4CE:  MOVLW  10
0E4D0:  MOVWF  FE9
0E4D2:  CLRF   1B
0E4D4:  BTFSC  FF2.7
0E4D6:  BSF    1B.7
0E4D8:  BCF    FF2.7
0E4DA:  MOVFF  20,A26
0E4DE:  MOVFF  1F,A25
0E4E2:  CALL   1192
0E4E6:  BTFSC  1B.7
0E4E8:  BSF    FF2.7
0E4EA:  MOVLW  20
0E4EC:  BTFSS  F9E.4
0E4EE:  BRA    E4EC
0E4F0:  MOVWF  FAD
0E4F2:  MOVLW  55
0E4F4:  BTFSS  F9E.4
0E4F6:  BRA    E4F4
0E4F8:  MOVWF  FAD
0E4FA:  CLRF   1B
0E4FC:  BTFSC  FF2.7
0E4FE:  BSF    1B.7
0E500:  BCF    FF2.7
0E502:  MOVFF  73C,A25
0E506:  MOVLW  1B
0E508:  MOVLB  A
0E50A:  MOVWF  x26
0E50C:  MOVLB  0
0E50E:  CALL   0F92
0E512:  BTFSC  1B.7
0E514:  BSF    FF2.7
0E516:  MOVLW  20
0E518:  BTFSS  F9E.4
0E51A:  BRA    E518
0E51C:  MOVWF  FAD
0E51E:  MOVLW  04
0E520:  MOVWF  FE9
0E522:  MOVLB  8
0E524:  CLRF   x74
0E526:  CLRF   x73
0E528:  MOVFF  870,872
0E52C:  MOVFF  86F,871
0E530:  MOVLW  02
0E532:  MOVWF  x75
0E534:  MOVLB  0
0E536:  RCALL  DF02
0E538:  MOVLW  8C
0E53A:  MOVWF  FF6
0E53C:  MOVLW  25
0E53E:  MOVWF  FF7
0E540:  MOVLW  00
0E542:  MOVWF  FF8
0E544:  CLRF   1B
0E546:  BTFSC  FF2.7
0E548:  BSF    1B.7
0E54A:  BCF    FF2.7
0E54C:  MOVLW  03
0E54E:  MOVLB  A
0E550:  MOVWF  x25
0E552:  MOVLB  0
0E554:  CALL   1010
0E558:  BTFSC  1B.7
0E55A:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E55C:  MOVLW  90
0E55E:  MOVWF  FF6
0E560:  MOVLW  25
0E562:  MOVWF  FF7
0E564:  MOVLW  00
0E566:  MOVWF  FF8
0E568:  CLRF   1B
0E56A:  BTFSC  FF2.7
0E56C:  BSF    1B.7
0E56E:  BCF    FF2.7
0E570:  MOVLW  09
0E572:  MOVLB  A
0E574:  MOVWF  x25
0E576:  MOVLB  0
0E578:  CALL   1010
0E57C:  BTFSC  1B.7
0E57E:  BSF    FF2.7
0E580:  MOVLW  10
0E582:  MOVWF  FE9
0E584:  CLRF   1B
0E586:  BTFSC  FF2.7
0E588:  BSF    1B.7
0E58A:  BCF    FF2.7
0E58C:  MOVFF  7C0,A26
0E590:  MOVFF  7BF,A25
0E594:  CALL   1192
0E598:  BTFSC  1B.7
0E59A:  BSF    FF2.7
0E59C:  MOVLW  9C
0E59E:  MOVWF  FF6
0E5A0:  MOVLW  25
0E5A2:  MOVWF  FF7
0E5A4:  MOVLW  00
0E5A6:  MOVWF  FF8
0E5A8:  CLRF   1B
0E5AA:  BTFSC  FF2.7
0E5AC:  BSF    1B.7
0E5AE:  BCF    FF2.7
0E5B0:  MOVLW  05
0E5B2:  MOVLB  A
0E5B4:  MOVWF  x25
0E5B6:  MOVLB  0
0E5B8:  CALL   1010
0E5BC:  BTFSC  1B.7
0E5BE:  BSF    FF2.7
0E5C0:  MOVLW  10
0E5C2:  MOVWF  FE9
0E5C4:  MOVFF  7B2,8DB
0E5C8:  MOVFF  7B1,8DA
0E5CC:  CALL   9016
0E5D0:  MOVLW  0D
0E5D2:  BTFSS  F9E.4
0E5D4:  BRA    E5D2
0E5D6:  MOVWF  FAD
0E5D8:  MOVLW  0A
0E5DA:  BTFSS  F9E.4
0E5DC:  BRA    E5DA
0E5DE:  MOVWF  FAD
....................       RTC_display(); 
0E5E0:  RCALL  DFFE
....................       if (RTCfmt == 0) 
0E5E2:  MOVF   4B,F
0E5E4:  BTFSS  FD8.2
0E5E6:  BRA    E6EC
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E5E8:  MOVLW  A8
0E5EA:  MOVWF  FF6
0E5EC:  MOVLW  25
0E5EE:  MOVWF  FF7
0E5F0:  MOVLW  00
0E5F2:  MOVWF  FF8
0E5F4:  CLRF   1B
0E5F6:  BTFSC  FF2.7
0E5F8:  BSF    1B.7
0E5FA:  BCF    FF2.7
0E5FC:  MOVLW  05
0E5FE:  MOVLB  A
0E600:  MOVWF  x25
0E602:  MOVLB  0
0E604:  CALL   1010
0E608:  BTFSC  1B.7
0E60A:  BSF    FF2.7
0E60C:  CLRF   1B
0E60E:  BTFSC  FF2.7
0E610:  BSF    1B.7
0E612:  BCF    FF2.7
0E614:  MOVFF  736,A25
0E618:  MOVLW  01
0E61A:  MOVLB  A
0E61C:  MOVWF  x26
0E61E:  MOVLB  0
0E620:  CALL   0F92
0E624:  BTFSC  1B.7
0E626:  BSF    FF2.7
0E628:  MOVLW  2F
0E62A:  BTFSS  F9E.4
0E62C:  BRA    E62A
0E62E:  MOVWF  FAD
0E630:  CLRF   1B
0E632:  BTFSC  FF2.7
0E634:  BSF    1B.7
0E636:  BCF    FF2.7
0E638:  MOVFF  737,A25
0E63C:  MOVLW  01
0E63E:  MOVLB  A
0E640:  MOVWF  x26
0E642:  MOVLB  0
0E644:  CALL   0F92
0E648:  BTFSC  1B.7
0E64A:  BSF    FF2.7
0E64C:  MOVLW  2F
0E64E:  BTFSS  F9E.4
0E650:  BRA    E64E
0E652:  MOVWF  FAD
0E654:  CLRF   1B
0E656:  BTFSC  FF2.7
0E658:  BSF    1B.7
0E65A:  BCF    FF2.7
0E65C:  MOVFF  738,A25
0E660:  MOVLW  01
0E662:  MOVLB  A
0E664:  MOVWF  x26
0E666:  MOVLB  0
0E668:  CALL   0F92
0E66C:  BTFSC  1B.7
0E66E:  BSF    FF2.7
0E670:  MOVLW  20
0E672:  BTFSS  F9E.4
0E674:  BRA    E672
0E676:  MOVWF  FAD
0E678:  CLRF   1B
0E67A:  BTFSC  FF2.7
0E67C:  BSF    1B.7
0E67E:  BCF    FF2.7
0E680:  MOVFF  739,A25
0E684:  MOVLW  01
0E686:  MOVLB  A
0E688:  MOVWF  x26
0E68A:  MOVLB  0
0E68C:  CALL   0F92
0E690:  BTFSC  1B.7
0E692:  BSF    FF2.7
0E694:  MOVLW  3A
0E696:  BTFSS  F9E.4
0E698:  BRA    E696
0E69A:  MOVWF  FAD
0E69C:  CLRF   1B
0E69E:  BTFSC  FF2.7
0E6A0:  BSF    1B.7
0E6A2:  BCF    FF2.7
0E6A4:  MOVFF  73A,A25
0E6A8:  MOVLW  01
0E6AA:  MOVLB  A
0E6AC:  MOVWF  x26
0E6AE:  MOVLB  0
0E6B0:  CALL   0F92
0E6B4:  BTFSC  1B.7
0E6B6:  BSF    FF2.7
0E6B8:  MOVLW  3A
0E6BA:  BTFSS  F9E.4
0E6BC:  BRA    E6BA
0E6BE:  MOVWF  FAD
0E6C0:  CLRF   1B
0E6C2:  BTFSC  FF2.7
0E6C4:  BSF    1B.7
0E6C6:  BCF    FF2.7
0E6C8:  MOVFF  73B,A25
0E6CC:  MOVLW  01
0E6CE:  MOVLB  A
0E6D0:  MOVWF  x26
0E6D2:  MOVLB  0
0E6D4:  CALL   0F92
0E6D8:  BTFSC  1B.7
0E6DA:  BSF    FF2.7
0E6DC:  MOVLW  0D
0E6DE:  BTFSS  F9E.4
0E6E0:  BRA    E6DE
0E6E2:  MOVWF  FAD
0E6E4:  MOVLW  0A
0E6E6:  BTFSS  F9E.4
0E6E8:  BRA    E6E6
0E6EA:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E6EC:  DECFSZ 4B,W
0E6EE:  BRA    E7F4
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E6F0:  MOVLW  CE
0E6F2:  MOVWF  FF6
0E6F4:  MOVLW  25
0E6F6:  MOVWF  FF7
0E6F8:  MOVLW  00
0E6FA:  MOVWF  FF8
0E6FC:  CLRF   1B
0E6FE:  BTFSC  FF2.7
0E700:  BSF    1B.7
0E702:  BCF    FF2.7
0E704:  MOVLW  05
0E706:  MOVLB  A
0E708:  MOVWF  x25
0E70A:  MOVLB  0
0E70C:  CALL   1010
0E710:  BTFSC  1B.7
0E712:  BSF    FF2.7
0E714:  CLRF   1B
0E716:  BTFSC  FF2.7
0E718:  BSF    1B.7
0E71A:  BCF    FF2.7
0E71C:  MOVFF  737,A25
0E720:  MOVLW  01
0E722:  MOVLB  A
0E724:  MOVWF  x26
0E726:  MOVLB  0
0E728:  CALL   0F92
0E72C:  BTFSC  1B.7
0E72E:  BSF    FF2.7
0E730:  MOVLW  2F
0E732:  BTFSS  F9E.4
0E734:  BRA    E732
0E736:  MOVWF  FAD
0E738:  CLRF   1B
0E73A:  BTFSC  FF2.7
0E73C:  BSF    1B.7
0E73E:  BCF    FF2.7
0E740:  MOVFF  736,A25
0E744:  MOVLW  01
0E746:  MOVLB  A
0E748:  MOVWF  x26
0E74A:  MOVLB  0
0E74C:  CALL   0F92
0E750:  BTFSC  1B.7
0E752:  BSF    FF2.7
0E754:  MOVLW  2F
0E756:  BTFSS  F9E.4
0E758:  BRA    E756
0E75A:  MOVWF  FAD
0E75C:  CLRF   1B
0E75E:  BTFSC  FF2.7
0E760:  BSF    1B.7
0E762:  BCF    FF2.7
0E764:  MOVFF  738,A25
0E768:  MOVLW  01
0E76A:  MOVLB  A
0E76C:  MOVWF  x26
0E76E:  MOVLB  0
0E770:  CALL   0F92
0E774:  BTFSC  1B.7
0E776:  BSF    FF2.7
0E778:  MOVLW  20
0E77A:  BTFSS  F9E.4
0E77C:  BRA    E77A
0E77E:  MOVWF  FAD
0E780:  CLRF   1B
0E782:  BTFSC  FF2.7
0E784:  BSF    1B.7
0E786:  BCF    FF2.7
0E788:  MOVFF  739,A25
0E78C:  MOVLW  01
0E78E:  MOVLB  A
0E790:  MOVWF  x26
0E792:  MOVLB  0
0E794:  CALL   0F92
0E798:  BTFSC  1B.7
0E79A:  BSF    FF2.7
0E79C:  MOVLW  3A
0E79E:  BTFSS  F9E.4
0E7A0:  BRA    E79E
0E7A2:  MOVWF  FAD
0E7A4:  CLRF   1B
0E7A6:  BTFSC  FF2.7
0E7A8:  BSF    1B.7
0E7AA:  BCF    FF2.7
0E7AC:  MOVFF  73A,A25
0E7B0:  MOVLW  01
0E7B2:  MOVLB  A
0E7B4:  MOVWF  x26
0E7B6:  MOVLB  0
0E7B8:  CALL   0F92
0E7BC:  BTFSC  1B.7
0E7BE:  BSF    FF2.7
0E7C0:  MOVLW  3A
0E7C2:  BTFSS  F9E.4
0E7C4:  BRA    E7C2
0E7C6:  MOVWF  FAD
0E7C8:  CLRF   1B
0E7CA:  BTFSC  FF2.7
0E7CC:  BSF    1B.7
0E7CE:  BCF    FF2.7
0E7D0:  MOVFF  73B,A25
0E7D4:  MOVLW  01
0E7D6:  MOVLB  A
0E7D8:  MOVWF  x26
0E7DA:  MOVLB  0
0E7DC:  CALL   0F92
0E7E0:  BTFSC  1B.7
0E7E2:  BSF    FF2.7
0E7E4:  MOVLW  0D
0E7E6:  BTFSS  F9E.4
0E7E8:  BRA    E7E6
0E7EA:  MOVWF  FAD
0E7EC:  MOVLW  0A
0E7EE:  BTFSS  F9E.4
0E7F0:  BRA    E7EE
0E7F2:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0E7F4:  RCALL  E188
....................       RTC_display_alarm(); 
0E7F6:  RCALL  E25E
....................    } 
0E7F8:  GOTO   F00C (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0E7FC:  DECFSZ 44,W
0E7FE:  BRA    EAD6
0E800:  MOVF   45,F
0E802:  BTFSS  FD8.2
0E804:  BRA    EAD6
0E806:  MOVF   46,F
0E808:  BTFSS  FD8.2
0E80A:  BRA    EAD6
0E80C:  MOVF   47,F
0E80E:  BTFSS  FD8.2
0E810:  BRA    EAD6
....................       v_supply = read_supply(); 
0E812:  CALL   5146
0E816:  MOVFF  02,870
0E81A:  MOVFF  01,86F
....................        
....................       RTC_reset_HT(); 
0E81E:  CALL   3506
....................       RTC_read(); 
0E822:  CALL   3398
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0E826:  MOVLW  41
0E828:  BTFSS  F9E.4
0E82A:  BRA    E828
0E82C:  MOVWF  FAD
0E82E:  MOVLW  10
0E830:  MOVWF  FE9
0E832:  CLRF   1B
0E834:  BTFSC  FF2.7
0E836:  BSF    1B.7
0E838:  BCF    FF2.7
0E83A:  MOVFF  2A,A26
0E83E:  MOVFF  29,A25
0E842:  CALL   1192
0E846:  BTFSC  1B.7
0E848:  BSF    FF2.7
0E84A:  MOVLW  20
0E84C:  BTFSS  F9E.4
0E84E:  BRA    E84C
0E850:  MOVWF  FAD
0E852:  MOVLW  49
0E854:  BTFSS  F9E.4
0E856:  BRA    E854
0E858:  MOVWF  FAD
0E85A:  MOVLW  10
0E85C:  MOVWF  FE9
0E85E:  CLRF   1B
0E860:  BTFSC  FF2.7
0E862:  BSF    1B.7
0E864:  BCF    FF2.7
0E866:  MOVFF  24,A26
0E86A:  MOVFF  23,A25
0E86E:  CALL   1192
0E872:  BTFSC  1B.7
0E874:  BSF    FF2.7
0E876:  MOVLW  20
0E878:  BTFSS  F9E.4
0E87A:  BRA    E878
0E87C:  MOVWF  FAD
0E87E:  MOVLW  4C
0E880:  BTFSS  F9E.4
0E882:  BRA    E880
0E884:  MOVWF  FAD
0E886:  MOVLW  10
0E888:  MOVWF  FE9
0E88A:  CLRF   1B
0E88C:  BTFSC  FF2.7
0E88E:  BSF    1B.7
0E890:  BCF    FF2.7
0E892:  MOVFF  2C,A26
0E896:  MOVFF  2B,A25
0E89A:  CALL   1192
0E89E:  BTFSC  1B.7
0E8A0:  BSF    FF2.7
0E8A2:  MOVLW  20
0E8A4:  BTFSS  F9E.4
0E8A6:  BRA    E8A4
0E8A8:  MOVWF  FAD
0E8AA:  MOVLW  51
0E8AC:  BTFSS  F9E.4
0E8AE:  BRA    E8AC
0E8B0:  MOVWF  FAD
0E8B2:  MOVLW  10
0E8B4:  MOVWF  FE9
0E8B6:  CLRF   1B
0E8B8:  BTFSC  FF2.7
0E8BA:  BSF    1B.7
0E8BC:  BCF    FF2.7
0E8BE:  MOVFF  2E,A26
0E8C2:  MOVFF  2D,A25
0E8C6:  CALL   1192
0E8CA:  BTFSC  1B.7
0E8CC:  BSF    FF2.7
0E8CE:  MOVLW  20
0E8D0:  BTFSS  F9E.4
0E8D2:  BRA    E8D0
0E8D4:  MOVWF  FAD
0E8D6:  MOVLW  53
0E8D8:  BTFSS  F9E.4
0E8DA:  BRA    E8D8
0E8DC:  MOVWF  FAD
0E8DE:  MOVLW  10
0E8E0:  MOVWF  FE9
0E8E2:  CLRF   1B
0E8E4:  BTFSC  FF2.7
0E8E6:  BSF    1B.7
0E8E8:  BCF    FF2.7
0E8EA:  MOVFF  22,A26
0E8EE:  MOVFF  21,A25
0E8F2:  CALL   1192
0E8F6:  BTFSC  1B.7
0E8F8:  BSF    FF2.7
0E8FA:  MOVLW  20
0E8FC:  BTFSS  F9E.4
0E8FE:  BRA    E8FC
0E900:  MOVWF  FAD
0E902:  MOVLW  04
0E904:  MOVWF  FE9
0E906:  MOVLB  8
0E908:  CLRF   x74
0E90A:  CLRF   x73
0E90C:  MOVFF  870,872
0E910:  MOVFF  86F,871
0E914:  MOVLW  02
0E916:  MOVWF  x75
0E918:  MOVLB  0
0E91A:  CALL   DF02
0E91E:  MOVLW  12
0E920:  MOVWF  FF6
0E922:  MOVLW  26
0E924:  MOVWF  FF7
0E926:  MOVLW  00
0E928:  MOVWF  FF8
0E92A:  CLRF   1B
0E92C:  BTFSC  FF2.7
0E92E:  BSF    1B.7
0E930:  BCF    FF2.7
0E932:  MOVLW  03
0E934:  MOVLB  A
0E936:  MOVWF  x25
0E938:  MOVLB  0
0E93A:  CALL   1010
0E93E:  BTFSC  1B.7
0E940:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E942:  MOVLW  16
0E944:  MOVWF  FF6
0E946:  MOVLW  26
0E948:  MOVWF  FF7
0E94A:  MOVLW  00
0E94C:  MOVWF  FF8
0E94E:  CLRF   1B
0E950:  BTFSC  FF2.7
0E952:  BSF    1B.7
0E954:  BCF    FF2.7
0E956:  MOVLW  09
0E958:  MOVLB  A
0E95A:  MOVWF  x25
0E95C:  MOVLB  0
0E95E:  CALL   1010
0E962:  BTFSC  1B.7
0E964:  BSF    FF2.7
0E966:  MOVLW  10
0E968:  MOVWF  FE9
0E96A:  CLRF   1B
0E96C:  BTFSC  FF2.7
0E96E:  BSF    1B.7
0E970:  BCF    FF2.7
0E972:  MOVFF  7C0,A26
0E976:  MOVFF  7BF,A25
0E97A:  CALL   1192
0E97E:  BTFSC  1B.7
0E980:  BSF    FF2.7
0E982:  MOVLW  22
0E984:  MOVWF  FF6
0E986:  MOVLW  26
0E988:  MOVWF  FF7
0E98A:  MOVLW  00
0E98C:  MOVWF  FF8
0E98E:  CLRF   1B
0E990:  BTFSC  FF2.7
0E992:  BSF    1B.7
0E994:  BCF    FF2.7
0E996:  MOVLW  05
0E998:  MOVLB  A
0E99A:  MOVWF  x25
0E99C:  MOVLB  0
0E99E:  CALL   1010
0E9A2:  BTFSC  1B.7
0E9A4:  BSF    FF2.7
0E9A6:  MOVLW  10
0E9A8:  MOVWF  FE9
0E9AA:  MOVFF  7B2,8DB
0E9AE:  MOVFF  7B1,8DA
0E9B2:  CALL   9016
0E9B6:  MOVLW  0D
0E9B8:  BTFSS  F9E.4
0E9BA:  BRA    E9B8
0E9BC:  MOVWF  FAD
0E9BE:  MOVLW  0A
0E9C0:  BTFSS  F9E.4
0E9C2:  BRA    E9C0
0E9C4:  MOVWF  FAD
....................       RTC_display(); 
0E9C6:  CALL   DFFE
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E9CA:  MOVLW  2E
0E9CC:  MOVWF  FF6
0E9CE:  MOVLW  26
0E9D0:  MOVWF  FF7
0E9D2:  MOVLW  00
0E9D4:  MOVWF  FF8
0E9D6:  CLRF   1B
0E9D8:  BTFSC  FF2.7
0E9DA:  BSF    1B.7
0E9DC:  BCF    FF2.7
0E9DE:  MOVLW  05
0E9E0:  MOVLB  A
0E9E2:  MOVWF  x25
0E9E4:  MOVLB  0
0E9E6:  CALL   1010
0E9EA:  BTFSC  1B.7
0E9EC:  BSF    FF2.7
0E9EE:  CLRF   1B
0E9F0:  BTFSC  FF2.7
0E9F2:  BSF    1B.7
0E9F4:  BCF    FF2.7
0E9F6:  MOVFF  736,A25
0E9FA:  MOVLW  01
0E9FC:  MOVLB  A
0E9FE:  MOVWF  x26
0EA00:  MOVLB  0
0EA02:  CALL   0F92
0EA06:  BTFSC  1B.7
0EA08:  BSF    FF2.7
0EA0A:  MOVLW  2F
0EA0C:  BTFSS  F9E.4
0EA0E:  BRA    EA0C
0EA10:  MOVWF  FAD
0EA12:  CLRF   1B
0EA14:  BTFSC  FF2.7
0EA16:  BSF    1B.7
0EA18:  BCF    FF2.7
0EA1A:  MOVFF  737,A25
0EA1E:  MOVLW  01
0EA20:  MOVLB  A
0EA22:  MOVWF  x26
0EA24:  MOVLB  0
0EA26:  CALL   0F92
0EA2A:  BTFSC  1B.7
0EA2C:  BSF    FF2.7
0EA2E:  MOVLW  2F
0EA30:  BTFSS  F9E.4
0EA32:  BRA    EA30
0EA34:  MOVWF  FAD
0EA36:  CLRF   1B
0EA38:  BTFSC  FF2.7
0EA3A:  BSF    1B.7
0EA3C:  BCF    FF2.7
0EA3E:  MOVFF  738,A25
0EA42:  MOVLW  01
0EA44:  MOVLB  A
0EA46:  MOVWF  x26
0EA48:  MOVLB  0
0EA4A:  CALL   0F92
0EA4E:  BTFSC  1B.7
0EA50:  BSF    FF2.7
0EA52:  MOVLW  20
0EA54:  BTFSS  F9E.4
0EA56:  BRA    EA54
0EA58:  MOVWF  FAD
0EA5A:  CLRF   1B
0EA5C:  BTFSC  FF2.7
0EA5E:  BSF    1B.7
0EA60:  BCF    FF2.7
0EA62:  MOVFF  739,A25
0EA66:  MOVLW  01
0EA68:  MOVLB  A
0EA6A:  MOVWF  x26
0EA6C:  MOVLB  0
0EA6E:  CALL   0F92
0EA72:  BTFSC  1B.7
0EA74:  BSF    FF2.7
0EA76:  MOVLW  3A
0EA78:  BTFSS  F9E.4
0EA7A:  BRA    EA78
0EA7C:  MOVWF  FAD
0EA7E:  CLRF   1B
0EA80:  BTFSC  FF2.7
0EA82:  BSF    1B.7
0EA84:  BCF    FF2.7
0EA86:  MOVFF  73A,A25
0EA8A:  MOVLW  01
0EA8C:  MOVLB  A
0EA8E:  MOVWF  x26
0EA90:  MOVLB  0
0EA92:  CALL   0F92
0EA96:  BTFSC  1B.7
0EA98:  BSF    FF2.7
0EA9A:  MOVLW  3A
0EA9C:  BTFSS  F9E.4
0EA9E:  BRA    EA9C
0EAA0:  MOVWF  FAD
0EAA2:  CLRF   1B
0EAA4:  BTFSC  FF2.7
0EAA6:  BSF    1B.7
0EAA8:  BCF    FF2.7
0EAAA:  MOVFF  73B,A25
0EAAE:  MOVLW  01
0EAB0:  MOVLB  A
0EAB2:  MOVWF  x26
0EAB4:  MOVLB  0
0EAB6:  CALL   0F92
0EABA:  BTFSC  1B.7
0EABC:  BSF    FF2.7
0EABE:  MOVLW  0D
0EAC0:  BTFSS  F9E.4
0EAC2:  BRA    EAC0
0EAC4:  MOVWF  FAD
0EAC6:  MOVLW  0A
0EAC8:  BTFSS  F9E.4
0EACA:  BRA    EAC8
0EACC:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EACE:  CALL   E188
....................       RTC_display_alarm(); 
0EAD2:  CALL   E25E
....................    } 
0EAD6:  GOTO   F00C (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0ED64:  DECFSZ 44,W
0ED66:  BRA    EFCC
0ED68:  MOVF   45,F
0ED6A:  BTFSS  FD8.2
0ED6C:  BRA    EFCC
0ED6E:  MOVF   46,F
0ED70:  BTFSS  FD8.2
0ED72:  BRA    EFCC
0ED74:  MOVF   47,F
0ED76:  BTFSS  FD8.2
0ED78:  BRA    EFCC
....................       v_supply = read_supply(); 
0ED7A:  CALL   5146
0ED7E:  MOVFF  02,870
0ED82:  MOVFF  01,86F
....................        
....................       RTC_reset_HT(); 
0ED86:  CALL   3506
....................       RTC_read(); 
0ED8A:  CALL   3398
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0ED8E:  MOVLW  49
0ED90:  BTFSS  F9E.4
0ED92:  BRA    ED90
0ED94:  MOVWF  FAD
0ED96:  MOVLW  10
0ED98:  MOVWF  FE9
0ED9A:  CLRF   1B
0ED9C:  BTFSC  FF2.7
0ED9E:  BSF    1B.7
0EDA0:  BCF    FF2.7
0EDA2:  MOVFF  24,A26
0EDA6:  MOVFF  23,A25
0EDAA:  CALL   1192
0EDAE:  BTFSC  1B.7
0EDB0:  BSF    FF2.7
0EDB2:  MOVLW  20
0EDB4:  BTFSS  F9E.4
0EDB6:  BRA    EDB4
0EDB8:  MOVWF  FAD
0EDBA:  MOVLW  4E
0EDBC:  BTFSS  F9E.4
0EDBE:  BRA    EDBC
0EDC0:  MOVWF  FAD
0EDC2:  MOVLW  10
0EDC4:  MOVWF  FE9
0EDC6:  CLRF   1B
0EDC8:  BTFSC  FF2.7
0EDCA:  BSF    1B.7
0EDCC:  BCF    FF2.7
0EDCE:  MOVFF  22,A26
0EDD2:  MOVFF  21,A25
0EDD6:  CALL   1192
0EDDA:  BTFSC  1B.7
0EDDC:  BSF    FF2.7
0EDDE:  MOVLW  2F
0EDE0:  BTFSS  F9E.4
0EDE2:  BRA    EDE0
0EDE4:  MOVWF  FAD
0EDE6:  MOVLW  10
0EDE8:  MOVWF  FE9
0EDEA:  CLRF   1B
0EDEC:  BTFSC  FF2.7
0EDEE:  BSF    1B.7
0EDF0:  BCF    FF2.7
0EDF2:  MOVFF  28,A26
0EDF6:  MOVFF  27,A25
0EDFA:  CALL   1192
0EDFE:  BTFSC  1B.7
0EE00:  BSF    FF2.7
0EE02:  MOVLW  20
0EE04:  BTFSS  F9E.4
0EE06:  BRA    EE04
0EE08:  MOVWF  FAD
0EE0A:  MOVLW  50
0EE0C:  BTFSS  F9E.4
0EE0E:  BRA    EE0C
0EE10:  MOVWF  FAD
0EE12:  MOVLW  10
0EE14:  MOVWF  FE9
0EE16:  CLRF   1B
0EE18:  BTFSC  FF2.7
0EE1A:  BSF    1B.7
0EE1C:  BCF    FF2.7
0EE1E:  MOVFF  2E,A26
0EE22:  MOVFF  2D,A25
0EE26:  CALL   1192
0EE2A:  BTFSC  1B.7
0EE2C:  BSF    FF2.7
0EE2E:  MOVLW  20
0EE30:  BTFSS  F9E.4
0EE32:  BRA    EE30
0EE34:  MOVWF  FAD
0EE36:  MOVLW  04
0EE38:  MOVWF  FE9
0EE3A:  MOVLB  8
0EE3C:  CLRF   x74
0EE3E:  CLRF   x73
0EE40:  MOVFF  870,872
0EE44:  MOVFF  86F,871
0EE48:  MOVLW  02
0EE4A:  MOVWF  x75
0EE4C:  MOVLB  0
0EE4E:  CALL   DF02
0EE52:  MOVLW  6C
0EE54:  MOVWF  FF6
0EE56:  MOVLW  26
0EE58:  MOVWF  FF7
0EE5A:  MOVLW  00
0EE5C:  MOVWF  FF8
0EE5E:  CLRF   1B
0EE60:  BTFSC  FF2.7
0EE62:  BSF    1B.7
0EE64:  BCF    FF2.7
0EE66:  MOVLW  03
0EE68:  MOVLB  A
0EE6A:  MOVWF  x25
0EE6C:  MOVLB  0
0EE6E:  CALL   1010
0EE72:  BTFSC  1B.7
0EE74:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0EE76:  MOVLW  70
0EE78:  MOVWF  FF6
0EE7A:  MOVLW  26
0EE7C:  MOVWF  FF7
0EE7E:  MOVLW  00
0EE80:  MOVWF  FF8
0EE82:  CLRF   1B
0EE84:  BTFSC  FF2.7
0EE86:  BSF    1B.7
0EE88:  BCF    FF2.7
0EE8A:  MOVLW  09
0EE8C:  MOVLB  A
0EE8E:  MOVWF  x25
0EE90:  MOVLB  0
0EE92:  CALL   1010
0EE96:  BTFSC  1B.7
0EE98:  BSF    FF2.7
0EE9A:  MOVLW  10
0EE9C:  MOVWF  FE9
0EE9E:  MOVFF  7B2,8DB
0EEA2:  MOVFF  7B1,8DA
0EEA6:  CALL   9016
0EEAA:  MOVLW  0D
0EEAC:  BTFSS  F9E.4
0EEAE:  BRA    EEAC
0EEB0:  MOVWF  FAD
0EEB2:  MOVLW  0A
0EEB4:  BTFSS  F9E.4
0EEB6:  BRA    EEB4
0EEB8:  MOVWF  FAD
....................       display_valve_status(); 
0EEBA:  RCALL  EADA
....................       RTC_display(); 
0EEBC:  CALL   DFFE
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EEC0:  MOVLW  80
0EEC2:  MOVWF  FF6
0EEC4:  MOVLW  26
0EEC6:  MOVWF  FF7
0EEC8:  MOVLW  00
0EECA:  MOVWF  FF8
0EECC:  CLRF   1B
0EECE:  BTFSC  FF2.7
0EED0:  BSF    1B.7
0EED2:  BCF    FF2.7
0EED4:  MOVLW  05
0EED6:  MOVLB  A
0EED8:  MOVWF  x25
0EEDA:  MOVLB  0
0EEDC:  CALL   1010
0EEE0:  BTFSC  1B.7
0EEE2:  BSF    FF2.7
0EEE4:  CLRF   1B
0EEE6:  BTFSC  FF2.7
0EEE8:  BSF    1B.7
0EEEA:  BCF    FF2.7
0EEEC:  MOVFF  736,A25
0EEF0:  MOVLW  01
0EEF2:  MOVLB  A
0EEF4:  MOVWF  x26
0EEF6:  MOVLB  0
0EEF8:  CALL   0F92
0EEFC:  BTFSC  1B.7
0EEFE:  BSF    FF2.7
0EF00:  MOVLW  2F
0EF02:  BTFSS  F9E.4
0EF04:  BRA    EF02
0EF06:  MOVWF  FAD
0EF08:  CLRF   1B
0EF0A:  BTFSC  FF2.7
0EF0C:  BSF    1B.7
0EF0E:  BCF    FF2.7
0EF10:  MOVFF  737,A25
0EF14:  MOVLW  01
0EF16:  MOVLB  A
0EF18:  MOVWF  x26
0EF1A:  MOVLB  0
0EF1C:  CALL   0F92
0EF20:  BTFSC  1B.7
0EF22:  BSF    FF2.7
0EF24:  MOVLW  2F
0EF26:  BTFSS  F9E.4
0EF28:  BRA    EF26
0EF2A:  MOVWF  FAD
0EF2C:  CLRF   1B
0EF2E:  BTFSC  FF2.7
0EF30:  BSF    1B.7
0EF32:  BCF    FF2.7
0EF34:  MOVFF  738,A25
0EF38:  MOVLW  01
0EF3A:  MOVLB  A
0EF3C:  MOVWF  x26
0EF3E:  MOVLB  0
0EF40:  CALL   0F92
0EF44:  BTFSC  1B.7
0EF46:  BSF    FF2.7
0EF48:  MOVLW  20
0EF4A:  BTFSS  F9E.4
0EF4C:  BRA    EF4A
0EF4E:  MOVWF  FAD
0EF50:  CLRF   1B
0EF52:  BTFSC  FF2.7
0EF54:  BSF    1B.7
0EF56:  BCF    FF2.7
0EF58:  MOVFF  739,A25
0EF5C:  MOVLW  01
0EF5E:  MOVLB  A
0EF60:  MOVWF  x26
0EF62:  MOVLB  0
0EF64:  CALL   0F92
0EF68:  BTFSC  1B.7
0EF6A:  BSF    FF2.7
0EF6C:  MOVLW  3A
0EF6E:  BTFSS  F9E.4
0EF70:  BRA    EF6E
0EF72:  MOVWF  FAD
0EF74:  CLRF   1B
0EF76:  BTFSC  FF2.7
0EF78:  BSF    1B.7
0EF7A:  BCF    FF2.7
0EF7C:  MOVFF  73A,A25
0EF80:  MOVLW  01
0EF82:  MOVLB  A
0EF84:  MOVWF  x26
0EF86:  MOVLB  0
0EF88:  CALL   0F92
0EF8C:  BTFSC  1B.7
0EF8E:  BSF    FF2.7
0EF90:  MOVLW  3A
0EF92:  BTFSS  F9E.4
0EF94:  BRA    EF92
0EF96:  MOVWF  FAD
0EF98:  CLRF   1B
0EF9A:  BTFSC  FF2.7
0EF9C:  BSF    1B.7
0EF9E:  BCF    FF2.7
0EFA0:  MOVFF  73B,A25
0EFA4:  MOVLW  01
0EFA6:  MOVLB  A
0EFA8:  MOVWF  x26
0EFAA:  MOVLB  0
0EFAC:  CALL   0F92
0EFB0:  BTFSC  1B.7
0EFB2:  BSF    FF2.7
0EFB4:  MOVLW  0D
0EFB6:  BTFSS  F9E.4
0EFB8:  BRA    EFB6
0EFBA:  MOVWF  FAD
0EFBC:  MOVLW  0A
0EFBE:  BTFSS  F9E.4
0EFC0:  BRA    EFBE
0EFC2:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0EFC4:  CALL   E188
....................       RTC_display_alarm(); 
0EFC8:  CALL   E25E
....................    } 
0EFCC:  GOTO   F00C (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0EFD0:  MOVF   2F,W
0EFD2:  MOVWF  00
0EFD4:  MOVF   30,W
0EFD6:  MOVWF  03
0EFD8:  BNZ   EFDE
0EFDA:  MOVF   00,F
0EFDC:  BZ    EFFE
0EFDE:  MOVF   03,W
0EFE0:  BNZ   EFE8
0EFE2:  MOVLW  01
0EFE4:  SUBWF  00,W
0EFE6:  BZ    F004
0EFE8:  MOVF   03,W
0EFEA:  BNZ   EFF2
0EFEC:  MOVLW  03
0EFEE:  SUBWF  00,W
0EFF0:  BZ    F004
0EFF2:  MOVF   03,W
0EFF4:  BNZ   EFFC
0EFF6:  MOVLW  02
0EFF8:  SUBWF  00,W
0EFFA:  BZ    F00A
0EFFC:  BRA    F00C
....................       case ECO : commandHe(); 
0EFFE:  GOTO   E3D8
....................          break; 
0F002:  BRA    F00C
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0F004:  GOTO   E7FC
....................          break; 
0F008:  BRA    F00C
....................       case AWS : commandHa(); 
0F00A:  BRA    ED64
....................          break;          
....................    } 
0F00C:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0F010:  MOVF   44,F
0F012:  BNZ   F020
0F014:  MOVF   45,F
0F016:  BNZ   F020
0F018:  MOVF   46,F
0F01A:  BNZ   F020
0F01C:  MOVF   47,F
0F01E:  BZ    F054
0F020:  MOVF   47,F
0F022:  BNZ   F054
0F024:  MOVF   46,F
0F026:  BNZ   F054
0F028:  MOVF   45,W
0F02A:  SUBLW  FD
0F02C:  BNC   F054
0F02E:  BNZ   F036
0F030:  MOVF   44,W
0F032:  SUBLW  20
0F034:  BNC   F054
....................       nv_interval = arg; 
0F036:  MOVFF  45,24
0F03A:  MOVFF  44,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0F03E:  MOVLW  14
0F040:  MOVLB  8
0F042:  MOVWF  xD8
0F044:  MOVFF  24,8DA
0F048:  MOVFF  23,8D9
0F04C:  MOVLB  0
0F04E:  CALL   501E
....................    } 
0F052:  BRA    F058
....................    else cmd_arg(); 
0F054:  CALL   B062
0F058:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0F05C:  MOVF   47,F
0F05E:  BNZ   F08E
0F060:  MOVF   46,F
0F062:  BNZ   F08E
0F064:  MOVF   45,W
0F066:  SUBLW  27
0F068:  BNC   F08E
0F06A:  BNZ   F072
0F06C:  MOVF   44,W
0F06E:  SUBLW  0F
0F070:  BNC   F08E
....................       nv_serial = arg; 
0F072:  MOVFF  45,26
0F076:  MOVFF  44,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0F07A:  MOVLB  8
0F07C:  CLRF   xD8
0F07E:  MOVFF  26,8DA
0F082:  MOVFF  25,8D9
0F086:  MOVLB  0
0F088:  CALL   501E
....................    } 
0F08C:  BRA    F092
....................    else cmd_arg(); 
0F08E:  CALL   B062
0F092:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F2B6:  MOVF   2F,F
0F2B8:  BNZ   F2E8
0F2BA:  MOVF   30,F
0F2BC:  BNZ   F2E8
....................        
....................       if (arg > 0 && arg < 3){ 
0F2BE:  MOVF   44,F
0F2C0:  BNZ   F2CE
0F2C2:  MOVF   45,F
0F2C4:  BNZ   F2CE
0F2C6:  MOVF   46,F
0F2C8:  BNZ   F2CE
0F2CA:  MOVF   47,F
0F2CC:  BZ    F2E4
0F2CE:  MOVF   47,F
0F2D0:  BNZ   F2E4
0F2D2:  MOVF   46,F
0F2D4:  BNZ   F2E4
0F2D6:  MOVF   45,F
0F2D8:  BNZ   F2E4
0F2DA:  MOVF   44,W
0F2DC:  SUBLW  02
0F2DE:  BNC   F2E4
....................          det_cmd(); 
0F2E0:  RCALL  F176
....................       } 
0F2E2:  BRA    F2E8
....................       else cmd_arg(); 
0F2E4:  CALL   B062
....................        
....................    } 
0F2E8:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
10154:  MOVF   47,F
10156:  BNZ   101C2
10158:  MOVF   46,F
1015A:  BNZ   101C2
1015C:  MOVF   45,W
1015E:  SUBLW  0F
10160:  BNC   101C2
....................       switch (nv_det_type){ 
10162:  MOVFF  41,00
10166:  MOVF   42,W
10168:  MOVWF  03
1016A:  BNZ   10172
1016C:  MOVLW  01
1016E:  SUBWF  00,W
10170:  BZ    10188
10172:  MOVF   03,W
10174:  BNZ   1017C
10176:  MOVLW  02
10178:  SUBWF  00,W
1017A:  BZ    1018E
1017C:  MOVF   03,W
1017E:  BNZ   10186
10180:  MOVLW  03
10182:  SUBWF  00,W
10184:  BZ    101AC
10186:  BRA    101C0
....................          case 1 : det_cmd(); 
10188:  CALL   F176
....................             break; 
1018C:  BRA    101C0
....................          case 2 : DAC_set(1,arg); 
1018E:  MOVFF  45,870
10192:  MOVFF  44,86F
10196:  MOVLW  01
10198:  MOVLB  8
1019A:  MOVWF  xBD
1019C:  MOVFF  45,8BF
101A0:  MOVFF  44,8BE
101A4:  MOVLB  0
101A6:  CALL   F2EC
....................             break; 
101AA:  BRA    101C0
....................          case 3 : set_LED(arg); 
101AC:  MOVFF  45,870
101B0:  MOVFF  44,86F
101B4:  MOVFF  45,8B0
101B8:  MOVFF  44,8AF
101BC:  CALL   F63A
....................             break; 
....................       } 
....................    } 
101C0:  BRA    10220
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
101C2:  MOVF   47,F
101C4:  BNZ   101DA
101C6:  MOVF   46,F
101C8:  BNZ   101DA
101CA:  MOVF   45,W
101CC:  SUBLW  4D
101CE:  BC    10204
101D0:  XORLW  FF
101D2:  BNZ   101DA
101D4:  MOVF   44,W
101D6:  SUBLW  20
101D8:  BC    10204
101DA:  MOVF   47,F
101DC:  BNZ   10204
101DE:  MOVF   46,F
101E0:  BNZ   10204
101E2:  MOVF   45,W
101E4:  SUBLW  4E
101E6:  BNC   10204
101E8:  BNZ   101F0
101EA:  MOVF   44,W
101EC:  SUBLW  22
101EE:  BNC   10204
101F0:  MOVFF  45,870
101F4:  MOVFF  44,86F
101F8:  MOVFF  45,872
101FC:  MOVFF  44,871
10200:  BRA    10000
10202:  BRA    10220
....................    else if(arg==30001)set_LED_test(); 
10204:  MOVF   44,W
10206:  SUBLW  31
10208:  BNZ   1021C
1020A:  MOVF   45,W
1020C:  SUBLW  75
1020E:  BNZ   1021C
10210:  MOVF   46,F
10212:  BNZ   1021C
10214:  MOVF   47,F
10216:  BNZ   1021C
10218:  BRA    100C8
1021A:  BRA    10220
....................    else cmd_arg(); 
1021C:  CALL   B062
10220:  GOTO   1028A (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
10224:  MOVF   47,F
10226:  BNZ   10258
10228:  MOVF   46,F
1022A:  BNZ   10258
1022C:  MOVF   45,W
1022E:  SUBLW  57
10230:  BNC   10258
10232:  BNZ   1023A
10234:  MOVF   44,W
10236:  SUBLW  E4
10238:  BNC   10258
....................       nv_volume = arg; 
1023A:  MOVFF  45,2C
1023E:  MOVFF  44,2B
....................       write16(ADDR_VOLUME, nv_volume); 
10242:  MOVLW  22
10244:  MOVLB  8
10246:  MOVWF  xD8
10248:  MOVFF  2C,8DA
1024C:  MOVFF  2B,8D9
10250:  MOVLB  0
10252:  CALL   501E
....................    } 
10256:  BRA    1025C
....................    else cmd_arg(); 
10258:  CALL   B062
1025C:  GOTO   1028A (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
10260:  MOVF   2F,W
10262:  MOVWF  00
10264:  MOVF   30,W
10266:  MOVWF  03
10268:  BNZ   1026E
1026A:  MOVF   00,F
1026C:  BZ    10284
1026E:  MOVF   03,W
10270:  BNZ   10278
10272:  MOVLW  01
10274:  SUBWF  00,W
10276:  BZ    10288
10278:  MOVF   03,W
1027A:  BNZ   10282
1027C:  MOVLW  03
1027E:  SUBWF  00,W
10280:  BZ    10288
10282:  BRA    1028A
....................       case ECO : commandLe(); 
10284:  BRA    10154
....................          break; 
10286:  BRA    1028A
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
10288:  BRA    10224
....................          break; 
....................    } 
1028A:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
1699A:  CALL   2A14
....................     
....................    user_quit = FALSE; 
1699E:  CLRF   4C
....................     
....................    if(arg > 0 && arg < 21) 
169A0:  MOVF   44,F
169A2:  BNZ   169B0
169A4:  MOVF   45,F
169A6:  BNZ   169B0
169A8:  MOVF   46,F
169AA:  BNZ   169B0
169AC:  MOVF   47,F
169AE:  BZ    16A2C
169B0:  MOVF   47,F
169B2:  BNZ   16A2C
169B4:  MOVF   46,F
169B6:  BNZ   16A2C
169B8:  MOVF   45,F
169BA:  BNZ   16A2C
169BC:  MOVF   44,W
169BE:  SUBLW  14
169C0:  BNC   16A2C
....................    { 
....................       macro = arg; 
169C2:  MOVFF  44,870
....................       switch(nv_product){ 
169C6:  MOVFF  2F,00
169CA:  MOVF   30,W
169CC:  MOVWF  03
169CE:  BNZ   169D4
169D0:  MOVF   00,F
169D2:  BZ    169F4
169D4:  MOVF   03,W
169D6:  BNZ   169DE
169D8:  MOVLW  01
169DA:  SUBWF  00,W
169DC:  BZ    169F4
169DE:  MOVF   03,W
169E0:  BNZ   169E8
169E2:  MOVLW  03
169E4:  SUBWF  00,W
169E6:  BZ    169F4
169E8:  MOVF   03,W
169EA:  BNZ   169F2
169EC:  MOVLW  02
169EE:  SUBWF  00,W
169F0:  BZ    16A1A
169F2:  BRA    16A2A
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
169F4:  MOVLW  01
169F6:  MOVLB  7
169F8:  ADDWF  xBF,W
169FA:  MOVLB  8
169FC:  MOVWF  x71
169FE:  MOVLW  00
16A00:  MOVLB  7
16A02:  ADDWFC xC0,W
16A04:  MOVLB  8
16A06:  MOVWF  x72
16A08:  MOVFF  870,881
16A0C:  MOVWF  x83
16A0E:  MOVFF  871,882
16A12:  MOVLB  0
16A14:  CALL   14FC0
....................             break; 
16A18:  BRA    16A2A
....................          case AWS : play_macro(macro,nv_port); 
16A1A:  MOVFF  870,881
16A1E:  MOVFF  2E,883
16A22:  MOVFF  2D,882
16A26:  CALL   14FC0
....................             break; 
....................       } 
....................    }    
16A2A:  BRA    16A94
....................    else if (arg == 0) 
16A2C:  MOVF   44,F
16A2E:  BNZ   16A90
16A30:  MOVF   45,F
16A32:  BNZ   16A90
16A34:  MOVF   46,F
16A36:  BNZ   16A90
16A38:  MOVF   47,F
16A3A:  BNZ   16A90
....................    { 
....................       MaxSamples=FALSE; 
16A3C:  CLRF   34
16A3E:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
16A40:  MOVLW  28
16A42:  MOVLB  8
16A44:  MOVWF  x73
16A46:  MOVFF  33,874
16A4A:  MOVLB  0
16A4C:  CALL   3466
....................       if (LoggingReentry != TRUE) 
16A50:  MOVLB  8
16A52:  DECFSZ x6F,W
16A54:  BRA    16A58
16A56:  BRA    16A70
....................       { 
....................          nv_sample = 0; 
16A58:  CLRF   22
16A5A:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
16A5C:  MOVLW  16
16A5E:  MOVWF  xD8
16A60:  MOVFF  22,8DA
16A64:  MOVFF  21,8D9
16A68:  MOVLB  0
16A6A:  CALL   501E
16A6E:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
16A70:  CLRF   x6F
....................       nv_macro_step = 0; 
16A72:  CLRF   38
16A74:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
16A76:  MOVLW  3A
16A78:  MOVWF  xD8
16A7A:  MOVFF  38,8DA
16A7E:  MOVFF  37,8D9
16A82:  MOVLB  0
16A84:  CALL   501E
....................       user_quit = auto_sample_ready(); 
16A88:  BRA    16798
16A8A:  MOVFF  01,4C
....................    } 
16A8E:  BRA    16A94
....................    else cmd_arg(); 
16A90:  CALL   B062
....................     
....................    busy_clear(); 
16A94:  CALL   AE9E
16A98:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
16A9A:  MOVF   44,F
16A9C:  BNZ   16AAA
16A9E:  MOVF   45,F
16AA0:  BNZ   16AAA
16AA2:  MOVF   46,F
16AA4:  BNZ   16AAA
16AA6:  MOVF   47,F
16AA8:  BZ    16ADE
16AAA:  MOVF   47,F
16AAC:  BNZ   16ADE
16AAE:  MOVF   46,F
16AB0:  BNZ   16ADE
16AB2:  MOVF   45,W
16AB4:  SUBLW  0D
16AB6:  BNC   16ADE
16AB8:  BNZ   16AC0
16ABA:  MOVF   44,W
16ABC:  SUBLW  AC
16ABE:  BNC   16ADE
....................       nv_max_samples = arg; 
16AC0:  MOVFF  45,28
16AC4:  MOVFF  44,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
16AC8:  MOVLW  18
16ACA:  MOVLB  8
16ACC:  MOVWF  xD8
16ACE:  MOVFF  28,8DA
16AD2:  MOVFF  27,8D9
16AD6:  MOVLB  0
16AD8:  CALL   501E
....................    } 
16ADC:  BRA    16B24
....................    else if(arg == 0) { 
16ADE:  MOVF   44,F
16AE0:  BNZ   16B20
16AE2:  MOVF   45,F
16AE4:  BNZ   16B20
16AE6:  MOVF   46,F
16AE8:  BNZ   16B20
16AEA:  MOVF   47,F
16AEC:  BNZ   16B20
....................       nv_sample = 0; 
16AEE:  CLRF   22
16AF0:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
16AF2:  MOVLW  16
16AF4:  MOVLB  8
16AF6:  MOVWF  xD8
16AF8:  MOVFF  22,8DA
16AFC:  MOVFF  21,8D9
16B00:  MOVLB  0
16B02:  CALL   501E
....................       nv_macro_step = 0; 
16B06:  CLRF   38
16B08:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16B0A:  MOVLW  3A
16B0C:  MOVLB  8
16B0E:  MOVWF  xD8
16B10:  MOVFF  38,8DA
16B14:  MOVFF  37,8D9
16B18:  MOVLB  0
16B1A:  CALL   501E
....................    } 
16B1E:  BRA    16B24
....................    else cmd_arg(); 
16B20:  CALL   B062
16B24:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
16C4A:  DECFSZ 44,W
16C4C:  BRA    16C66
16C4E:  MOVF   45,F
16C50:  BNZ   16C66
16C52:  MOVF   46,F
16C54:  BNZ   16C66
16C56:  MOVF   47,F
16C58:  BNZ   16C66
....................    { 
....................       bus_on(); 
16C5A:  CALL   D0E8
....................       open_pipe(); 
16C5E:  BRA    16B40
....................       bus_off(); 
16C60:  CALL   D10C
....................    } 
16C64:  BRA    16C6A
....................    else cmd_arg(); 
16C66:  CALL   B062
16C6A:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
16D28:  MOVLB  7
16D2A:  DECFSZ x3D,W
16D2C:  BRA    16D30
16D2E:  CLRF   x3C
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
16D30:  MOVF   44,F
16D32:  BNZ   16D42
16D34:  MOVF   45,F
16D36:  BNZ   16D42
16D38:  MOVF   46,F
16D3A:  BNZ   16D42
16D3C:  MOVF   47,F
16D3E:  BTFSC  FD8.2
16D40:  BRA    16E0A
16D42:  BCF    FD8.0
16D44:  RLCF   x3C,W
16D46:  CLRF   03
16D48:  ADDLW  5E
16D4A:  MOVWF  FE9
16D4C:  MOVLW  07
16D4E:  ADDWFC 03,W
16D50:  MOVWF  FEA
16D52:  MOVFF  FEC,03
16D56:  MOVF   FED,F
16D58:  MOVFF  FEF,01
16D5C:  MOVF   47,F
16D5E:  BNZ   16E0A
16D60:  MOVF   46,F
16D62:  BNZ   16E0A
16D64:  MOVF   45,W
16D66:  SUBWF  03,W
16D68:  BNC   16E0A
16D6A:  BNZ   16D72
16D6C:  MOVF   44,W
16D6E:  SUBWF  01,W
16D70:  BNC   16E0A
....................       if(e_mode[motor]==2){     // if port mode then move 
16D72:  BCF    FD8.0
16D74:  RLCF   x3C,W
16D76:  CLRF   03
16D78:  ADDLW  62
16D7A:  MOVWF  FE9
16D7C:  MOVLW  07
16D7E:  ADDWFC 03,W
16D80:  MOVWF  FEA
16D82:  MOVFF  FEC,870
16D86:  MOVF   FED,F
16D88:  MOVFF  FEF,86F
16D8C:  MOVLB  8
16D8E:  MOVF   x6F,W
16D90:  SUBLW  02
16D92:  BNZ   16E00
16D94:  MOVF   x70,F
16D96:  BNZ   16E00
....................          switch (nv_product){ 
16D98:  MOVF   2F,W
16D9A:  MOVWF  00
16D9C:  MOVF   30,W
16D9E:  MOVWF  03
16DA0:  MOVF   03,W
16DA2:  BNZ   16DAC
16DA4:  MOVF   00,F
16DA6:  MOVLB  0
16DA8:  BZ    16DCA
16DAA:  MOVLB  8
16DAC:  MOVF   03,W
16DAE:  BNZ   16DBA
16DB0:  MOVLW  01
16DB2:  SUBWF  00,W
16DB4:  MOVLB  0
16DB6:  BZ    16DDC
16DB8:  MOVLB  8
16DBA:  MOVF   03,W
16DBC:  BNZ   16DC8
16DBE:  MOVLW  03
16DC0:  SUBWF  00,W
16DC2:  MOVLB  0
16DC4:  BZ    16DEE
16DC6:  MOVLB  8
16DC8:  BRA    16DFE
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
16DCA:  MOVLW  01
16DCC:  MOVLB  8
16DCE:  MOVWF  x6F
16DD0:  CLRF   x70
16DD2:  MOVWF  x71
16DD4:  MOVLB  0
16DD6:  RCALL  16C6E
....................                break;             
16DD8:  MOVLB  8
16DDA:  BRA    16DFE
....................             case WMS4: command_move(0,0,1); 
16DDC:  MOVLB  8
16DDE:  CLRF   x6F
16DE0:  CLRF   x70
16DE2:  MOVLW  01
16DE4:  MOVWF  x71
16DE6:  MOVLB  0
16DE8:  RCALL  16C6E
....................                break; 
16DEA:  MOVLB  8
16DEC:  BRA    16DFE
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
16DEE:  MOVLB  8
16DF0:  CLRF   x6F
16DF2:  CLRF   x70
16DF4:  MOVLW  01
16DF6:  MOVWF  x71
16DF8:  MOVLB  0
16DFA:  RCALL  16C6E
....................                break; 
16DFC:  MOVLB  8
....................          } 
....................       } 
16DFE:  BRA    16E08
....................       else cmd_err();                           // else error 
16E00:  MOVLB  0
16E02:  CALL   BD24
16E06:  MOVLB  8
....................    } 
16E08:  BRA    16E12
....................    else cmd_arg(); 
16E0A:  MOVLB  0
16E0C:  CALL   B062
16E10:  MOVLB  8
16E12:  MOVLB  0
16E14:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
16E16:  MOVF   47,F
16E18:  BNZ   16E46
16E1A:  MOVF   46,F
16E1C:  BNZ   16E46
16E1E:  MOVF   45,F
16E20:  BNZ   16E46
16E22:  MOVF   44,W
16E24:  SUBLW  30
16E26:  BNC   16E46
....................       nv_port = arg; 
16E28:  MOVFF  45,2E
16E2C:  MOVFF  44,2D
....................       write16(ADDR_PORT, nv_port); 
16E30:  MOVLW  24
16E32:  MOVLB  8
16E34:  MOVWF  xD8
16E36:  MOVFF  2E,8DA
16E3A:  MOVFF  2D,8D9
16E3E:  MOVLB  0
16E40:  CALL   501E
....................    } 
16E44:  BRA    16E4A
....................    else cmd_arg(); 
16E46:  CALL   B062
16E4A:  GOTO   16E86 (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
16E4E:  MOVF   2F,W
16E50:  MOVWF  00
16E52:  MOVF   30,W
16E54:  MOVWF  03
16E56:  BNZ   16E5C
16E58:  MOVF   00,F
16E5A:  BZ    16E7C
16E5C:  MOVF   03,W
16E5E:  BNZ   16E66
16E60:  MOVLW  01
16E62:  SUBWF  00,W
16E64:  BZ    16E80
16E66:  MOVF   03,W
16E68:  BNZ   16E70
16E6A:  MOVLW  03
16E6C:  SUBWF  00,W
16E6E:  BZ    16E80
16E70:  MOVF   03,W
16E72:  BNZ   16E7A
16E74:  MOVLW  02
16E76:  SUBWF  00,W
16E78:  BZ    16E84
16E7A:  BRA    16E86
....................       case ECO : commandPe(); 
16E7C:  RCALL  16D28
....................          break; 
16E7E:  BRA    16E86
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
16E80:  RCALL  16D28
....................          break; 
16E82:  BRA    16E86
....................       case AWS : commandPa(); 
16E84:  BRA    16E16
....................          break;          
....................    } 
16E86:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
16ED2:  MOVLB  4
16ED4:  DECFSZ xB2,W
16ED6:  BRA    16F02
....................     
....................       if(arg<33){ 
16ED8:  MOVF   47,F
16EDA:  BNZ   16EFA
16EDC:  MOVF   46,F
16EDE:  BNZ   16EFA
16EE0:  MOVF   45,F
16EE2:  BNZ   16EFA
16EE4:  MOVF   44,W
16EE6:  SUBLW  20
16EE8:  BNC   16EFA
....................          valve=arg;    
16EEA:  MOVFF  44,86F
....................          sol_switch(valve); 
16EEE:  MOVFF  86F,89F
16EF2:  MOVLB  0
16EF4:  CALL   1418A
....................       }  
16EF8:  BRA    16F00
....................       else cmd_arg(); 
16EFA:  MOVLB  0
16EFC:  CALL   B062
....................    } 
16F00:  BRA    16F08
....................    else cmd_err(); 
16F02:  MOVLB  0
16F04:  CALL   BD24
16F08:  GOTO   16F38 (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
16E8A:  MOVF   44,F
16E8C:  BNZ   16E9A
16E8E:  MOVF   45,F
16E90:  BNZ   16E9A
16E92:  MOVF   46,F
16E94:  BNZ   16E9A
16E96:  MOVF   47,F
16E98:  BZ    16ECA
16E9A:  MOVF   47,F
16E9C:  BNZ   16ECA
16E9E:  MOVF   46,F
16EA0:  BNZ   16ECA
16EA2:  MOVF   45,F
16EA4:  BNZ   16ECA
16EA6:  MOVF   44,W
16EA8:  SUBLW  32
16EAA:  BNC   16ECA
....................       nv_port = arg; 
16EAC:  MOVFF  45,2E
16EB0:  MOVFF  44,2D
....................       write16(ADDR_SAMPLE, nv_port); 
16EB4:  MOVLW  16
16EB6:  MOVLB  8
16EB8:  MOVWF  xD8
16EBA:  MOVFF  2E,8DA
16EBE:  MOVFF  2D,8D9
16EC2:  MOVLB  0
16EC4:  CALL   501E
....................    } 
16EC8:  BRA    16ECE
....................    else cmd_arg(); 
16ECA:  CALL   B062
16ECE:  GOTO   16F38 (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
16F0C:  MOVF   2F,W
16F0E:  MOVWF  00
16F10:  MOVF   30,W
16F12:  MOVWF  03
16F14:  BNZ   16F1C
16F16:  MOVLW  01
16F18:  SUBWF  00,W
16F1A:  BZ    16F32
16F1C:  MOVF   03,W
16F1E:  BNZ   16F26
16F20:  MOVLW  03
16F22:  SUBWF  00,W
16F24:  BZ    16F32
16F26:  MOVF   03,W
16F28:  BNZ   16F30
16F2A:  MOVLW  02
16F2C:  SUBWF  00,W
16F2E:  BZ    16F36
16F30:  BRA    16F38
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
16F32:  BRA    16E8A
....................          break; 
16F34:  BRA    16F38
....................       case AWS : commandQa(); 
16F36:  BRA    16ED2
....................          break;          
....................    } 
16F38:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
16F3C:  CALL   2A14
....................     
....................    nv_macro_step = 0; 
16F40:  CLRF   38
16F42:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
16F44:  MOVLW  3A
16F46:  MOVLB  8
16F48:  MOVWF  xD8
16F4A:  MOVFF  38,8DA
16F4E:  MOVFF  37,8D9
16F52:  MOVLB  0
16F54:  CALL   501E
....................     
....................    user_quit = FALSE; 
16F58:  CLRF   4C
....................     
....................    if (arg > 0 && arg < 3501){ 
16F5A:  MOVF   44,F
16F5C:  BNZ   16F6A
16F5E:  MOVF   45,F
16F60:  BNZ   16F6A
16F62:  MOVF   46,F
16F64:  BNZ   16F6A
16F66:  MOVF   47,F
16F68:  BZ    17016
16F6A:  MOVF   47,F
16F6C:  BNZ   17016
16F6E:  MOVF   46,F
16F70:  BNZ   17016
16F72:  MOVF   45,W
16F74:  SUBLW  0D
16F76:  BNC   17016
16F78:  BNZ   16F80
16F7A:  MOVF   44,W
16F7C:  SUBLW  AC
16F7E:  BNC   17016
....................       samples = arg; 
16F80:  MOVFF  45,871
16F84:  MOVFF  44,870
....................       user_quit = FALSE; 
16F88:  CLRF   4C
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
16F8A:  MOVLB  8
16F8C:  CLRF   x73
16F8E:  CLRF   x72
16F90:  MOVF   x73,W
16F92:  SUBWF  x71,W
16F94:  BNC   17014
16F96:  BNZ   16F9E
16F98:  MOVF   x70,W
16F9A:  SUBWF  x72,W
16F9C:  BC    17014
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
16F9E:  MOVLW  01
16FA0:  ADDWF  x72,W
16FA2:  MOVWF  x74
16FA4:  MOVLW  00
16FA6:  ADDWFC x73,W
16FA8:  MOVWF  x75
16FAA:  MOVLW  A6
16FAC:  MOVWF  FF6
16FAE:  MOVLW  26
16FB0:  MOVWF  FF7
16FB2:  MOVLW  00
16FB4:  MOVWF  FF8
16FB6:  CLRF   1B
16FB8:  BTFSC  FF2.7
16FBA:  BSF    1B.7
16FBC:  BCF    FF2.7
16FBE:  MOVLW  05
16FC0:  MOVLB  A
16FC2:  MOVWF  x25
16FC4:  MOVLB  0
16FC6:  CALL   1010
16FCA:  BTFSC  1B.7
16FCC:  BSF    FF2.7
16FCE:  MOVLW  09
16FD0:  MOVWF  FE9
16FD2:  CLRF   1B
16FD4:  BTFSC  FF2.7
16FD6:  BSF    1B.7
16FD8:  BCF    FF2.7
16FDA:  MOVFF  875,A26
16FDE:  MOVFF  874,A25
16FE2:  CALL   1192
16FE6:  BTFSC  1B.7
16FE8:  BSF    FF2.7
16FEA:  MOVLW  0D
16FEC:  BTFSS  F9E.4
16FEE:  BRA    16FEC
16FF0:  MOVWF  FAD
16FF2:  MOVLW  0A
16FF4:  BTFSS  F9E.4
16FF6:  BRA    16FF4
16FF8:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
16FFA:  CALL   15B88
16FFE:  MOVFF  01,86F
....................          if (macro_cmd == ';') break; 
17002:  MOVLB  8
17004:  MOVF   x6F,W
17006:  SUBLW  3B
17008:  BTFSC  FD8.2
1700A:  BRA    17014
1700C:  INCF   x72,F
1700E:  BTFSC  FD8.2
17010:  INCF   x73,F
17012:  BRA    16F90
17014:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
17016:  CALL   AE9E
1701A:  GOTO   171DA (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
1701E:  MOVF   44,F
17020:  BNZ   1702E
17022:  MOVF   45,F
17024:  BNZ   1702E
17026:  MOVF   46,F
17028:  BNZ   1702E
1702A:  MOVF   47,F
1702C:  BZ    17072
1702E:  MOVF   47,F
17030:  BNZ   17072
17032:  MOVF   46,F
17034:  BNZ   17072
17036:  MOVF   45,F
17038:  BNZ   17072
1703A:  MOVF   44,W
1703C:  SUBLW  2F
1703E:  BNC   17072
....................       n=arg; 
17040:  MOVFF  44,872
....................       port=2; 
17044:  MOVLB  8
17046:  CLRF   x70
17048:  MOVLW  02
1704A:  MOVWF  x6F
....................       for(i=0;i<n;++i){ 
1704C:  CLRF   x71
1704E:  MOVF   x72,W
17050:  SUBWF  x71,W
17052:  BC    1706E
....................          play_wms_hard_macro(port); 
17054:  MOVFF  870,874
17058:  MOVFF  86F,873
1705C:  MOVLB  0
1705E:  CALL   D578
....................          ++port; 
17062:  MOVLB  8
17064:  INCF   x6F,F
17066:  BTFSC  FD8.2
17068:  INCF   x70,F
1706A:  INCF   x71,F
1706C:  BRA    1704E
....................       } 
....................    } 
1706E:  BRA    17078
17070:  MOVLB  0
....................    else cmd_arg(); 
17072:  CALL   B062
17076:  MOVLB  8
17078:  MOVLB  0
1707A:  GOTO   171DA (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
1707E:  CALL   2A14
....................     
....................    nv_macro_step = 0; 
17082:  CLRF   38
17084:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
17086:  MOVLW  3A
17088:  MOVLB  8
1708A:  MOVWF  xD8
1708C:  MOVFF  38,8DA
17090:  MOVFF  37,8D9
17094:  MOVLB  0
17096:  CALL   501E
....................     
....................    user_quit = FALSE; 
1709A:  CLRF   4C
....................     
....................    if (arg > 0 && arg < 241){ 
1709C:  MOVF   44,F
1709E:  BNZ   170AE
170A0:  MOVF   45,F
170A2:  BNZ   170AE
170A4:  MOVF   46,F
170A6:  BNZ   170AE
170A8:  MOVF   47,F
170AA:  BTFSC  FD8.2
170AC:  BRA    1719A
170AE:  MOVF   47,F
170B0:  BTFSS  FD8.2
170B2:  BRA    1719A
170B4:  MOVF   46,F
170B6:  BTFSS  FD8.2
170B8:  BRA    1719A
170BA:  MOVF   45,F
170BC:  BTFSS  FD8.2
170BE:  BRA    1719A
170C0:  MOVF   44,W
170C2:  SUBLW  F0
170C4:  BNC   1719A
....................       samples = arg; 
170C6:  MOVFF  45,871
170CA:  MOVFF  44,870
....................       user_quit = FALSE; 
170CE:  CLRF   4C
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
170D0:  MOVLB  8
170D2:  CLRF   x73
170D4:  CLRF   x72
170D6:  MOVF   x73,W
170D8:  SUBWF  x71,W
170DA:  BNC   17198
170DC:  BNZ   170E4
170DE:  MOVF   x70,W
170E0:  SUBWF  x72,W
170E2:  BC    17198
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
170E4:  MOVLW  01
170E6:  ADDWF  x72,W
170E8:  MOVWF  x74
170EA:  MOVLW  00
170EC:  ADDWFC x73,W
170EE:  MOVWF  x75
170F0:  MOVLW  B4
170F2:  MOVWF  FF6
170F4:  MOVLW  26
170F6:  MOVWF  FF7
170F8:  MOVLW  00
170FA:  MOVWF  FF8
170FC:  CLRF   1B
170FE:  BTFSC  FF2.7
17100:  BSF    1B.7
17102:  BCF    FF2.7
17104:  MOVLW  05
17106:  MOVLB  A
17108:  MOVWF  x25
1710A:  MOVLB  0
1710C:  CALL   1010
17110:  BTFSC  1B.7
17112:  BSF    FF2.7
17114:  MOVLW  09
17116:  MOVWF  FE9
17118:  CLRF   1B
1711A:  BTFSC  FF2.7
1711C:  BSF    1B.7
1711E:  BCF    FF2.7
17120:  MOVFF  875,A26
17124:  MOVFF  874,A25
17128:  CALL   1192
1712C:  BTFSC  1B.7
1712E:  BSF    FF2.7
17130:  MOVLW  0D
17132:  BTFSS  F9E.4
17134:  BRA    17132
17136:  MOVWF  FAD
17138:  MOVLW  0A
1713A:  BTFSS  F9E.4
1713C:  BRA    1713A
1713E:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
17140:  MOVLW  01
17142:  MOVLB  8
17144:  ADDWF  x72,W
17146:  MOVWF  x74
17148:  MOVLW  00
1714A:  ADDWFC x73,W
1714C:  MOVWF  x75
1714E:  MOVWF  x77
17150:  MOVFF  874,876
17154:  MOVLB  0
17156:  CALL   1643E
1715A:  MOVFF  01,86F
....................          ++nv_sample;                     // increment sample number 
1715E:  INCF   21,F
17160:  BTFSC  FD8.2
17162:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
17164:  MOVLW  16
17166:  MOVLB  8
17168:  MOVWF  xD8
1716A:  MOVFF  22,8DA
1716E:  MOVFF  21,8D9
17172:  MOVLB  0
17174:  CALL   501E
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
17178:  MOVF   27,W
1717A:  SUBWF  21,W
1717C:  BNZ   17184
1717E:  MOVF   28,W
17180:  SUBWF  22,W
17182:  BZ    1718C
17184:  MOVLB  8
17186:  MOVF   x6F,W
17188:  SUBLW  3B
1718A:  BNZ   17190
1718C:  MOVLB  8
1718E:  BRA    17198
17190:  INCF   x72,F
17192:  BTFSC  FD8.2
17194:  INCF   x73,F
17196:  BRA    170D6
17198:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
1719A:  CALL   AE9E
1719E:  GOTO   171DA (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
171A2:  MOVF   2F,W
171A4:  MOVWF  00
171A6:  MOVF   30,W
171A8:  MOVWF  03
171AA:  BNZ   171B0
171AC:  MOVF   00,F
171AE:  BZ    171D0
171B0:  MOVF   03,W
171B2:  BNZ   171BA
171B4:  MOVLW  01
171B6:  SUBWF  00,W
171B8:  BZ    171D4
171BA:  MOVF   03,W
171BC:  BNZ   171C4
171BE:  MOVLW  03
171C0:  SUBWF  00,W
171C2:  BZ    171D4
171C4:  MOVF   03,W
171C6:  BNZ   171CE
171C8:  MOVLW  02
171CA:  SUBWF  00,W
171CC:  BZ    171D8
171CE:  BRA    171DA
....................       case ECO : commandRe(); 
171D0:  BRA    16F3C
....................          break; 
171D2:  BRA    171DA
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
171D4:  BRA    1701E
....................          break; 
171D6:  BRA    171DA
....................       case AWS : commandRa(); 
171D8:  BRA    1707E
....................          break;          
....................    } 
171DA:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
171DE:  CALL   2A14
....................     
....................    switch(arg){ 
171E2:  MOVFF  44,00
171E6:  MOVF   45,W
171E8:  MOVWF  03
171EA:  BNZ   171F2
171EC:  MOVLW  01
171EE:  SUBWF  00,W
171F0:  BZ    171FE
171F2:  MOVF   03,W
171F4:  BNZ   171FC
171F6:  MOVLW  02
171F8:  SUBWF  00,W
171FA:  BZ    17242
171FC:  BRA    17252
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
171FE:  DECFSZ 41,W
17200:  BRA    17216
17202:  MOVF   42,F
17204:  BNZ   17216
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
17206:  MOVLB  8
17208:  CLRF   xAC
1720A:  MOVLW  01
1720C:  MOVWF  xAD
1720E:  MOVLB  0
17210:  CALL   134CC
....................       } 
17214:  BRA    17240
....................       else if(nv_det_type==2 || nv_det_type==3) 
17216:  MOVF   41,W
17218:  SUBLW  02
1721A:  BNZ   17220
1721C:  MOVF   42,F
1721E:  BZ    1722A
17220:  MOVF   41,W
17222:  SUBLW  03
17224:  BNZ   17240
17226:  MOVF   42,F
17228:  BNZ   17240
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
1722A:  MOVLB  8
1722C:  CLRF   xAD
1722E:  MOVLW  C8
17230:  MOVWF  xAC
17232:  CLRF   xAE
17234:  MOVLW  01
17236:  MOVWF  xAF
17238:  CLRF   xB0
1723A:  MOVLB  0
1723C:  CALL   FD7C
....................       } 
....................       break;                                                        //200 scans,don't store,display 
17240:  BRA    17256
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
17242:  MOVLB  8
17244:  CLRF   xAC
17246:  MOVLW  01
17248:  MOVWF  xAD
1724A:  MOVLB  0
1724C:  CALL   137CE
....................       break; 
17250:  BRA    17256
....................    default: cmd_arg(); 
17252:  CALL   B062
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
17256:  CALL   AE9E
1725A:  GOTO   17306 (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
1725E:  MOVF   47,F
17260:  BNZ   17292
17262:  MOVF   46,F
17264:  BNZ   17292
17266:  MOVF   45,W
17268:  SUBLW  04
1726A:  BNC   17292
1726C:  BNZ   17274
1726E:  MOVF   44,W
17270:  SUBLW  00
17272:  BNC   17292
....................       nv_sample = arg; 
17274:  MOVFF  45,22
17278:  MOVFF  44,21
....................       write16(ADDR_SAMPLE, nv_sample); 
1727C:  MOVLW  16
1727E:  MOVLB  8
17280:  MOVWF  xD8
17282:  MOVFF  22,8DA
17286:  MOVFF  21,8D9
1728A:  MOVLB  0
1728C:  CALL   501E
....................    } 
17290:  BRA    17296
....................    else cmd_arg(); 
17292:  CALL   B062
17296:  GOTO   17306 (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
1729A:  MOVF   47,F
1729C:  BNZ   172C6
1729E:  MOVF   46,F
172A0:  BNZ   172C6
172A2:  MOVF   45,W
172A4:  SUBLW  01
172A6:  BNC   172C6
172A8:  BNZ   172B0
172AA:  MOVF   44,W
172AC:  SUBLW  02
172AE:  BNC   172C6
....................       setting = arg; 
172B0:  MOVFF  45,870
172B4:  MOVFF  44,86F
....................       sol_switch_cmd(setting); 
172B8:  MOVFF  870,8A1
172BC:  MOVFF  86F,8A0
172C0:  CALL   140D4
....................    } 
172C4:  BRA    172CA
....................    else cmd_arg(); 
172C6:  CALL   B062
172CA:  GOTO   17306 (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
172CE:  MOVF   2F,W
172D0:  MOVWF  00
172D2:  MOVF   30,W
172D4:  MOVWF  03
172D6:  BNZ   172DC
172D8:  MOVF   00,F
172DA:  BZ    172FC
172DC:  MOVF   03,W
172DE:  BNZ   172E6
172E0:  MOVLW  01
172E2:  SUBWF  00,W
172E4:  BZ    17300
172E6:  MOVF   03,W
172E8:  BNZ   172F0
172EA:  MOVLW  03
172EC:  SUBWF  00,W
172EE:  BZ    17300
172F0:  MOVF   03,W
172F2:  BNZ   172FA
172F4:  MOVLW  02
172F6:  SUBWF  00,W
172F8:  BZ    17304
172FA:  BRA    17306
....................       case ECO : commandSe(); 
172FC:  BRA    171DE
....................          break; 
172FE:  BRA    17306
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
17300:  BRA    1725E
....................          break; 
17302:  BRA    17306
....................       case AWS : commandSa(); 
17304:  BRA    1729A
....................          break;          
....................    } 
17306:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
1786C:  MOVLW  C2
1786E:  MOVWF  FF6
17870:  MOVLW  26
17872:  MOVWF  FF7
17874:  MOVLW  00
17876:  MOVWF  FF8
17878:  CLRF   1B
1787A:  BTFSC  FF2.7
1787C:  BSF    1B.7
1787E:  BCF    FF2.7
17880:  CALL   0E3A
17884:  BTFSC  1B.7
17886:  BSF    FF2.7
....................    fputc('>',COM_A); 
17888:  MOVLW  3E
1788A:  CALL   AEA6
....................    RTCfmt=fgetc(COM_A); 
1788E:  CALL   0E24
17892:  MOVFF  01,4B
....................    if (com_echo == TRUE) 
17896:  DECFSZ 48,W
17898:  BRA    178A0
....................       { 
....................       fputc(RTCfmt,COM_A); 
1789A:  MOVF   4B,W
1789C:  CALL   AEA6
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
178A0:  MOVLW  30
178A2:  SUBWF  4B,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
178A4:  MOVF   4B,W
178A6:  SUBLW  01
178A8:  BNC   178DE
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
178AA:  MOVLW  EE
178AC:  MOVWF  FF6
178AE:  MOVLW  26
178B0:  MOVWF  FF7
178B2:  MOVLW  00
178B4:  MOVWF  FF8
178B6:  CALL   AE74
178BA:  MOVLW  0D
178BC:  BTFSS  F9E.4
178BE:  BRA    178BC
178C0:  MOVWF  FAD
178C2:  MOVLW  0A
178C4:  BTFSS  F9E.4
178C6:  BRA    178C4
178C8:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
178CA:  MOVLW  1A
178CC:  MOVLB  8
178CE:  MOVWF  xD8
178D0:  CLRF   xDA
178D2:  MOVFF  4B,8D9
178D6:  MOVLB  0
178D8:  CALL   501E
....................       }  
178DC:  BRA    178E2
....................    else cmd_arg(); 
178DE:  CALL   B062
....................     
....................    if(arg == 1) 
178E2:  DECFSZ 44,W
178E4:  BRA    178F6
178E6:  MOVF   45,F
178E8:  BNZ   178F6
178EA:  MOVF   46,F
178EC:  BNZ   178F6
178EE:  MOVF   47,F
178F0:  BNZ   178F6
....................    { 
....................       RTC_Set(); 
178F2:  BRA    17722
....................    } 
178F4:  BRA    178FA
....................    else cmd_arg(); 
178F6:  CALL   B062
178FA:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
1826E:  MOVF   47,F
18270:  BNZ   1828C
18272:  MOVF   46,F
18274:  BNZ   1828C
18276:  MOVF   45,F
18278:  BNZ   1828C
1827A:  MOVF   44,W
1827C:  SUBLW  14
1827E:  BNC   1828C
....................       macro = arg; 
18280:  MOVFF  44,86F
....................       upload_macro(macro);    
18284:  MOVFF  86F,870
18288:  BRA    17FBC
....................    }    
1828A:  BRA    182A8
....................    else if (arg == 5525){ 
1828C:  MOVF   44,W
1828E:  SUBLW  95
18290:  BNZ   182A4
18292:  MOVF   45,W
18294:  SUBLW  15
18296:  BNZ   182A4
18298:  MOVF   46,F
1829A:  BNZ   182A4
1829C:  MOVF   47,F
1829E:  BNZ   182A4
....................       write_blank_macros(); 
182A0:  BRA    180F2
....................    } 
182A2:  BRA    182A8
....................    else cmd_arg(); 
182A4:  CALL   B062
182A8:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
183C6:  MOVF   47,F
183C8:  BNZ   183E4
183CA:  MOVF   46,F
183CC:  BNZ   183E4
183CE:  MOVF   45,F
183D0:  BNZ   183E4
183D2:  MOVF   44,W
183D4:  SUBLW  14
183D6:  BNC   183E4
....................       macro = arg;  
183D8:  MOVFF  44,86F
....................       read_macro(macro); 
183DC:  MOVFF  86F,870
183E0:  BRA    18360
....................    }    
183E2:  BRA    183E8
....................    else cmd_arg(); 
183E4:  CALL   B062
183E8:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
1853A:  DECFSZ 44,W
1853C:  BRA    18556
1853E:  MOVF   45,F
18540:  BNZ   18556
18542:  MOVF   46,F
18544:  BNZ   18556
18546:  MOVF   47,F
18548:  BNZ   18556
....................       RTC_alarm(); 
1854A:  BRA    183EC
....................       RTC_late(); 
1854C:  CALL   1537E
....................       RTC_alarm_status(); 
18550:  CALL   15838
....................    } 
18554:  BRA    1855A
....................    else cmd_arg(); 
18556:  CALL   B062
1855A:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
1855E:  MOVF   44,W
18560:  MOVWF  00
18562:  MOVF   45,W
18564:  MOVWF  03
18566:  BNZ   1856C
18568:  MOVF   00,F
1856A:  BZ    185A0
1856C:  MOVF   03,W
1856E:  BNZ   18576
18570:  MOVLW  02
18572:  SUBWF  00,W
18574:  BZ    185A0
18576:  MOVF   03,W
18578:  BNZ   18580
1857A:  MOVLW  03
1857C:  SUBWF  00,W
1857E:  BZ    185A0
18580:  MOVF   03,W
18582:  BNZ   1858A
18584:  MOVLW  04
18586:  SUBWF  00,W
18588:  BZ    185A0
1858A:  MOVF   03,W
1858C:  BNZ   18594
1858E:  MOVLW  05
18590:  SUBWF  00,W
18592:  BZ    185A0
18594:  MOVF   03,W
18596:  BNZ   1859E
18598:  MOVLW  06
1859A:  SUBWF  00,W
1859C:  BZ    185A0
1859E:  BRA    185BE
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
185A0:  MOVFF  45,20
185A4:  MOVFF  44,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
185A8:  MOVLW  1C
185AA:  MOVLB  8
185AC:  MOVWF  xD8
185AE:  MOVFF  20,8DA
185B2:  MOVFF  1F,8D9
185B6:  MOVLB  0
185B8:  CALL   501E
....................          break; 
185BC:  BRA    185C2
....................       default: cmd_arg(); 
185BE:  CALL   B062
....................          break; 
....................    } 
185C2:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
185C6:  CALL   2A14
....................     
....................    switch(arg){ 
185CA:  MOVFF  44,00
185CE:  MOVF   45,W
185D0:  MOVWF  03
185D2:  BNZ   185D8
185D4:  MOVF   00,F
185D6:  BZ    1865C
185D8:  MOVF   03,W
185DA:  BNZ   185E2
185DC:  MOVLW  0A
185DE:  SUBWF  00,W
185E0:  BZ    1865C
185E2:  MOVF   03,W
185E4:  BNZ   185EC
185E6:  MOVLW  01
185E8:  SUBWF  00,W
185EA:  BZ    18664
185EC:  MOVF   03,W
185EE:  BNZ   185F6
185F0:  MOVLW  0B
185F2:  SUBWF  00,W
185F4:  BZ    18664
185F6:  MOVF   03,W
185F8:  BNZ   18600
185FA:  MOVLW  14
185FC:  SUBWF  00,W
185FE:  BZ    1866E
18600:  MOVF   03,W
18602:  BNZ   1860A
18604:  MOVLW  15
18606:  SUBWF  00,W
18608:  BZ    18674
1860A:  MOVF   03,W
1860C:  BNZ   18614
1860E:  MOVLW  1E
18610:  SUBWF  00,W
18612:  BZ    1867A
18614:  MOVF   03,W
18616:  BNZ   1861E
18618:  MOVLW  1F
1861A:  SUBWF  00,W
1861C:  BZ    18680
1861E:  MOVF   03,W
18620:  BNZ   18628
18622:  MOVLW  28
18624:  SUBWF  00,W
18626:  BZ    18686
18628:  MOVF   03,W
1862A:  BNZ   18632
1862C:  MOVLW  29
1862E:  SUBWF  00,W
18630:  BZ    1868C
18632:  MOVF   03,W
18634:  BNZ   1863C
18636:  MOVLW  32
18638:  SUBWF  00,W
1863A:  BZ    18692
1863C:  MOVF   03,W
1863E:  BNZ   18646
18640:  MOVLW  33
18642:  SUBWF  00,W
18644:  BZ    18698
18646:  MOVF   03,W
18648:  BNZ   18650
1864A:  MOVLW  3C
1864C:  SUBWF  00,W
1864E:  BZ    1869E
18650:  MOVF   03,W
18652:  BNZ   1865A
18654:  MOVLW  3D
18656:  SUBWF  00,W
18658:  BZ    186AC
1865A:  BRA    186BE
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
1865C:  BCF    F90.7
....................                bus_pwr_status=0; 
1865E:  MOVLB  4
18660:  CLRF   xB2
....................          break; 
18662:  BRA    186C4
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
18664:  BSF    F90.7
....................                bus_pwr_status=1; 
18666:  MOVLW  01
18668:  MOVLB  4
1866A:  MOVWF  xB2
....................          break; 
1866C:  BRA    186C4
....................       case 20: output_bit(VMOT,OFF); 
1866E:  BCF    F8E.1
....................          break; 
18670:  MOVLB  4
18672:  BRA    186C4
....................       case 21: output_bit(VMOT,ON); 
18674:  BSF    F8E.1
....................          break; 
18676:  MOVLB  4
18678:  BRA    186C4
....................       case 30: output_bit(VENC1,OFF); 
1867A:  BCF    F8E.6
....................          break; 
1867C:  MOVLB  4
1867E:  BRA    186C4
....................       case 31: output_bit(VENC1,ON); 
18680:  BSF    F8E.6
....................          break; 
18682:  MOVLB  4
18684:  BRA    186C4
....................       case 40: output_bit(VENC2,OFF); 
18686:  BCF    F8E.7
....................          break; 
18688:  MOVLB  4
1868A:  BRA    186C4
....................       case 41: output_bit(VENC2,ON); 
1868C:  BSF    F8E.7
....................          break; 
1868E:  MOVLB  4
18690:  BRA    186C4
....................       case 50: output_bit(VHBRDG,OFF); 
18692:  BCF    F8E.2
....................          break; 
18694:  MOVLB  4
18696:  BRA    186C4
....................       case 51: output_bit(VHBRDG,ON); 
18698:  BSF    F8E.2
....................          break;          
1869A:  MOVLB  4
1869C:  BRA    186C4
....................       case 60: set_heaters(0); 
1869E:  MOVLB  8
186A0:  CLRF   xAF
186A2:  MOVLB  0
186A4:  CALL   124B0
....................          break; 
186A8:  MOVLB  4
186AA:  BRA    186C4
....................       case 61: set_heaters(3); 
186AC:  MOVLW  03
186AE:  MOVLB  8
186B0:  MOVWF  xAF
186B2:  MOVLB  0
186B4:  CALL   124B0
....................          break; 
186B8:  MOVLB  4
186BA:  BRA    186C4
186BC:  MOVLB  0
....................       default : cmd_arg(); 
186BE:  CALL   B062
....................          break;          
186C2:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
186C4:  MOVLB  0
186C6:  CALL   AE9E
186CA:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
186CE:  MOVF   44,F
186D0:  BNZ   186EC
186D2:  MOVF   45,F
186D4:  BNZ   186EC
186D6:  MOVF   46,F
186D8:  BNZ   186EC
186DA:  MOVF   47,F
186DC:  BNZ   186EC
....................       motor_sleep_rdy(); 
186DE:  CALL   29EC
....................       shutdown(); 
186E2:  CALL   1585A
....................       go_to_sleep(); 
186E6:  CALL   15AC2
....................    } 
186EA:  BRA    186F0
....................    else cmd_arg(); 
186EC:  CALL   B062
186F0:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
1881E:  DECFSZ 44,W
18820:  BRA    18832
18822:  MOVF   45,F
18824:  BNZ   18832
18826:  MOVF   46,F
18828:  BNZ   18832
1882A:  MOVF   47,F
1882C:  BNZ   18832
1882E:  BRA    18718
18830:  BRA    18836
....................    else cmd_arg(); 
18832:  CALL   B062
18836:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
1883A:  MOVF   47,F
1883C:  BNZ   188CC
1883E:  MOVF   46,F
18840:  BNZ   188CC
18842:  MOVF   45,W
18844:  SUBLW  27
18846:  BNC   188CC
18848:  BNZ   18850
1884A:  MOVF   44,W
1884C:  SUBLW  10
1884E:  BNC   188CC
....................       m_bklsh[motor] = arg; 
18850:  BCF    FD8.0
18852:  MOVLB  7
18854:  RLCF   x3C,W
18856:  CLRF   03
18858:  ADDLW  6E
1885A:  MOVWF  FE9
1885C:  MOVLW  07
1885E:  ADDWFC 03,W
18860:  MOVWF  FEA
18862:  MOVFF  44,FEF
18866:  MOVFF  45,FEC
....................       switch(motor){ 
1886A:  MOVF   x3C,W
1886C:  XORLW  00
1886E:  MOVLB  0
18870:  BZ    18878
18872:  XORLW  01
18874:  BZ    188A2
18876:  BRA    188CA
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
18878:  BCF    FD8.0
1887A:  MOVLB  7
1887C:  RLCF   x3C,W
1887E:  CLRF   03
18880:  ADDLW  6E
18882:  MOVWF  FE9
18884:  MOVLW  07
18886:  ADDWFC 03,W
18888:  MOVWF  FEA
1888A:  MOVFF  FEC,8DA
1888E:  MOVF   FED,F
18890:  MOVFF  FEF,8D9
18894:  MOVLW  72
18896:  MOVLB  8
18898:  MOVWF  xD8
1889A:  MOVLB  0
1889C:  CALL   501E
....................             break; 
188A0:  BRA    188CA
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
188A2:  BCF    FD8.0
188A4:  MOVLB  7
188A6:  RLCF   x3C,W
188A8:  CLRF   03
188AA:  ADDLW  6E
188AC:  MOVWF  FE9
188AE:  MOVLW  07
188B0:  ADDWFC 03,W
188B2:  MOVWF  FEA
188B4:  MOVFF  FEC,8DA
188B8:  MOVF   FED,F
188BA:  MOVFF  FEF,8D9
188BE:  MOVLW  74
188C0:  MOVLB  8
188C2:  MOVWF  xD8
188C4:  MOVLB  0
188C6:  CALL   501E
....................             break;             
....................       } 
....................    } 
188CA:  BRA    188D0
....................    else cmd_arg();    
188CC:  CALL   B062
188D0:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_c(){ 
....................    if(arg == 0){ 
188D4:  MOVF   44,F
188D6:  BNZ   188E8
188D8:  MOVF   45,F
188DA:  BNZ   188E8
188DC:  MOVF   46,F
188DE:  BNZ   188E8
188E0:  MOVF   47,F
188E2:  BNZ   188E8
....................       output_bit(PIN_J7,0); 
188E4:  BCF    F91.7
....................    }else if(arg == 1){ 
188E6:  BRA    18918
188E8:  DECFSZ 44,W
188EA:  BRA    188FC
188EC:  MOVF   45,F
188EE:  BNZ   188FC
188F0:  MOVF   46,F
188F2:  BNZ   188FC
188F4:  MOVF   47,F
188F6:  BNZ   188FC
....................       output_bit(PIN_J7,1); 
188F8:  BSF    F91.7
....................    }else{ 
188FA:  BRA    18918
....................       RTC_reset_HT(); 
188FC:  CALL   3506
....................       output_bit(RTC_CS, ENABLE); 
18900:  BCF    F91.0
....................       spi_write(0x89); 
18902:  MOVF   FC9,W
18904:  MOVLW  89
18906:  MOVWF  FC9
18908:  RRCF   FC7,W
1890A:  BNC   18908
....................       spi_write(arg); 
1890C:  MOVF   FC9,W
1890E:  MOVFF  44,FC9
18912:  RRCF   FC7,W
18914:  BNC   18912
....................       output_bit(RTC_CS, DISABLE); 
18916:  BSF    F91.0
....................    } 
18918:  GOTO   1ADE8 (RETURN)
.................... } 
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
1891C:  MOVF   47,F
1891E:  BNZ   189AA
18920:  MOVF   46,F
18922:  BNZ   189AA
18924:  MOVF   45,F
18926:  BNZ   189AA
18928:  MOVF   44,W
1892A:  SUBLW  01
1892C:  BNC   189AA
....................       m_pos_dir[motor] = arg; 
1892E:  BCF    FD8.0
18930:  MOVLB  7
18932:  RLCF   x3C,W
18934:  CLRF   03
18936:  ADDLW  4A
18938:  MOVWF  FE9
1893A:  MOVLW  07
1893C:  ADDWFC 03,W
1893E:  MOVWF  FEA
18940:  MOVFF  44,FEF
18944:  MOVFF  45,FEC
....................       switch(motor){ 
18948:  MOVF   x3C,W
1894A:  XORLW  00
1894C:  MOVLB  0
1894E:  BZ    18956
18950:  XORLW  01
18952:  BZ    18980
18954:  BRA    189A8
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
18956:  BCF    FD8.0
18958:  MOVLB  7
1895A:  RLCF   x3C,W
1895C:  CLRF   03
1895E:  ADDLW  4A
18960:  MOVWF  FE9
18962:  MOVLW  07
18964:  ADDWFC 03,W
18966:  MOVWF  FEA
18968:  MOVFF  FEC,8DA
1896C:  MOVF   FED,F
1896E:  MOVFF  FEF,8D9
18972:  MOVLW  92
18974:  MOVLB  8
18976:  MOVWF  xD8
18978:  MOVLB  0
1897A:  CALL   501E
....................             break; 
1897E:  BRA    189A8
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
18980:  BCF    FD8.0
18982:  MOVLB  7
18984:  RLCF   x3C,W
18986:  CLRF   03
18988:  ADDLW  4A
1898A:  MOVWF  FE9
1898C:  MOVLW  07
1898E:  ADDWFC 03,W
18990:  MOVWF  FEA
18992:  MOVFF  FEC,8DA
18996:  MOVF   FED,F
18998:  MOVFF  FEF,8D9
1899C:  MOVLW  94
1899E:  MOVLB  8
189A0:  MOVWF  xD8
189A2:  MOVLB  0
189A4:  CALL   501E
....................             break;             
....................       } 
....................    } 
189A8:  BRA    189AE
....................    else cmd_arg();    
189AA:  CALL   B062
189AE:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
189B2:  MOVF   47,F
189B4:  BNZ   18A44
189B6:  MOVF   46,F
189B8:  BNZ   18A44
189BA:  MOVF   45,W
189BC:  SUBLW  27
189BE:  BNC   18A44
189C0:  BNZ   189C8
189C2:  MOVF   44,W
189C4:  SUBLW  10
189C6:  BNC   18A44
....................       e_cpr[motor] = arg; 
189C8:  BCF    FD8.0
189CA:  MOVLB  7
189CC:  RLCF   x3C,W
189CE:  CLRF   03
189D0:  ADDLW  5A
189D2:  MOVWF  FE9
189D4:  MOVLW  07
189D6:  ADDWFC 03,W
189D8:  MOVWF  FEA
189DA:  MOVFF  44,FEF
189DE:  MOVFF  45,FEC
....................       switch(motor){ 
189E2:  MOVF   x3C,W
189E4:  XORLW  00
189E6:  MOVLB  0
189E8:  BZ    189F0
189EA:  XORLW  01
189EC:  BZ    18A1A
189EE:  BRA    18A42
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
189F0:  BCF    FD8.0
189F2:  MOVLB  7
189F4:  RLCF   x3C,W
189F6:  CLRF   03
189F8:  ADDLW  5A
189FA:  MOVWF  FE9
189FC:  MOVLW  07
189FE:  ADDWFC 03,W
18A00:  MOVWF  FEA
18A02:  MOVFF  FEC,8DA
18A06:  MOVF   FED,F
18A08:  MOVFF  FEF,8D9
18A0C:  MOVLW  A2
18A0E:  MOVLB  8
18A10:  MOVWF  xD8
18A12:  MOVLB  0
18A14:  CALL   501E
....................             break; 
18A18:  BRA    18A42
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
18A1A:  BCF    FD8.0
18A1C:  MOVLB  7
18A1E:  RLCF   x3C,W
18A20:  CLRF   03
18A22:  ADDLW  5A
18A24:  MOVWF  FE9
18A26:  MOVLW  07
18A28:  ADDWFC 03,W
18A2A:  MOVWF  FEA
18A2C:  MOVFF  FEC,8DA
18A30:  MOVF   FED,F
18A32:  MOVFF  FEF,8D9
18A36:  MOVLW  A4
18A38:  MOVLB  8
18A3A:  MOVWF  xD8
18A3C:  MOVLB  0
18A3E:  CALL   501E
....................             break;             
....................       } 
....................    } 
18A42:  BRA    18A48
....................    else cmd_arg();    
18A44:  CALL   B062
18A48:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
18A4C:  MOVF   47,F
18A4E:  BNZ   18A64
18A50:  MOVF   46,F
18A52:  BNZ   18A64
18A54:  MOVF   45,F
18A56:  BNZ   18A64
18A58:  MOVF   44,W
18A5A:  SUBLW  01
18A5C:  BNC   18A64
18A5E:  MOVFF  44,73D
18A62:  BRA    18A68
....................    else cmd_arg();    
18A64:  CALL   B062
18A68:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
18A6C:  MOVF   47,F
18A6E:  BNZ   18AFE
18A70:  MOVF   46,F
18A72:  BNZ   18AFE
18A74:  MOVF   45,W
18A76:  SUBLW  EA
18A78:  BNC   18AFE
18A7A:  BNZ   18A82
18A7C:  MOVF   44,W
18A7E:  SUBLW  60
18A80:  BNC   18AFE
....................       m_gb_err[motor] = arg; 
18A82:  BCF    FD8.0
18A84:  MOVLB  7
18A86:  RLCF   x3C,W
18A88:  CLRF   03
18A8A:  ADDLW  56
18A8C:  MOVWF  FE9
18A8E:  MOVLW  07
18A90:  ADDWFC 03,W
18A92:  MOVWF  FEA
18A94:  MOVFF  44,FEF
18A98:  MOVFF  45,FEC
....................       switch(motor){ 
18A9C:  MOVF   x3C,W
18A9E:  XORLW  00
18AA0:  MOVLB  0
18AA2:  BZ    18AAA
18AA4:  XORLW  01
18AA6:  BZ    18AD4
18AA8:  BRA    18AFC
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
18AAA:  BCF    FD8.0
18AAC:  MOVLB  7
18AAE:  RLCF   x3C,W
18AB0:  CLRF   03
18AB2:  ADDLW  56
18AB4:  MOVWF  FE9
18AB6:  MOVLW  07
18AB8:  ADDWFC 03,W
18ABA:  MOVWF  FEA
18ABC:  MOVFF  FEC,8DA
18AC0:  MOVF   FED,F
18AC2:  MOVFF  FEF,8D9
18AC6:  MOVLW  9E
18AC8:  MOVLB  8
18ACA:  MOVWF  xD8
18ACC:  MOVLB  0
18ACE:  CALL   501E
....................             break; 
18AD2:  BRA    18AFC
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
18AD4:  BCF    FD8.0
18AD6:  MOVLB  7
18AD8:  RLCF   x3C,W
18ADA:  CLRF   03
18ADC:  ADDLW  56
18ADE:  MOVWF  FE9
18AE0:  MOVLW  07
18AE2:  ADDWFC 03,W
18AE4:  MOVWF  FEA
18AE6:  MOVFF  FEC,8DA
18AEA:  MOVF   FED,F
18AEC:  MOVFF  FEF,8D9
18AF0:  MOVLW  A0
18AF2:  MOVLB  8
18AF4:  MOVWF  xD8
18AF6:  MOVLB  0
18AF8:  CALL   501E
....................             break;             
....................       } 
....................    } 
18AFC:  BRA    18B02
....................    else cmd_arg();    
18AFE:  CALL   B062
18B02:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
18B06:  MOVF   47,F
18B08:  BNZ   18BD2
18B0A:  MOVF   46,F
18B0C:  BNZ   18BD2
18B0E:  MOVF   45,F
18B10:  BNZ   18BD2
18B12:  MOVF   44,W
18B14:  SUBLW  64
18B16:  BNC   18BD2
....................       hold_pc=arg; 
18B18:  MOVFF  45,870
18B1C:  MOVFF  44,86F
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
18B20:  BCF    FD8.0
18B22:  MOVLB  7
18B24:  RLCF   x3C,W
18B26:  CLRF   03
18B28:  ADDLW  4E
18B2A:  MOVWF  FE9
18B2C:  MOVLW  07
18B2E:  ADDWFC 03,W
18B30:  MOVWF  FEA
18B32:  MOVFF  870,9F7
18B36:  MOVFF  86F,9F6
18B3A:  MOVLW  01
18B3C:  MOVLB  9
18B3E:  MOVWF  xF9
18B40:  SETF   xF8
18B42:  MOVLB  0
18B44:  CALL   5D06
18B48:  MOVFF  02,874
18B4C:  MOVFF  01,873
18B50:  MOVFF  02,8C6
18B54:  MOVFF  01,8C5
18B58:  MOVLB  8
18B5A:  CLRF   xC8
18B5C:  MOVLW  64
18B5E:  MOVWF  xC7
18B60:  MOVLB  0
18B62:  CALL   2D28
18B66:  MOVFF  01,FEF
18B6A:  MOVFF  02,FEC
....................       switch(motor){ 
18B6E:  MOVLB  7
18B70:  MOVF   x3C,W
18B72:  XORLW  00
18B74:  MOVLB  0
18B76:  BZ    18B7E
18B78:  XORLW  01
18B7A:  BZ    18BA8
18B7C:  BRA    18BD0
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
18B7E:  BCF    FD8.0
18B80:  MOVLB  7
18B82:  RLCF   x3C,W
18B84:  CLRF   03
18B86:  ADDLW  4E
18B88:  MOVWF  FE9
18B8A:  MOVLW  07
18B8C:  ADDWFC 03,W
18B8E:  MOVWF  FEA
18B90:  MOVFF  FEC,8DA
18B94:  MOVF   FED,F
18B96:  MOVFF  FEF,8D9
18B9A:  MOVLW  96
18B9C:  MOVLB  8
18B9E:  MOVWF  xD8
18BA0:  MOVLB  0
18BA2:  CALL   501E
....................             break; 
18BA6:  BRA    18BD0
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
18BA8:  BCF    FD8.0
18BAA:  MOVLB  7
18BAC:  RLCF   x3C,W
18BAE:  CLRF   03
18BB0:  ADDLW  4E
18BB2:  MOVWF  FE9
18BB4:  MOVLW  07
18BB6:  ADDWFC 03,W
18BB8:  MOVWF  FEA
18BBA:  MOVFF  FEC,8DA
18BBE:  MOVF   FED,F
18BC0:  MOVFF  FEF,8D9
18BC4:  MOVLW  98
18BC6:  MOVLB  8
18BC8:  MOVWF  xD8
18BCA:  MOVLB  0
18BCC:  CALL   501E
....................             break;             
....................       } 
....................    } 
18BD0:  BRA    18BD6
....................    else cmd_arg();    
18BD2:  CALL   B062
18BD6:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
18BDA:  MOVF   47,F
18BDC:  BNZ   18CAE
18BDE:  MOVF   46,F
18BE0:  BNZ   18CAE
18BE2:  MOVF   45,W
18BE4:  SUBLW  EA
18BE6:  BNC   18CAE
18BE8:  BNZ   18BF0
18BEA:  MOVF   44,W
18BEC:  SUBLW  60
18BEE:  BNC   18CAE
....................       m_stp_int[motor] = (arg/100); 
18BF0:  BCF    FD8.0
18BF2:  MOVLB  7
18BF4:  RLCF   x3C,W
18BF6:  CLRF   03
18BF8:  ADDLW  46
18BFA:  MOVWF  FE9
18BFC:  MOVLW  07
18BFE:  ADDWFC 03,W
18C00:  MOVWF  FEA
18C02:  MOVFF  FEA,872
18C06:  MOVFF  FE9,871
18C0A:  BCF    FD8.1
18C0C:  CLRF   1B
18C0E:  BTFSC  FF2.7
18C10:  BSF    1B.7
18C12:  BCF    FF2.7
18C14:  MOVFF  47,A34
18C18:  MOVFF  46,A33
18C1C:  MOVFF  45,A32
18C20:  MOVFF  44,A31
18C24:  MOVLB  A
18C26:  CLRF   x38
18C28:  CLRF   x37
18C2A:  CLRF   x36
18C2C:  MOVLW  64
18C2E:  MOVWF  x35
18C30:  MOVLB  0
18C32:  CALL   1042
18C36:  BTFSC  1B.7
18C38:  BSF    FF2.7
18C3A:  MOVFF  872,FEA
18C3E:  MOVFF  871,FE9
18C42:  MOVFF  00,FEF
18C46:  MOVFF  01,FEC
....................       switch(motor){ 
18C4A:  MOVLB  7
18C4C:  MOVF   x3C,W
18C4E:  XORLW  00
18C50:  MOVLB  0
18C52:  BZ    18C5A
18C54:  XORLW  01
18C56:  BZ    18C84
18C58:  BRA    18CAC
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
18C5A:  BCF    FD8.0
18C5C:  MOVLB  7
18C5E:  RLCF   x3C,W
18C60:  CLRF   03
18C62:  ADDLW  46
18C64:  MOVWF  FE9
18C66:  MOVLW  07
18C68:  ADDWFC 03,W
18C6A:  MOVWF  FEA
18C6C:  MOVFF  FEC,8DA
18C70:  MOVF   FED,F
18C72:  MOVFF  FEF,8D9
18C76:  MOVLW  8E
18C78:  MOVLB  8
18C7A:  MOVWF  xD8
18C7C:  MOVLB  0
18C7E:  CALL   501E
....................             break; 
18C82:  BRA    18CAC
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
18C84:  BCF    FD8.0
18C86:  MOVLB  7
18C88:  RLCF   x3C,W
18C8A:  CLRF   03
18C8C:  ADDLW  46
18C8E:  MOVWF  FE9
18C90:  MOVLW  07
18C92:  ADDWFC 03,W
18C94:  MOVWF  FEA
18C96:  MOVFF  FEC,8DA
18C9A:  MOVF   FED,F
18C9C:  MOVFF  FEF,8D9
18CA0:  MOVLW  90
18CA2:  MOVLB  8
18CA4:  MOVWF  xD8
18CA6:  MOVLB  0
18CA8:  CALL   501E
....................             break;             
....................       } 
....................    } 
18CAC:  BRA    18CB2
....................    else cmd_arg();    
18CAE:  CALL   B062
18CB2:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
18CB6:  MOVF   47,F
18CB8:  BNZ   18D48
18CBA:  MOVF   46,F
18CBC:  BNZ   18D48
18CBE:  MOVF   45,W
18CC0:  SUBLW  27
18CC2:  BNC   18D48
18CC4:  BNZ   18CCC
18CC6:  MOVF   44,W
18CC8:  SUBLW  10
18CCA:  BNC   18D48
....................       m_run[motor] = arg; 
18CCC:  BCF    FD8.0
18CCE:  MOVLB  7
18CD0:  RLCF   x3C,W
18CD2:  CLRF   03
18CD4:  ADDLW  6A
18CD6:  MOVWF  FE9
18CD8:  MOVLW  07
18CDA:  ADDWFC 03,W
18CDC:  MOVWF  FEA
18CDE:  MOVFF  44,FEF
18CE2:  MOVFF  45,FEC
....................       switch(motor){ 
18CE6:  MOVF   x3C,W
18CE8:  XORLW  00
18CEA:  MOVLB  0
18CEC:  BZ    18CF4
18CEE:  XORLW  01
18CF0:  BZ    18D1E
18CF2:  BRA    18D46
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
18CF4:  BCF    FD8.0
18CF6:  MOVLB  7
18CF8:  RLCF   x3C,W
18CFA:  CLRF   03
18CFC:  ADDLW  6A
18CFE:  MOVWF  FE9
18D00:  MOVLW  07
18D02:  ADDWFC 03,W
18D04:  MOVWF  FEA
18D06:  MOVFF  FEC,8DA
18D0A:  MOVF   FED,F
18D0C:  MOVFF  FEF,8D9
18D10:  MOVLW  76
18D12:  MOVLB  8
18D14:  MOVWF  xD8
18D16:  MOVLB  0
18D18:  CALL   501E
....................             break; 
18D1C:  BRA    18D46
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
18D1E:  BCF    FD8.0
18D20:  MOVLB  7
18D22:  RLCF   x3C,W
18D24:  CLRF   03
18D26:  ADDLW  6A
18D28:  MOVWF  FE9
18D2A:  MOVLW  07
18D2C:  ADDWFC 03,W
18D2E:  MOVWF  FEA
18D30:  MOVFF  FEC,8DA
18D34:  MOVF   FED,F
18D36:  MOVFF  FEF,8D9
18D3A:  MOVLW  78
18D3C:  MOVLB  8
18D3E:  MOVWF  xD8
18D40:  MOVLB  0
18D42:  CALL   501E
....................             break;             
....................       } 
....................    } 
18D46:  BRA    18D4C
....................    else cmd_arg();    
18D48:  CALL   B062
18D4C:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
18D50:  MOVF   47,F
18D52:  BNZ   18DDE
18D54:  MOVF   46,F
18D56:  BNZ   18DDE
18D58:  MOVF   45,F
18D5A:  BNZ   18DDE
18D5C:  MOVF   44,W
18D5E:  SUBLW  03
18D60:  BNC   18DDE
....................       e_mode[motor] = arg; 
18D62:  BCF    FD8.0
18D64:  MOVLB  7
18D66:  RLCF   x3C,W
18D68:  CLRF   03
18D6A:  ADDLW  62
18D6C:  MOVWF  FE9
18D6E:  MOVLW  07
18D70:  ADDWFC 03,W
18D72:  MOVWF  FEA
18D74:  MOVFF  44,FEF
18D78:  MOVFF  45,FEC
....................       switch(motor){ 
18D7C:  MOVF   x3C,W
18D7E:  XORLW  00
18D80:  MOVLB  0
18D82:  BZ    18D8A
18D84:  XORLW  01
18D86:  BZ    18DB4
18D88:  BRA    18DDC
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
18D8A:  BCF    FD8.0
18D8C:  MOVLB  7
18D8E:  RLCF   x3C,W
18D90:  CLRF   03
18D92:  ADDLW  62
18D94:  MOVWF  FE9
18D96:  MOVLW  07
18D98:  ADDWFC 03,W
18D9A:  MOVWF  FEA
18D9C:  MOVFF  FEC,8DA
18DA0:  MOVF   FED,F
18DA2:  MOVFF  FEF,8D9
18DA6:  MOVLW  82
18DA8:  MOVLB  8
18DAA:  MOVWF  xD8
18DAC:  MOVLB  0
18DAE:  CALL   501E
....................             break; 
18DB2:  BRA    18DDC
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
18DB4:  BCF    FD8.0
18DB6:  MOVLB  7
18DB8:  RLCF   x3C,W
18DBA:  CLRF   03
18DBC:  ADDLW  62
18DBE:  MOVWF  FE9
18DC0:  MOVLW  07
18DC2:  ADDWFC 03,W
18DC4:  MOVWF  FEA
18DC6:  MOVFF  FEC,8DA
18DCA:  MOVF   FED,F
18DCC:  MOVFF  FEF,8D9
18DD0:  MOVLW  84
18DD2:  MOVLB  8
18DD4:  MOVWF  xD8
18DD6:  MOVLB  0
18DD8:  CALL   501E
....................             break;             
....................       } 
....................    } 
18DDC:  BRA    18DE2
....................    else cmd_arg();    
18DDE:  CALL   B062
18DE2:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
19A46:  MOVF   47,F
19A48:  BNZ   19AD4
19A4A:  MOVF   46,F
19A4C:  BNZ   19AD4
19A4E:  MOVF   45,F
19A50:  BNZ   19AD4
19A52:  MOVF   44,W
19A54:  SUBLW  01
19A56:  BNC   19AD4
....................       m_mode[motor] = arg; 
19A58:  BCF    FD8.0
19A5A:  MOVLB  7
19A5C:  RLCF   x3C,W
19A5E:  CLRF   03
19A60:  ADDLW  42
19A62:  MOVWF  FE9
19A64:  MOVLW  07
19A66:  ADDWFC 03,W
19A68:  MOVWF  FEA
19A6A:  MOVFF  44,FEF
19A6E:  MOVFF  45,FEC
....................       switch(motor){ 
19A72:  MOVF   x3C,W
19A74:  XORLW  00
19A76:  MOVLB  0
19A78:  BZ    19A80
19A7A:  XORLW  01
19A7C:  BZ    19AAA
19A7E:  BRA    19AD2
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
19A80:  BCF    FD8.0
19A82:  MOVLB  7
19A84:  RLCF   x3C,W
19A86:  CLRF   03
19A88:  ADDLW  42
19A8A:  MOVWF  FE9
19A8C:  MOVLW  07
19A8E:  ADDWFC 03,W
19A90:  MOVWF  FEA
19A92:  MOVFF  FEC,8DA
19A96:  MOVF   FED,F
19A98:  MOVFF  FEF,8D9
19A9C:  MOVLW  8A
19A9E:  MOVLB  8
19AA0:  MOVWF  xD8
19AA2:  MOVLB  0
19AA4:  CALL   501E
....................             break; 
19AA8:  BRA    19AD2
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
19AAA:  BCF    FD8.0
19AAC:  MOVLB  7
19AAE:  RLCF   x3C,W
19AB0:  CLRF   03
19AB2:  ADDLW  42
19AB4:  MOVWF  FE9
19AB6:  MOVLW  07
19AB8:  ADDWFC 03,W
19ABA:  MOVWF  FEA
19ABC:  MOVFF  FEC,8DA
19AC0:  MOVF   FED,F
19AC2:  MOVFF  FEF,8D9
19AC6:  MOVLW  8C
19AC8:  MOVLB  8
19ACA:  MOVWF  xD8
19ACC:  MOVLB  0
19ACE:  CALL   501E
....................             break;             
....................       } 
....................    } 
19AD2:  BRA    19AD8
....................    else cmd_arg();    
19AD4:  CALL   B062
19AD8:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
19ADC:  MOVF   47,F
19ADE:  BNZ   19B6A
19AE0:  MOVF   46,F
19AE2:  BNZ   19B6A
19AE4:  MOVF   45,F
19AE6:  BNZ   19B6A
19AE8:  MOVF   44,W
19AEA:  SUBLW  01
19AEC:  BNC   19B6A
....................       e_index[motor] = arg; 
19AEE:  BCF    FD8.0
19AF0:  MOVLB  7
19AF2:  RLCF   x3C,W
19AF4:  CLRF   03
19AF6:  ADDLW  76
19AF8:  MOVWF  FE9
19AFA:  MOVLW  07
19AFC:  ADDWFC 03,W
19AFE:  MOVWF  FEA
19B00:  MOVFF  44,FEF
19B04:  MOVFF  45,FEC
....................       switch(motor){ 
19B08:  MOVF   x3C,W
19B0A:  XORLW  00
19B0C:  MOVLB  0
19B0E:  BZ    19B16
19B10:  XORLW  01
19B12:  BZ    19B40
19B14:  BRA    19B68
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
19B16:  BCF    FD8.0
19B18:  MOVLB  7
19B1A:  RLCF   x3C,W
19B1C:  CLRF   03
19B1E:  ADDLW  76
19B20:  MOVWF  FE9
19B22:  MOVLW  07
19B24:  ADDWFC 03,W
19B26:  MOVWF  FEA
19B28:  MOVFF  FEC,8DA
19B2C:  MOVF   FED,F
19B2E:  MOVFF  FEF,8D9
19B32:  MOVLW  BA
19B34:  MOVLB  8
19B36:  MOVWF  xD8
19B38:  MOVLB  0
19B3A:  CALL   501E
....................             break; 
19B3E:  BRA    19B68
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
19B40:  BCF    FD8.0
19B42:  MOVLB  7
19B44:  RLCF   x3C,W
19B46:  CLRF   03
19B48:  ADDLW  76
19B4A:  MOVWF  FE9
19B4C:  MOVLW  07
19B4E:  ADDWFC 03,W
19B50:  MOVWF  FEA
19B52:  MOVFF  FEC,8DA
19B56:  MOVF   FED,F
19B58:  MOVFF  FEF,8D9
19B5C:  MOVLW  BC
19B5E:  MOVLB  8
19B60:  MOVWF  xD8
19B62:  MOVLB  0
19B64:  CALL   501E
....................             break;             
....................       } 
....................    } 
19B68:  BRA    19B6E
....................    else cmd_arg();    
19B6A:  CALL   B062
19B6E:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
19B72:  MOVF   47,F
19B74:  BNZ   19C04
19B76:  MOVF   46,F
19B78:  BNZ   19C04
19B7A:  MOVF   45,W
19B7C:  SUBLW  01
19B7E:  BNC   19C04
19B80:  BNZ   19B88
19B82:  MOVF   44,W
19B84:  SUBLW  0A
19B86:  BNC   19C04
....................        evn_so[motor] = arg; 
19B88:  BCF    FD8.0
19B8A:  MOVLB  7
19B8C:  RLCF   x3C,W
19B8E:  CLRF   03
19B90:  ADDLW  7A
19B92:  MOVWF  FE9
19B94:  MOVLW  07
19B96:  ADDWFC 03,W
19B98:  MOVWF  FEA
19B9A:  MOVFF  44,FEF
19B9E:  MOVFF  45,FEC
....................        switch(motor){ 
19BA2:  MOVF   x3C,W
19BA4:  XORLW  00
19BA6:  MOVLB  0
19BA8:  BZ    19BB0
19BAA:  XORLW  01
19BAC:  BZ    19BDA
19BAE:  BRA    19C02
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
19BB0:  BCF    FD8.0
19BB2:  MOVLB  7
19BB4:  RLCF   x3C,W
19BB6:  CLRF   03
19BB8:  ADDLW  7A
19BBA:  MOVWF  FE9
19BBC:  MOVLW  07
19BBE:  ADDWFC 03,W
19BC0:  MOVWF  FEA
19BC2:  MOVFF  FEC,8DA
19BC6:  MOVF   FED,F
19BC8:  MOVFF  FEF,8D9
19BCC:  MOVLW  BE
19BCE:  MOVLB  8
19BD0:  MOVWF  xD8
19BD2:  MOVLB  0
19BD4:  CALL   501E
....................             break; 
19BD8:  BRA    19C02
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
19BDA:  BCF    FD8.0
19BDC:  MOVLB  7
19BDE:  RLCF   x3C,W
19BE0:  CLRF   03
19BE2:  ADDLW  7A
19BE4:  MOVWF  FE9
19BE6:  MOVLW  07
19BE8:  ADDWFC 03,W
19BEA:  MOVWF  FEA
19BEC:  MOVFF  FEC,8DA
19BF0:  MOVF   FED,F
19BF2:  MOVFF  FEF,8D9
19BF6:  MOVLW  C0
19BF8:  MOVLB  8
19BFA:  MOVWF  xD8
19BFC:  MOVLB  0
19BFE:  CALL   501E
....................             break;             
....................       } 
....................    } 
19C02:  BRA    19C08
....................    else cmd_arg();    
19C04:  CALL   B062
19C08:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
19C0C:  MOVF   47,F
19C0E:  BNZ   19C9E
19C10:  MOVF   46,F
19C12:  BNZ   19C9E
19C14:  MOVF   45,W
19C16:  SUBLW  03
19C18:  BNC   19C9E
19C1A:  BNZ   19C22
19C1C:  MOVF   44,W
19C1E:  SUBLW  E8
19C20:  BNC   19C9E
....................       e_ppr[motor] = arg; 
19C22:  BCF    FD8.0
19C24:  MOVLB  7
19C26:  RLCF   x3C,W
19C28:  CLRF   03
19C2A:  ADDLW  5E
19C2C:  MOVWF  FE9
19C2E:  MOVLW  07
19C30:  ADDWFC 03,W
19C32:  MOVWF  FEA
19C34:  MOVFF  44,FEF
19C38:  MOVFF  45,FEC
....................       switch(motor){ 
19C3C:  MOVF   x3C,W
19C3E:  XORLW  00
19C40:  MOVLB  0
19C42:  BZ    19C4A
19C44:  XORLW  01
19C46:  BZ    19C74
19C48:  BRA    19C9C
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
19C4A:  BCF    FD8.0
19C4C:  MOVLB  7
19C4E:  RLCF   x3C,W
19C50:  CLRF   03
19C52:  ADDLW  5E
19C54:  MOVWF  FE9
19C56:  MOVLW  07
19C58:  ADDWFC 03,W
19C5A:  MOVWF  FEA
19C5C:  MOVFF  FEC,8DA
19C60:  MOVF   FED,F
19C62:  MOVFF  FEF,8D9
19C66:  MOVLW  A6
19C68:  MOVLB  8
19C6A:  MOVWF  xD8
19C6C:  MOVLB  0
19C6E:  CALL   501E
....................             break; 
19C72:  BRA    19C9C
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
19C74:  BCF    FD8.0
19C76:  MOVLB  7
19C78:  RLCF   x3C,W
19C7A:  CLRF   03
19C7C:  ADDLW  5E
19C7E:  MOVWF  FE9
19C80:  MOVLW  07
19C82:  ADDWFC 03,W
19C84:  MOVWF  FEA
19C86:  MOVFF  FEC,8DA
19C8A:  MOVF   FED,F
19C8C:  MOVFF  FEF,8D9
19C90:  MOVLW  A8
19C92:  MOVLB  8
19C94:  MOVWF  xD8
19C96:  MOVLB  0
19C98:  CALL   501E
....................             break;             
....................       } 
....................    } 
19C9C:  BRA    19CA2
....................    else cmd_arg();    
19C9E:  CALL   B062
19CA2:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
19CA6:  MOVF   44,F
19CA8:  BNZ   19CBA
19CAA:  MOVF   45,F
19CAC:  BNZ   19CBA
19CAE:  MOVF   46,F
19CB0:  BNZ   19CBA
19CB2:  MOVF   47,F
19CB4:  BNZ   19CBA
19CB6:  BCF    F8E.1
19CB8:  BRA    19CBE
....................    else cmd_arg();    
19CBA:  CALL   B062
19CBE:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1A7A2:  MOVF   44,F
1A7A4:  BNZ   1A7F4
1A7A6:  MOVF   45,F
1A7A8:  BNZ   1A7F4
1A7AA:  MOVF   46,F
1A7AC:  BNZ   1A7F4
1A7AE:  MOVF   47,F
1A7B0:  BNZ   1A7F4
....................       switch (nv_product) { 
1A7B2:  MOVFF  2F,00
1A7B6:  MOVF   30,W
1A7B8:  MOVWF  03
1A7BA:  BNZ   1A7C0
1A7BC:  MOVF   00,F
1A7BE:  BZ    1A7E0
1A7C0:  MOVF   03,W
1A7C2:  BNZ   1A7CA
1A7C4:  MOVLW  01
1A7C6:  SUBWF  00,W
1A7C8:  BZ    1A7E6
1A7CA:  MOVF   03,W
1A7CC:  BNZ   1A7D4
1A7CE:  MOVLW  02
1A7D0:  SUBWF  00,W
1A7D2:  BZ    1A7EC
1A7D4:  MOVF   03,W
1A7D6:  BNZ   1A7DE
1A7D8:  MOVLW  03
1A7DA:  SUBWF  00,W
1A7DC:  BZ    1A7F0
1A7DE:  BRA    1A7F2
....................          case ECO : rst_step_vars_eco(); 
1A7E0:  GOTO   19CC2
....................             break; 
1A7E4:  BRA    1A7F2
....................          case WMS4 : rst_step_vars_wms4(); 
1A7E6:  GOTO   19FAC
....................             break; 
1A7EA:  BRA    1A7F2
....................          case AWS : rst_step_vars_aws(); 
1A7EC:  BRA    1A258
....................             break;             
1A7EE:  BRA    1A7F2
....................          case WMS2 : rst_step_vars_wms2(); 
1A7F0:  BRA    1A4F2
....................             break; 
....................       } 
....................    }  
1A7F2:  BRA    1A7F8
....................    else cmd_arg(); 
1A7F4:  CALL   B062
1A7F8:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1A7FC:  MOVF   47,F
1A7FE:  BTFSS  FD8.2
1A800:  BRA    1A902
1A802:  MOVF   46,W
1A804:  SUBLW  00
1A806:  BTFSS  FD8.0
1A808:  BRA    1A902
....................       m_spr[motor] = arg; 
1A80A:  BCF    FD8.0
1A80C:  MOVLB  7
1A80E:  RLCF   x3C,W
1A810:  CLRF   03
1A812:  ADDLW  72
1A814:  MOVWF  FE9
1A816:  MOVLW  07
1A818:  ADDWFC 03,W
1A81A:  MOVWF  FEA
1A81C:  MOVFF  44,FEF
1A820:  MOVFF  45,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1A824:  BCF    FD8.0
1A826:  RLCF   x3C,W
1A828:  CLRF   03
1A82A:  ADDLW  A7
1A82C:  MOVWF  01
1A82E:  MOVLW  07
1A830:  ADDWFC 03,F
1A832:  MOVFF  01,86F
1A836:  MOVLB  8
1A838:  MOVFF  03,870
1A83C:  BCF    FD8.0
1A83E:  MOVLB  7
1A840:  RLCF   x3C,W
1A842:  CLRF   03
1A844:  ADDLW  72
1A846:  MOVWF  FE9
1A848:  MOVLW  07
1A84A:  ADDWFC 03,W
1A84C:  MOVWF  FEA
1A84E:  MOVFF  FEC,8C6
1A852:  MOVF   FED,F
1A854:  MOVFF  FEF,8C5
1A858:  BCF    FD8.0
1A85A:  RLCF   x3C,W
1A85C:  CLRF   03
1A85E:  ADDLW  5E
1A860:  MOVWF  FE9
1A862:  MOVLW  07
1A864:  ADDWFC 03,W
1A866:  MOVWF  FEA
1A868:  MOVFF  FEC,03
1A86C:  MOVF   FED,F
1A86E:  MOVFF  FEF,8C7
1A872:  MOVFF  03,874
1A876:  MOVFF  03,8C8
1A87A:  MOVLB  0
1A87C:  CALL   2D28
1A880:  MOVFF  02,872
1A884:  BCF    FD8.0
1A886:  MOVLB  8
1A888:  RLCF   01,W
1A88A:  MOVWF  02
1A88C:  RLCF   x72,W
1A88E:  MOVFF  870,FEA
1A892:  MOVFF  86F,FE9
1A896:  MOVWF  FEC
1A898:  MOVF   FED,F
1A89A:  MOVFF  02,FEF
....................       switch(motor){ 
1A89E:  MOVLB  7
1A8A0:  MOVF   x3C,W
1A8A2:  XORLW  00
1A8A4:  MOVLB  0
1A8A6:  BZ    1A8AE
1A8A8:  XORLW  01
1A8AA:  BZ    1A8D8
1A8AC:  BRA    1A900
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1A8AE:  BCF    FD8.0
1A8B0:  MOVLB  7
1A8B2:  RLCF   x3C,W
1A8B4:  CLRF   03
1A8B6:  ADDLW  72
1A8B8:  MOVWF  FE9
1A8BA:  MOVLW  07
1A8BC:  ADDWFC 03,W
1A8BE:  MOVWF  FEA
1A8C0:  MOVFF  FEC,8DA
1A8C4:  MOVF   FED,F
1A8C6:  MOVFF  FEF,8D9
1A8CA:  MOVLW  AE
1A8CC:  MOVLB  8
1A8CE:  MOVWF  xD8
1A8D0:  MOVLB  0
1A8D2:  CALL   501E
....................             break; 
1A8D6:  BRA    1A900
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1A8D8:  BCF    FD8.0
1A8DA:  MOVLB  7
1A8DC:  RLCF   x3C,W
1A8DE:  CLRF   03
1A8E0:  ADDLW  72
1A8E2:  MOVWF  FE9
1A8E4:  MOVLW  07
1A8E6:  ADDWFC 03,W
1A8E8:  MOVWF  FEA
1A8EA:  MOVFF  FEC,8DA
1A8EE:  MOVF   FED,F
1A8F0:  MOVFF  FEF,8D9
1A8F4:  MOVLW  B0
1A8F6:  MOVLB  8
1A8F8:  MOVWF  xD8
1A8FA:  MOVLB  0
1A8FC:  CALL   501E
....................             break;             
....................       } 
....................    } 
1A900:  BRA    1A906
....................    else cmd_arg();    
1A902:  CALL   B062
1A906:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1A90A:  MOVF   47,F
1A90C:  BNZ   1A998
1A90E:  MOVF   46,F
1A910:  BNZ   1A998
1A912:  MOVF   45,F
1A914:  BNZ   1A998
1A916:  MOVF   44,W
1A918:  SUBLW  02
1A91A:  BNC   1A998
....................       e_type[motor] = arg; 
1A91C:  BCF    FD8.0
1A91E:  MOVLB  7
1A920:  RLCF   x3C,W
1A922:  CLRF   03
1A924:  ADDLW  66
1A926:  MOVWF  FE9
1A928:  MOVLW  07
1A92A:  ADDWFC 03,W
1A92C:  MOVWF  FEA
1A92E:  MOVFF  44,FEF
1A932:  MOVFF  45,FEC
....................       switch(motor){ 
1A936:  MOVF   x3C,W
1A938:  XORLW  00
1A93A:  MOVLB  0
1A93C:  BZ    1A944
1A93E:  XORLW  01
1A940:  BZ    1A96E
1A942:  BRA    1A996
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1A944:  BCF    FD8.0
1A946:  MOVLB  7
1A948:  RLCF   x3C,W
1A94A:  CLRF   03
1A94C:  ADDLW  66
1A94E:  MOVWF  FE9
1A950:  MOVLW  07
1A952:  ADDWFC 03,W
1A954:  MOVWF  FEA
1A956:  MOVFF  FEC,8DA
1A95A:  MOVF   FED,F
1A95C:  MOVFF  FEF,8D9
1A960:  MOVLW  7A
1A962:  MOVLB  8
1A964:  MOVWF  xD8
1A966:  MOVLB  0
1A968:  CALL   501E
....................             break; 
1A96C:  BRA    1A996
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1A96E:  BCF    FD8.0
1A970:  MOVLB  7
1A972:  RLCF   x3C,W
1A974:  CLRF   03
1A976:  ADDLW  66
1A978:  MOVWF  FE9
1A97A:  MOVLW  07
1A97C:  ADDWFC 03,W
1A97E:  MOVWF  FEA
1A980:  MOVFF  FEC,8DA
1A984:  MOVF   FED,F
1A986:  MOVFF  FEF,8D9
1A98A:  MOVLW  7C
1A98C:  MOVLB  8
1A98E:  MOVWF  xD8
1A990:  MOVLB  0
1A992:  CALL   501E
....................             break;             
....................       } 
....................    } 
1A996:  BRA    1A99C
....................    else cmd_arg();    
1A998:  CALL   B062
1A99C:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
*
1A9D8:  MOVF   47,F
1A9DA:  BNZ   1AAA4
1A9DC:  MOVF   46,F
1A9DE:  BNZ   1AAA4
1A9E0:  MOVF   45,F
1A9E2:  BNZ   1AAA4
1A9E4:  MOVF   44,W
1A9E6:  SUBLW  64
1A9E8:  BNC   1AAA4
....................       drive_pc=arg; 
1A9EA:  MOVFF  45,870
1A9EE:  MOVFF  44,86F
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1A9F2:  BCF    FD8.0
1A9F4:  MOVLB  7
1A9F6:  RLCF   x3C,W
1A9F8:  CLRF   03
1A9FA:  ADDLW  52
1A9FC:  MOVWF  FE9
1A9FE:  MOVLW  07
1AA00:  ADDWFC 03,W
1AA02:  MOVWF  FEA
1AA04:  MOVFF  870,9F7
1AA08:  MOVFF  86F,9F6
1AA0C:  MOVLW  01
1AA0E:  MOVLB  9
1AA10:  MOVWF  xF9
1AA12:  SETF   xF8
1AA14:  MOVLB  0
1AA16:  CALL   5D06
1AA1A:  MOVFF  02,874
1AA1E:  MOVFF  01,873
1AA22:  MOVFF  02,8C6
1AA26:  MOVFF  01,8C5
1AA2A:  MOVLB  8
1AA2C:  CLRF   xC8
1AA2E:  MOVLW  64
1AA30:  MOVWF  xC7
1AA32:  MOVLB  0
1AA34:  CALL   2D28
1AA38:  MOVFF  01,FEF
1AA3C:  MOVFF  02,FEC
....................       switch(motor){ 
1AA40:  MOVLB  7
1AA42:  MOVF   x3C,W
1AA44:  XORLW  00
1AA46:  MOVLB  0
1AA48:  BZ    1AA50
1AA4A:  XORLW  01
1AA4C:  BZ    1AA7A
1AA4E:  BRA    1AAA2
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1AA50:  BCF    FD8.0
1AA52:  MOVLB  7
1AA54:  RLCF   x3C,W
1AA56:  CLRF   03
1AA58:  ADDLW  52
1AA5A:  MOVWF  FE9
1AA5C:  MOVLW  07
1AA5E:  ADDWFC 03,W
1AA60:  MOVWF  FEA
1AA62:  MOVFF  FEC,8DA
1AA66:  MOVF   FED,F
1AA68:  MOVFF  FEF,8D9
1AA6C:  MOVLW  9A
1AA6E:  MOVLB  8
1AA70:  MOVWF  xD8
1AA72:  MOVLB  0
1AA74:  CALL   501E
....................             break; 
1AA78:  BRA    1AAA2
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1AA7A:  BCF    FD8.0
1AA7C:  MOVLB  7
1AA7E:  RLCF   x3C,W
1AA80:  CLRF   03
1AA82:  ADDLW  52
1AA84:  MOVWF  FE9
1AA86:  MOVLW  07
1AA88:  ADDWFC 03,W
1AA8A:  MOVWF  FEA
1AA8C:  MOVFF  FEC,8DA
1AA90:  MOVF   FED,F
1AA92:  MOVFF  FEF,8D9
1AA96:  MOVLW  9C
1AA98:  MOVLB  8
1AA9A:  MOVWF  xD8
1AA9C:  MOVLB  0
1AA9E:  CALL   501E
....................             break;             
....................       } 
....................    } 
1AAA2:  BRA    1AAA8
....................    else cmd_arg();    
1AAA4:  CALL   B062
1AAA8:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1AAAC:  MOVF   47,F
1AAAE:  BNZ   1AB3E
1AAB0:  MOVF   46,F
1AAB2:  BNZ   1AB3E
1AAB4:  MOVF   45,W
1AAB6:  SUBLW  27
1AAB8:  BNC   1AB3E
1AABA:  BNZ   1AAC2
1AABC:  MOVF   44,W
1AABE:  SUBLW  0F
1AAC0:  BNC   1AB3E
....................        align_os[motor] = arg; 
1AAC2:  BCF    FD8.0
1AAC4:  MOVLB  7
1AAC6:  RLCF   x3C,W
1AAC8:  CLRF   03
1AACA:  ADDLW  7E
1AACC:  MOVWF  FE9
1AACE:  MOVLW  07
1AAD0:  ADDWFC 03,W
1AAD2:  MOVWF  FEA
1AAD4:  MOVFF  44,FEF
1AAD8:  MOVFF  45,FEC
....................        switch(motor){ 
1AADC:  MOVF   x3C,W
1AADE:  XORLW  00
1AAE0:  MOVLB  0
1AAE2:  BZ    1AAEA
1AAE4:  XORLW  01
1AAE6:  BZ    1AB14
1AAE8:  BRA    1AB3C
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1AAEA:  BCF    FD8.0
1AAEC:  MOVLB  7
1AAEE:  RLCF   x3C,W
1AAF0:  CLRF   03
1AAF2:  ADDLW  7E
1AAF4:  MOVWF  FE9
1AAF6:  MOVLW  07
1AAF8:  ADDWFC 03,W
1AAFA:  MOVWF  FEA
1AAFC:  MOVFF  FEC,8DA
1AB00:  MOVF   FED,F
1AB02:  MOVFF  FEF,8D9
1AB06:  MOVLW  C2
1AB08:  MOVLB  8
1AB0A:  MOVWF  xD8
1AB0C:  MOVLB  0
1AB0E:  CALL   501E
....................             break; 
1AB12:  BRA    1AB3C
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1AB14:  BCF    FD8.0
1AB16:  MOVLB  7
1AB18:  RLCF   x3C,W
1AB1A:  CLRF   03
1AB1C:  ADDLW  7E
1AB1E:  MOVWF  FE9
1AB20:  MOVLW  07
1AB22:  ADDWFC 03,W
1AB24:  MOVWF  FEA
1AB26:  MOVFF  FEC,8DA
1AB2A:  MOVF   FED,F
1AB2C:  MOVFF  FEF,8D9
1AB30:  MOVLW  C4
1AB32:  MOVLB  8
1AB34:  MOVWF  xD8
1AB36:  MOVLB  0
1AB38:  CALL   501E
....................             break;             
....................       } 
....................    } 
1AB3C:  BRA    1AB42
....................    else cmd_arg();    
1AB3E:  CALL   B062
1AB42:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1AB46:  MOVF   47,F
1AB48:  BNZ   1ABD4
1AB4A:  MOVF   46,F
1AB4C:  BNZ   1ABD4
1AB4E:  MOVF   45,F
1AB50:  BNZ   1ABD4
1AB52:  MOVF   44,W
1AB54:  SUBLW  01
1AB56:  BNC   1ABD4
....................       m_ctrl[motor] = arg; 
1AB58:  BCF    FD8.0
1AB5A:  MOVLB  7
1AB5C:  RLCF   x3C,W
1AB5E:  CLRF   03
1AB60:  ADDLW  3E
1AB62:  MOVWF  FE9
1AB64:  MOVLW  07
1AB66:  ADDWFC 03,W
1AB68:  MOVWF  FEA
1AB6A:  MOVFF  44,FEF
1AB6E:  MOVFF  45,FEC
....................       switch(motor){ 
1AB72:  MOVF   x3C,W
1AB74:  XORLW  00
1AB76:  MOVLB  0
1AB78:  BZ    1AB80
1AB7A:  XORLW  01
1AB7C:  BZ    1ABAA
1AB7E:  BRA    1ABD2
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1AB80:  BCF    FD8.0
1AB82:  MOVLB  7
1AB84:  RLCF   x3C,W
1AB86:  CLRF   03
1AB88:  ADDLW  3E
1AB8A:  MOVWF  FE9
1AB8C:  MOVLW  07
1AB8E:  ADDWFC 03,W
1AB90:  MOVWF  FEA
1AB92:  MOVFF  FEC,8DA
1AB96:  MOVF   FED,F
1AB98:  MOVFF  FEF,8D9
1AB9C:  MOVLW  86
1AB9E:  MOVLB  8
1ABA0:  MOVWF  xD8
1ABA2:  MOVLB  0
1ABA4:  CALL   501E
....................             break; 
1ABA8:  BRA    1ABD2
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1ABAA:  BCF    FD8.0
1ABAC:  MOVLB  7
1ABAE:  RLCF   x3C,W
1ABB0:  CLRF   03
1ABB2:  ADDLW  3E
1ABB4:  MOVWF  FE9
1ABB6:  MOVLW  07
1ABB8:  ADDWFC 03,W
1ABBA:  MOVWF  FEA
1ABBC:  MOVFF  FEC,8DA
1ABC0:  MOVF   FED,F
1ABC2:  MOVFF  FEF,8D9
1ABC6:  MOVLW  88
1ABC8:  MOVLB  8
1ABCA:  MOVWF  xD8
1ABCC:  MOVLB  0
1ABCE:  CALL   501E
....................             break;             
....................       } 
....................    } 
1ABD2:  BRA    1ABD8
....................    else cmd_arg();    
1ABD4:  CALL   B062
1ABD8:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1A9A0:  MOVF   44,W
1A9A2:  MOVWF  00
1A9A4:  MOVF   45,W
1A9A6:  MOVWF  03
1A9A8:  BNZ   1A9B0
1A9AA:  MOVLW  01
1A9AC:  SUBWF  00,W
1A9AE:  BZ    1A9BC
1A9B0:  MOVF   03,W
1A9B2:  BNZ   1A9BA
1A9B4:  MOVLW  02
1A9B6:  SUBWF  00,W
1A9B8:  BZ    1A9C2
1A9BA:  BRA    1A9CC
....................       case 1: motor = 0; 
1A9BC:  MOVLB  7
1A9BE:  CLRF   x3C
....................          break; 
1A9C0:  BRA    1A9D2
....................       case 2: motor = 1; 
1A9C2:  MOVLW  01
1A9C4:  MOVLB  7
1A9C6:  MOVWF  x3C
....................          break; 
1A9C8:  BRA    1A9D2
1A9CA:  MOVLB  0
....................       default : cmd_arg(); 
1A9CC:  CALL   B062
....................          break; 
1A9D0:  MOVLB  7
....................    } 
1A9D2:  MOVLB  0
1A9D4:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1ABDC:  MOVF   44,F
1ABDE:  BNZ   1ABEC
1ABE0:  MOVF   45,F
1ABE2:  BNZ   1ABEC
1ABE4:  MOVF   46,F
1ABE6:  BNZ   1ABEC
1ABE8:  MOVF   47,F
1ABEA:  BZ    1AC4A
1ABEC:  MOVF   47,F
1ABEE:  BNZ   1AC4A
1ABF0:  MOVF   46,F
1ABF2:  BNZ   1AC4A
1ABF4:  MOVF   45,F
1ABF6:  BNZ   1AC4A
1ABF8:  MOVF   44,W
1ABFA:  SUBLW  02
1ABFC:  BNC   1AC4A
....................       switch(arg){ 
1ABFE:  MOVFF  44,00
1AC02:  MOVF   45,W
1AC04:  MOVWF  03
1AC06:  BNZ   1AC0E
1AC08:  MOVLW  01
1AC0A:  SUBWF  00,W
1AC0C:  BZ    1AC1A
1AC0E:  MOVF   03,W
1AC10:  BNZ   1AC18
1AC12:  MOVLW  02
1AC14:  SUBWF  00,W
1AC16:  BZ    1AC32
1AC18:  BRA    1AC48
....................          case 1 : e_pos[0] = 0; 
1AC1A:  MOVLB  7
1AC1C:  CLRF   xBC
1AC1E:  CLRF   xBB
....................                   write16(ADDR_E1_POS, 0); 
1AC20:  MOVLW  7E
1AC22:  MOVLB  8
1AC24:  MOVWF  xD8
1AC26:  CLRF   xDA
1AC28:  CLRF   xD9
1AC2A:  MOVLB  0
1AC2C:  CALL   501E
....................             break; 
1AC30:  BRA    1AC48
....................          case 2 : e_pos[1] = 0; 
1AC32:  MOVLB  7
1AC34:  CLRF   xBE
1AC36:  CLRF   xBD
....................                   write16(ADDR_E2_POS, 0); 
1AC38:  MOVLW  80
1AC3A:  MOVLB  8
1AC3C:  MOVWF  xD8
1AC3E:  CLRF   xDA
1AC40:  CLRF   xD9
1AC42:  MOVLB  0
1AC44:  CALL   501E
....................             break;             
....................       } 
....................    } 
1AC48:  BRA    1AC4E
....................    else cmd_arg();  
1AC4A:  CALL   B062
1AC4E:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
18DE6:  DECFSZ 44,W
18DE8:  GOTO   19A3E
18DEC:  MOVF   45,F
18DEE:  BTFSS  FD8.2
18DF0:  GOTO   19A3E
18DF4:  MOVF   46,F
18DF6:  BTFSS  FD8.2
18DF8:  GOTO   19A3E
18DFC:  MOVF   47,F
18DFE:  BTFSS  FD8.2
18E00:  GOTO   19A3E
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18E04:  MOVFF  74F,9F7
18E08:  MOVFF  74E,9F6
18E0C:  MOVLB  9
18E0E:  CLRF   xF9
18E10:  MOVLW  64
18E12:  MOVWF  xF8
18E14:  MOVLB  0
18E16:  CALL   5D06
18E1A:  MOVFF  02,876
18E1E:  MOVFF  01,875
18E22:  MOVFF  02,8C6
18E26:  MOVFF  01,8C5
18E2A:  MOVLW  01
18E2C:  MOVLB  8
18E2E:  MOVWF  xC8
18E30:  SETF   xC7
18E32:  MOVLB  0
18E34:  CALL   2D28
18E38:  MOVFF  02,870
18E3C:  MOVFF  01,86F
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
18E40:  MOVFF  753,9F7
18E44:  MOVFF  752,9F6
18E48:  MOVLB  9
18E4A:  CLRF   xF9
18E4C:  MOVLW  64
18E4E:  MOVWF  xF8
18E50:  MOVLB  0
18E52:  CALL   5D06
18E56:  MOVFF  02,876
18E5A:  MOVFF  01,875
18E5E:  MOVFF  02,8C6
18E62:  MOVFF  01,8C5
18E66:  MOVLW  01
18E68:  MOVLB  8
18E6A:  MOVWF  xC8
18E6C:  SETF   xC7
18E6E:  MOVLB  0
18E70:  CALL   2D28
18E74:  MOVFF  02,872
18E78:  MOVFF  01,871
....................       step_us  =   m_stp_int[0]*100; 
18E7C:  MOVFF  747,9F7
18E80:  MOVFF  746,9F6
18E84:  MOVLB  9
18E86:  CLRF   xF9
18E88:  MOVLW  64
18E8A:  MOVWF  xF8
18E8C:  MOVLB  0
18E8E:  CALL   5D06
18E92:  MOVFF  02,874
18E96:  MOVFF  01,873
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
18E9A:  MOVLW  06
18E9C:  MOVWF  FF6
18E9E:  MOVLW  27
18EA0:  MOVWF  FF7
18EA2:  MOVLW  00
18EA4:  MOVWF  FF8
18EA6:  CLRF   1B
18EA8:  BTFSC  FF2.7
18EAA:  BSF    1B.7
18EAC:  BCF    FF2.7
18EAE:  CALL   0E3A
18EB2:  BTFSC  1B.7
18EB4:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
18EB6:  MOVLW  62
18EB8:  BTFSS  F9E.4
18EBA:  BRA    18EB8
18EBC:  MOVWF  FAD
18EBE:  MOVLW  3A
18EC0:  BTFSS  F9E.4
18EC2:  BRA    18EC0
18EC4:  MOVWF  FAD
18EC6:  MOVLW  10
18EC8:  MOVWF  FE9
18ECA:  CLRF   1B
18ECC:  BTFSC  FF2.7
18ECE:  BSF    1B.7
18ED0:  BCF    FF2.7
18ED2:  MOVFF  76F,A26
18ED6:  MOVFF  76E,A25
18EDA:  CALL   1192
18EDE:  BTFSC  1B.7
18EE0:  BSF    FF2.7
18EE2:  MOVLW  0D
18EE4:  BTFSS  F9E.4
18EE6:  BRA    18EE4
18EE8:  MOVWF  FAD
18EEA:  MOVLW  0A
18EEC:  BTFSS  F9E.4
18EEE:  BRA    18EEC
18EF0:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
18EF2:  MOVLW  63
18EF4:  BTFSS  F9E.4
18EF6:  BRA    18EF4
18EF8:  MOVWF  FAD
18EFA:  MOVLW  3A
18EFC:  BTFSS  F9E.4
18EFE:  BRA    18EFC
18F00:  MOVWF  FAD
18F02:  MOVLW  41
18F04:  MOVWF  FE9
18F06:  CLRF   1B
18F08:  BTFSC  FF2.7
18F0A:  BSF    1B.7
18F0C:  BCF    FF2.7
18F0E:  MOVFF  7A1,A28
18F12:  MOVFF  7A0,A27
18F16:  MOVFF  79F,A26
18F1A:  MOVFF  79E,A25
18F1E:  CALL   10D6
18F22:  BTFSC  1B.7
18F24:  BSF    FF2.7
18F26:  MOVLW  2F
18F28:  BTFSS  F9E.4
18F2A:  BRA    18F28
18F2C:  MOVWF  FAD
18F2E:  MOVLW  10
18F30:  MOVWF  FE9
18F32:  CLRF   1B
18F34:  BTFSC  FF2.7
18F36:  BSF    1B.7
18F38:  BCF    FF2.7
18F3A:  MOVFF  7B8,A26
18F3E:  MOVFF  7B7,A25
18F42:  CALL   1192
18F46:  BTFSC  1B.7
18F48:  BSF    FF2.7
18F4A:  MOVLW  2F
18F4C:  BTFSS  F9E.4
18F4E:  BRA    18F4C
18F50:  MOVWF  FAD
18F52:  MOVLW  10
18F54:  MOVWF  FE9
18F56:  CLRF   1B
18F58:  BTFSC  FF2.7
18F5A:  BSF    1B.7
18F5C:  BCF    FF2.7
18F5E:  MOVFF  7BC,A26
18F62:  MOVFF  7BB,A25
18F66:  CALL   1192
18F6A:  BTFSC  1B.7
18F6C:  BSF    FF2.7
18F6E:  MOVLW  0D
18F70:  BTFSS  F9E.4
18F72:  BRA    18F70
18F74:  MOVWF  FAD
18F76:  MOVLW  0A
18F78:  BTFSS  F9E.4
18F7A:  BRA    18F78
18F7C:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
18F7E:  MOVLW  64
18F80:  BTFSS  F9E.4
18F82:  BRA    18F80
18F84:  MOVWF  FAD
18F86:  MOVLW  3A
18F88:  BTFSS  F9E.4
18F8A:  BRA    18F88
18F8C:  MOVWF  FAD
18F8E:  MOVLW  10
18F90:  MOVWF  FE9
18F92:  CLRF   1B
18F94:  BTFSC  FF2.7
18F96:  BSF    1B.7
18F98:  BCF    FF2.7
18F9A:  MOVFF  74B,A26
18F9E:  MOVFF  74A,A25
18FA2:  CALL   1192
18FA6:  BTFSC  1B.7
18FA8:  BSF    FF2.7
18FAA:  MOVLW  0D
18FAC:  BTFSS  F9E.4
18FAE:  BRA    18FAC
18FB0:  MOVWF  FAD
18FB2:  MOVLW  0A
18FB4:  BTFSS  F9E.4
18FB6:  BRA    18FB4
18FB8:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
18FBA:  MOVLW  65
18FBC:  BTFSS  F9E.4
18FBE:  BRA    18FBC
18FC0:  MOVWF  FAD
18FC2:  MOVLW  3A
18FC4:  BTFSS  F9E.4
18FC6:  BRA    18FC4
18FC8:  MOVWF  FAD
18FCA:  MOVLW  10
18FCC:  MOVWF  FE9
18FCE:  CLRF   1B
18FD0:  BTFSC  FF2.7
18FD2:  BSF    1B.7
18FD4:  BCF    FF2.7
18FD6:  MOVFF  75B,A26
18FDA:  MOVFF  75A,A25
18FDE:  CALL   1192
18FE2:  BTFSC  1B.7
18FE4:  BSF    FF2.7
18FE6:  MOVLW  0D
18FE8:  BTFSS  F9E.4
18FEA:  BRA    18FE8
18FEC:  MOVWF  FAD
18FEE:  MOVLW  0A
18FF0:  BTFSS  F9E.4
18FF2:  BRA    18FF0
18FF4:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
18FF6:  MOVLW  66
18FF8:  BTFSS  F9E.4
18FFA:  BRA    18FF8
18FFC:  MOVWF  FAD
18FFE:  MOVLW  3A
19000:  BTFSS  F9E.4
19002:  BRA    19000
19004:  MOVWF  FAD
19006:  CLRF   1B
19008:  BTFSC  FF2.7
1900A:  BSF    1B.7
1900C:  BCF    FF2.7
1900E:  MOVFF  73D,A25
19012:  MOVLW  1B
19014:  MOVLB  A
19016:  MOVWF  x26
19018:  MOVLB  0
1901A:  CALL   0F92
1901E:  BTFSC  1B.7
19020:  BSF    FF2.7
19022:  MOVLW  0D
19024:  BTFSS  F9E.4
19026:  BRA    19024
19028:  MOVWF  FAD
1902A:  MOVLW  0A
1902C:  BTFSS  F9E.4
1902E:  BRA    1902C
19030:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
19032:  MOVLW  67
19034:  BTFSS  F9E.4
19036:  BRA    19034
19038:  MOVWF  FAD
1903A:  MOVLW  3A
1903C:  BTFSS  F9E.4
1903E:  BRA    1903C
19040:  MOVWF  FAD
19042:  MOVLW  10
19044:  MOVWF  FE9
19046:  CLRF   1B
19048:  BTFSC  FF2.7
1904A:  BSF    1B.7
1904C:  BCF    FF2.7
1904E:  MOVFF  757,A26
19052:  MOVFF  756,A25
19056:  CALL   1192
1905A:  BTFSC  1B.7
1905C:  BSF    FF2.7
1905E:  MOVLW  0D
19060:  BTFSS  F9E.4
19062:  BRA    19060
19064:  MOVWF  FAD
19066:  MOVLW  0A
19068:  BTFSS  F9E.4
1906A:  BRA    19068
1906C:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
1906E:  MOVLW  68
19070:  BTFSS  F9E.4
19072:  BRA    19070
19074:  MOVWF  FAD
19076:  MOVLW  3A
19078:  BTFSS  F9E.4
1907A:  BRA    19078
1907C:  MOVWF  FAD
1907E:  MOVLW  10
19080:  MOVWF  FE9
19082:  CLRF   1B
19084:  BTFSC  FF2.7
19086:  BSF    1B.7
19088:  BCF    FF2.7
1908A:  MOVFF  870,A26
1908E:  MOVFF  86F,A25
19092:  CALL   1192
19096:  BTFSC  1B.7
19098:  BSF    FF2.7
1909A:  MOVLW  0D
1909C:  BTFSS  F9E.4
1909E:  BRA    1909C
190A0:  MOVWF  FAD
190A2:  MOVLW  0A
190A4:  BTFSS  F9E.4
190A6:  BRA    190A4
190A8:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
190AA:  MOVLW  69
190AC:  BTFSS  F9E.4
190AE:  BRA    190AC
190B0:  MOVWF  FAD
190B2:  MOVLW  3A
190B4:  BTFSS  F9E.4
190B6:  BRA    190B4
190B8:  MOVWF  FAD
190BA:  MOVLW  10
190BC:  MOVWF  FE9
190BE:  CLRF   1B
190C0:  BTFSC  FF2.7
190C2:  BSF    1B.7
190C4:  BCF    FF2.7
190C6:  MOVFF  874,A26
190CA:  MOVFF  873,A25
190CE:  CALL   1192
190D2:  BTFSC  1B.7
190D4:  BSF    FF2.7
190D6:  MOVLW  0D
190D8:  BTFSS  F9E.4
190DA:  BRA    190D8
190DC:  MOVWF  FAD
190DE:  MOVLW  0A
190E0:  BTFSS  F9E.4
190E2:  BRA    190E0
190E4:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
190E6:  MOVLW  6A
190E8:  BTFSS  F9E.4
190EA:  BRA    190E8
190EC:  MOVWF  FAD
190EE:  MOVLW  3A
190F0:  BTFSS  F9E.4
190F2:  BRA    190F0
190F4:  MOVWF  FAD
190F6:  MOVLW  10
190F8:  MOVWF  FE9
190FA:  CLRF   1B
190FC:  BTFSC  FF2.7
190FE:  BSF    1B.7
19100:  BCF    FF2.7
19102:  MOVFF  76B,A26
19106:  MOVFF  76A,A25
1910A:  CALL   1192
1910E:  BTFSC  1B.7
19110:  BSF    FF2.7
19112:  MOVLW  0D
19114:  BTFSS  F9E.4
19116:  BRA    19114
19118:  MOVWF  FAD
1911A:  MOVLW  0A
1911C:  BTFSS  F9E.4
1911E:  BRA    1911C
19120:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
19122:  MOVLW  6B
19124:  BTFSS  F9E.4
19126:  BRA    19124
19128:  MOVWF  FAD
1912A:  MOVLW  3A
1912C:  BTFSS  F9E.4
1912E:  BRA    1912C
19130:  MOVWF  FAD
19132:  MOVLW  10
19134:  MOVWF  FE9
19136:  CLRF   1B
19138:  BTFSC  FF2.7
1913A:  BSF    1B.7
1913C:  BCF    FF2.7
1913E:  MOVFF  763,A26
19142:  MOVFF  762,A25
19146:  CALL   1192
1914A:  BTFSC  1B.7
1914C:  BSF    FF2.7
1914E:  MOVLW  0D
19150:  BTFSS  F9E.4
19152:  BRA    19150
19154:  MOVWF  FAD
19156:  MOVLW  0A
19158:  BTFSS  F9E.4
1915A:  BRA    19158
1915C:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
1915E:  MOVLW  6D
19160:  BTFSS  F9E.4
19162:  BRA    19160
19164:  MOVWF  FAD
19166:  MOVLW  3A
19168:  BTFSS  F9E.4
1916A:  BRA    19168
1916C:  MOVWF  FAD
1916E:  MOVLW  10
19170:  MOVWF  FE9
19172:  CLRF   1B
19174:  BTFSC  FF2.7
19176:  BSF    1B.7
19178:  BCF    FF2.7
1917A:  MOVFF  743,A26
1917E:  MOVFF  742,A25
19182:  CALL   1192
19186:  BTFSC  1B.7
19188:  BSF    FF2.7
1918A:  MOVLW  0D
1918C:  BTFSS  F9E.4
1918E:  BRA    1918C
19190:  MOVWF  FAD
19192:  MOVLW  0A
19194:  BTFSS  F9E.4
19196:  BRA    19194
19198:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
1919A:  MOVLW  6E
1919C:  BTFSS  F9E.4
1919E:  BRA    1919C
191A0:  MOVWF  FAD
191A2:  MOVLW  3A
191A4:  BTFSS  F9E.4
191A6:  BRA    191A4
191A8:  MOVWF  FAD
191AA:  MOVLW  10
191AC:  MOVWF  FE9
191AE:  CLRF   1B
191B0:  BTFSC  FF2.7
191B2:  BSF    1B.7
191B4:  BCF    FF2.7
191B6:  MOVFF  777,A26
191BA:  MOVFF  776,A25
191BE:  CALL   1192
191C2:  BTFSC  1B.7
191C4:  BSF    FF2.7
191C6:  MOVLW  0D
191C8:  BTFSS  F9E.4
191CA:  BRA    191C8
191CC:  MOVWF  FAD
191CE:  MOVLW  0A
191D0:  BTFSS  F9E.4
191D2:  BRA    191D0
191D4:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
191D6:  MOVLW  6F
191D8:  BTFSS  F9E.4
191DA:  BRA    191D8
191DC:  MOVWF  FAD
191DE:  MOVLW  3A
191E0:  BTFSS  F9E.4
191E2:  BRA    191E0
191E4:  MOVWF  FAD
191E6:  MOVLW  10
191E8:  MOVWF  FE9
191EA:  CLRF   1B
191EC:  BTFSC  FF2.7
191EE:  BSF    1B.7
191F0:  BCF    FF2.7
191F2:  MOVFF  77B,A26
191F6:  MOVFF  77A,A25
191FA:  CALL   1192
191FE:  BTFSC  1B.7
19200:  BSF    FF2.7
19202:  MOVLW  0D
19204:  BTFSS  F9E.4
19206:  BRA    19204
19208:  MOVWF  FAD
1920A:  MOVLW  0A
1920C:  BTFSS  F9E.4
1920E:  BRA    1920C
19210:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
19212:  MOVLW  70
19214:  BTFSS  F9E.4
19216:  BRA    19214
19218:  MOVWF  FAD
1921A:  MOVLW  3A
1921C:  BTFSS  F9E.4
1921E:  BRA    1921C
19220:  MOVWF  FAD
19222:  MOVLW  10
19224:  MOVWF  FE9
19226:  CLRF   1B
19228:  BTFSC  FF2.7
1922A:  BSF    1B.7
1922C:  BCF    FF2.7
1922E:  MOVFF  7C0,A26
19232:  MOVFF  7BF,A25
19236:  CALL   1192
1923A:  BTFSC  1B.7
1923C:  BSF    FF2.7
1923E:  MOVLW  2F
19240:  BTFSS  F9E.4
19242:  BRA    19240
19244:  MOVWF  FAD
19246:  MOVLW  10
19248:  MOVWF  FE9
1924A:  CLRF   1B
1924C:  BTFSC  FF2.7
1924E:  BSF    1B.7
19250:  BCF    FF2.7
19252:  MOVFF  75F,A26
19256:  MOVFF  75E,A25
1925A:  CALL   1192
1925E:  BTFSC  1B.7
19260:  BSF    FF2.7
19262:  MOVLW  0D
19264:  BTFSS  F9E.4
19266:  BRA    19264
19268:  MOVWF  FAD
1926A:  MOVLW  0A
1926C:  BTFSS  F9E.4
1926E:  BRA    1926C
19270:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
19272:  MOVLW  71
19274:  BTFSS  F9E.4
19276:  BRA    19274
19278:  MOVWF  FAD
1927A:  MOVLW  3A
1927C:  BTFSS  F9E.4
1927E:  BRA    1927C
19280:  MOVWF  FAD
19282:  MOVLW  10
19284:  MOVWF  FE9
19286:  CLRF   1B
19288:  BTFSC  FF2.7
1928A:  BSF    1B.7
1928C:  BCF    FF2.7
1928E:  MOVFF  793,A26
19292:  MOVFF  792,A25
19296:  CALL   1192
1929A:  BTFSC  1B.7
1929C:  BSF    FF2.7
1929E:  MOVLW  0D
192A0:  BTFSS  F9E.4
192A2:  BRA    192A0
192A4:  MOVWF  FAD
192A6:  MOVLW  0A
192A8:  BTFSS  F9E.4
192AA:  BRA    192A8
192AC:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
192AE:  MOVLW  73
192B0:  BTFSS  F9E.4
192B2:  BRA    192B0
192B4:  MOVWF  FAD
192B6:  MOVLW  3A
192B8:  BTFSS  F9E.4
192BA:  BRA    192B8
192BC:  MOVWF  FAD
192BE:  MOVLW  10
192C0:  MOVWF  FE9
192C2:  CLRF   1B
192C4:  BTFSC  FF2.7
192C6:  BSF    1B.7
192C8:  BCF    FF2.7
192CA:  MOVFF  773,A26
192CE:  MOVFF  772,A25
192D2:  CALL   1192
192D6:  BTFSC  1B.7
192D8:  BSF    FF2.7
192DA:  MOVLW  0D
192DC:  BTFSS  F9E.4
192DE:  BRA    192DC
192E0:  MOVWF  FAD
192E2:  MOVLW  0A
192E4:  BTFSS  F9E.4
192E6:  BRA    192E4
192E8:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
192EA:  MOVLW  74
192EC:  BTFSS  F9E.4
192EE:  BRA    192EC
192F0:  MOVWF  FAD
192F2:  MOVLW  3A
192F4:  BTFSS  F9E.4
192F6:  BRA    192F4
192F8:  MOVWF  FAD
192FA:  MOVLW  10
192FC:  MOVWF  FE9
192FE:  CLRF   1B
19300:  BTFSC  FF2.7
19302:  BSF    1B.7
19304:  BCF    FF2.7
19306:  MOVFF  767,A26
1930A:  MOVFF  766,A25
1930E:  CALL   1192
19312:  BTFSC  1B.7
19314:  BSF    FF2.7
19316:  MOVLW  0D
19318:  BTFSS  F9E.4
1931A:  BRA    19318
1931C:  MOVWF  FAD
1931E:  MOVLW  0A
19320:  BTFSS  F9E.4
19322:  BRA    19320
19324:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19326:  MOVLW  01
19328:  MOVLB  7
1932A:  ADDWF  x3C,W
1932C:  MOVLB  8
1932E:  MOVWF  x75
19330:  MOVLW  75
19332:  BTFSS  F9E.4
19334:  BRA    19332
19336:  MOVWF  FAD
19338:  MOVLW  3A
1933A:  BTFSS  F9E.4
1933C:  BRA    1933A
1933E:  MOVWF  FAD
19340:  CLRF   1B
19342:  BTFSC  FF2.7
19344:  BSF    1B.7
19346:  BCF    FF2.7
19348:  MOVFF  875,A25
1934C:  MOVLW  1B
1934E:  MOVLB  A
19350:  MOVWF  x26
19352:  MOVLB  0
19354:  CALL   0F92
19358:  BTFSC  1B.7
1935A:  BSF    FF2.7
1935C:  MOVLW  0D
1935E:  BTFSS  F9E.4
19360:  BRA    1935E
19362:  MOVWF  FAD
19364:  MOVLW  0A
19366:  BTFSS  F9E.4
19368:  BRA    19366
1936A:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
1936C:  MOVLW  77
1936E:  BTFSS  F9E.4
19370:  BRA    1936E
19372:  MOVWF  FAD
19374:  MOVLW  3A
19376:  BTFSS  F9E.4
19378:  BRA    19376
1937A:  MOVWF  FAD
1937C:  MOVLW  10
1937E:  MOVWF  FE9
19380:  CLRF   1B
19382:  BTFSC  FF2.7
19384:  BSF    1B.7
19386:  BCF    FF2.7
19388:  MOVFF  872,A26
1938C:  MOVFF  871,A25
19390:  CALL   1192
19394:  BTFSC  1B.7
19396:  BSF    FF2.7
19398:  MOVLW  0D
1939A:  BTFSS  F9E.4
1939C:  BRA    1939A
1939E:  MOVWF  FAD
193A0:  MOVLW  0A
193A2:  BTFSS  F9E.4
193A4:  BRA    193A2
193A6:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
193A8:  MOVLW  78
193AA:  BTFSS  F9E.4
193AC:  BRA    193AA
193AE:  MOVWF  FAD
193B0:  MOVLW  3A
193B2:  BTFSS  F9E.4
193B4:  BRA    193B2
193B6:  MOVWF  FAD
193B8:  MOVLW  10
193BA:  MOVWF  FE9
193BC:  CLRF   1B
193BE:  BTFSC  FF2.7
193C0:  BSF    1B.7
193C2:  BCF    FF2.7
193C4:  MOVFF  77F,A26
193C8:  MOVFF  77E,A25
193CC:  CALL   1192
193D0:  BTFSC  1B.7
193D2:  BSF    FF2.7
193D4:  MOVLW  0D
193D6:  BTFSS  F9E.4
193D8:  BRA    193D6
193DA:  MOVWF  FAD
193DC:  MOVLW  0A
193DE:  BTFSS  F9E.4
193E0:  BRA    193DE
193E2:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
193E4:  MOVLW  79
193E6:  BTFSS  F9E.4
193E8:  BRA    193E6
193EA:  MOVWF  FAD
193EC:  MOVLW  3A
193EE:  BTFSS  F9E.4
193F0:  BRA    193EE
193F2:  MOVWF  FAD
193F4:  MOVLW  10
193F6:  MOVWF  FE9
193F8:  CLRF   1B
193FA:  BTFSC  FF2.7
193FC:  BSF    1B.7
193FE:  BCF    FF2.7
19400:  MOVFF  73F,A26
19404:  MOVFF  73E,A25
19408:  CALL   1192
1940C:  BTFSC  1B.7
1940E:  BSF    FF2.7
19410:  MOVLW  0D
19412:  BTFSS  F9E.4
19414:  BRA    19412
19416:  MOVWF  FAD
19418:  MOVLW  0A
1941A:  BTFSS  F9E.4
1941C:  BRA    1941A
1941E:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19420:  MOVFF  751,9F7
19424:  MOVFF  750,9F6
19428:  MOVLB  9
1942A:  CLRF   xF9
1942C:  MOVLW  64
1942E:  MOVWF  xF8
19430:  MOVLB  0
19432:  CALL   5D06
19436:  MOVFF  02,876
1943A:  MOVFF  01,875
1943E:  MOVFF  02,8C6
19442:  MOVFF  01,8C5
19446:  MOVLW  01
19448:  MOVLB  8
1944A:  MOVWF  xC8
1944C:  SETF   xC7
1944E:  MOVLB  0
19450:  CALL   2D28
19454:  MOVFF  02,870
19458:  MOVFF  01,86F
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
1945C:  MOVFF  755,9F7
19460:  MOVFF  754,9F6
19464:  MOVLB  9
19466:  CLRF   xF9
19468:  MOVLW  64
1946A:  MOVWF  xF8
1946C:  MOVLB  0
1946E:  CALL   5D06
19472:  MOVFF  02,876
19476:  MOVFF  01,875
1947A:  MOVFF  02,8C6
1947E:  MOVFF  01,8C5
19482:  MOVLW  01
19484:  MOVLB  8
19486:  MOVWF  xC8
19488:  SETF   xC7
1948A:  MOVLB  0
1948C:  CALL   2D28
19490:  MOVFF  02,872
19494:  MOVFF  01,871
....................       step_us  =   m_stp_int[1]*100; 
19498:  MOVFF  749,9F7
1949C:  MOVFF  748,9F6
194A0:  MOVLB  9
194A2:  CLRF   xF9
194A4:  MOVLW  64
194A6:  MOVWF  xF8
194A8:  MOVLB  0
194AA:  CALL   5D06
194AE:  MOVFF  02,874
194B2:  MOVFF  01,873
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
194B6:  MOVLW  12
194B8:  MOVWF  FF6
194BA:  MOVLW  27
194BC:  MOVWF  FF7
194BE:  MOVLW  00
194C0:  MOVWF  FF8
194C2:  CLRF   1B
194C4:  BTFSC  FF2.7
194C6:  BSF    1B.7
194C8:  BCF    FF2.7
194CA:  CALL   0E3A
194CE:  BTFSC  1B.7
194D0:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
194D2:  MOVLW  62
194D4:  BTFSS  F9E.4
194D6:  BRA    194D4
194D8:  MOVWF  FAD
194DA:  MOVLW  3A
194DC:  BTFSS  F9E.4
194DE:  BRA    194DC
194E0:  MOVWF  FAD
194E2:  MOVLW  10
194E4:  MOVWF  FE9
194E6:  CLRF   1B
194E8:  BTFSC  FF2.7
194EA:  BSF    1B.7
194EC:  BCF    FF2.7
194EE:  MOVFF  771,A26
194F2:  MOVFF  770,A25
194F6:  CALL   1192
194FA:  BTFSC  1B.7
194FC:  BSF    FF2.7
194FE:  MOVLW  0D
19500:  BTFSS  F9E.4
19502:  BRA    19500
19504:  MOVWF  FAD
19506:  MOVLW  0A
19508:  BTFSS  F9E.4
1950A:  BRA    19508
1950C:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
1950E:  MOVLW  63
19510:  BTFSS  F9E.4
19512:  BRA    19510
19514:  MOVWF  FAD
19516:  MOVLW  3A
19518:  BTFSS  F9E.4
1951A:  BRA    19518
1951C:  MOVWF  FAD
1951E:  MOVLW  41
19520:  MOVWF  FE9
19522:  CLRF   1B
19524:  BTFSC  FF2.7
19526:  BSF    1B.7
19528:  BCF    FF2.7
1952A:  MOVFF  7A5,A28
1952E:  MOVFF  7A4,A27
19532:  MOVFF  7A3,A26
19536:  MOVFF  7A2,A25
1953A:  CALL   10D6
1953E:  BTFSC  1B.7
19540:  BSF    FF2.7
19542:  MOVLW  2F
19544:  BTFSS  F9E.4
19546:  BRA    19544
19548:  MOVWF  FAD
1954A:  MOVLW  10
1954C:  MOVWF  FE9
1954E:  CLRF   1B
19550:  BTFSC  FF2.7
19552:  BSF    1B.7
19554:  BCF    FF2.7
19556:  MOVFF  7BA,A26
1955A:  MOVFF  7B9,A25
1955E:  CALL   1192
19562:  BTFSC  1B.7
19564:  BSF    FF2.7
19566:  MOVLW  2F
19568:  BTFSS  F9E.4
1956A:  BRA    19568
1956C:  MOVWF  FAD
1956E:  MOVLW  10
19570:  MOVWF  FE9
19572:  CLRF   1B
19574:  BTFSC  FF2.7
19576:  BSF    1B.7
19578:  BCF    FF2.7
1957A:  MOVFF  7BE,A26
1957E:  MOVFF  7BD,A25
19582:  CALL   1192
19586:  BTFSC  1B.7
19588:  BSF    FF2.7
1958A:  MOVLW  0D
1958C:  BTFSS  F9E.4
1958E:  BRA    1958C
19590:  MOVWF  FAD
19592:  MOVLW  0A
19594:  BTFSS  F9E.4
19596:  BRA    19594
19598:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
1959A:  MOVLW  64
1959C:  BTFSS  F9E.4
1959E:  BRA    1959C
195A0:  MOVWF  FAD
195A2:  MOVLW  3A
195A4:  BTFSS  F9E.4
195A6:  BRA    195A4
195A8:  MOVWF  FAD
195AA:  MOVLW  10
195AC:  MOVWF  FE9
195AE:  CLRF   1B
195B0:  BTFSC  FF2.7
195B2:  BSF    1B.7
195B4:  BCF    FF2.7
195B6:  MOVFF  74D,A26
195BA:  MOVFF  74C,A25
195BE:  CALL   1192
195C2:  BTFSC  1B.7
195C4:  BSF    FF2.7
195C6:  MOVLW  0D
195C8:  BTFSS  F9E.4
195CA:  BRA    195C8
195CC:  MOVWF  FAD
195CE:  MOVLW  0A
195D0:  BTFSS  F9E.4
195D2:  BRA    195D0
195D4:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
195D6:  MOVLW  65
195D8:  BTFSS  F9E.4
195DA:  BRA    195D8
195DC:  MOVWF  FAD
195DE:  MOVLW  3A
195E0:  BTFSS  F9E.4
195E2:  BRA    195E0
195E4:  MOVWF  FAD
195E6:  MOVLW  10
195E8:  MOVWF  FE9
195EA:  CLRF   1B
195EC:  BTFSC  FF2.7
195EE:  BSF    1B.7
195F0:  BCF    FF2.7
195F2:  MOVFF  75D,A26
195F6:  MOVFF  75C,A25
195FA:  CALL   1192
195FE:  BTFSC  1B.7
19600:  BSF    FF2.7
19602:  MOVLW  0D
19604:  BTFSS  F9E.4
19606:  BRA    19604
19608:  MOVWF  FAD
1960A:  MOVLW  0A
1960C:  BTFSS  F9E.4
1960E:  BRA    1960C
19610:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19612:  MOVLW  66
19614:  BTFSS  F9E.4
19616:  BRA    19614
19618:  MOVWF  FAD
1961A:  MOVLW  3A
1961C:  BTFSS  F9E.4
1961E:  BRA    1961C
19620:  MOVWF  FAD
19622:  CLRF   1B
19624:  BTFSC  FF2.7
19626:  BSF    1B.7
19628:  BCF    FF2.7
1962A:  MOVFF  73D,A25
1962E:  MOVLW  1B
19630:  MOVLB  A
19632:  MOVWF  x26
19634:  MOVLB  0
19636:  CALL   0F92
1963A:  BTFSC  1B.7
1963C:  BSF    FF2.7
1963E:  MOVLW  0D
19640:  BTFSS  F9E.4
19642:  BRA    19640
19644:  MOVWF  FAD
19646:  MOVLW  0A
19648:  BTFSS  F9E.4
1964A:  BRA    19648
1964C:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
1964E:  MOVLW  67
19650:  BTFSS  F9E.4
19652:  BRA    19650
19654:  MOVWF  FAD
19656:  MOVLW  3A
19658:  BTFSS  F9E.4
1965A:  BRA    19658
1965C:  MOVWF  FAD
1965E:  MOVLW  10
19660:  MOVWF  FE9
19662:  CLRF   1B
19664:  BTFSC  FF2.7
19666:  BSF    1B.7
19668:  BCF    FF2.7
1966A:  MOVFF  759,A26
1966E:  MOVFF  758,A25
19672:  CALL   1192
19676:  BTFSC  1B.7
19678:  BSF    FF2.7
1967A:  MOVLW  0D
1967C:  BTFSS  F9E.4
1967E:  BRA    1967C
19680:  MOVWF  FAD
19682:  MOVLW  0A
19684:  BTFSS  F9E.4
19686:  BRA    19684
19688:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
1968A:  MOVLW  68
1968C:  BTFSS  F9E.4
1968E:  BRA    1968C
19690:  MOVWF  FAD
19692:  MOVLW  3A
19694:  BTFSS  F9E.4
19696:  BRA    19694
19698:  MOVWF  FAD
1969A:  MOVLW  10
1969C:  MOVWF  FE9
1969E:  CLRF   1B
196A0:  BTFSC  FF2.7
196A2:  BSF    1B.7
196A4:  BCF    FF2.7
196A6:  MOVFF  870,A26
196AA:  MOVFF  86F,A25
196AE:  CALL   1192
196B2:  BTFSC  1B.7
196B4:  BSF    FF2.7
196B6:  MOVLW  0D
196B8:  BTFSS  F9E.4
196BA:  BRA    196B8
196BC:  MOVWF  FAD
196BE:  MOVLW  0A
196C0:  BTFSS  F9E.4
196C2:  BRA    196C0
196C4:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
196C6:  MOVLW  69
196C8:  BTFSS  F9E.4
196CA:  BRA    196C8
196CC:  MOVWF  FAD
196CE:  MOVLW  3A
196D0:  BTFSS  F9E.4
196D2:  BRA    196D0
196D4:  MOVWF  FAD
196D6:  MOVLW  10
196D8:  MOVWF  FE9
196DA:  CLRF   1B
196DC:  BTFSC  FF2.7
196DE:  BSF    1B.7
196E0:  BCF    FF2.7
196E2:  MOVFF  874,A26
196E6:  MOVFF  873,A25
196EA:  CALL   1192
196EE:  BTFSC  1B.7
196F0:  BSF    FF2.7
196F2:  MOVLW  0D
196F4:  BTFSS  F9E.4
196F6:  BRA    196F4
196F8:  MOVWF  FAD
196FA:  MOVLW  0A
196FC:  BTFSS  F9E.4
196FE:  BRA    196FC
19700:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
19702:  MOVLW  6A
19704:  BTFSS  F9E.4
19706:  BRA    19704
19708:  MOVWF  FAD
1970A:  MOVLW  3A
1970C:  BTFSS  F9E.4
1970E:  BRA    1970C
19710:  MOVWF  FAD
19712:  MOVLW  10
19714:  MOVWF  FE9
19716:  CLRF   1B
19718:  BTFSC  FF2.7
1971A:  BSF    1B.7
1971C:  BCF    FF2.7
1971E:  MOVFF  76D,A26
19722:  MOVFF  76C,A25
19726:  CALL   1192
1972A:  BTFSC  1B.7
1972C:  BSF    FF2.7
1972E:  MOVLW  0D
19730:  BTFSS  F9E.4
19732:  BRA    19730
19734:  MOVWF  FAD
19736:  MOVLW  0A
19738:  BTFSS  F9E.4
1973A:  BRA    19738
1973C:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
1973E:  MOVLW  6B
19740:  BTFSS  F9E.4
19742:  BRA    19740
19744:  MOVWF  FAD
19746:  MOVLW  3A
19748:  BTFSS  F9E.4
1974A:  BRA    19748
1974C:  MOVWF  FAD
1974E:  MOVLW  10
19750:  MOVWF  FE9
19752:  CLRF   1B
19754:  BTFSC  FF2.7
19756:  BSF    1B.7
19758:  BCF    FF2.7
1975A:  MOVFF  765,A26
1975E:  MOVFF  764,A25
19762:  CALL   1192
19766:  BTFSC  1B.7
19768:  BSF    FF2.7
1976A:  MOVLW  0D
1976C:  BTFSS  F9E.4
1976E:  BRA    1976C
19770:  MOVWF  FAD
19772:  MOVLW  0A
19774:  BTFSS  F9E.4
19776:  BRA    19774
19778:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
1977A:  MOVLW  6D
1977C:  BTFSS  F9E.4
1977E:  BRA    1977C
19780:  MOVWF  FAD
19782:  MOVLW  3A
19784:  BTFSS  F9E.4
19786:  BRA    19784
19788:  MOVWF  FAD
1978A:  MOVLW  10
1978C:  MOVWF  FE9
1978E:  CLRF   1B
19790:  BTFSC  FF2.7
19792:  BSF    1B.7
19794:  BCF    FF2.7
19796:  MOVFF  745,A26
1979A:  MOVFF  744,A25
1979E:  CALL   1192
197A2:  BTFSC  1B.7
197A4:  BSF    FF2.7
197A6:  MOVLW  0D
197A8:  BTFSS  F9E.4
197AA:  BRA    197A8
197AC:  MOVWF  FAD
197AE:  MOVLW  0A
197B0:  BTFSS  F9E.4
197B2:  BRA    197B0
197B4:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
197B6:  MOVLW  6E
197B8:  BTFSS  F9E.4
197BA:  BRA    197B8
197BC:  MOVWF  FAD
197BE:  MOVLW  3A
197C0:  BTFSS  F9E.4
197C2:  BRA    197C0
197C4:  MOVWF  FAD
197C6:  MOVLW  10
197C8:  MOVWF  FE9
197CA:  CLRF   1B
197CC:  BTFSC  FF2.7
197CE:  BSF    1B.7
197D0:  BCF    FF2.7
197D2:  MOVFF  779,A26
197D6:  MOVFF  778,A25
197DA:  CALL   1192
197DE:  BTFSC  1B.7
197E0:  BSF    FF2.7
197E2:  MOVLW  0D
197E4:  BTFSS  F9E.4
197E6:  BRA    197E4
197E8:  MOVWF  FAD
197EA:  MOVLW  0A
197EC:  BTFSS  F9E.4
197EE:  BRA    197EC
197F0:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
197F2:  MOVLW  6F
197F4:  BTFSS  F9E.4
197F6:  BRA    197F4
197F8:  MOVWF  FAD
197FA:  MOVLW  3A
197FC:  BTFSS  F9E.4
197FE:  BRA    197FC
19800:  MOVWF  FAD
19802:  MOVLW  10
19804:  MOVWF  FE9
19806:  CLRF   1B
19808:  BTFSC  FF2.7
1980A:  BSF    1B.7
1980C:  BCF    FF2.7
1980E:  MOVFF  77D,A26
19812:  MOVFF  77C,A25
19816:  CALL   1192
1981A:  BTFSC  1B.7
1981C:  BSF    FF2.7
1981E:  MOVLW  0D
19820:  BTFSS  F9E.4
19822:  BRA    19820
19824:  MOVWF  FAD
19826:  MOVLW  0A
19828:  BTFSS  F9E.4
1982A:  BRA    19828
1982C:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
1982E:  MOVLW  70
19830:  BTFSS  F9E.4
19832:  BRA    19830
19834:  MOVWF  FAD
19836:  MOVLW  3A
19838:  BTFSS  F9E.4
1983A:  BRA    19838
1983C:  MOVWF  FAD
1983E:  MOVLW  10
19840:  MOVWF  FE9
19842:  CLRF   1B
19844:  BTFSC  FF2.7
19846:  BSF    1B.7
19848:  BCF    FF2.7
1984A:  MOVFF  7C2,A26
1984E:  MOVFF  7C1,A25
19852:  CALL   1192
19856:  BTFSC  1B.7
19858:  BSF    FF2.7
1985A:  MOVLW  2F
1985C:  BTFSS  F9E.4
1985E:  BRA    1985C
19860:  MOVWF  FAD
19862:  MOVLW  10
19864:  MOVWF  FE9
19866:  CLRF   1B
19868:  BTFSC  FF2.7
1986A:  BSF    1B.7
1986C:  BCF    FF2.7
1986E:  MOVFF  761,A26
19872:  MOVFF  760,A25
19876:  CALL   1192
1987A:  BTFSC  1B.7
1987C:  BSF    FF2.7
1987E:  MOVLW  0D
19880:  BTFSS  F9E.4
19882:  BRA    19880
19884:  MOVWF  FAD
19886:  MOVLW  0A
19888:  BTFSS  F9E.4
1988A:  BRA    19888
1988C:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
1988E:  MOVLW  71
19890:  BTFSS  F9E.4
19892:  BRA    19890
19894:  MOVWF  FAD
19896:  MOVLW  3A
19898:  BTFSS  F9E.4
1989A:  BRA    19898
1989C:  MOVWF  FAD
1989E:  MOVLW  10
198A0:  MOVWF  FE9
198A2:  CLRF   1B
198A4:  BTFSC  FF2.7
198A6:  BSF    1B.7
198A8:  BCF    FF2.7
198AA:  MOVFF  795,A26
198AE:  MOVFF  794,A25
198B2:  CALL   1192
198B6:  BTFSC  1B.7
198B8:  BSF    FF2.7
198BA:  MOVLW  0D
198BC:  BTFSS  F9E.4
198BE:  BRA    198BC
198C0:  MOVWF  FAD
198C2:  MOVLW  0A
198C4:  BTFSS  F9E.4
198C6:  BRA    198C4
198C8:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
198CA:  MOVLW  73
198CC:  BTFSS  F9E.4
198CE:  BRA    198CC
198D0:  MOVWF  FAD
198D2:  MOVLW  3A
198D4:  BTFSS  F9E.4
198D6:  BRA    198D4
198D8:  MOVWF  FAD
198DA:  MOVLW  10
198DC:  MOVWF  FE9
198DE:  CLRF   1B
198E0:  BTFSC  FF2.7
198E2:  BSF    1B.7
198E4:  BCF    FF2.7
198E6:  MOVFF  775,A26
198EA:  MOVFF  774,A25
198EE:  CALL   1192
198F2:  BTFSC  1B.7
198F4:  BSF    FF2.7
198F6:  MOVLW  0D
198F8:  BTFSS  F9E.4
198FA:  BRA    198F8
198FC:  MOVWF  FAD
198FE:  MOVLW  0A
19900:  BTFSS  F9E.4
19902:  BRA    19900
19904:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
19906:  MOVLW  74
19908:  BTFSS  F9E.4
1990A:  BRA    19908
1990C:  MOVWF  FAD
1990E:  MOVLW  3A
19910:  BTFSS  F9E.4
19912:  BRA    19910
19914:  MOVWF  FAD
19916:  MOVLW  10
19918:  MOVWF  FE9
1991A:  CLRF   1B
1991C:  BTFSC  FF2.7
1991E:  BSF    1B.7
19920:  BCF    FF2.7
19922:  MOVFF  769,A26
19926:  MOVFF  768,A25
1992A:  CALL   1192
1992E:  BTFSC  1B.7
19930:  BSF    FF2.7
19932:  MOVLW  0D
19934:  BTFSS  F9E.4
19936:  BRA    19934
19938:  MOVWF  FAD
1993A:  MOVLW  0A
1993C:  BTFSS  F9E.4
1993E:  BRA    1993C
19940:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19942:  MOVLW  01
19944:  MOVLB  7
19946:  ADDWF  x3C,W
19948:  MOVLB  8
1994A:  MOVWF  x75
1994C:  MOVLW  75
1994E:  BTFSS  F9E.4
19950:  BRA    1994E
19952:  MOVWF  FAD
19954:  MOVLW  3A
19956:  BTFSS  F9E.4
19958:  BRA    19956
1995A:  MOVWF  FAD
1995C:  CLRF   1B
1995E:  BTFSC  FF2.7
19960:  BSF    1B.7
19962:  BCF    FF2.7
19964:  MOVFF  875,A25
19968:  MOVLW  1B
1996A:  MOVLB  A
1996C:  MOVWF  x26
1996E:  MOVLB  0
19970:  CALL   0F92
19974:  BTFSC  1B.7
19976:  BSF    FF2.7
19978:  MOVLW  0D
1997A:  BTFSS  F9E.4
1997C:  BRA    1997A
1997E:  MOVWF  FAD
19980:  MOVLW  0A
19982:  BTFSS  F9E.4
19984:  BRA    19982
19986:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19988:  MOVLW  77
1998A:  BTFSS  F9E.4
1998C:  BRA    1998A
1998E:  MOVWF  FAD
19990:  MOVLW  3A
19992:  BTFSS  F9E.4
19994:  BRA    19992
19996:  MOVWF  FAD
19998:  MOVLW  10
1999A:  MOVWF  FE9
1999C:  CLRF   1B
1999E:  BTFSC  FF2.7
199A0:  BSF    1B.7
199A2:  BCF    FF2.7
199A4:  MOVFF  872,A26
199A8:  MOVFF  871,A25
199AC:  CALL   1192
199B0:  BTFSC  1B.7
199B2:  BSF    FF2.7
199B4:  MOVLW  0D
199B6:  BTFSS  F9E.4
199B8:  BRA    199B6
199BA:  MOVWF  FAD
199BC:  MOVLW  0A
199BE:  BTFSS  F9E.4
199C0:  BRA    199BE
199C2:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
199C4:  MOVLW  78
199C6:  BTFSS  F9E.4
199C8:  BRA    199C6
199CA:  MOVWF  FAD
199CC:  MOVLW  3A
199CE:  BTFSS  F9E.4
199D0:  BRA    199CE
199D2:  MOVWF  FAD
199D4:  MOVLW  10
199D6:  MOVWF  FE9
199D8:  CLRF   1B
199DA:  BTFSC  FF2.7
199DC:  BSF    1B.7
199DE:  BCF    FF2.7
199E0:  MOVFF  781,A26
199E4:  MOVFF  780,A25
199E8:  CALL   1192
199EC:  BTFSC  1B.7
199EE:  BSF    FF2.7
199F0:  MOVLW  0D
199F2:  BTFSS  F9E.4
199F4:  BRA    199F2
199F6:  MOVWF  FAD
199F8:  MOVLW  0A
199FA:  BTFSS  F9E.4
199FC:  BRA    199FA
199FE:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
19A00:  MOVLW  79
19A02:  BTFSS  F9E.4
19A04:  BRA    19A02
19A06:  MOVWF  FAD
19A08:  MOVLW  3A
19A0A:  BTFSS  F9E.4
19A0C:  BRA    19A0A
19A0E:  MOVWF  FAD
19A10:  MOVLW  10
19A12:  MOVWF  FE9
19A14:  CLRF   1B
19A16:  BTFSC  FF2.7
19A18:  BSF    1B.7
19A1A:  BCF    FF2.7
19A1C:  MOVFF  741,A26
19A20:  MOVFF  740,A25
19A24:  CALL   1192
19A28:  BTFSC  1B.7
19A2A:  BSF    FF2.7
19A2C:  MOVLW  0D
19A2E:  BTFSS  F9E.4
19A30:  BRA    19A2E
19A32:  MOVWF  FAD
19A34:  MOVLW  0A
19A36:  BTFSS  F9E.4
19A38:  BRA    19A36
19A3A:  MOVWF  FAD
....................    } 
19A3C:  BRA    19A42
....................    else cmd_arg(); 
19A3E:  CALL   B062
19A42:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BCAA:  MOVF   44,W
0BCAC:  SUBLW  0D
0BCAE:  BNZ   BCCE
0BCB0:  MOVF   45,W
0BCB2:  SUBLW  07
0BCB4:  BNZ   BCCE
0BCB6:  MOVF   46,F
0BCB8:  BNZ   BCCE
0BCBA:  MOVF   47,F
0BCBC:  BNZ   BCCE
0BCBE:  MOVLW  03
0BCC0:  MOVLB  8
0BCC2:  MOVWF  x74
0BCC4:  MOVLW  11
0BCC6:  MOVWF  x73
0BCC8:  MOVLB  0
0BCCA:  RCALL  B888
0BCCC:  BRA    BCF0
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BCCE:  MOVF   44,W
0BCD0:  SUBLW  98
0BCD2:  BNZ   BCF0
0BCD4:  MOVF   45,W
0BCD6:  SUBLW  07
0BCD8:  BNZ   BCF0
0BCDA:  MOVF   46,F
0BCDC:  BNZ   BCF0
0BCDE:  MOVF   47,F
0BCE0:  BNZ   BCF0
0BCE2:  MOVLW  03
0BCE4:  MOVLB  8
0BCE6:  MOVWF  x74
0BCE8:  MOVLW  11
0BCEA:  MOVWF  x73
0BCEC:  MOVLB  0
0BCEE:  RCALL  BA02
0BCF0:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0B0BC:  MOVF   44,W
0B0BE:  MOVWF  00
0B0C0:  MOVFF  45,03
0B0C4:  MOVLW  15
0B0C6:  SUBWF  45,W
0B0C8:  BNZ   B0D0
0B0CA:  MOVLW  95
0B0CC:  SUBWF  00,W
0B0CE:  BZ    B0F6
0B0D0:  MOVLW  15
0B0D2:  SUBWF  03,W
0B0D4:  BNZ   B0DC
0B0D6:  MOVLW  96
0B0D8:  SUBWF  00,W
0B0DA:  BZ    B128
0B0DC:  MOVLW  15
0B0DE:  SUBWF  03,W
0B0E0:  BNZ   B0E8
0B0E2:  MOVLW  97
0B0E4:  SUBWF  00,W
0B0E6:  BZ    B15E
0B0E8:  MOVLW  15
0B0EA:  SUBWF  03,W
0B0EC:  BNZ   B0F4
0B0EE:  MOVLW  98
0B0F0:  SUBWF  00,W
0B0F2:  BZ    B194
0B0F4:  BRA    B1C8
....................       case 5525 : nv_product = ECO; 
0B0F6:  CLRF   30
0B0F8:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0B0FA:  MOVLW  1E
0B0FC:  MOVLB  8
0B0FE:  MOVWF  xD8
0B100:  CLRF   xDA
0B102:  CLRF   xD9
0B104:  MOVLB  0
0B106:  CALL   501E
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B10A:  MOVLW  01
0B10C:  MOVWF  1E
0B10E:  MOVLW  A3
0B110:  MOVWF  1D
0B112:  MOVLW  1E
0B114:  MOVWF  FF6
0B116:  MOVLW  27
0B118:  MOVWF  FF7
0B11A:  MOVLW  00
0B11C:  MOVWF  FF8
0B11E:  CALL   5108
....................                   record_event(); 
0B122:  CALL   850C
....................          break; 
0B126:  BRA    B1C8
....................       case 5526 : nv_product = WMS4; 
0B128:  CLRF   30
0B12A:  MOVLW  01
0B12C:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B12E:  MOVLW  1E
0B130:  MOVLB  8
0B132:  MOVWF  xD8
0B134:  CLRF   xDA
0B136:  MOVLW  01
0B138:  MOVWF  xD9
0B13A:  MOVLB  0
0B13C:  CALL   501E
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B140:  MOVLW  01
0B142:  MOVWF  1E
0B144:  MOVLW  A3
0B146:  MOVWF  1D
0B148:  MOVLW  2E
0B14A:  MOVWF  FF6
0B14C:  MOVLW  27
0B14E:  MOVWF  FF7
0B150:  MOVLW  00
0B152:  MOVWF  FF8
0B154:  CALL   5108
....................                   record_event();                   
0B158:  CALL   850C
....................          break;    
0B15C:  BRA    B1C8
....................       case 5527 : nv_product = AWS; 
0B15E:  CLRF   30
0B160:  MOVLW  02
0B162:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B164:  MOVLW  1E
0B166:  MOVLB  8
0B168:  MOVWF  xD8
0B16A:  CLRF   xDA
0B16C:  MOVLW  02
0B16E:  MOVWF  xD9
0B170:  MOVLB  0
0B172:  CALL   501E
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B176:  MOVLW  01
0B178:  MOVWF  1E
0B17A:  MOVLW  A3
0B17C:  MOVWF  1D
0B17E:  MOVLW  44
0B180:  MOVWF  FF6
0B182:  MOVLW  27
0B184:  MOVWF  FF7
0B186:  MOVLW  00
0B188:  MOVWF  FF8
0B18A:  CALL   5108
....................                   record_event();                   
0B18E:  CALL   850C
....................          break;   
0B192:  BRA    B1C8
....................       case 5528 : nv_product = WMS2; 
0B194:  CLRF   30
0B196:  MOVLW  03
0B198:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B19A:  MOVLW  1E
0B19C:  MOVLB  8
0B19E:  MOVWF  xD8
0B1A0:  CLRF   xDA
0B1A2:  MOVLW  03
0B1A4:  MOVWF  xD9
0B1A6:  MOVLB  0
0B1A8:  CALL   501E
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B1AC:  MOVLW  01
0B1AE:  MOVWF  1E
0B1B0:  MOVLW  A3
0B1B2:  MOVWF  1D
0B1B4:  MOVLW  54
0B1B6:  MOVWF  FF6
0B1B8:  MOVLW  27
0B1BA:  MOVWF  FF7
0B1BC:  MOVLW  00
0B1BE:  MOVWF  FF8
0B1C0:  CALL   5108
....................                   record_event();                   
0B1C4:  CALL   850C
....................          break;            
....................    } 
0B1C8:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0B080:  MOVF   44,W
0B082:  MOVWF  00
0B084:  MOVF   45,W
0B086:  MOVWF  03
0B088:  BNZ   B08E
0B08A:  MOVF   00,F
0B08C:  BZ    B0A4
0B08E:  MOVF   03,W
0B090:  BNZ   B098
0B092:  MOVLW  01
0B094:  SUBWF  00,W
0B096:  BZ    B0AA
0B098:  MOVF   03,W
0B09A:  BNZ   B0A2
0B09C:  MOVLW  02
0B09E:  SUBWF  00,W
0B0A0:  BZ    B0B0
0B0A2:  BRA    B0B6
....................       case 0 : kill_wd(); 
0B0A4:  CALL   314A
....................          break; 
0B0A8:  BRA    B0B8
....................       case 1 : start_heartbeat(); 
0B0AA:  CALL   2954
....................          break; 
0B0AE:  BRA    B0B8
....................       case 2 : suspend_heartbeat(); 
0B0B0:  CALL   559A
....................          break; 
0B0B4:  BRA    B0B8
....................       default : cmd_arg(); 
0B0B6:  RCALL  B062
....................          break; 
....................    } 
0B0B8:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0AFC0:  MOVF   44,W
0AFC2:  MOVWF  00
0AFC4:  MOVF   45,W
0AFC6:  MOVWF  03
0AFC8:  BNZ   AFCE
0AFCA:  MOVF   00,F
0AFCC:  BZ    AFDC
0AFCE:  MOVLW  15
0AFD0:  SUBWF  03,W
0AFD2:  BNZ   AFDA
0AFD4:  MOVLW  95
0AFD6:  SUBWF  00,W
0AFD8:  BZ    B03A
0AFDA:  BRA    B05E
....................       case 0:     signon(); 
0AFDC:  CALL   319C
....................                   fprintf(COM_A, __DATE__); 
0AFE0:  MOVLW  6A
0AFE2:  MOVWF  FF6
0AFE4:  MOVLW  27
0AFE6:  MOVWF  FF7
0AFE8:  MOVLW  00
0AFEA:  MOVWF  FF8
0AFEC:  CLRF   1B
0AFEE:  BTFSC  FF2.7
0AFF0:  BSF    1B.7
0AFF2:  BCF    FF2.7
0AFF4:  CALL   0E3A
0AFF8:  BTFSC  1B.7
0AFFA:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0AFFC:  MOVLW  0D
0AFFE:  BTFSS  F9E.4
0B000:  BRA    AFFE
0B002:  MOVWF  FAD
0B004:  MOVLW  0A
0B006:  BTFSS  F9E.4
0B008:  BRA    B006
0B00A:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0B00C:  MOVLW  74
0B00E:  MOVWF  FF6
0B010:  MOVLW  27
0B012:  MOVWF  FF7
0B014:  MOVLW  00
0B016:  MOVWF  FF8
0B018:  CLRF   1B
0B01A:  BTFSC  FF2.7
0B01C:  BSF    1B.7
0B01E:  BCF    FF2.7
0B020:  CALL   0E3A
0B024:  BTFSC  1B.7
0B026:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B028:  MOVLW  0D
0B02A:  BTFSS  F9E.4
0B02C:  BRA    B02A
0B02E:  MOVWF  FAD
0B030:  MOVLW  0A
0B032:  BTFSS  F9E.4
0B034:  BRA    B032
0B036:  MOVWF  FAD
....................          break; 
0B038:  BRA    B05E
....................       case 5525 : kill_wd(); 
0B03A:  CALL   314A
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0B03E:  MOVLW  7E
0B040:  MOVWF  FF6
0B042:  MOVLW  27
0B044:  MOVWF  FF7
0B046:  MOVLW  00
0B048:  MOVWF  FF8
0B04A:  CLRF   1B
0B04C:  BTFSC  FF2.7
0B04E:  BSF    1B.7
0B050:  BCF    FF2.7
0B052:  CALL   0E3A
0B056:  BTFSC  1B.7
0B058:  BSF    FF2.7
....................                   load_program(); 
0B05A:  CALL   1F800
....................          break; 
....................    } 
0B05E:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
186F2:  MOVF   44,W
186F4:  MOVWF  00
186F6:  MOVF   45,W
186F8:  MOVWF  03
186FA:  BNZ   18700
186FC:  MOVF   00,F
186FE:  BZ    1870C
18700:  MOVF   03,W
18702:  BNZ   1870A
18704:  MOVLW  01
18706:  SUBWF  00,W
18708:  BZ    18710
1870A:  BRA    18714
....................       case 0 : cmd_set=0;  // user 
1870C:  CLRF   4D
....................          break; 
1870E:  BRA    18714
....................       case 1 : cmd_set=1;  // full 
18710:  MOVLW  01
18712:  MOVWF  4D
....................          break; 
....................    } 
18714:  GOTO   1ADE8 (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1AC52:  CALL   AE9E
....................     
....................    switch (cmd) 
1AC56:  MOVLW  23
1AC58:  SUBWF  43,W
1AC5A:  ADDLW  A8
1AC5C:  BTFSC  FD8.0
1AC5E:  BRA    1ADE8
1AC60:  ADDLW  58
1AC62:  GOTO   1ADEC
....................    { 
....................       case '&': commandFW(); 
1AC66:  GOTO   AFC0
....................          break; 
1AC6A:  BRA    1ADE8
....................       case '#': command_hash(); 
1AC6C:  GOTO   B080
....................          break;          
1AC70:  BRA    1ADE8
....................       case '%': command_prod(); 
1AC72:  GOTO   B0BC
....................          break; 
1AC76:  BRA    1ADE8
....................       case '*': command_star(); 
1AC78:  GOTO   BCAA
....................          break;       
1AC7C:  BRA    1ADE8
....................       // standard commands 
....................       case '/': command_addr(); 
1AC7E:  GOTO   BCF4
....................          break; 
1AC82:  BRA    1ADE8
....................       case 'A': commandA(); 
1AC84:  GOTO   BE8E
....................          break; 
1AC88:  BRA    1ADE8
....................       case 'B': commandB(); 
1AC8A:  GOTO   BFFA
....................          break; 
1AC8E:  BRA    1ADE8
....................       case 'C': commandC(); 
1AC90:  GOTO   DA32
....................          break; 
1AC94:  BRA    1ADE8
....................       case 'D': commandD(); 
1AC96:  GOTO   DA70
....................          break; 
1AC9A:  BRA    1ADE8
....................       case 'E': commandE(); 
1AC9C:  GOTO   DB0A
....................          break;          
1ACA0:  BRA    1ADE8
....................       case 'F': commandF(); 
1ACA2:  GOTO   DE08
....................          break;          
1ACA6:  BRA    1ADE8
....................       case 'G': commandG(); 
1ACA8:  GOTO   DE72
....................          break; 
1ACAC:  BRA    1ADE8
....................       case 'H': commandH(); 
1ACAE:  GOTO   EFD0
....................          break; 
1ACB2:  BRA    1ADE8
....................       case 'I': commandI(); 
1ACB4:  GOTO   F010
....................          break;    
1ACB8:  BRA    1ADE8
....................       case 'J': commandJ(); 
1ACBA:  GOTO   F05C
....................          break;      
1ACBE:  BRA    1ADE8
....................       case 'K': commandK(); 
1ACC0:  GOTO   F2B6
....................          break;    
1ACC4:  BRA    1ADE8
....................       case 'L': commandL(); 
1ACC6:  GOTO   10260
....................          break;             
1ACCA:  BRA    1ADE8
....................       case 'M': commandM(FALSE); 
1ACCC:  MOVLB  8
1ACCE:  CLRF   x6F
1ACD0:  MOVLB  0
1ACD2:  CALL   1699A
....................          break;   
1ACD6:  BRA    1ADE8
....................       case 'N': commandN(); 
1ACD8:  GOTO   16A9A
....................          break;          
1ACDC:  BRA    1ADE8
....................       case 'O': commandO(); 
1ACDE:  GOTO   16C4A
....................          break;    
1ACE2:  BRA    1ADE8
....................       case 'P': commandP(); 
1ACE4:  GOTO   16E4E
....................          break;  
1ACE8:  BRA    1ADE8
....................       case 'Q': commandQ(); 
1ACEA:  GOTO   16F0C
....................          break;              
1ACEE:  BRA    1ADE8
....................       case 'R': commandR(); 
1ACF0:  GOTO   171A2
....................          break;    
1ACF4:  BRA    1ADE8
....................       case 'S': commandS(); 
1ACF6:  GOTO   172CE
....................          break;  
1ACFA:  BRA    1ADE8
....................       case 'T': commandT(); 
1ACFC:  GOTO   1786C
....................          break;            
1AD00:  BRA    1ADE8
....................       case 'U': commandU(); 
1AD02:  GOTO   1826E
....................          break;           
1AD06:  BRA    1ADE8
....................       case 'V': commandV(); 
1AD08:  GOTO   183C6
....................          break; 
1AD0C:  BRA    1ADE8
....................       case 'W': commandW(); 
1AD0E:  GOTO   1853A
....................          break; 
1AD12:  BRA    1ADE8
....................       case 'X': commandX(); 
1AD14:  GOTO   1855E
....................          break; 
1AD18:  BRA    1ADE8
....................       case 'Y': commandY(); 
1AD1A:  GOTO   185C6
....................          break;  
1AD1E:  BRA    1ADE8
....................       case 'Z': commandZ(); 
1AD20:  CALL   186CE
....................          break;    
1AD24:  BRA    1ADE8
....................       // stepper 
....................       case '^': command_set(); 
1AD26:  GOTO   186F2
....................          break;       
1AD2A:  BRA    1ADE8
....................       case '+': if(m_fixed==1) motor=1; 
1AD2C:  MOVLB  7
1AD2E:  DECFSZ x3D,W
1AD30:  BRA    1AD36
1AD32:  MOVLW  01
1AD34:  MOVWF  x3C
....................                 command_move(0,0,1); 
1AD36:  MOVLB  8
1AD38:  CLRF   x6F
1AD3A:  CLRF   x70
1AD3C:  MOVLW  01
1AD3E:  MOVWF  x71
1AD40:  MOVLB  0
1AD42:  CALL   16C6E
....................          break; 
1AD46:  BRA    1ADE8
....................       case '-': if(m_fixed==1) motor=1; 
1AD48:  MOVLB  7
1AD4A:  DECFSZ x3D,W
1AD4C:  BRA    1AD52
1AD4E:  MOVLW  01
1AD50:  MOVWF  x3C
....................                 command_move(0,1,1); 
1AD52:  MOVLB  8
1AD54:  CLRF   x6F
1AD56:  MOVLW  01
1AD58:  MOVWF  x70
1AD5A:  MOVWF  x71
1AD5C:  MOVLB  0
1AD5E:  CALL   16C6E
....................          break; 
1AD62:  BRA    1ADE8
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1AD64:  GOTO   1881E
....................          break;     
1AD68:  BRA    1ADE8
....................       case 'b': command_b(); 
1AD6A:  GOTO   1883A
....................          break; 
1AD6E:  BRA    1ADE8
....................       case 'c': command_c(); 
1AD70:  GOTO   188D4
....................          break; 
1AD74:  BRA    1ADE8
....................       case 'd': command_d(); 
1AD76:  GOTO   1891C
....................          break;          
1AD7A:  BRA    1ADE8
....................       case 'e': command_e(); 
1AD7C:  GOTO   189B2
....................          break;       
1AD80:  BRA    1ADE8
....................       case 'f': command_f(); 
1AD82:  GOTO   18A4C
....................          break; 
1AD86:  BRA    1ADE8
....................       case 'g': command_g(); 
1AD88:  GOTO   18A6C
....................          break;          
1AD8C:  BRA    1ADE8
....................       case 'h': command_h(); 
1AD8E:  GOTO   18B06
....................          break; 
1AD92:  BRA    1ADE8
....................       case 'i': command_i(); 
1AD94:  GOTO   18BDA
....................          break;   
1AD98:  BRA    1ADE8
....................       case 'j': command_j(); 
1AD9A:  GOTO   18CB6
....................          break;           
1AD9E:  BRA    1ADE8
....................       case 'k': command_k(); 
1ADA0:  GOTO   18D50
....................          break;          
1ADA4:  BRA    1ADE8
....................       case 'l': step_var_list(); 
1ADA6:  GOTO   18DE6
....................          break;          
1ADAA:  BRA    1ADE8
....................       case 'm': command_m(); 
1ADAC:  GOTO   19A46
....................          break;    
1ADB0:  BRA    1ADE8
....................       case 'n': command_n(); 
1ADB2:  GOTO   19ADC
....................          break; 
1ADB6:  BRA    1ADE8
....................       case 'o': command_o(); 
1ADB8:  GOTO   19B72
....................          break;    
1ADBC:  BRA    1ADE8
....................       case 'p': command_p(); 
1ADBE:  GOTO   19C0C
....................          break;   
1ADC2:  BRA    1ADE8
....................       case 'q': command_q(); 
1ADC4:  GOTO   19CA6
....................          break; 
1ADC8:  BRA    1ADE8
....................       case 'r': command_r(); 
1ADCA:  BRA    1A7A2
....................          break;    
1ADCC:  BRA    1ADE8
....................       case 's': command_s(); 
1ADCE:  BRA    1A7FC
....................          break;           
1ADD0:  BRA    1ADE8
....................       case 't': command_t(); 
1ADD2:  BRA    1A90A
....................          break;          
1ADD4:  BRA    1ADE8
....................       case 'u': command_u(); 
1ADD6:  BRA    1A9A0
....................          break;           
1ADD8:  BRA    1ADE8
....................       case 'w': command_w(); 
1ADDA:  BRA    1A9D8
....................          break; 
1ADDC:  BRA    1ADE8
....................       case 'x': command_x(); 
1ADDE:  BRA    1AAAC
....................          break;    
1ADE0:  BRA    1ADE8
....................       case 'y': command_y(); 
1ADE2:  BRA    1AB46
....................          break;  
1ADE4:  BRA    1ADE8
....................       case 'z': command_z(); 
1ADE6:  BRA    1ABDC
....................          break;           
....................    } 
1ADE8:  GOTO   1AF70 (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... #define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c" 
.................... #define BYTE_TO_BINARY(byte)  \ 
....................   (byte & 0x80 ? '1' : '0'), \ 
....................   (byte & 0x40 ? '1' : '0'), \ 
....................   (byte & 0x20 ? '1' : '0'), \ 
....................   (byte & 0x10 ? '1' : '0'), \ 
....................   (byte & 0x08 ? '1' : '0'), \ 
....................   (byte & 0x04 ? '1' : '0'), \ 
....................   (byte & 0x02 ? '1' : '0'), \ 
....................   (byte & 0x01 ? '1' : '0')  
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................  
....................   number = 0; 
*
1AEBC:  MOVLB  8
1AEBE:  CLRF   x6D
....................   arg = 0; 
1AEC0:  CLRF   47
1AEC2:  CLRF   46
1AEC4:  CLRF   45
1AEC6:  CLRF   44
....................   good_arg = FALSE; 
1AEC8:  CLRF   x6E
....................    
....................   while (number != CARRIAGE_RET) 
1AECA:  MOVF   x6D,W
1AECC:  SUBLW  0D
1AECE:  BZ    1AFA2
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
1AED0:  MOVLB  0
1AED2:  CALL   0E24
1AED6:  MOVFF  01,86D
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
1AEDA:  MOVLB  8
1AEDC:  MOVF   x6D,W
1AEDE:  SUBLW  0D
1AEE0:  BZ    1AEEC
1AEE2:  MOVF   x6D,W
1AEE4:  MOVLB  0
1AEE6:  CALL   AEA6
1AEEA:  MOVLB  8
....................      if (number > 47 && number < 58) 
1AEEC:  MOVF   x6D,W
1AEEE:  SUBLW  2F
1AEF0:  BC    1AF42
1AEF2:  MOVF   x6D,W
1AEF4:  SUBLW  39
1AEF6:  BNC   1AF42
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
1AEF8:  MOVLW  30
1AEFA:  SUBWF  x6D,F
....................         arg = arg * 10;                    // increase significance 
1AEFC:  MOVFF  47,9E3
1AF00:  MOVFF  46,9E2
1AF04:  MOVFF  45,9E1
1AF08:  MOVFF  44,9E0
1AF0C:  MOVLB  9
1AF0E:  CLRF   xE7
1AF10:  CLRF   xE6
1AF12:  CLRF   xE5
1AF14:  MOVLW  0A
1AF16:  MOVWF  xE4
1AF18:  MOVLB  0
1AF1A:  CALL   4844
1AF1E:  MOVFF  03,47
1AF22:  MOVFF  02,46
1AF26:  MOVFF  01,45
1AF2A:  MOVFF  00,44
....................         arg = arg + number;                // for each number 
1AF2E:  MOVLB  8
1AF30:  MOVF   x6D,W
1AF32:  ADDWF  44,F
1AF34:  MOVLW  00
1AF36:  ADDWFC 45,F
1AF38:  ADDWFC 46,F
1AF3A:  ADDWFC 47,F
....................         good_arg = TRUE; 
1AF3C:  MOVLW  01
1AF3E:  MOVWF  x6E
....................      } 
1AF40:  BRA    1AF9A
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
1AF42:  MOVF   x6D,W
1AF44:  SUBLW  0D
1AF46:  BNZ   1AF74
1AF48:  DECFSZ x6E,W
1AF4A:  BRA    1AF74
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
1AF4C:  MOVLW  A4
1AF4E:  MOVWF  FF6
1AF50:  MOVLW  27
1AF52:  MOVWF  FF7
1AF54:  MOVLW  00
1AF56:  MOVWF  FF8
1AF58:  MOVLB  0
1AF5A:  CALL   AE74
1AF5E:  MOVLW  0D
1AF60:  BTFSS  F9E.4
1AF62:  BRA    1AF60
1AF64:  MOVWF  FAD
1AF66:  MOVLW  0A
1AF68:  BTFSS  F9E.4
1AF6A:  BRA    1AF68
1AF6C:  MOVWF  FAD
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
1AF6E:  BRA    1AC52
....................      } 
1AF70:  BRA    1AF98
1AF72:  MOVLB  8
....................      else 
....................      { 
....................         good_arg = FALSE; 
1AF74:  CLRF   x6E
....................         fputs("@ARG ", COM_A);             // bad input 
1AF76:  MOVLW  AA
1AF78:  MOVWF  FF6
1AF7A:  MOVLW  27
1AF7C:  MOVWF  FF7
1AF7E:  MOVLW  00
1AF80:  MOVWF  FF8
1AF82:  MOVLB  0
1AF84:  CALL   AE74
1AF88:  MOVLW  0D
1AF8A:  BTFSS  F9E.4
1AF8C:  BRA    1AF8A
1AF8E:  MOVWF  FAD
1AF90:  MOVLW  0A
1AF92:  BTFSS  F9E.4
1AF94:  BRA    1AF92
1AF96:  MOVWF  FAD
1AF98:  MOVLB  8
....................      } 
....................      if (good_arg == FALSE) break; 
1AF9A:  MOVF   x6E,F
1AF9C:  BTFSC  FD8.2
1AF9E:  BRA    1AFA2
1AFA0:  BRA    1AECA
....................   } 
1AFA2:  MOVLB  0
1AFA4:  GOTO   1AFD8 (RETURN)
.................... } 
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0AEF0:  MOVF   4D,F
0AEF2:  BNZ   AF44
0AEF4:  MOVLB  8
0AEF6:  MOVF   x6D,W
0AEF8:  SUBLW  24
0AEFA:  BC    AF02
0AEFC:  MOVF   x6D,W
0AEFE:  SUBLW  26
0AF00:  BC    AF3C
0AF02:  MOVF   x6D,W
0AF04:  SUBLW  29
0AF06:  BC    AF0E
0AF08:  MOVF   x6D,W
0AF0A:  SUBLW  2B
0AF0C:  BC    AF3C
0AF0E:  MOVF   x6D,W
0AF10:  SUBLW  2D
0AF12:  BZ    AF3C
0AF14:  MOVF   x6D,W
0AF16:  SUBLW  2F
0AF18:  BZ    AF3C
0AF1A:  MOVF   x6D,W
0AF1C:  SUBLW  40
0AF1E:  BC    AF26
0AF20:  MOVF   x6D,W
0AF22:  SUBLW  42
0AF24:  BC    AF3C
0AF26:  MOVF   x6D,W
0AF28:  SUBLW  43
0AF2A:  BC    AF32
0AF2C:  MOVF   x6D,W
0AF2E:  SUBLW  5A
0AF30:  BC    AF3C
0AF32:  MOVF   x6D,W
0AF34:  SUBLW  5E
0AF36:  BZ    AF3C
0AF38:  MOVLW  00
0AF3A:  BRA    AF3E
0AF3C:  MOVLW  01
0AF3E:  MOVWF  x6E
0AF40:  BRA    AFB2
0AF42:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0AF44:  DECFSZ 4D,W
0AF46:  BRA    AFB4
0AF48:  MOVLB  8
0AF4A:  MOVF   x6D,W
0AF4C:  SUBLW  23
0AF4E:  BZ    AFAE
0AF50:  MOVF   x6D,W
0AF52:  SUBLW  24
0AF54:  BC    AF5C
0AF56:  MOVF   x6D,W
0AF58:  SUBLW  26
0AF5A:  BC    AFAE
0AF5C:  MOVF   x6D,W
0AF5E:  SUBLW  29
0AF60:  BC    AF68
0AF62:  MOVF   x6D,W
0AF64:  SUBLW  2B
0AF66:  BC    AFAE
0AF68:  MOVF   x6D,W
0AF6A:  SUBLW  2D
0AF6C:  BZ    AFAE
0AF6E:  MOVF   x6D,W
0AF70:  SUBLW  2F
0AF72:  BZ    AFAE
0AF74:  MOVF   x6D,W
0AF76:  SUBLW  40
0AF78:  BC    AF80
0AF7A:  MOVF   x6D,W
0AF7C:  SUBLW  42
0AF7E:  BC    AFAE
0AF80:  MOVF   x6D,W
0AF82:  SUBLW  43
0AF84:  BC    AF8C
0AF86:  MOVF   x6D,W
0AF88:  SUBLW  5A
0AF8A:  BC    AFAE
0AF8C:  MOVF   x6D,W
0AF8E:  SUBLW  5E
0AF90:  BZ    AFAE
0AF92:  MOVF   x6D,W
0AF94:  SUBLW  60
0AF96:  BC    AF9E
0AF98:  MOVF   x6D,W
0AF9A:  SUBLW  75
0AF9C:  BC    AFAE
0AF9E:  MOVF   x6D,W
0AFA0:  SUBLW  76
0AFA2:  BC    AFAA
0AFA4:  MOVF   x6D,W
0AFA6:  SUBLW  7A
0AFA8:  BC    AFAE
0AFAA:  MOVLW  00
0AFAC:  BRA    AFB0
0AFAE:  MOVLW  01
0AFB0:  MOVWF  x6E
0AFB2:  MOVLB  0
....................    return(valid); 
0AFB4:  MOVLB  8
0AFB6:  MOVFF  86E,01
0AFBA:  MOVLB  0
0AFBC:  GOTO   1AFB0 (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
*
1AFA8:  MOVFF  43,86D
1AFAC:  GOTO   AEF0
1AFB0:  MOVF   01,F
1AFB2:  BZ    1AFB8
1AFB4:  BRA    1AEBC
1AFB6:  BRA    1AFD8
....................    else fputs("@INV", COM_A); 
1AFB8:  MOVLW  B0
1AFBA:  MOVWF  FF6
1AFBC:  MOVLW  27
1AFBE:  MOVWF  FF7
1AFC0:  MOVLW  00
1AFC2:  MOVWF  FF8
1AFC4:  CALL   AE74
1AFC8:  MOVLW  0D
1AFCA:  BTFSS  F9E.4
1AFCC:  BRA    1AFCA
1AFCE:  MOVWF  FAD
1AFD0:  MOVLW  0A
1AFD2:  BTFSS  F9E.4
1AFD4:  BRA    1AFD2
1AFD6:  MOVWF  FAD
1AFD8:  GOTO   1B05A (RETURN)
.................... } 
....................  
.................... void command_prompt() 
.................... { 
....................    //disable_interrupts(INT_EXT); 
....................     
....................    nv_cmd_mode = TRUE; 
1AFDC:  CLRF   32
1AFDE:  MOVLW  01
1AFE0:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1AFE2:  MOVLW  02
1AFE4:  MOVLB  8
1AFE6:  MOVWF  x73
1AFE8:  MOVFF  31,874
1AFEC:  MOVLB  0
1AFEE:  CALL   3466
....................     
....................    fputs("@CMD", COM_A); 
1AFF2:  MOVLW  B6
1AFF4:  MOVWF  FF6
1AFF6:  MOVLW  27
1AFF8:  MOVWF  FF7
1AFFA:  MOVLW  00
1AFFC:  MOVWF  FF8
1AFFE:  CALL   AE74
1B002:  MOVLW  0D
1B004:  BTFSS  F9E.4
1B006:  BRA    1B004
1B008:  MOVWF  FAD
1B00A:  MOVLW  0A
1B00C:  BTFSS  F9E.4
1B00E:  BRA    1B00C
1B010:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1B012:  MOVLW  01
1B014:  MOVWF  1E
1B016:  MOVLW  A3
1B018:  MOVWF  1D
1B01A:  MOVLW  BC
1B01C:  MOVWF  FF6
1B01E:  MOVLW  27
1B020:  MOVWF  FF7
1B022:  MOVLW  00
1B024:  MOVWF  FF8
1B026:  CALL   5108
....................    record_event(); 
1B02A:  CALL   850C
....................     
....................    busy_clear(); 
1B02E:  CALL   AE9E
....................     
....................    cmd_set=0; // user 
1B032:  CLRF   4D
....................     
....................    do { 
....................       fputc('>',COM_A); 
1B034:  MOVLW  3E
1B036:  CALL   AEA6
....................       cmd=fgetc(COM_A); 
1B03A:  CALL   0E24
1B03E:  MOVFF  01,43
....................       if (com_echo == TRUE) 
1B042:  DECFSZ 48,W
1B044:  BRA    1B04C
....................       { 
....................          fputc(cmd,COM_A); 
1B046:  MOVF   43,W
1B048:  CALL   AEA6
....................       } 
....................       if (cmd == '?') msg_busy(); 
1B04C:  MOVF   43,W
1B04E:  SUBLW  3F
1B050:  BNZ   1B058
1B052:  GOTO   AEAE
1B056:  BRA    1B05A
....................       else proc_cmd(); 
1B058:  BRA    1AFA8
....................       //restart_wdt(); 
....................    } while(nv_cmd_mode == TRUE); 
1B05A:  DECFSZ 31,W
1B05C:  BRA    1B062
1B05E:  MOVF   32,F
1B060:  BZ    1B034
1B062:  RETURN 0
.................... } 
....................  
....................  
.................... void main() 
1B064:  CLRF   FF8
1B066:  BCF    FD0.7
1B068:  BSF    07.7
1B06A:  MOVLW  70
1B06C:  MOVWF  FD3
1B06E:  MOVLW  40
1B070:  MOVWF  F9B
1B072:  CLRF   F64
1B074:  CLRF   1C
1B076:  BSF    F65.3
1B078:  MOVWF  FAF
1B07A:  MOVLW  03
1B07C:  MOVWF  FD4
1B07E:  MOVLW  A6
1B080:  MOVWF  FAC
1B082:  MOVLW  90
1B084:  MOVWF  FAB
1B086:  MOVLB  F
1B088:  BSF    x20.3
1B08A:  MOVLW  82
1B08C:  MOVWF  x1E
1B08E:  MOVLW  06
1B090:  MOVWF  x1F
1B092:  MOVLW  A6
1B094:  MOVWF  x21
1B096:  MOVLW  90
1B098:  MOVWF  x22
1B09A:  BSF    F65.3
1B09C:  MOVLW  40
1B09E:  MOVWF  FAF
1B0A0:  MOVLW  03
1B0A2:  MOVWF  FD4
1B0A4:  MOVLW  A6
1B0A6:  MOVWF  FAC
1B0A8:  MOVLW  90
1B0AA:  MOVWF  FAB
1B0AC:  CLRF   1E
1B0AE:  CLRF   1D
1B0B0:  CLRF   42
1B0B2:  MOVLW  01
1B0B4:  MOVWF  41
1B0B6:  MOVWF  48
1B0B8:  BCF    49.0
1B0BA:  BCF    49.1
1B0BC:  BCF    49.2
1B0BE:  MOVLB  0
1B0C0:  CLRF   x62
1B0C2:  MOVLB  2
1B0C4:  MOVWF  xD5
1B0C6:  MOVLB  3
1B0C8:  CLRF   x37
1B0CA:  MOVLB  4
1B0CC:  CLRF   xE3
1B0CE:  MOVWF  xE9
1B0D0:  MOVLW  04
1B0D2:  MOVLB  7
1B0D4:  MOVWF  x0F
1B0D6:  MOVLW  EA
1B0D8:  MOVWF  x0E
1B0DA:  CLRF   xC9
1B0DC:  MOVLB  8
1B0DE:  CLRF   x54
1B0E0:  CLRF   x53
1B0E2:  CLRF   x58
1B0E4:  CLRF   x57
1B0E6:  CLRF   x56
1B0E8:  CLRF   x55
1B0EA:  CLRF   x5C
1B0EC:  CLRF   x5B
1B0EE:  CLRF   x5A
1B0F0:  CLRF   x59
1B0F2:  MOVLW  00
1B0F4:  MOVLB  F
1B0F6:  MOVWF  x23
1B0F8:  MOVWF  x24
1B0FA:  MOVWF  x25
1B0FC:  BCF    FC1.3
1B0FE:  BCF    FC1.4
1B100:  BCF    FC1.5
1B102:  CLRF   x2E
1B104:  CLRF   x2F
1B106:  CLRF   x54
1B108:  BRA    1B1CA
1B10A:  DATA 44,02
1B10C:  DATA D9,20
1B10E:  DATA 64,72
1B110:  DATA 61,77
1B112:  DATA 5F,61
1B114:  DATA 6C,6C
1B116:  DATA 2E,63
1B118:  DATA 73,76
1B11A:  DATA 00,20
1B11C:  DATA 64,72
1B11E:  DATA 61,77
1B120:  DATA 5F,6E
1B122:  DATA 65,77
1B124:  DATA 2E,63
1B126:  DATA 73,76
1B128:  DATA 00,20
1B12A:  DATA 64,72
1B12C:  DATA 65,6C
1B12E:  DATA 5F,61
1B130:  DATA 6C,6C
1B132:  DATA 2E,63
1B134:  DATA 73,76
1B136:  DATA 00,20
1B138:  DATA 64,72
1B13A:  DATA 65,6C
1B13C:  DATA 5F,6E
1B13E:  DATA 65,77
1B140:  DATA 2E,63
1B142:  DATA 73,76
1B144:  DATA 00,20
1B146:  DATA 65,76
1B148:  DATA 65,6E
1B14A:  DATA 74,73
1B14C:  DATA 2E,74
1B14E:  DATA 78,74
1B150:  DATA 00,02
1B152:  DATA 03,35
1B154:  DATA 2C,00
1B156:  DATA 02,04
1B158:  DATA D4,00
1B15A:  DATA 00,10
1B15C:  DATA 07,10
1B15E:  DATA 46,41
1B160:  DATA 54,31
1B162:  DATA 32,46
1B164:  DATA 41,54
1B166:  DATA 31,36
1B168:  DATA 46,41
1B16A:  DATA 54,33
1B16C:  DATA 32,00
1B16E:  DATA 57,07
1B170:  DATA CA,0D
1B172:  DATA 0A,00
1B174:  DATA 00,03
1B176:  DATA 00,0F
1B178:  DATA 00,1B
1B17A:  DATA 00,27
1B17C:  DATA 00,33
1B17E:  DATA 00,3F
1B180:  DATA 00,4B
1B182:  DATA 00,57
1B184:  DATA 00,63
1B186:  DATA 00,6F
1B188:  DATA 00,7B
1B18A:  DATA 00,87
1B18C:  DATA 00,93
1B18E:  DATA 00,9F
1B190:  DATA 00,AB
1B192:  DATA 00,B7
1B194:  DATA 00,C3
1B196:  DATA 48,B1
1B198:  DATA 70,D4
1B19A:  DATA 98,F7
1B19C:  DATA C0,1A
1B19E:  DATA 00,CF
1B1A0:  DATA 28,F2
1B1A2:  DATA 50,15
1B1A4:  DATA 78,38
1B1A6:  DATA A0,5B
1B1A8:  DATA C8,7E
1B1AA:  DATA F0,A1
1B1AC:  DATA 18,C5
1B1AE:  DATA 40,E8
1B1B0:  DATA 68,0B
1B1B2:  DATA 90,2E
1B1B4:  DATA B8,51
1B1B6:  DATA E0,74
1B1B8:  DATA 08,98
1B1BA:  DATA 30,BB
1B1BC:  DATA 58,DE
1B1BE:  DATA 80,01
1B1C0:  DATA A8,24
1B1C2:  DATA D0,47
1B1C4:  DATA F8,6A
1B1C6:  DATA 20,8E
1B1C8:  DATA 00,00
1B1CA:  MOVLW  01
1B1CC:  MOVWF  FF8
1B1CE:  MOVLW  B1
1B1D0:  MOVWF  FF7
1B1D2:  MOVLW  0A
1B1D4:  MOVWF  FF6
1B1D6:  TBLRD*+
1B1D8:  MOVF   FF5,W
1B1DA:  MOVWF  00
1B1DC:  XORLW  00
1B1DE:  BZ    1B206
1B1E0:  TBLRD*+
1B1E2:  MOVF   FF5,W
1B1E4:  MOVWF  01
1B1E6:  BTFSC  FE8.7
1B1E8:  BRA    1B1F4
1B1EA:  ANDLW  0F
1B1EC:  MOVWF  FEA
1B1EE:  TBLRD*+
1B1F0:  MOVFF  FF5,FE9
1B1F4:  BTFSC  01.6
1B1F6:  TBLRD*+
1B1F8:  BTFSS  01.6
1B1FA:  TBLRD*+
1B1FC:  MOVFF  FF5,FEE
1B200:  DCFSNZ 00,F
1B202:  BRA    1B1D6
1B204:  BRA    1B1F8
1B206:  CLRF   FF8
1B208:  MOVLB  8
1B20A:  CLRF   x5D
1B20C:  CLRF   x5F
1B20E:  CLRF   x5E
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B210:  BCF    FF2.6
1B212:  BCF    FF2.7
1B214:  BTFSC  FF2.7
1B216:  BRA    1B212
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B218:  BCF    FC6.5
1B21A:  MOVLW  21
1B21C:  MOVWF  FC6
1B21E:  MOVLW  40
1B220:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B222:  BCF    F67.5
1B224:  MOVLW  21
1B226:  MOVWF  F67
1B228:  MOVLW  40
1B22A:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B22C:  MOVLW  00
1B22E:  MOVLB  F
1B230:  MOVWF  x23
1B232:  MOVWF  x24
1B234:  MOVLW  1F
1B236:  MOVWF  x25
1B238:  BCF    FC1.3
1B23A:  BSF    FC1.4
1B23C:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B23E:  MOVF   FC0,W
1B240:  ANDLW  C0
1B242:  IORLW  07
1B244:  MOVWF  FC0
1B246:  BSF    FC0.7
1B248:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B24A:  MOVLW  87
1B24C:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B24E:  MOVLW  37
1B250:  MOVWF  FCD
1B252:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B254:  MOVLB  0
1B256:  GOTO   2918
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B25A:  CLRF   FB0
1B25C:  MOVLW  07
1B25E:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B260:  MOVLW  04
1B262:  MOVLB  F
1B264:  MOVWF  x2E
1B266:  MOVWF  x2F
1B268:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B26A:  MOVLW  70
1B26C:  MOVWF  FD3
1B26E:  MOVLW  40
1B270:  MOVWF  F9B
1B272:  CLRF   F64
....................     
....................    //setup_wdt(WDT_4S); 
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B274:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B276:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B278:  MOVLB  0
1B27A:  CALL   2954
....................  
....................    enable_interrupts(GLOBAL); 
1B27E:  MOVLW  C0
1B280:  IORWF  FF2,F
....................     
....................     
....................  
....................    init_hardware(); 
1B282:  CALL   298E
....................    motor_sleep_rdy(); 
1B286:  CALL   29EC
....................  
....................    sleep_mode = FALSE;    
1B28A:  BCF    49.1
....................    busy_set(); 
1B28C:  CALL   2A14
....................     
....................    init_nv_vars(); 
1B290:  CALL   2B0C
....................    get_step_vars(); 
1B294:  CALL   2D6E
....................    init_aws(); 
1B298:  GOTO   3130
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B29C:  CALL   314A
....................    blink(); 
1B2A0:  GOTO   3150
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B2A4:  CALL   319C
....................     
....................    RTC_read(); 
1B2A8:  CALL   3398
....................    RTC_last_power(); 
1B2AC:  GOTO   3496
....................    RTC_reset_HT();   
1B2B0:  CALL   3506
....................    RTC_read(); 
1B2B4:  CALL   3398
1B2B8:  CLRF   1B
1B2BA:  BTFSC  FF2.7
1B2BC:  BSF    1B.7
1B2BE:  BCF    FF2.7
....................    RTC_read_flags(); 
1B2C0:  CALL   0DCC
1B2C4:  BTFSC  1B.7
1B2C6:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B2C8:  MOVF   3B,F
1B2CA:  BNZ   1B2D0
1B2CC:  MOVF   3C,F
1B2CE:  BZ    1B320
1B2D0:  MOVLW  CE
1B2D2:  MOVWF  FF6
1B2D4:  MOVLW  27
1B2D6:  MOVWF  FF7
1B2D8:  MOVLW  00
1B2DA:  MOVWF  FF8
1B2DC:  CLRF   1B
1B2DE:  BTFSC  FF2.7
1B2E0:  BSF    1B.7
1B2E2:  BCF    FF2.7
1B2E4:  MOVLW  04
1B2E6:  MOVLB  A
1B2E8:  MOVWF  x25
1B2EA:  MOVLB  0
1B2EC:  CALL   1010
1B2F0:  BTFSC  1B.7
1B2F2:  BSF    FF2.7
1B2F4:  MOVLW  10
1B2F6:  MOVWF  FE9
1B2F8:  CLRF   1B
1B2FA:  BTFSC  FF2.7
1B2FC:  BSF    1B.7
1B2FE:  BCF    FF2.7
1B300:  MOVFF  3C,A26
1B304:  MOVFF  3B,A25
1B308:  CALL   1192
1B30C:  BTFSC  1B.7
1B30E:  BSF    FF2.7
1B310:  MOVLW  0D
1B312:  BTFSS  F9E.4
1B314:  BRA    1B312
1B316:  MOVWF  FAD
1B318:  MOVLW  0A
1B31A:  BTFSS  F9E.4
1B31C:  BRA    1B31A
1B31E:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B320:  CALL   355C
....................    sd_status = init_sdcard(); 
1B324:  CALL   5084
1B328:  MOVFF  01,2D8
....................    if(sd_status>0) msg_card_fail(); 
1B32C:  MOVLB  2
1B32E:  MOVF   xD8,F
1B330:  BZ    1B33A
1B332:  MOVLB  0
1B334:  CALL   50CA
1B338:  MOVLB  2
....................    
....................     
....................     
....................    reset_event(); 
1B33A:  MOVLB  0
1B33C:  GOTO   ABF0
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B340:  MOVLB  7
1B342:  MOVF   x92,F
1B344:  BNZ   1B352
1B346:  MOVF   x93,F
1B348:  BNZ   1B352
1B34A:  MOVF   x94,F
1B34C:  BNZ   1B352
1B34E:  MOVF   x95,F
1B350:  BZ    1B35A
1B352:  MOVLB  0
1B354:  CALL   9D34
1B358:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B35A:  MOVF   xAB,F
1B35C:  BNZ   1B3E0
1B35E:  MOVF   xAC,F
1B360:  BNZ   1B3E0
....................       e_port[0]=0; 
1B362:  CLRF   xC0
1B364:  CLRF   xBF
....................       write16(ADDR_E1_PORT,0); 
1B366:  MOVLW  AA
1B368:  MOVLB  8
1B36A:  MOVWF  xD8
1B36C:  CLRF   xDA
1B36E:  CLRF   xD9
1B370:  MOVLB  0
1B372:  CALL   501E
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B376:  MOVLW  D8
1B378:  MOVWF  FF6
1B37A:  MOVLW  27
1B37C:  MOVWF  FF7
1B37E:  MOVLW  00
1B380:  MOVWF  FF8
1B382:  CLRF   1B
1B384:  BTFSC  FF2.7
1B386:  BSF    1B.7
1B388:  BCF    FF2.7
1B38A:  MOVLW  05
1B38C:  MOVLB  A
1B38E:  MOVWF  x25
1B390:  MOVLB  0
1B392:  CALL   1010
1B396:  BTFSC  1B.7
1B398:  BSF    FF2.7
1B39A:  MOVLW  10
1B39C:  MOVWF  FE9
1B39E:  CLRF   1B
1B3A0:  BTFSC  FF2.7
1B3A2:  BSF    1B.7
1B3A4:  BCF    FF2.7
1B3A6:  MOVFF  7AC,A26
1B3AA:  MOVFF  7AB,A25
1B3AE:  CALL   1192
1B3B2:  BTFSC  1B.7
1B3B4:  BSF    FF2.7
1B3B6:  MOVLW  2C
1B3B8:  BTFSS  F9E.4
1B3BA:  BRA    1B3B8
1B3BC:  MOVWF  FAD
1B3BE:  MOVLW  10
1B3C0:  MOVWF  FE9
1B3C2:  MOVFF  7C0,8DB
1B3C6:  MOVFF  7BF,8DA
1B3CA:  CALL   9016
1B3CE:  MOVLW  0D
1B3D0:  BTFSS  F9E.4
1B3D2:  BRA    1B3D0
1B3D4:  MOVWF  FAD
1B3D6:  MOVLW  0A
1B3D8:  BTFSS  F9E.4
1B3DA:  BRA    1B3D8
1B3DC:  MOVWF  FAD
1B3DE:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B3E0:  MOVF   xAD,F
1B3E2:  BNZ   1B466
1B3E4:  MOVF   xAE,F
1B3E6:  BNZ   1B466
....................       m_lin_pos[1]=-1; 
1B3E8:  SETF   xB2
1B3EA:  SETF   xB1
....................       write16(ADDR_M2_LIN_POS, -1); 
1B3EC:  MOVLW  B8
1B3EE:  MOVLB  8
1B3F0:  MOVWF  xD8
1B3F2:  SETF   xDA
1B3F4:  SETF   xD9
1B3F6:  MOVLB  0
1B3F8:  CALL   501E
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B3FC:  MOVLW  E8
1B3FE:  MOVWF  FF6
1B400:  MOVLW  27
1B402:  MOVWF  FF7
1B404:  MOVLW  00
1B406:  MOVWF  FF8
1B408:  CLRF   1B
1B40A:  BTFSC  FF2.7
1B40C:  BSF    1B.7
1B40E:  BCF    FF2.7
1B410:  MOVLW  05
1B412:  MOVLB  A
1B414:  MOVWF  x25
1B416:  MOVLB  0
1B418:  CALL   1010
1B41C:  BTFSC  1B.7
1B41E:  BSF    FF2.7
1B420:  MOVLW  10
1B422:  MOVWF  FE9
1B424:  CLRF   1B
1B426:  BTFSC  FF2.7
1B428:  BSF    1B.7
1B42A:  BCF    FF2.7
1B42C:  MOVFF  7AE,A26
1B430:  MOVFF  7AD,A25
1B434:  CALL   1192
1B438:  BTFSC  1B.7
1B43A:  BSF    FF2.7
1B43C:  MOVLW  2C
1B43E:  BTFSS  F9E.4
1B440:  BRA    1B43E
1B442:  MOVWF  FAD
1B444:  MOVLW  10
1B446:  MOVWF  FE9
1B448:  MOVFF  7B2,8DB
1B44C:  MOVFF  7B1,8DA
1B450:  CALL   9016
1B454:  MOVLW  0D
1B456:  BTFSS  F9E.4
1B458:  BRA    1B456
1B45A:  MOVWF  FAD
1B45C:  MOVLW  0A
1B45E:  BTFSS  F9E.4
1B460:  BRA    1B45E
1B462:  MOVWF  FAD
1B464:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1B466:  MOVF   31,F
1B468:  BNZ   1B50C
1B46A:  MOVF   32,F
1B46C:  BNZ   1B50C
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1B46E:  MOVLW  F8
1B470:  MOVWF  FF6
1B472:  MOVLW  27
1B474:  MOVWF  FF7
1B476:  MOVLW  00
1B478:  MOVWF  FF8
1B47A:  CLRF   1B
1B47C:  BTFSC  FF2.7
1B47E:  BSF    1B.7
1B480:  BCF    FF2.7
1B482:  MOVLB  0
1B484:  CALL   0E3A
1B488:  BTFSC  1B.7
1B48A:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1B48C:  MOVLB  8
1B48E:  MOVF   x5F,F
1B490:  BNZ   1B4BE
1B492:  MOVF   x5E,W
1B494:  SUBLW  63
1B496:  BNC   1B4BE
1B498:  MOVF   x5D,W
1B49A:  SUBLW  1B
1B49C:  BZ    1B4BE
....................       { 
....................          EscNum=TestForEsc(); 
1B49E:  MOVLB  0
1B4A0:  GOTO   AE1A
1B4A4:  MOVFF  01,85D
....................          if(EscNum == ESCAPE) command_prompt(); 
1B4A8:  MOVLB  8
1B4AA:  MOVF   x5D,W
1B4AC:  SUBLW  1B
1B4AE:  BNZ   1B4B6
1B4B0:  MOVLB  0
1B4B2:  RCALL  1AFDC
1B4B4:  MOVLB  8
....................          EscCount++; 
1B4B6:  INCF   x5E,F
1B4B8:  BTFSC  FD8.2
1B4BA:  INCF   x5F,F
1B4BC:  BRA    1B48E
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1B4BE:  DECFSZ 33,W
1B4C0:  BRA    1B4D6
1B4C2:  MOVF   34,F
1B4C4:  BNZ   1B4D6
....................       { 
....................          arg=0; 
1B4C6:  CLRF   47
1B4C8:  CLRF   46
1B4CA:  CLRF   45
1B4CC:  CLRF   44
....................          commandZ(); 
1B4CE:  MOVLB  0
1B4D0:  CALL   186CE
1B4D4:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1B4D6:  MOVLW  30
1B4D8:  MOVWF  FF6
1B4DA:  MOVLW  28
1B4DC:  MOVWF  FF7
1B4DE:  MOVLW  00
1B4E0:  MOVWF  FF8
1B4E2:  CLRF   1B
1B4E4:  BTFSC  FF2.7
1B4E6:  BSF    1B.7
1B4E8:  BCF    FF2.7
1B4EA:  MOVLB  0
1B4EC:  CALL   0E3A
1B4F0:  BTFSC  1B.7
1B4F2:  BSF    FF2.7
....................       arg = 0; 
1B4F4:  CLRF   47
1B4F6:  CLRF   46
1B4F8:  CLRF   45
1B4FA:  CLRF   44
....................       commandM(TRUE); 
1B4FC:  MOVLW  01
1B4FE:  MOVLB  8
1B500:  MOVWF  x6F
1B502:  MOVLB  0
1B504:  CALL   1699A
....................    } 
1B508:  BRA    1BB8E
1B50A:  MOVLB  7
....................    else 
....................    { 
....................       int8 RTC_buffer = 0; 
....................       unsigned int8 a0 = 0; 
....................       unsigned int8 a1 = 0; 
....................       unsigned int8 a2 = 0; 
....................       unsigned int8 a3 = 0; 
....................       unsigned int8 a4 = 0; 
....................       unsigned int8 a5 = 0; 
....................       unsigned int8 a6 = 0; 
....................       unsigned int8 a7 = 0; 
....................       unsigned int8 a8 = 0; 
....................       unsigned int8 a9 = 0; 
....................       unsigned int8 a10 = 0; 
....................       unsigned int8 a11 = 0; 
1B50C:  MOVLB  8
1B50E:  CLRF   x60
1B510:  CLRF   x61
1B512:  CLRF   x62
1B514:  CLRF   x63
1B516:  CLRF   x64
1B518:  CLRF   x65
1B51A:  CLRF   x66
1B51C:  CLRF   x67
1B51E:  CLRF   x68
1B520:  CLRF   x69
1B522:  CLRF   x6A
1B524:  CLRF   x6B
1B526:  CLRF   x6C
....................        
....................       RTC_reset_HT(); 
1B528:  MOVLB  0
1B52A:  CALL   3506
....................       output_bit(RTC_CS, ENABLE); 
1B52E:  BCF    F91.0
....................       spi_write(0x89); 
1B530:  MOVF   FC9,W
1B532:  MOVLW  89
1B534:  MOVWF  FC9
1B536:  RRCF   FC7,W
1B538:  BNC   1B536
....................       spi_write(0b11000011); 
1B53A:  MOVF   FC9,W
1B53C:  MOVLW  C3
1B53E:  MOVWF  FC9
1B540:  RRCF   FC7,W
1B542:  BNC   1B540
....................       output_bit(RTC_CS, DISABLE); 
1B544:  BSF    F91.0
....................        
....................       output_bit(RTC_CS, ENABLE); 
1B546:  BCF    F91.0
....................       RTC_buffer = spi_read(0x00); 
1B548:  MOVF   FC9,W
1B54A:  CLRF   FC9
1B54C:  RRCF   FC7,W
1B54E:  BNC   1B54C
1B550:  MOVFF  FC9,860
....................       a0 = RTC_buffer; 
1B554:  MOVFF  860,861
....................       fprintf(COM_A,"crap: %u\r\n",RTC_buffer); 
1B558:  MOVLW  4C
1B55A:  MOVWF  FF6
1B55C:  MOVLW  28
1B55E:  MOVWF  FF7
1B560:  MOVLW  00
1B562:  MOVWF  FF8
1B564:  CLRF   1B
1B566:  BTFSC  FF2.7
1B568:  BSF    1B.7
1B56A:  BCF    FF2.7
1B56C:  MOVLW  06
1B56E:  MOVLB  A
1B570:  MOVWF  x25
1B572:  MOVLB  0
1B574:  CALL   1010
1B578:  BTFSC  1B.7
1B57A:  BSF    FF2.7
1B57C:  CLRF   1B
1B57E:  BTFSC  FF2.7
1B580:  BSF    1B.7
1B582:  BCF    FF2.7
1B584:  MOVFF  860,A25
1B588:  MOVLW  1B
1B58A:  MOVLB  A
1B58C:  MOVWF  x26
1B58E:  MOVLB  0
1B590:  CALL   0F92
1B594:  BTFSC  1B.7
1B596:  BSF    FF2.7
1B598:  MOVLW  0D
1B59A:  BTFSS  F9E.4
1B59C:  BRA    1B59A
1B59E:  MOVWF  FAD
1B5A0:  MOVLW  0A
1B5A2:  BTFSS  F9E.4
1B5A4:  BRA    1B5A2
1B5A6:  MOVWF  FAD
....................       a1 = spi_read(RTC_buffer); 
1B5A8:  MOVF   FC9,W
1B5AA:  MOVFF  860,FC9
1B5AE:  RRCF   FC7,W
1B5B0:  BNC   1B5AE
1B5B2:  MOVFF  FC9,862
....................       fprintf(COM_A,"reg0: %u\r\n",a1); 
1B5B6:  MOVLW  58
1B5B8:  MOVWF  FF6
1B5BA:  MOVLW  28
1B5BC:  MOVWF  FF7
1B5BE:  MOVLW  00
1B5C0:  MOVWF  FF8
1B5C2:  CLRF   1B
1B5C4:  BTFSC  FF2.7
1B5C6:  BSF    1B.7
1B5C8:  BCF    FF2.7
1B5CA:  MOVLW  06
1B5CC:  MOVLB  A
1B5CE:  MOVWF  x25
1B5D0:  MOVLB  0
1B5D2:  CALL   1010
1B5D6:  BTFSC  1B.7
1B5D8:  BSF    FF2.7
1B5DA:  CLRF   1B
1B5DC:  BTFSC  FF2.7
1B5DE:  BSF    1B.7
1B5E0:  BCF    FF2.7
1B5E2:  MOVFF  862,A25
1B5E6:  MOVLW  1B
1B5E8:  MOVLB  A
1B5EA:  MOVWF  x26
1B5EC:  MOVLB  0
1B5EE:  CALL   0F92
1B5F2:  BTFSC  1B.7
1B5F4:  BSF    FF2.7
1B5F6:  MOVLW  0D
1B5F8:  BTFSS  F9E.4
1B5FA:  BRA    1B5F8
1B5FC:  MOVWF  FAD
1B5FE:  MOVLW  0A
1B600:  BTFSS  F9E.4
1B602:  BRA    1B600
1B604:  MOVWF  FAD
....................       a2 = spi_read(RTC_buffer); 
1B606:  MOVF   FC9,W
1B608:  MOVFF  860,FC9
1B60C:  RRCF   FC7,W
1B60E:  BNC   1B60C
1B610:  MOVFF  FC9,863
....................       fprintf(COM_A,"reg1: %u\r\n",a2); 
1B614:  MOVLW  64
1B616:  MOVWF  FF6
1B618:  MOVLW  28
1B61A:  MOVWF  FF7
1B61C:  MOVLW  00
1B61E:  MOVWF  FF8
1B620:  CLRF   1B
1B622:  BTFSC  FF2.7
1B624:  BSF    1B.7
1B626:  BCF    FF2.7
1B628:  MOVLW  06
1B62A:  MOVLB  A
1B62C:  MOVWF  x25
1B62E:  MOVLB  0
1B630:  CALL   1010
1B634:  BTFSC  1B.7
1B636:  BSF    FF2.7
1B638:  CLRF   1B
1B63A:  BTFSC  FF2.7
1B63C:  BSF    1B.7
1B63E:  BCF    FF2.7
1B640:  MOVFF  863,A25
1B644:  MOVLW  1B
1B646:  MOVLB  A
1B648:  MOVWF  x26
1B64A:  MOVLB  0
1B64C:  CALL   0F92
1B650:  BTFSC  1B.7
1B652:  BSF    FF2.7
1B654:  MOVLW  0D
1B656:  BTFSS  F9E.4
1B658:  BRA    1B656
1B65A:  MOVWF  FAD
1B65C:  MOVLW  0A
1B65E:  BTFSS  F9E.4
1B660:  BRA    1B65E
1B662:  MOVWF  FAD
....................       a3 = spi_read(RTC_buffer); 
1B664:  MOVF   FC9,W
1B666:  MOVFF  860,FC9
1B66A:  RRCF   FC7,W
1B66C:  BNC   1B66A
1B66E:  MOVFF  FC9,864
....................       fprintf(COM_A,"reg2: %u\r\n",a3); 
1B672:  MOVLW  70
1B674:  MOVWF  FF6
1B676:  MOVLW  28
1B678:  MOVWF  FF7
1B67A:  MOVLW  00
1B67C:  MOVWF  FF8
1B67E:  CLRF   1B
1B680:  BTFSC  FF2.7
1B682:  BSF    1B.7
1B684:  BCF    FF2.7
1B686:  MOVLW  06
1B688:  MOVLB  A
1B68A:  MOVWF  x25
1B68C:  MOVLB  0
1B68E:  CALL   1010
1B692:  BTFSC  1B.7
1B694:  BSF    FF2.7
1B696:  CLRF   1B
1B698:  BTFSC  FF2.7
1B69A:  BSF    1B.7
1B69C:  BCF    FF2.7
1B69E:  MOVFF  864,A25
1B6A2:  MOVLW  1B
1B6A4:  MOVLB  A
1B6A6:  MOVWF  x26
1B6A8:  MOVLB  0
1B6AA:  CALL   0F92
1B6AE:  BTFSC  1B.7
1B6B0:  BSF    FF2.7
1B6B2:  MOVLW  0D
1B6B4:  BTFSS  F9E.4
1B6B6:  BRA    1B6B4
1B6B8:  MOVWF  FAD
1B6BA:  MOVLW  0A
1B6BC:  BTFSS  F9E.4
1B6BE:  BRA    1B6BC
1B6C0:  MOVWF  FAD
....................       a4 = spi_read(RTC_buffer); 
1B6C2:  MOVF   FC9,W
1B6C4:  MOVFF  860,FC9
1B6C8:  RRCF   FC7,W
1B6CA:  BNC   1B6C8
1B6CC:  MOVFF  FC9,865
....................       fprintf(COM_A,"reg3: %u\r\n",a4); 
1B6D0:  MOVLW  7C
1B6D2:  MOVWF  FF6
1B6D4:  MOVLW  28
1B6D6:  MOVWF  FF7
1B6D8:  MOVLW  00
1B6DA:  MOVWF  FF8
1B6DC:  CLRF   1B
1B6DE:  BTFSC  FF2.7
1B6E0:  BSF    1B.7
1B6E2:  BCF    FF2.7
1B6E4:  MOVLW  06
1B6E6:  MOVLB  A
1B6E8:  MOVWF  x25
1B6EA:  MOVLB  0
1B6EC:  CALL   1010
1B6F0:  BTFSC  1B.7
1B6F2:  BSF    FF2.7
1B6F4:  CLRF   1B
1B6F6:  BTFSC  FF2.7
1B6F8:  BSF    1B.7
1B6FA:  BCF    FF2.7
1B6FC:  MOVFF  865,A25
1B700:  MOVLW  1B
1B702:  MOVLB  A
1B704:  MOVWF  x26
1B706:  MOVLB  0
1B708:  CALL   0F92
1B70C:  BTFSC  1B.7
1B70E:  BSF    FF2.7
1B710:  MOVLW  0D
1B712:  BTFSS  F9E.4
1B714:  BRA    1B712
1B716:  MOVWF  FAD
1B718:  MOVLW  0A
1B71A:  BTFSS  F9E.4
1B71C:  BRA    1B71A
1B71E:  MOVWF  FAD
....................       a5 = spi_read(RTC_buffer); 
1B720:  MOVF   FC9,W
1B722:  MOVFF  860,FC9
1B726:  RRCF   FC7,W
1B728:  BNC   1B726
1B72A:  MOVFF  FC9,866
....................       fprintf(COM_A,"reg4: %u\r\n",a5); 
1B72E:  MOVLW  88
1B730:  MOVWF  FF6
1B732:  MOVLW  28
1B734:  MOVWF  FF7
1B736:  MOVLW  00
1B738:  MOVWF  FF8
1B73A:  CLRF   1B
1B73C:  BTFSC  FF2.7
1B73E:  BSF    1B.7
1B740:  BCF    FF2.7
1B742:  MOVLW  06
1B744:  MOVLB  A
1B746:  MOVWF  x25
1B748:  MOVLB  0
1B74A:  CALL   1010
1B74E:  BTFSC  1B.7
1B750:  BSF    FF2.7
1B752:  CLRF   1B
1B754:  BTFSC  FF2.7
1B756:  BSF    1B.7
1B758:  BCF    FF2.7
1B75A:  MOVFF  866,A25
1B75E:  MOVLW  1B
1B760:  MOVLB  A
1B762:  MOVWF  x26
1B764:  MOVLB  0
1B766:  CALL   0F92
1B76A:  BTFSC  1B.7
1B76C:  BSF    FF2.7
1B76E:  MOVLW  0D
1B770:  BTFSS  F9E.4
1B772:  BRA    1B770
1B774:  MOVWF  FAD
1B776:  MOVLW  0A
1B778:  BTFSS  F9E.4
1B77A:  BRA    1B778
1B77C:  MOVWF  FAD
....................       a6 = spi_read(RTC_buffer); 
1B77E:  MOVF   FC9,W
1B780:  MOVFF  860,FC9
1B784:  RRCF   FC7,W
1B786:  BNC   1B784
1B788:  MOVFF  FC9,867
....................       fprintf(COM_A,"reg5: %u\r\n",a6); 
1B78C:  MOVLW  94
1B78E:  MOVWF  FF6
1B790:  MOVLW  28
1B792:  MOVWF  FF7
1B794:  MOVLW  00
1B796:  MOVWF  FF8
1B798:  CLRF   1B
1B79A:  BTFSC  FF2.7
1B79C:  BSF    1B.7
1B79E:  BCF    FF2.7
1B7A0:  MOVLW  06
1B7A2:  MOVLB  A
1B7A4:  MOVWF  x25
1B7A6:  MOVLB  0
1B7A8:  CALL   1010
1B7AC:  BTFSC  1B.7
1B7AE:  BSF    FF2.7
1B7B0:  CLRF   1B
1B7B2:  BTFSC  FF2.7
1B7B4:  BSF    1B.7
1B7B6:  BCF    FF2.7
1B7B8:  MOVFF  867,A25
1B7BC:  MOVLW  1B
1B7BE:  MOVLB  A
1B7C0:  MOVWF  x26
1B7C2:  MOVLB  0
1B7C4:  CALL   0F92
1B7C8:  BTFSC  1B.7
1B7CA:  BSF    FF2.7
1B7CC:  MOVLW  0D
1B7CE:  BTFSS  F9E.4
1B7D0:  BRA    1B7CE
1B7D2:  MOVWF  FAD
1B7D4:  MOVLW  0A
1B7D6:  BTFSS  F9E.4
1B7D8:  BRA    1B7D6
1B7DA:  MOVWF  FAD
....................       a7 = spi_read(RTC_buffer); 
1B7DC:  MOVF   FC9,W
1B7DE:  MOVFF  860,FC9
1B7E2:  RRCF   FC7,W
1B7E4:  BNC   1B7E2
1B7E6:  MOVFF  FC9,868
....................       fprintf(COM_A,"reg6: %u\r\n",a7); 
1B7EA:  MOVLW  A0
1B7EC:  MOVWF  FF6
1B7EE:  MOVLW  28
1B7F0:  MOVWF  FF7
1B7F2:  MOVLW  00
1B7F4:  MOVWF  FF8
1B7F6:  CLRF   1B
1B7F8:  BTFSC  FF2.7
1B7FA:  BSF    1B.7
1B7FC:  BCF    FF2.7
1B7FE:  MOVLW  06
1B800:  MOVLB  A
1B802:  MOVWF  x25
1B804:  MOVLB  0
1B806:  CALL   1010
1B80A:  BTFSC  1B.7
1B80C:  BSF    FF2.7
1B80E:  CLRF   1B
1B810:  BTFSC  FF2.7
1B812:  BSF    1B.7
1B814:  BCF    FF2.7
1B816:  MOVFF  868,A25
1B81A:  MOVLW  1B
1B81C:  MOVLB  A
1B81E:  MOVWF  x26
1B820:  MOVLB  0
1B822:  CALL   0F92
1B826:  BTFSC  1B.7
1B828:  BSF    FF2.7
1B82A:  MOVLW  0D
1B82C:  BTFSS  F9E.4
1B82E:  BRA    1B82C
1B830:  MOVWF  FAD
1B832:  MOVLW  0A
1B834:  BTFSS  F9E.4
1B836:  BRA    1B834
1B838:  MOVWF  FAD
....................       a8 = spi_read(RTC_buffer); 
1B83A:  MOVF   FC9,W
1B83C:  MOVFF  860,FC9
1B840:  RRCF   FC7,W
1B842:  BNC   1B840
1B844:  MOVFF  FC9,869
....................       fprintf(COM_A,"reg7: %u\r\n",a8); 
1B848:  MOVLW  AC
1B84A:  MOVWF  FF6
1B84C:  MOVLW  28
1B84E:  MOVWF  FF7
1B850:  MOVLW  00
1B852:  MOVWF  FF8
1B854:  CLRF   1B
1B856:  BTFSC  FF2.7
1B858:  BSF    1B.7
1B85A:  BCF    FF2.7
1B85C:  MOVLW  06
1B85E:  MOVLB  A
1B860:  MOVWF  x25
1B862:  MOVLB  0
1B864:  CALL   1010
1B868:  BTFSC  1B.7
1B86A:  BSF    FF2.7
1B86C:  CLRF   1B
1B86E:  BTFSC  FF2.7
1B870:  BSF    1B.7
1B872:  BCF    FF2.7
1B874:  MOVFF  869,A25
1B878:  MOVLW  1B
1B87A:  MOVLB  A
1B87C:  MOVWF  x26
1B87E:  MOVLB  0
1B880:  CALL   0F92
1B884:  BTFSC  1B.7
1B886:  BSF    FF2.7
1B888:  MOVLW  0D
1B88A:  BTFSS  F9E.4
1B88C:  BRA    1B88A
1B88E:  MOVWF  FAD
1B890:  MOVLW  0A
1B892:  BTFSS  F9E.4
1B894:  BRA    1B892
1B896:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1B898:  MOVF   FC9,W
1B89A:  MOVFF  860,FC9
1B89E:  RRCF   FC7,W
1B8A0:  BNC   1B89E
1B8A2:  MOVFF  FC9,86A
....................       fprintf(COM_A,"reg8: %u\r\n",a9); 
1B8A6:  MOVLW  B8
1B8A8:  MOVWF  FF6
1B8AA:  MOVLW  28
1B8AC:  MOVWF  FF7
1B8AE:  MOVLW  00
1B8B0:  MOVWF  FF8
1B8B2:  CLRF   1B
1B8B4:  BTFSC  FF2.7
1B8B6:  BSF    1B.7
1B8B8:  BCF    FF2.7
1B8BA:  MOVLW  06
1B8BC:  MOVLB  A
1B8BE:  MOVWF  x25
1B8C0:  MOVLB  0
1B8C2:  CALL   1010
1B8C6:  BTFSC  1B.7
1B8C8:  BSF    FF2.7
1B8CA:  CLRF   1B
1B8CC:  BTFSC  FF2.7
1B8CE:  BSF    1B.7
1B8D0:  BCF    FF2.7
1B8D2:  MOVFF  86A,A25
1B8D6:  MOVLW  1B
1B8D8:  MOVLB  A
1B8DA:  MOVWF  x26
1B8DC:  MOVLB  0
1B8DE:  CALL   0F92
1B8E2:  BTFSC  1B.7
1B8E4:  BSF    FF2.7
1B8E6:  MOVLW  0D
1B8E8:  BTFSS  F9E.4
1B8EA:  BRA    1B8E8
1B8EC:  MOVWF  FAD
1B8EE:  MOVLW  0A
1B8F0:  BTFSS  F9E.4
1B8F2:  BRA    1B8F0
1B8F4:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1B8F6:  MOVF   FC9,W
1B8F8:  MOVFF  860,FC9
1B8FC:  RRCF   FC7,W
1B8FE:  BNC   1B8FC
1B900:  MOVFF  FC9,86A
....................       fprintf(COM_A,"reg9: %u\r\n",a9); 
1B904:  MOVLW  C4
1B906:  MOVWF  FF6
1B908:  MOVLW  28
1B90A:  MOVWF  FF7
1B90C:  MOVLW  00
1B90E:  MOVWF  FF8
1B910:  CLRF   1B
1B912:  BTFSC  FF2.7
1B914:  BSF    1B.7
1B916:  BCF    FF2.7
1B918:  MOVLW  06
1B91A:  MOVLB  A
1B91C:  MOVWF  x25
1B91E:  MOVLB  0
1B920:  CALL   1010
1B924:  BTFSC  1B.7
1B926:  BSF    FF2.7
1B928:  CLRF   1B
1B92A:  BTFSC  FF2.7
1B92C:  BSF    1B.7
1B92E:  BCF    FF2.7
1B930:  MOVFF  86A,A25
1B934:  MOVLW  1B
1B936:  MOVLB  A
1B938:  MOVWF  x26
1B93A:  MOVLB  0
1B93C:  CALL   0F92
1B940:  BTFSC  1B.7
1B942:  BSF    FF2.7
1B944:  MOVLW  0D
1B946:  BTFSS  F9E.4
1B948:  BRA    1B946
1B94A:  MOVWF  FAD
1B94C:  MOVLW  0A
1B94E:  BTFSS  F9E.4
1B950:  BRA    1B94E
1B952:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1B954:  MOVF   FC9,W
1B956:  MOVFF  860,FC9
1B95A:  RRCF   FC7,W
1B95C:  BNC   1B95A
1B95E:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regA: %u\r\n",a9); 
1B962:  MOVLW  D0
1B964:  MOVWF  FF6
1B966:  MOVLW  28
1B968:  MOVWF  FF7
1B96A:  MOVLW  00
1B96C:  MOVWF  FF8
1B96E:  CLRF   1B
1B970:  BTFSC  FF2.7
1B972:  BSF    1B.7
1B974:  BCF    FF2.7
1B976:  MOVLW  06
1B978:  MOVLB  A
1B97A:  MOVWF  x25
1B97C:  MOVLB  0
1B97E:  CALL   1010
1B982:  BTFSC  1B.7
1B984:  BSF    FF2.7
1B986:  CLRF   1B
1B988:  BTFSC  FF2.7
1B98A:  BSF    1B.7
1B98C:  BCF    FF2.7
1B98E:  MOVFF  86A,A25
1B992:  MOVLW  1B
1B994:  MOVLB  A
1B996:  MOVWF  x26
1B998:  MOVLB  0
1B99A:  CALL   0F92
1B99E:  BTFSC  1B.7
1B9A0:  BSF    FF2.7
1B9A2:  MOVLW  0D
1B9A4:  BTFSS  F9E.4
1B9A6:  BRA    1B9A4
1B9A8:  MOVWF  FAD
1B9AA:  MOVLW  0A
1B9AC:  BTFSS  F9E.4
1B9AE:  BRA    1B9AC
1B9B0:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1B9B2:  MOVF   FC9,W
1B9B4:  MOVFF  860,FC9
1B9B8:  RRCF   FC7,W
1B9BA:  BNC   1B9B8
1B9BC:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regB: %u\r\n",a9); 
1B9C0:  MOVLW  DC
1B9C2:  MOVWF  FF6
1B9C4:  MOVLW  28
1B9C6:  MOVWF  FF7
1B9C8:  MOVLW  00
1B9CA:  MOVWF  FF8
1B9CC:  CLRF   1B
1B9CE:  BTFSC  FF2.7
1B9D0:  BSF    1B.7
1B9D2:  BCF    FF2.7
1B9D4:  MOVLW  06
1B9D6:  MOVLB  A
1B9D8:  MOVWF  x25
1B9DA:  MOVLB  0
1B9DC:  CALL   1010
1B9E0:  BTFSC  1B.7
1B9E2:  BSF    FF2.7
1B9E4:  CLRF   1B
1B9E6:  BTFSC  FF2.7
1B9E8:  BSF    1B.7
1B9EA:  BCF    FF2.7
1B9EC:  MOVFF  86A,A25
1B9F0:  MOVLW  1B
1B9F2:  MOVLB  A
1B9F4:  MOVWF  x26
1B9F6:  MOVLB  0
1B9F8:  CALL   0F92
1B9FC:  BTFSC  1B.7
1B9FE:  BSF    FF2.7
1BA00:  MOVLW  0D
1BA02:  BTFSS  F9E.4
1BA04:  BRA    1BA02
1BA06:  MOVWF  FAD
1BA08:  MOVLW  0A
1BA0A:  BTFSS  F9E.4
1BA0C:  BRA    1BA0A
1BA0E:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1BA10:  MOVF   FC9,W
1BA12:  MOVFF  860,FC9
1BA16:  RRCF   FC7,W
1BA18:  BNC   1BA16
1BA1A:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regC: %u\r\n",a9); 
1BA1E:  MOVLW  E8
1BA20:  MOVWF  FF6
1BA22:  MOVLW  28
1BA24:  MOVWF  FF7
1BA26:  MOVLW  00
1BA28:  MOVWF  FF8
1BA2A:  CLRF   1B
1BA2C:  BTFSC  FF2.7
1BA2E:  BSF    1B.7
1BA30:  BCF    FF2.7
1BA32:  MOVLW  06
1BA34:  MOVLB  A
1BA36:  MOVWF  x25
1BA38:  MOVLB  0
1BA3A:  CALL   1010
1BA3E:  BTFSC  1B.7
1BA40:  BSF    FF2.7
1BA42:  CLRF   1B
1BA44:  BTFSC  FF2.7
1BA46:  BSF    1B.7
1BA48:  BCF    FF2.7
1BA4A:  MOVFF  86A,A25
1BA4E:  MOVLW  1B
1BA50:  MOVLB  A
1BA52:  MOVWF  x26
1BA54:  MOVLB  0
1BA56:  CALL   0F92
1BA5A:  BTFSC  1B.7
1BA5C:  BSF    FF2.7
1BA5E:  MOVLW  0D
1BA60:  BTFSS  F9E.4
1BA62:  BRA    1BA60
1BA64:  MOVWF  FAD
1BA66:  MOVLW  0A
1BA68:  BTFSS  F9E.4
1BA6A:  BRA    1BA68
1BA6C:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1BA6E:  MOVF   FC9,W
1BA70:  MOVFF  860,FC9
1BA74:  RRCF   FC7,W
1BA76:  BNC   1BA74
1BA78:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regD: %u\r\n",a9); 
1BA7C:  MOVLW  F4
1BA7E:  MOVWF  FF6
1BA80:  MOVLW  28
1BA82:  MOVWF  FF7
1BA84:  MOVLW  00
1BA86:  MOVWF  FF8
1BA88:  CLRF   1B
1BA8A:  BTFSC  FF2.7
1BA8C:  BSF    1B.7
1BA8E:  BCF    FF2.7
1BA90:  MOVLW  06
1BA92:  MOVLB  A
1BA94:  MOVWF  x25
1BA96:  MOVLB  0
1BA98:  CALL   1010
1BA9C:  BTFSC  1B.7
1BA9E:  BSF    FF2.7
1BAA0:  CLRF   1B
1BAA2:  BTFSC  FF2.7
1BAA4:  BSF    1B.7
1BAA6:  BCF    FF2.7
1BAA8:  MOVFF  86A,A25
1BAAC:  MOVLW  1B
1BAAE:  MOVLB  A
1BAB0:  MOVWF  x26
1BAB2:  MOVLB  0
1BAB4:  CALL   0F92
1BAB8:  BTFSC  1B.7
1BABA:  BSF    FF2.7
1BABC:  MOVLW  0D
1BABE:  BTFSS  F9E.4
1BAC0:  BRA    1BABE
1BAC2:  MOVWF  FAD
1BAC4:  MOVLW  0A
1BAC6:  BTFSS  F9E.4
1BAC8:  BRA    1BAC6
1BACA:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1BACC:  MOVF   FC9,W
1BACE:  MOVFF  860,FC9
1BAD2:  RRCF   FC7,W
1BAD4:  BNC   1BAD2
1BAD6:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regE: %u\r\n",a9); 
1BADA:  MOVLW  00
1BADC:  MOVWF  FF6
1BADE:  MOVLW  29
1BAE0:  MOVWF  FF7
1BAE2:  MOVLW  00
1BAE4:  MOVWF  FF8
1BAE6:  CLRF   1B
1BAE8:  BTFSC  FF2.7
1BAEA:  BSF    1B.7
1BAEC:  BCF    FF2.7
1BAEE:  MOVLW  06
1BAF0:  MOVLB  A
1BAF2:  MOVWF  x25
1BAF4:  MOVLB  0
1BAF6:  CALL   1010
1BAFA:  BTFSC  1B.7
1BAFC:  BSF    FF2.7
1BAFE:  CLRF   1B
1BB00:  BTFSC  FF2.7
1BB02:  BSF    1B.7
1BB04:  BCF    FF2.7
1BB06:  MOVFF  86A,A25
1BB0A:  MOVLW  1B
1BB0C:  MOVLB  A
1BB0E:  MOVWF  x26
1BB10:  MOVLB  0
1BB12:  CALL   0F92
1BB16:  BTFSC  1B.7
1BB18:  BSF    FF2.7
1BB1A:  MOVLW  0D
1BB1C:  BTFSS  F9E.4
1BB1E:  BRA    1BB1C
1BB20:  MOVWF  FAD
1BB22:  MOVLW  0A
1BB24:  BTFSS  F9E.4
1BB26:  BRA    1BB24
1BB28:  MOVWF  FAD
....................       a9 = spi_read(RTC_buffer); 
1BB2A:  MOVF   FC9,W
1BB2C:  MOVFF  860,FC9
1BB30:  RRCF   FC7,W
1BB32:  BNC   1BB30
1BB34:  MOVFF  FC9,86A
....................       fprintf(COM_A,"regF: %u\r\n",a9); 
1BB38:  MOVLW  0C
1BB3A:  MOVWF  FF6
1BB3C:  MOVLW  29
1BB3E:  MOVWF  FF7
1BB40:  MOVLW  00
1BB42:  MOVWF  FF8
1BB44:  CLRF   1B
1BB46:  BTFSC  FF2.7
1BB48:  BSF    1B.7
1BB4A:  BCF    FF2.7
1BB4C:  MOVLW  06
1BB4E:  MOVLB  A
1BB50:  MOVWF  x25
1BB52:  MOVLB  0
1BB54:  CALL   1010
1BB58:  BTFSC  1B.7
1BB5A:  BSF    FF2.7
1BB5C:  CLRF   1B
1BB5E:  BTFSC  FF2.7
1BB60:  BSF    1B.7
1BB62:  BCF    FF2.7
1BB64:  MOVFF  86A,A25
1BB68:  MOVLW  1B
1BB6A:  MOVLB  A
1BB6C:  MOVWF  x26
1BB6E:  MOVLB  0
1BB70:  CALL   0F92
1BB74:  BTFSC  1B.7
1BB76:  BSF    FF2.7
1BB78:  MOVLW  0D
1BB7A:  BTFSS  F9E.4
1BB7C:  BRA    1BB7A
1BB7E:  MOVWF  FAD
1BB80:  MOVLW  0A
1BB82:  BTFSS  F9E.4
1BB84:  BRA    1BB82
1BB86:  MOVWF  FAD
....................        
....................       output_bit(RTC_CS, DISABLE); 
1BB88:  BSF    F91.0
....................     
....................       command_prompt(); 
1BB8A:  CALL   1AFDC
....................    } 
....................  
....................    reset_cpu(); 
1BB8E:  RESET
.................... } 
....................  
1BB90:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 7F78   PUT NOBROWNOUT BORV18 ZPBORM WDT WDT1048576
   Word  3: 8BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
