CCS PCH C Compiler, Version 5.071d, 1               07-Jul-17 11:31
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Green Eyes\Dropbox\Green Eyes\Code\SUBGEN\SUB 2.125_fraser\main.lst

               ROM used:   114810 bytes (88%)
                           Largest free fragment is 15896
               RAM used:   2148 (56%) at main() level
                           2649 (69%) worst case
               Stack used: 20 locations (16 in main + 4 for interrupts)
               Stack size: 31

*
00000:  GOTO   1B530
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   0EDC
00068:  BTFSS  F9D.0
0006A:  GOTO   0074
0006E:  BTFSC  F9E.0
00070:  GOTO   0F06
00074:  BTFSS  FA0.1
00076:  GOTO   0080
0007A:  BTFSC  FA1.1
0007C:  GOTO   18FC
00080:  BTFSS  FF2.4
00082:  GOTO   008C
00086:  BTFSC  FF2.1
00088:  GOTO   0E08
0008C:  BTFSS  FF0.3
0008E:  GOTO   0098
00092:  BTFSC  FF0.0
00094:  GOTO   16DE
00098:  BTFSS  FF0.4
0009A:  GOTO   00A4
0009E:  BTFSC  FF0.1
000A0:  GOTO   1754
000A4:  BTFSS  F9D.5
000A6:  GOTO   00B0
000AA:  BTFSC  F9E.5
000AC:  GOTO   0E6C
000B0:  MOVFF  0E,00
000B4:  MOVFF  0F,01
000B8:  MOVFF  10,02
000BC:  MOVFF  11,03
000C0:  MOVFF  0C,FE9
000C4:  MOVFF  07,FEA
000C8:  BSF    07.7
000CA:  MOVFF  08,FE1
000CE:  MOVFF  09,FE2
000D2:  MOVFF  0A,FD9
000D6:  MOVFF  0B,FDA
000DA:  MOVFF  12,FF3
000DE:  MOVFF  13,FF4
000E2:  MOVFF  14,FFA
000E6:  MOVFF  15,FF5
000EA:  MOVFF  16,FF6
000EE:  MOVFF  17,FF7
000F2:  MOVFF  18,FF8
000F6:  MOVFF  19,FFB
000FA:  MOVF   04,W
000FC:  MOVFF  06,FE0
00100:  MOVFF  05,FD8
00104:  RETFIE 0
....................              /* TITLE BLOCK 
....................    
....................    filename : main.c 
....................    purpose  : main application file 
....................    hardware : 323-01A  
....................    PIC      : PIC18F87K22 
....................   
.................... */ 
....................  
.................... #include <18F87K22.h> 
.................... //////////// Standard Header file for the PIC18F87K22 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F87K22 
00106:  CLRF   FF7
00108:  ADDLW  1A
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  MOVLW  00
00112:  MOVWF  FF8
00114:  TBLRD*+
00116:  MOVF   FF5,W
00118:  RETURN 0
0011A:  DATA 4E,6F
0011C:  DATA 20,45
0011E:  DATA 72,72
00120:  DATA 6F,72
00122:  DATA 00,00
00124:  CLRF   FF7
00126:  ADDLW  38
00128:  MOVWF  FF6
0012A:  MOVLW  01
0012C:  ADDWFC FF7,F
0012E:  MOVLW  00
00130:  MOVWF  FF8
00132:  TBLRD*+
00134:  MOVF   FF5,W
00136:  RETURN 0
00138:  DATA 49,4C
0013A:  DATA 4C,45
0013C:  DATA 47,41
0013E:  DATA 4C,20
00140:  DATA 46,49
00142:  DATA 4C,45
00144:  DATA 20,4E
00146:  DATA 41,4D
00148:  DATA 45,00
0014A:  CLRF   FF7
0014C:  ADDLW  5E
0014E:  MOVWF  FF6
00150:  MOVLW  01
00152:  ADDWFC FF7,F
00154:  MOVLW  00
00156:  MOVWF  FF8
00158:  TBLRD*+
0015A:  MOVF   FF5,W
0015C:  RETURN 0
0015E:  DATA 4D,45
00160:  DATA 44,49
00162:  DATA 41,20
00164:  DATA 4E,4F
00166:  DATA 54,20
00168:  DATA 52,45
0016A:  DATA 41,44
0016C:  DATA 59,00
0016E:  CLRF   FF7
00170:  ADDLW  82
00172:  MOVWF  FF6
00174:  MOVLW  01
00176:  ADDWFC FF7,F
00178:  MOVLW  00
0017A:  MOVWF  FF8
0017C:  TBLRD*+
0017E:  MOVF   FF5,W
00180:  RETURN 0
00182:  DATA 46,49
00184:  DATA 4C,45
00186:  DATA 20,4E
00188:  DATA 4F,54
0018A:  DATA 20,46
0018C:  DATA 4F,55
0018E:  DATA 4E,44
00190:  DATA 00,00
00192:  CLRF   FF7
00194:  ADDLW  A6
00196:  MOVWF  FF6
00198:  MOVLW  01
0019A:  ADDWFC FF7,F
0019C:  MOVLW  00
0019E:  MOVWF  FF8
001A0:  TBLRD*+
001A2:  MOVF   FF5,W
001A4:  RETURN 0
001A6:  DATA 50,41
001A8:  DATA 54,48
001AA:  DATA 20,4E
001AC:  DATA 4F,54
001AE:  DATA 20,46
001B0:  DATA 4F,55
001B2:  DATA 4E,44
001B4:  DATA 00,00
001B6:  CLRF   FF7
001B8:  ADDLW  CA
001BA:  MOVWF  FF6
001BC:  MOVLW  01
001BE:  ADDWFC FF7,F
001C0:  MOVLW  00
001C2:  MOVWF  FF8
001C4:  TBLRD*+
001C6:  MOVF   FF5,W
001C8:  RETURN 0
001CA:  DATA 41,43
001CC:  DATA 43,45
001CE:  DATA 53,53
001D0:  DATA 20,44
001D2:  DATA 45,4E
001D4:  DATA 49,45
001D6:  DATA 44,00
001D8:  CLRF   FF7
001DA:  ADDLW  EC
001DC:  MOVWF  FF6
001DE:  MOVLW  01
001E0:  ADDWFC FF7,F
001E2:  MOVLW  00
001E4:  MOVWF  FF8
001E6:  TBLRD*+
001E8:  MOVF   FF5,W
001EA:  RETURN 0
001EC:  DATA 4D,45
001EE:  DATA 44,49
001F0:  DATA 41,20
001F2:  DATA 46,55
001F4:  DATA 4C,4C
001F6:  DATA 00,00
001F8:  CLRF   FF7
001FA:  ADDLW  0C
001FC:  MOVWF  FF6
001FE:  MOVLW  02
00200:  ADDWFC FF7,F
00202:  MOVLW  00
00204:  MOVWF  FF8
00206:  TBLRD*+
00208:  MOVF   FF5,W
0020A:  RETURN 0
0020C:  DATA 52,2F
0020E:  DATA 57,20
00210:  DATA 45,52
00212:  DATA 52,4F
00214:  DATA 52,00
00216:  CLRF   FF7
00218:  ADDLW  2A
0021A:  MOVWF  FF6
0021C:  MOVLW  02
0021E:  ADDWFC FF7,F
00220:  MOVLW  00
00222:  MOVWF  FF8
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 49,4E
0022C:  DATA 43,4F
0022E:  DATA 52,52
00230:  DATA 45,43
00232:  DATA 54,20
00234:  DATA 4D,45
00236:  DATA 44,49
00238:  DATA 41,20
0023A:  DATA 43,48
0023C:  DATA 41,4E
0023E:  DATA 47,45
00240:  DATA 00,00
00242:  CLRF   FF7
00244:  ADDLW  56
00246:  MOVWF  FF6
00248:  MOVLW  02
0024A:  ADDWFC FF7,F
0024C:  MOVLW  00
0024E:  MOVWF  FF8
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 57,52
00258:  DATA 49,54
0025A:  DATA 45,20
0025C:  DATA 50,52
0025E:  DATA 4F,54
00260:  DATA 45,43
00262:  DATA 54,45
00264:  DATA 44,00
00266:  CLRF   FF7
00268:  ADDLW  7A
0026A:  MOVWF  FF6
0026C:  MOVLW  02
0026E:  ADDWFC FF7,F
00270:  MOVLW  00
00272:  MOVWF  FF8
00274:  TBLRD*+
00276:  MOVF   FF5,W
00278:  RETURN 0
0027A:  DATA 46,53
0027C:  DATA 20,4E
0027E:  DATA 4F,54
00280:  DATA 20,45
00282:  DATA 4E,41
00284:  DATA 42,4C
00286:  DATA 45,44
00288:  DATA 00,00
0028A:  CLRF   FF7
0028C:  ADDLW  9E
0028E:  MOVWF  FF6
00290:  MOVLW  02
00292:  ADDWFC FF7,F
00294:  MOVLW  00
00296:  MOVWF  FF8
00298:  TBLRD*+
0029A:  MOVF   FF5,W
0029C:  RETURN 0
0029E:  DATA 4E,4F
002A0:  DATA 20,46
002A2:  DATA 49,4C
002A4:  DATA 45,53
002A6:  DATA 59,53
002A8:  DATA 54,45
002AA:  DATA 4D,00
002AC:  CLRF   FF7
002AE:  ADDLW  C0
002B0:  MOVWF  FF6
002B2:  MOVLW  02
002B4:  ADDWFC FF7,F
002B6:  MOVLW  00
002B8:  MOVWF  FF8
002BA:  TBLRD*+
002BC:  MOVF   FF5,W
002BE:  RETURN 0
002C0:  DATA 55,4E
002C2:  DATA 4B,4E
002C4:  DATA 4F,57
002C6:  DATA 4E,20
002C8:  DATA 45,52
002CA:  DATA 52,4F
002CC:  DATA 52,00
002CE:  CLRF   FF7
002D0:  ADDLW  E2
002D2:  MOVWF  FF6
002D4:  MOVLW  02
002D6:  ADDWFC FF7,F
002D8:  MOVLW  00
002DA:  MOVWF  FF8
002DC:  TBLRD*+
002DE:  MOVF   FF5,W
002E0:  RETURN 0
002E2:  DATA 00,00
002E4:  CLRF   FF7
002E6:  ADDLW  F8
002E8:  MOVWF  FF6
002EA:  MOVLW  02
002EC:  ADDWFC FF7,F
002EE:  MOVLW  00
002F0:  MOVWF  FF8
002F2:  TBLRD*+
002F4:  MOVF   FF5,W
002F6:  RETURN 0
002F8:  DATA 58,58
002FA:  DATA 58,00
002FC:  CLRF   FF7
002FE:  ADDLW  10
00300:  MOVWF  FF6
00302:  MOVLW  03
00304:  ADDWFC FF7,F
00306:  MOVLW  00
00308:  MOVWF  FF8
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 4E,4F
00312:  DATA 33,00
00314:  CLRF   FF7
00316:  ADDLW  28
00318:  MOVWF  FF6
0031A:  MOVLW  03
0031C:  ADDWFC FF7,F
0031E:  MOVLW  00
00320:  MOVWF  FF8
00322:  TBLRD*+
00324:  MOVF   FF5,W
00326:  RETURN 0
00328:  DATA 50,4F
0032A:  DATA 34,00
0032C:  CLRF   FF7
0032E:  ADDLW  40
00330:  MOVWF  FF6
00332:  MOVLW  03
00334:  ADDWFC FF7,F
00336:  MOVLW  00
00338:  MOVWF  FF8
0033A:  TBLRD*+
0033C:  MOVF   FF5,W
0033E:  RETURN 0
00340:  DATA 4E,48
00342:  DATA 34,00
00344:  CLRF   FF7
00346:  ADDLW  58
00348:  MOVWF  FF6
0034A:  MOVLW  03
0034C:  ADDWFC FF7,F
0034E:  MOVLW  00
00350:  MOVWF  FF8
00352:  TBLRD*+
00354:  MOVF   FF5,W
00356:  RETURN 0
00358:  DATA 53,69
0035A:  DATA 4F,00
0035C:  CLRF   FF7
0035E:  ADDLW  70
00360:  MOVWF  FF6
00362:  MOVLW  03
00364:  ADDWFC FF7,F
00366:  MOVLW  00
00368:  MOVWF  FF8
0036A:  TBLRD*+
0036C:  MOVF   FF5,W
0036E:  RETURN 0
00370:  DATA 55,72
00372:  DATA 65,00
00374:  CLRF   FF7
00376:  ADDLW  88
00378:  MOVWF  FF6
0037A:  MOVLW  03
0037C:  ADDWFC FF7,F
0037E:  MOVLW  00
00380:  MOVWF  FF8
00382:  TBLRD*+
00384:  MOVF   FF5,W
00386:  RETURN 0
00388:  DATA 4E,4F
0038A:  DATA 32,00
0038C:  CLRF   FF7
0038E:  ADDLW  A0
00390:  MOVWF  FF6
00392:  MOVLW  03
00394:  ADDWFC FF7,F
00396:  MOVLW  00
00398:  MOVWF  FF8
0039A:  TBLRD*+
0039C:  MOVF   FF5,W
0039E:  RETURN 0
003A0:  DATA 46,65
003A2:  DATA 5F,00
003A4:  CLRF   FF7
003A6:  ADDLW  B8
003A8:  MOVWF  FF6
003AA:  MOVLW  03
003AC:  ADDWFC FF7,F
003AE:  MOVLW  00
003B0:  MOVWF  FF8
003B2:  TBLRD*+
003B4:  MOVF   FF5,W
003B6:  RETURN 0
003B8:  DATA 43,6C
003BA:  DATA 5F,00
003BC:  CLRF   FF7
003BE:  ADDLW  D0
003C0:  MOVWF  FF6
003C2:  MOVLW  03
003C4:  ADDWFC FF7,F
003C6:  MOVLW  00
003C8:  MOVWF  FF8
003CA:  TBLRD*+
003CC:  MOVF   FF5,W
003CE:  RETURN 0
003D0:  DATA 53,6D
003D2:  DATA 70,00
003D4:  CLRF   FF7
003D6:  ADDLW  E8
003D8:  MOVWF  FF6
003DA:  MOVLW  03
003DC:  ADDWFC FF7,F
003DE:  MOVLW  00
003E0:  MOVWF  FF8
003E2:  TBLRD*+
003E4:  MOVF   FF5,W
003E6:  RETURN 0
003E8:  DATA 53,74
003EA:  DATA 64,00
003EC:  CLRF   FF7
003EE:  ADDLW  00
003F0:  MOVWF  FF6
003F2:  MOVLW  04
003F4:  ADDWFC FF7,F
003F6:  MOVLW  00
003F8:  MOVWF  FF8
003FA:  TBLRD*+
003FC:  MOVF   FF5,W
003FE:  RETURN 0
00400:  DATA 43,6D
00402:  DATA 62,00
00404:  CLRF   FF7
00406:  ADDLW  18
00408:  MOVWF  FF6
0040A:  MOVLW  04
0040C:  ADDWFC FF7,F
0040E:  MOVLW  00
00410:  MOVWF  FF8
00412:  TBLRD*+
00414:  MOVF   FF5,W
00416:  RETURN 0
00418:  DATA 54,73
0041A:  DATA 74,00
0041C:  CLRF   FF7
0041E:  ADDLW  30
00420:  MOVWF  FF6
00422:  MOVLW  04
00424:  ADDWFC FF7,F
00426:  MOVLW  00
00428:  MOVWF  FF8
0042A:  TBLRD*+
0042C:  MOVF   FF5,W
0042E:  RETURN 0
00430:  DATA 52,62
00432:  DATA 6C,00
00434:  CLRF   FF7
00436:  ADDLW  48
00438:  MOVWF  FF6
0043A:  MOVLW  04
0043C:  ADDWFC FF7,F
0043E:  MOVLW  00
00440:  MOVWF  FF8
00442:  TBLRD*+
00444:  MOVF   FF5,W
00446:  RETURN 0
00448:  DATA 43,61
0044A:  DATA 6C,00
0044C:  CLRF   FF7
0044E:  ADDLW  60
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  MOVLW  00
00458:  MOVWF  FF8
0045A:  TBLRD*+
0045C:  MOVF   FF5,W
0045E:  RETURN 0
00460:  DATA 46,6C
00462:  DATA 73,00
00464:  CLRF   FF7
00466:  ADDLW  78
00468:  MOVWF  FF6
0046A:  MOVLW  04
0046C:  ADDWFC FF7,F
0046E:  MOVLW  00
00470:  MOVWF  FF8
00472:  TBLRD*+
00474:  MOVF   FF5,W
00476:  RETURN 0
00478:  DATA 55,74
0047A:  DATA 6C,00
0047C:  CLRF   FF7
0047E:  ADDLW  90
00480:  MOVWF  FF6
00482:  MOVLW  04
00484:  ADDWFC FF7,F
00486:  MOVLW  00
00488:  MOVWF  FF8
0048A:  TBLRD*+
0048C:  MOVF   FF5,W
0048E:  RETURN 0
00490:  DATA 49,30
00492:  DATA 73,00
00494:  CLRF   FF7
00496:  ADDLW  A8
00498:  MOVWF  FF6
0049A:  MOVLW  04
0049C:  ADDWFC FF7,F
0049E:  MOVLW  00
004A0:  MOVWF  FF8
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 49,31
004AA:  DATA 73,00
004AC:  CLRF   FF7
004AE:  ADDLW  C0
004B0:  MOVWF  FF6
004B2:  MOVLW  04
004B4:  ADDWFC FF7,F
004B6:  MOVLW  00
004B8:  MOVWF  FF8
004BA:  TBLRD*+
004BC:  MOVF   FF5,W
004BE:  RETURN 0
004C0:  DATA 49,30
004C2:  DATA 74,00
004C4:  CLRF   FF7
004C6:  ADDLW  D8
004C8:  MOVWF  FF6
004CA:  MOVLW  04
004CC:  ADDWFC FF7,F
004CE:  MOVLW  00
004D0:  MOVWF  FF8
004D2:  TBLRD*+
004D4:  MOVF   FF5,W
004D6:  RETURN 0
004D8:  DATA 49,31
004DA:  DATA 74,00
004DC:  CLRF   FF7
004DE:  ADDLW  F0
004E0:  MOVWF  FF6
004E2:  MOVLW  04
004E4:  ADDWFC FF7,F
004E6:  MOVLW  00
004E8:  MOVWF  FF8
004EA:  TBLRD*+
004EC:  MOVF   FF5,W
004EE:  RETURN 0
004F0:  DATA 49,30
004F2:  DATA 72,00
004F4:  CLRF   FF7
004F6:  ADDLW  08
004F8:  MOVWF  FF6
004FA:  MOVLW  05
004FC:  ADDWFC FF7,F
004FE:  MOVLW  00
00500:  MOVWF  FF8
00502:  TBLRD*+
00504:  MOVF   FF5,W
00506:  RETURN 0
00508:  DATA 49,31
0050A:  DATA 72,00
0050C:  CLRF   FF7
0050E:  ADDLW  20
00510:  MOVWF  FF6
00512:  MOVLW  05
00514:  ADDWFC FF7,F
00516:  MOVLW  00
00518:  MOVWF  FF8
0051A:  TBLRD*+
0051C:  MOVF   FF5,W
0051E:  RETURN 0
00520:  DATA 49,30
00522:  DATA 75,00
00524:  CLRF   FF7
00526:  ADDLW  38
00528:  MOVWF  FF6
0052A:  MOVLW  05
0052C:  ADDWFC FF7,F
0052E:  MOVLW  00
00530:  MOVWF  FF8
00532:  TBLRD*+
00534:  MOVF   FF5,W
00536:  RETURN 0
00538:  DATA 49,31
0053A:  DATA 75,00
0053C:  CLRF   FF7
0053E:  ADDLW  50
00540:  MOVWF  FF6
00542:  MOVLW  05
00544:  ADDWFC FF7,F
00546:  MOVLW  00
00548:  MOVWF  FF8
0054A:  TBLRD*+
0054C:  MOVF   FF5,W
0054E:  RETURN 0
00550:  DATA 43,68
00552:  DATA 6B,00
00554:  CLRF   FF7
00556:  ADDLW  68
00558:  MOVWF  FF6
0055A:  MOVLW  05
0055C:  ADDWFC FF7,F
0055E:  MOVLW  00
00560:  MOVWF  FF8
00562:  TBLRD*+
00564:  MOVF   FF5,W
00566:  RETURN 0
00568:  DATA 58,58
0056A:  DATA 00,00
0056C:  CLRF   FF7
0056E:  ADDLW  80
00570:  MOVWF  FF6
00572:  MOVLW  05
00574:  ADDWFC FF7,F
00576:  MOVLW  00
00578:  MOVWF  FF8
0057A:  TBLRD*+
0057C:  MOVF   FF5,W
0057E:  RETURN 0
00580:  DATA 2C,2C
00582:  DATA 2C,2C
00584:  DATA 2C,2C
00586:  DATA 2C,00
00588:  DATA 77,72
0058A:  DATA 69,74
0058C:  DATA 69,6E
0058E:  DATA 67,00
00590:  DATA 72,65
00592:  DATA 61,64
00594:  DATA 69,6E
00596:  DATA 67,00
00598:  DATA 25,6C
0059A:  DATA 78,3A
0059C:  DATA 20,72
0059E:  DATA 65,61
005A0:  DATA 64,20
005A2:  DATA 25,78
005A4:  DATA 2C,20
005A6:  DATA 73,68
005A8:  DATA 6F,75
005AA:  DATA 6C,64
005AC:  DATA 20,62
005AE:  DATA 65,20
005B0:  DATA 25,78
005B2:  DATA 0A,0D
005B4:  DATA 00,00
005B6:  DATA 64,6F
005B8:  DATA 6E,65
005BA:  DATA 0A,0D
005BC:  DATA 00,00
005BE:  DATA 45,43
005C0:  DATA 4F,2D
005C2:  DATA 32,20
005C4:  DATA 25,73
005C6:  DATA 0D,0A
005C8:  DATA 00,00
005CA:  DATA 56,32
005CC:  DATA 2E,31
005CE:  DATA 32,35
005D0:  DATA 00,00
005D2:  DATA 57,4D
005D4:  DATA 53,2D
005D6:  DATA 34,2D
005D8:  DATA 53,44
005DA:  DATA 20,25
005DC:  DATA 73,0D
005DE:  DATA 0A,00
005E0:  DATA 56,32
005E2:  DATA 2E,31
005E4:  DATA 32,35
005E6:  DATA 00,00
005E8:  DATA 41,57
005EA:  DATA 53,2D
005EC:  DATA 31,20
005EE:  DATA 25,73
005F0:  DATA 0D,0A
005F2:  DATA 00,00
005F4:  DATA 56,32
005F6:  DATA 2E,31
005F8:  DATA 32,35
005FA:  DATA 00,00
005FC:  DATA 57,4D
005FE:  DATA 53,2D
00600:  DATA 34,2D
00602:  DATA 51,45
00604:  DATA 20,25
00606:  DATA 73,0D
00608:  DATA 0A,00
0060A:  DATA 56,32
0060C:  DATA 2E,31
0060E:  DATA 32,35
00610:  DATA 00,00
00612:  DATA 58,58
00614:  DATA 58,2D
00616:  DATA 30,20
00618:  DATA 25,73
0061A:  DATA 0D,0A
0061C:  DATA 00,00
0061E:  DATA 56,32
00620:  DATA 2E,31
00622:  DATA 32,35
00624:  DATA 00,00
00626:  DATA 40,49
00628:  DATA 4E,56
0062A:  DATA 0D,0A
0062C:  DATA 00,00
0062E:  DATA 40,41
00630:  DATA 52,47
00632:  DATA 0D,0A
00634:  DATA 00,00
00636:  DATA 40,45
00638:  DATA 52,52
0063A:  DATA 0D,0A
0063C:  DATA 00,00
0063E:  DATA 40,4F
00640:  DATA 4B,21
00642:  DATA 0D,0A
00644:  DATA 00,00
00646:  DATA 40,52
00648:  DATA 45,53
0064A:  DATA 0D,0A
0064C:  DATA 00,00
0064E:  DATA 40,53
00650:  DATA 44,31
00652:  DATA 0D,0A
00654:  DATA 00,00
00656:  DATA 40,53
00658:  DATA 44,5F
0065A:  DATA 0D,0A
0065C:  DATA 00,00
0065E:  DATA 40,4D
00660:  DATA 41,58
00662:  DATA 0D,0A
00664:  DATA 00,00
00666:  DATA 3F,40
00668:  DATA 42,53
0066A:  DATA 59,0D
0066C:  DATA 0A,00
0066E:  DATA 40,52
00670:  DATA 44,59
00672:  DATA 0D,0A
00674:  DATA 00,00
00676:  DATA 40,46
00678:  DATA 53,3A
0067A:  DATA 44,69
0067C:  DATA 73,63
0067E:  DATA 6F,76
00680:  DATA 65,72
00682:  DATA 79,0D
00684:  DATA 0A,00
00686:  DATA 40,46
00688:  DATA 53,3A
0068A:  DATA 55,6E
0068C:  DATA 61,62
0068E:  DATA 6C,65
00690:  DATA 20,74
00692:  DATA 6F,20
00694:  DATA 70,75
00696:  DATA 74,20
00698:  DATA 63,61
0069A:  DATA 72,64
0069C:  DATA 20,69
0069E:  DATA 6E,20
006A0:  DATA 69,64
006A2:  DATA 6C,65
006A4:  DATA 20,73
006A6:  DATA 74,61
006A8:  DATA 74,65
006AA:  DATA 2C,20
006AC:  DATA 72,65
006AE:  DATA 73,70
006B0:  DATA 6F,6E
006B2:  DATA 73,65
006B4:  DATA 20,3D
006B6:  DATA 20,25
006B8:  DATA 30,32
006BA:  DATA 78,0D
006BC:  DATA 0A,00
006BE:  DATA 40,46
006C0:  DATA 53,3A
006C2:  DATA 43,61
006C4:  DATA 72,64
006C6:  DATA 20,69
006C8:  DATA 64,6C
006CA:  DATA 65,2C
006CC:  DATA 20,72
006CE:  DATA 65,73
006D0:  DATA 70,6F
006D2:  DATA 6E,73
006D4:  DATA 65,20
006D6:  DATA 3D,20
006D8:  DATA 25,30
006DA:  DATA 32,78
006DC:  DATA 0D,0A
006DE:  DATA 00,00
006E0:  DATA 40,46
006E2:  DATA 53,3A
006E4:  DATA 52,65
006E6:  DATA 73,70
006E8:  DATA 6F,6E
006EA:  DATA 73,65
006EC:  DATA 20,74
006EE:  DATA 6F,20
006F0:  DATA 53,44
006F2:  DATA 20,76
006F4:  DATA 65,72
006F6:  DATA 20,32
006F8:  DATA 20,74
006FA:  DATA 65,73
006FC:  DATA 74,20
006FE:  DATA 43,4D
00700:  DATA 44,38
00702:  DATA 20,3D
00704:  DATA 20,25
00706:  DATA 78,0D
00708:  DATA 0A,00
0070A:  DATA 40,46
0070C:  DATA 53,3A
0070E:  DATA 50,6F
00710:  DATA 73,73
00712:  DATA 69,62
00714:  DATA 6C,65
00716:  DATA 20,53
00718:  DATA 44,76
0071A:  DATA 32,20
0071C:  DATA 63,61
0071E:  DATA 72,64
00720:  DATA 20,64
00722:  DATA 65,74
00724:  DATA 65,63
00726:  DATA 74,65
00728:  DATA 64,0D
0072A:  DATA 0A,00
0072C:  DATA 40,46
0072E:  DATA 53,3A
00730:  DATA 56,6F
00732:  DATA 6C,74
00734:  DATA 61,67
00736:  DATA 65,20
00738:  DATA 72,61
0073A:  DATA 6E,67
0073C:  DATA 65,20
0073E:  DATA 63,68
00740:  DATA 65,63
00742:  DATA 6B,2C
00744:  DATA 20,6F
00746:  DATA 63,72
00748:  DATA 20,3D
0074A:  DATA 20,25
0074C:  DATA 30,32
0074E:  DATA 78,25
00750:  DATA 30,32
00752:  DATA 78,25
00754:  DATA 30,32
00756:  DATA 78,25
00758:  DATA 30,32
0075A:  DATA 78,0D
0075C:  DATA 0A,00
0075E:  DATA 40,46
00760:  DATA 53,3A
00762:  DATA 43,61
00764:  DATA 72,64
00766:  DATA 20,56
00768:  DATA 64,64
0076A:  DATA 20,72
0076C:  DATA 61,6E
0076E:  DATA 67,65
00770:  DATA 20,3D
00772:  DATA 20,32
00774:  DATA 2E,37
00776:  DATA 2D,33
00778:  DATA 2E,36
0077A:  DATA 20,76
0077C:  DATA 6F,6C
0077E:  DATA 74,73
00780:  DATA 0D,0A
00782:  DATA 00,00
00784:  DATA 40,46
00786:  DATA 53,3A
00788:  DATA 53,65
0078A:  DATA 6E,64
0078C:  DATA 69,6E
0078E:  DATA 67,20
00790:  DATA 41,43
00792:  DATA 4D,44
00794:  DATA 34,31
00796:  DATA 20,63
00798:  DATA 6F,6D
0079A:  DATA 6D,61
0079C:  DATA 6E,64
0079E:  DATA 20,74
007A0:  DATA 6F,20
007A2:  DATA 53,44
007A4:  DATA 20,76
007A6:  DATA 65,72
007A8:  DATA 20,32
007AA:  DATA 20,63
007AC:  DATA 61,72
007AE:  DATA 64,0D
007B0:  DATA 0A,00
007B2:  DATA 40,46
007B4:  DATA 53,3A
007B6:  DATA 52,65
007B8:  DATA 73,70
007BA:  DATA 6F,6E
007BC:  DATA 73,65
007BE:  DATA 20,66
007C0:  DATA 72,6F
007C2:  DATA 6D,20
007C4:  DATA 73,65
007C6:  DATA 6E,64
007C8:  DATA 69,6E
007CA:  DATA 67,20
007CC:  DATA 41,43
007CE:  DATA 4D,44
007D0:  DATA 34,31
007D2:  DATA 20,3D
007D4:  DATA 20,25
007D6:  DATA 30,32
007D8:  DATA 78,2C
007DA:  DATA 20,54
007DC:  DATA 69,6D
007DE:  DATA 65,72
007E0:  DATA 20,3D
007E2:  DATA 20,25
007E4:  DATA 6C,75
007E6:  DATA 0D,0A
007E8:  DATA 00,00
007EA:  DATA 40,46
007EC:  DATA 53,3A
007EE:  DATA 52,65
007F0:  DATA 73,70
007F2:  DATA 6F,6E
007F4:  DATA 73,65
007F6:  DATA 20,74
007F8:  DATA 6F,20
007FA:  DATA 43,4D
007FC:  DATA 44,35
007FE:  DATA 38,20
00800:  DATA 3D,20
00802:  DATA 25,78
00804:  DATA 0D,0A
00806:  DATA 00,00
00808:  DATA 40,46
0080A:  DATA 53,3A
0080C:  DATA 53,65
0080E:  DATA 6E,74
00810:  DATA 20,43
00812:  DATA 4D,44
00814:  DATA 20,35
00816:  DATA 38,2C
00818:  DATA 20,54
0081A:  DATA 69,6D
0081C:  DATA 65,72
0081E:  DATA 20,76
00820:  DATA 61,6C
00822:  DATA 75,65
00824:  DATA 20,3D
00826:  DATA 20,25
00828:  DATA 6C,75
0082A:  DATA 2C,20
0082C:  DATA 6F,63
0082E:  DATA 72,20
00830:  DATA 3D,20
00832:  DATA 25,30
00834:  DATA 32,78
00836:  DATA 25,30
00838:  DATA 32,78
0083A:  DATA 25,30
0083C:  DATA 32,78
0083E:  DATA 25,30
00840:  DATA 32,78
00842:  DATA 0D,0A
00844:  DATA 00,00
00846:  DATA 40,46
00848:  DATA 53,3A
0084A:  DATA 43,61
0084C:  DATA 72,64
0084E:  DATA 20,43
00850:  DATA 41,4E
00852:  DATA 4E,4F
00854:  DATA 54,20
00856:  DATA 77,6F
00858:  DATA 72,6B
0085A:  DATA 20,56
0085C:  DATA 64,64
0085E:  DATA 20,72
00860:  DATA 61,6E
00862:  DATA 67,65
00864:  DATA 20,6F
00866:  DATA 66,20
00868:  DATA 32,2E
0086A:  DATA 37,2D
0086C:  DATA 33,2E
0086E:  DATA 36,20
00870:  DATA 76,6F
00872:  DATA 6C,74
00874:  DATA 73,0D
00876:  DATA 0A,00
00878:  DATA 40,46
0087A:  DATA 53,3A
0087C:  DATA 4E,6F
0087E:  DATA 74,20
00880:  DATA 61,6E
00882:  DATA 20,53
00884:  DATA 44,53
00886:  DATA 43,20
00888:  DATA 6F,72
0088A:  DATA 20,53
0088C:  DATA 44,48
0088E:  DATA 43,20
00890:  DATA 63,61
00892:  DATA 72,64
00894:  DATA 2C,20
00896:  DATA 54,65
00898:  DATA 73,74
0089A:  DATA 69,6E
0089C:  DATA 67,20
0089E:  DATA 66,6F
008A0:  DATA 72,20
008A2:  DATA 53,44
008A4:  DATA 20,56
008A6:  DATA 65,72
008A8:  DATA 31,20
008AA:  DATA 6F,72
008AC:  DATA 20,4D
008AE:  DATA 4D,43
008B0:  DATA 20,43
008B2:  DATA 61,72
008B4:  DATA 64,0D
008B6:  DATA 0A,00
008B8:  DATA 40,46
008BA:  DATA 53,3A
008BC:  DATA 52,65
008BE:  DATA 73,70
008C0:  DATA 6F,6E
008C2:  DATA 73,65
008C4:  DATA 20,66
008C6:  DATA 72,6F
008C8:  DATA 6D,20
008CA:  DATA 47,4F
008CC:  DATA 5F,49
008CE:  DATA 44,4C
008D0:  DATA 45,20
008D2:  DATA 3D,20
008D4:  DATA 25,30
008D6:  DATA 32,78
008D8:  DATA 0D,0A
008DA:  DATA 00,00
008DC:  DATA 40,46
008DE:  DATA 53,3A
008E0:  DATA 52,65
008E2:  DATA 73,70
008E4:  DATA 6F,6E
008E6:  DATA 73,65
008E8:  DATA 20,66
008EA:  DATA 72,6F
008EC:  DATA 6D,20
008EE:  DATA 53,44
008F0:  DATA 5F,43
008F2:  DATA 4D,44
008F4:  DATA 5F,53
008F6:  DATA 45,4E
008F8:  DATA 44,5F
008FA:  DATA 4F,50
008FC:  DATA 5F,43
008FE:  DATA 4F,4E
00900:  DATA 44,20
00902:  DATA 3D,20
00904:  DATA 25,30
00906:  DATA 32,78
00908:  DATA 2C,20
0090A:  DATA 54,69
0090C:  DATA 6D,65
0090E:  DATA 72,20
00910:  DATA 3D,20
00912:  DATA 25,6C
00914:  DATA 75,0D
00916:  DATA 0A,00
00918:  DATA 40,46
0091A:  DATA 53,3A
0091C:  DATA 41,74
0091E:  DATA 74,65
00920:  DATA 6D,70
00922:  DATA 74,69
00924:  DATA 6E,67
00926:  DATA 20,53
00928:  DATA 44,76
0092A:  DATA 31,20
0092C:  DATA 76,65
0092E:  DATA 72,73
00930:  DATA 75,73
00932:  DATA 20,4D
00934:  DATA 4D,43
00936:  DATA 20,49
00938:  DATA 44,2C
0093A:  DATA 20,52
0093C:  DATA 65,73
0093E:  DATA 70,6F
00940:  DATA 6E,73
00942:  DATA 65,20
00944:  DATA 66,72
00946:  DATA 6F,6D
00948:  DATA 20,53
0094A:  DATA 44,5F
0094C:  DATA 43,4D
0094E:  DATA 44,5F
00950:  DATA 41,50
00952:  DATA 50,4C
00954:  DATA 5F,43
00956:  DATA 4D,44
00958:  DATA 20,3D
0095A:  DATA 20,25
0095C:  DATA 30,32
0095E:  DATA 78,0D
00960:  DATA 0A,00
00962:  DATA 40,46
00964:  DATA 53,3A
00966:  DATA 49,6E
00968:  DATA 76,61
0096A:  DATA 6C,69
0096C:  DATA 64,20
0096E:  DATA 72,65
00970:  DATA 73,70
00972:  DATA 6F,6E
00974:  DATA 73,65
00976:  DATA 20,74
00978:  DATA 6F,20
0097A:  DATA 53,44
0097C:  DATA 5F,41
0097E:  DATA 43,4D
00980:  DATA 44,34
00982:  DATA 31,2C
00984:  DATA 20,72
00986:  DATA 65,73
00988:  DATA 70,6F
0098A:  DATA 6E,73
0098C:  DATA 65,20
0098E:  DATA 3D,20
00990:  DATA 25,30
00992:  DATA 32,58
00994:  DATA 2C,20
00996:  DATA 72,65
00998:  DATA 69,6E
0099A:  DATA 69,74
0099C:  DATA 69,61
0099E:  DATA 6C,69
009A0:  DATA 7A,69
009A2:  DATA 6E,67
009A4:  DATA 20,61
009A6:  DATA 73,20
009A8:  DATA 4D,4D
009AA:  DATA 43,0D
009AC:  DATA 0A,00
009AE:  DATA 40,46
009B0:  DATA 53,3A
009B2:  DATA 46,61
009B4:  DATA 69,6C
009B6:  DATA 65,64
009B8:  DATA 20,74
009BA:  DATA 6F,20
009BC:  DATA 69,6E
009BE:  DATA 69,74
009C0:  DATA 69,61
009C2:  DATA 6C,69
009C4:  DATA 7A,65
009C6:  DATA 20,61
009C8:  DATA 73,20
009CA:  DATA 4D,4D
009CC:  DATA 43,2C
009CE:  DATA 20,72
009D0:  DATA 65,73
009D2:  DATA 70,6F
009D4:  DATA 6E,73
009D6:  DATA 65,20
009D8:  DATA 3D,20
009DA:  DATA 25,30
009DC:  DATA 32,58
009DE:  DATA 2C,20
009E0:  DATA 65,78
009E2:  DATA 69,74
009E4:  DATA 69,6E
009E6:  DATA 67,0D
009E8:  DATA 0A,00
009EA:  DATA 40,46
009EC:  DATA 53,3A
009EE:  DATA 43,61
009F0:  DATA 72,64
009F2:  DATA 20,66
009F4:  DATA 61,69
009F6:  DATA 6C,65
009F8:  DATA 64,20
009FA:  DATA 74,6F
009FC:  DATA 20,72
009FE:  DATA 65,73
00A00:  DATA 70,6F
00A02:  DATA 6E,64
00A04:  DATA 20,63
00A06:  DATA 6F,72
00A08:  DATA 72,65
00A0A:  DATA 63,6C
00A0C:  DATA 79,20
00A0E:  DATA 61,66
00A10:  DATA 74,65
00A12:  DATA 72,20
00A14:  DATA 53,44
00A16:  DATA 5F,43
00A18:  DATA 4D,44
00A1A:  DATA 5F,53
00A1C:  DATA 45,4E
00A1E:  DATA 44,5F
00A20:  DATA 4F,50
00A22:  DATA 5F,43
00A24:  DATA 4F,4E
00A26:  DATA 44,2C
00A28:  DATA 20,72
00A2A:  DATA 65,73
00A2C:  DATA 70,6F
00A2E:  DATA 6E,73
00A30:  DATA 65,20
00A32:  DATA 3D,20
00A34:  DATA 25,30
00A36:  DATA 32,58
00A38:  DATA 2C,20
00A3A:  DATA 54,69
00A3C:  DATA 6D,65
00A3E:  DATA 72,20
00A40:  DATA 3D,20
00A42:  DATA 25,6C
00A44:  DATA 75,0D
00A46:  DATA 0A,00
00A48:  DATA 40,46
00A4A:  DATA 53,3A
00A4C:  DATA 53,65
00A4E:  DATA 74,74
00A50:  DATA 69,6E
00A52:  DATA 67,20
00A54:  DATA 62,6C
00A56:  DATA 6F,63
00A58:  DATA 6B,20
00A5A:  DATA 6C,65
00A5C:  DATA 6E,67
00A5E:  DATA 74,68
00A60:  DATA 0D,0A
00A62:  DATA 00,00
00A64:  DATA 40,46
00A66:  DATA 53,3A
00A68:  DATA 45,72
00A6A:  DATA 72,6F
00A6C:  DATA 72,20
00A6E:  DATA 73,65
00A70:  DATA 74,74
00A72:  DATA 69,6E
00A74:  DATA 67,20
00A76:  DATA 62,6C
00A78:  DATA 6F,63
00A7A:  DATA 6B,20
00A7C:  DATA 6C,65
00A7E:  DATA 6E,67
00A80:  DATA 74,68
00A82:  DATA 2C,20
00A84:  DATA 72,65
00A86:  DATA 73,70
00A88:  DATA 6F,6E
00A8A:  DATA 73,65
00A8C:  DATA 20,3D
00A8E:  DATA 20,25
00A90:  DATA 30,32
00A92:  DATA 78,2C
00A94:  DATA 20,74
00A96:  DATA 69,6D
00A98:  DATA 65,72
00A9A:  DATA 20,3D
00A9C:  DATA 20,25
00A9E:  DATA 6C,75
00AA0:  DATA 0D,0A
00AA2:  DATA 00,00
00AA4:  DATA 40,46
00AA6:  DATA 53,3A
00AA8:  DATA 43,61
00AAA:  DATA 72,64
00AAC:  DATA 20,54
00AAE:  DATA 79,70
00AB0:  DATA 65,20
00AB2:  DATA 44,69
00AB4:  DATA 73,63
00AB6:  DATA 6F,76
00AB8:  DATA 65,72
00ABA:  DATA 79,20
00ABC:  DATA 45,72
00ABE:  DATA 72,6F
00AC0:  DATA 72,0D
00AC2:  DATA 0A,00
00AC4:  DATA 40,46
00AC6:  DATA 53,3A
00AC8:  DATA 4D,4D
00ACA:  DATA 43,20
00ACC:  DATA 43,61
00ACE:  DATA 72,64
00AD0:  DATA 20,66
00AD2:  DATA 6F,75
00AD4:  DATA 6E,64
00AD6:  DATA 0D,0A
00AD8:  DATA 00,00
00ADA:  DATA 40,46
00ADC:  DATA 53,3A
00ADE:  DATA 53,44
00AE0:  DATA 76,31
00AE2:  DATA 20,43
00AE4:  DATA 61,72
00AE6:  DATA 64,20
00AE8:  DATA 66,6F
00AEA:  DATA 75,6E
00AEC:  DATA 64,0D
00AEE:  DATA 0A,00
00AF0:  DATA 40,46
00AF2:  DATA 53,3A
00AF4:  DATA 53,44
00AF6:  DATA 53,43
00AF8:  DATA 20,43
00AFA:  DATA 61,72
00AFC:  DATA 64,20
00AFE:  DATA 66,6F
00B00:  DATA 75,6E
00B02:  DATA 64,0D
00B04:  DATA 0A,00
00B06:  DATA 40,46
00B08:  DATA 53,3A
00B0A:  DATA 53,44
00B0C:  DATA 48,43
00B0E:  DATA 20,43
00B10:  DATA 61,72
00B12:  DATA 64,20
00B14:  DATA 66,6F
00B16:  DATA 75,6E
00B18:  DATA 64,0D
00B1A:  DATA 0A,00
00B1C:  DATA 40,46
00B1E:  DATA 53,3A
00B20:  DATA 43,61
00B22:  DATA 72,64
00B24:  DATA 20,54
00B26:  DATA 79,70
00B28:  DATA 65,20
00B2A:  DATA 44,69
00B2C:  DATA 73,63
00B2E:  DATA 6F,76
00B30:  DATA 65,72
00B32:  DATA 79,20
00B34:  DATA 45,72
00B36:  DATA 72,6F
00B38:  DATA 72,2C
00B3A:  DATA 20,43
00B3C:  DATA 61,72
00B3E:  DATA 64,20
00B40:  DATA 3D,20
00B42:  DATA 25,30
00B44:  DATA 32,58
00B46:  DATA 0D,0A
00B48:  DATA 00,00
00B4A:  DATA 40,46
00B4C:  DATA 53,3A
00B4E:  DATA 43,61
00B50:  DATA 72,64
00B52:  DATA 20,72
00B54:  DATA 65,73
00B56:  DATA 65,74
00B58:  DATA 20,73
00B5A:  DATA 75,63
00B5C:  DATA 63,65
00B5E:  DATA 73,73
00B60:  DATA 20,2D
00B62:  DATA 20,43
00B64:  DATA 6D,64
00B66:  DATA 20,74
00B68:  DATA 6F,20
00B6A:  DATA 52,65
00B6C:  DATA 61,64
00B6E:  DATA 79,20
00B70:  DATA 63,6F
00B72:  DATA 75,6E
00B74:  DATA 74,20
00B76:  DATA 3D,20
00B78:  DATA 25,6C
00B7A:  DATA 75,0D
00B7C:  DATA 0A,00
00B7E:  DATA 40,46
00B80:  DATA 53,3A
00B82:  DATA 53,50
00B84:  DATA 49,20
00B86:  DATA 62,75
00B88:  DATA 73,20
00B8A:  DATA 73,70
00B8C:  DATA 65,65
00B8E:  DATA 64,20
00B90:  DATA 73,65
00B92:  DATA 74,20
00B94:  DATA 74,6F
00B96:  DATA 20,68
00B98:  DATA 69,67
00B9A:  DATA 68,0D
00B9C:  DATA 0A,00
00B9E:  DATA 40,46
00BA0:  DATA 53,3A
00BA2:  DATA 43,61
00BA4:  DATA 72,64
00BA6:  DATA 20,61
00BA8:  DATA 63,74
00BAA:  DATA 69,76
00BAC:  DATA 61,74
00BAE:  DATA 65,20
00BB0:  DATA 66,61
00BB2:  DATA 69,6C
00BB4:  DATA 75,72
00BB6:  DATA 65,2C
00BB8:  DATA 20,72
00BBA:  DATA 65,73
00BBC:  DATA 70,6F
00BBE:  DATA 6E,73
00BC0:  DATA 65,20
00BC2:  DATA 3D,20
00BC4:  DATA 25,30
00BC6:  DATA 32,58
00BC8:  DATA 2C,20
00BCA:  DATA 54,69
00BCC:  DATA 6D,65
00BCE:  DATA 72,20
00BD0:  DATA 3D,20
00BD2:  DATA 25,6C
00BD4:  DATA 75,0D
00BD6:  DATA 0A,00
00BD8:  DATA 40,46
00BDA:  DATA 53,3A
00BDC:  DATA 43,61
00BDE:  DATA 72,64
00BE0:  DATA 20,61
00BE2:  DATA 63,74
00BE4:  DATA 69,76
00BE6:  DATA 61,74
00BE8:  DATA 65,20
00BEA:  DATA 73,75
00BEC:  DATA 63,63
00BEE:  DATA 65,73
00BF0:  DATA 73,20
00BF2:  DATA 6F,6E
00BF4:  DATA 20,61
00BF6:  DATA 74,74
00BF8:  DATA 65,6D
00BFA:  DATA 70,74
00BFC:  DATA 20,25
00BFE:  DATA 6C,75
00C00:  DATA 0D,0A
00C02:  DATA 00,00
00C04:  DATA 46,41
00C06:  DATA 54,20
00C08:  DATA 61,74
00C0A:  DATA 20,73
00C0C:  DATA 65,63
00C0E:  DATA 74,6F
00C10:  DATA 72,20
00C12:  DATA 30,0D
00C14:  DATA 0A,00
00C16:  DATA 54,59
00C18:  DATA 50,45
00C1A:  DATA 20,63
00C1C:  DATA 6F,6D
00C1E:  DATA 6D,61
00C20:  DATA 6E,64
00C22:  DATA 20,45
00C24:  DATA 52,52
00C26:  DATA 4F,52
00C28:  DATA 0D,0A
00C2A:  DATA 00,00
00C2C:  DATA 40,46
00C2E:  DATA 53,3A
00C30:  DATA 20,25
00C32:  DATA 73,0D
00C34:  DATA 0A,00
00C36:  DATA 40,46
00C38:  DATA 53,3A
00C3A:  DATA 20,25
00C3C:  DATA 73,0D
00C3E:  DATA 0A,00
00C40:  DATA 2A,2A
00C42:  DATA 20,40
00C44:  DATA 46,53
00C46:  DATA 3A,20
00C48:  DATA 45,52
00C4A:  DATA 52,4F
00C4C:  DATA 52,0D
00C4E:  DATA 0A,00
00C50:  DATA 20,20
00C52:  DATA 20,4E
00C54:  DATA 6F,45
00C56:  DATA 72,72
00C58:  DATA 6F,72
00C5A:  DATA 0D,0A
00C5C:  DATA 00,00
00C5E:  DATA 20,20
00C60:  DATA 20,4D
00C62:  DATA 65,64
00C64:  DATA 69,61
00C66:  DATA 20,4E
00C68:  DATA 6F,74
00C6A:  DATA 20,52
00C6C:  DATA 65,61
00C6E:  DATA 64,79
00C70:  DATA 0D,0A
00C72:  DATA 00,00
00C74:  DATA 20,20
00C76:  DATA 20,46
00C78:  DATA 69,6C
00C7A:  DATA 65,20
00C7C:  DATA 4E,6F
00C7E:  DATA 74,20
00C80:  DATA 46,6F
00C82:  DATA 75,6E
00C84:  DATA 64,0D
00C86:  DATA 0A,00
00C88:  DATA 20,20
00C8A:  DATA 20,49
00C8C:  DATA 6E,76
00C8E:  DATA 61,6C
00C90:  DATA 69,64
00C92:  DATA 20,50
00C94:  DATA 61,74
00C96:  DATA 68,0D
00C98:  DATA 0A,00
00C9A:  DATA 20,20
00C9C:  DATA 20,49
00C9E:  DATA 6E,76
00CA0:  DATA 61,6C
00CA2:  DATA 69,64
00CA4:  DATA 20,4E
00CA6:  DATA 61,6D
00CA8:  DATA 65,0D
00CAA:  DATA 0A,00
00CAC:  DATA 20,20
00CAE:  DATA 20,41
00CB0:  DATA 63,63
00CB2:  DATA 65,73
00CB4:  DATA 73,20
00CB6:  DATA 44,65
00CB8:  DATA 6E,69
00CBA:  DATA 65,64
00CBC:  DATA 0D,0A
00CBE:  DATA 00,00
00CC0:  DATA 20,20
00CC2:  DATA 20,44
00CC4:  DATA 69,73
00CC6:  DATA 6B,20
00CC8:  DATA 46,75
00CCA:  DATA 6C,6C
00CCC:  DATA 0D,0A
00CCE:  DATA 00,00
00CD0:  DATA 20,20
00CD2:  DATA 20,52
00CD4:  DATA 65,61
00CD6:  DATA 64,2F
00CD8:  DATA 57,72
00CDA:  DATA 69,74
00CDC:  DATA 65,20
00CDE:  DATA 45,72
00CE0:  DATA 72,6F
00CE2:  DATA 72,0D
00CE4:  DATA 0A,00
00CE6:  DATA 20,20
00CE8:  DATA 20,49
00CEA:  DATA 6E,63
00CEC:  DATA 6F,72
00CEE:  DATA 72,65
00CF0:  DATA 63,74
00CF2:  DATA 20,4D
00CF4:  DATA 65,64
00CF6:  DATA 69,61
00CF8:  DATA 20,43
00CFA:  DATA 68,61
00CFC:  DATA 6E,67
00CFE:  DATA 65,0D
00D00:  DATA 0A,00
00D02:  DATA 20,20
00D04:  DATA 20,57
00D06:  DATA 72,69
00D08:  DATA 74,65
00D0A:  DATA 20,50
00D0C:  DATA 72,6F
00D0E:  DATA 74,65
00D10:  DATA 63,74
00D12:  DATA 65,64
00D14:  DATA 0D,0A
00D16:  DATA 00,00
00D18:  DATA 20,20
00D1A:  DATA 20,4E
00D1C:  DATA 6F,74
00D1E:  DATA 20,45
00D20:  DATA 6E,61
00D22:  DATA 62,6C
00D24:  DATA 65,64
00D26:  DATA 0D,0A
00D28:  DATA 00,00
00D2A:  DATA 20,20
00D2C:  DATA 20,4E
00D2E:  DATA 6F,20
00D30:  DATA 46,69
00D32:  DATA 6C,65
00D34:  DATA 20,53
00D36:  DATA 79,73
00D38:  DATA 74,65
00D3A:  DATA 6D,0D
00D3C:  DATA 0A,00
00D3E:  DATA 61,70
00D40:  DATA 70,65
00D42:  DATA 6E,64
00D44:  DATA 3A,20
00D46:  DATA 46,53
00D48:  DATA 20,45
00D4A:  DATA 52,52
00D4C:  DATA 4F,52
00D4E:  DATA 20,6F
00D50:  DATA 6E,20
00D52:  DATA 66,69
00D54:  DATA 6C,65
00D56:  DATA 5F,6F
00D58:  DATA 70,65
00D5A:  DATA 6E,0D
00D5C:  DATA 0A,00
00D5E:  DATA 40,46
00D60:  DATA 53,3A
00D62:  DATA 57,72
00D64:  DATA 69,74
00D66:  DATA 69,6E
00D68:  DATA 67,0D
00D6A:  DATA 0A,5B
00D6C:  DATA 25,73
00D6E:  DATA 5D,0D
00D70:  DATA 0A,00
00D72:  DATA 40,46
00D74:  DATA 53,3A
00D76:  DATA 45,52
00D78:  DATA 52,4F
00D7A:  DATA 52,5B
00D7C:  DATA 61,70
00D7E:  DATA 70,65
00D80:  DATA 6E,64
00D82:  DATA 5D,0D
00D84:  DATA 0A,00
00D86:  DATA 40,46
00D88:  DATA 53,3A
00D8A:  DATA 43,6C
00D8C:  DATA 6F,73
00D8E:  DATA 69,6E
00D90:  DATA 67,0D
00D92:  DATA 0A,00
00D94:  DATA 40,52
00D96:  DATA 54,43
00D98:  DATA 3A,25
00D9A:  DATA 30,32
00D9C:  DATA 75,2F
00D9E:  DATA 00,00
00DA0:  DATA 40,52
00DA2:  DATA 54,43
00DA4:  DATA 3A,25
00DA6:  DATA 30,32
00DA8:  DATA 75,2F
00DAA:  DATA 00,00
00DAC:  DATA 40,41
00DAE:  DATA 4C,4D
00DB0:  DATA 3A,25
00DB2:  DATA 30,32
00DB4:  DATA 75,2F
00DB6:  DATA 00,00
00DB8:  DATA 40,41
00DBA:  DATA 4C,4D
00DBC:  DATA 3A,25
00DBE:  DATA 30,32
00DC0:  DATA 75,2F
00DC2:  DATA 00,00
00DC4:  DATA 40,41
00DC6:  DATA 4C,4D
00DC8:  DATA 0D,0A
00DCA:  DATA 00,00
*
00E42:  TBLRD*+
00E44:  MOVF   FF5,F
00E46:  BZ    0E6A
00E48:  MOVFF  FF6,A38
00E4C:  MOVFF  FF7,A39
00E50:  MOVFF  FF8,A3A
00E54:  MOVF   FF5,W
00E56:  BTFSS  F9E.4
00E58:  BRA    0E56
00E5A:  MOVWF  FAD
00E5C:  MOVFF  A38,FF6
00E60:  MOVFF  A39,FF7
00E64:  MOVFF  A3A,FF8
00E68:  BRA    0E42
00E6A:  RETURN 0
*
00ECC:  DATA 3F,40
00ECE:  DATA 42,53
00ED0:  DATA 59,0D
00ED2:  DATA 0A,00
00ED4:  DATA 40,52
00ED6:  DATA 44,59
00ED8:  DATA 0D,0A
00EDA:  DATA 00,00
*
00F1C:  DATA 40,5B
00F1E:  DATA 4F,5D
00F20:  DATA 0D,0A
00F22:  DATA 00,00
00F24:  DATA 40,43
00F26:  DATA 4D,44
00F28:  DATA 20,74
00F2A:  DATA 6F,6F
00F2C:  DATA 20,6C
00F2E:  DATA 6F,6E
00F30:  DATA 67,0D
00F32:  DATA 0A,00
00F34:  DATA 40,5B
00F36:  DATA 43,5D
00F38:  DATA 0D,0A
00F3A:  DATA 00,00
00F3C:  DATA 40,53
00F3E:  DATA 4C,45
00F40:  DATA 45,50
00F42:  DATA 0D,0A
00F44:  DATA 00,00
00F46:  DATA 40,4D
00F48:  DATA 45,52
00F4A:  DATA 2C,25
00F4C:  DATA 4C,75
00F4E:  DATA 2C,25
00F50:  DATA 4C,75
00F52:  DATA 0D,0A
00F54:  DATA 00,00
00F56:  DATA 6D,3A
00F58:  DATA 25,75
00F5A:  DATA 2C,25
00F5C:  DATA 75,20
00F5E:  DATA 63,3A
00F60:  DATA 25,4C
00F62:  DATA 75,2C
00F64:  DATA 25,4C
00F66:  DATA 75,2C
00F68:  DATA 25,4C
00F6A:  DATA 75,0D
00F6C:  DATA 0A,00
00F6E:  MOVLB  A
00F70:  MOVF   x43,W
00F72:  CLRF   01
00F74:  SUBWF  x42,W
00F76:  BC    0F7E
00F78:  MOVFF  A42,00
00F7C:  BRA    0F96
00F7E:  CLRF   00
00F80:  MOVLW  08
00F82:  MOVWF  x44
00F84:  RLCF   x42,F
00F86:  RLCF   00,F
00F88:  MOVF   x43,W
00F8A:  SUBWF  00,W
00F8C:  BTFSC  FD8.0
00F8E:  MOVWF  00
00F90:  RLCF   01,F
00F92:  DECFSZ x44,F
00F94:  BRA    0F84
00F96:  MOVLB  0
00F98:  RETURN 0
00F9A:  MOVF   01,W
00F9C:  MOVFF  A40,A42
00FA0:  MOVLW  64
00FA2:  MOVLB  A
00FA4:  MOVWF  x43
00FA6:  MOVLB  0
00FA8:  RCALL  0F6E
00FAA:  MOVFF  00,A40
00FAE:  MOVF   01,W
00FB0:  MOVLW  30
00FB2:  BNZ   0FC4
00FB4:  MOVLB  A
00FB6:  BTFSS  x41.1
00FB8:  BRA    0FD6
00FBA:  BTFSC  x41.3
00FBC:  BRA    0FD6
00FBE:  BTFSC  x41.4
00FC0:  MOVLW  20
00FC2:  BRA    0FCC
00FC4:  MOVLB  A
00FC6:  BCF    x41.3
00FC8:  BCF    x41.4
00FCA:  BSF    x41.0
00FCC:  ADDWF  01,F
00FCE:  MOVF   01,W
00FD0:  BTFSS  F9E.4
00FD2:  BRA    0FD0
00FD4:  MOVWF  FAD
00FD6:  MOVFF  A40,A42
00FDA:  MOVLW  0A
00FDC:  MOVWF  x43
00FDE:  MOVLB  0
00FE0:  RCALL  0F6E
00FE2:  MOVFF  00,A40
00FE6:  MOVF   01,W
00FE8:  MOVLW  30
00FEA:  BNZ   0FFC
00FEC:  MOVLB  A
00FEE:  BTFSC  x41.3
00FF0:  BRA    1008
00FF2:  BTFSS  x41.0
00FF4:  BRA    1008
00FF6:  BTFSC  x41.4
00FF8:  MOVLW  20
00FFA:  MOVLB  0
00FFC:  ADDWF  01,F
00FFE:  MOVF   01,W
01000:  BTFSS  F9E.4
01002:  BRA    1000
01004:  MOVWF  FAD
01006:  MOVLB  A
01008:  MOVLW  30
0100A:  ADDWF  x40,F
0100C:  MOVF   x40,W
0100E:  BTFSS  F9E.4
01010:  BRA    100E
01012:  MOVWF  FAD
01014:  MOVLB  0
01016:  RETURN 0
01018:  TBLRD*+
0101A:  MOVFF  FF6,A41
0101E:  MOVFF  FF7,A42
01022:  MOVFF  FF8,A43
01026:  MOVF   FF5,W
01028:  BTFSS  F9E.4
0102A:  BRA    1028
0102C:  MOVWF  FAD
0102E:  MOVFF  A41,FF6
01032:  MOVFF  A42,FF7
01036:  MOVFF  A43,FF8
0103A:  MOVLB  A
0103C:  DECFSZ x40,F
0103E:  BRA    1042
01040:  BRA    1046
01042:  MOVLB  0
01044:  BRA    1018
01046:  MOVLB  0
01048:  RETURN 0
0104A:  BTFSC  FD8.1
0104C:  BRA    1056
0104E:  MOVLW  0A
01050:  MOVWF  FEA
01052:  MOVLW  54
01054:  MOVWF  FE9
01056:  CLRF   00
01058:  CLRF   01
0105A:  CLRF   02
0105C:  CLRF   03
0105E:  MOVLB  A
01060:  CLRF   x54
01062:  CLRF   x55
01064:  CLRF   x56
01066:  CLRF   x57
01068:  MOVF   x53,W
0106A:  IORWF  x52,W
0106C:  IORWF  x51,W
0106E:  IORWF  x50,W
01070:  BZ    10CA
01072:  MOVLW  20
01074:  MOVWF  x58
01076:  BCF    FD8.0
01078:  RLCF   x4C,F
0107A:  RLCF   x4D,F
0107C:  RLCF   x4E,F
0107E:  RLCF   x4F,F
01080:  RLCF   x54,F
01082:  RLCF   x55,F
01084:  RLCF   x56,F
01086:  RLCF   x57,F
01088:  MOVF   x53,W
0108A:  SUBWF  x57,W
0108C:  BNZ   109E
0108E:  MOVF   x52,W
01090:  SUBWF  x56,W
01092:  BNZ   109E
01094:  MOVF   x51,W
01096:  SUBWF  x55,W
01098:  BNZ   109E
0109A:  MOVF   x50,W
0109C:  SUBWF  x54,W
0109E:  BNC   10BE
010A0:  MOVF   x50,W
010A2:  SUBWF  x54,F
010A4:  MOVF   x51,W
010A6:  BTFSS  FD8.0
010A8:  INCFSZ x51,W
010AA:  SUBWF  x55,F
010AC:  MOVF   x52,W
010AE:  BTFSS  FD8.0
010B0:  INCFSZ x52,W
010B2:  SUBWF  x56,F
010B4:  MOVF   x53,W
010B6:  BTFSS  FD8.0
010B8:  INCFSZ x53,W
010BA:  SUBWF  x57,F
010BC:  BSF    FD8.0
010BE:  RLCF   00,F
010C0:  RLCF   01,F
010C2:  RLCF   02,F
010C4:  RLCF   03,F
010C6:  DECFSZ x58,F
010C8:  BRA    1076
010CA:  MOVFF  A54,FEF
010CE:  MOVFF  A55,FEC
010D2:  MOVFF  A56,FEC
010D6:  MOVFF  A57,FEC
010DA:  MOVLB  0
010DC:  RETURN 0
010DE:  MOVF   FE9,W
010E0:  MOVLB  A
010E2:  MOVWF  x44
010E4:  MOVLW  3B
010E6:  MOVWF  x4B
010E8:  MOVLW  9A
010EA:  MOVWF  x4A
010EC:  MOVLW  CA
010EE:  MOVWF  x49
010F0:  CLRF   x48
010F2:  MOVLW  0A
010F4:  MOVWF  x46
010F6:  BSF    FD8.1
010F8:  MOVLW  0A
010FA:  MOVWF  FEA
010FC:  MOVLW  40
010FE:  MOVWF  FE9
01100:  MOVFF  A43,A4F
01104:  MOVFF  A42,A4E
01108:  MOVFF  A41,A4D
0110C:  MOVFF  A40,A4C
01110:  MOVFF  A4B,A53
01114:  MOVFF  A4A,A52
01118:  MOVFF  A49,A51
0111C:  MOVFF  A48,A50
01120:  MOVLB  0
01122:  RCALL  104A
01124:  MOVF   01,W
01126:  MOVF   00,F
01128:  BNZ   1150
0112A:  MOVLB  A
0112C:  MOVF   x46,W
0112E:  XORLW  01
01130:  BTFSS  FD8.2
01132:  BRA    1138
01134:  MOVLB  0
01136:  BRA    1150
01138:  MOVF   x44,W
0113A:  BZ    1154
0113C:  ANDLW  0F
0113E:  SUBWF  x46,W
01140:  BZ    1144
01142:  BC    1160
01144:  BTFSC  x44.7
01146:  BRA    1160
01148:  BTFSC  x44.6
0114A:  BRA    1154
0114C:  MOVLW  20
0114E:  BRA    1156
01150:  MOVLB  A
01152:  CLRF   x44
01154:  MOVLW  30
01156:  ADDWF  00,F
01158:  MOVF   00,W
0115A:  BTFSS  F9E.4
0115C:  BRA    115A
0115E:  MOVWF  FAD
01160:  BCF    FD8.1
01162:  MOVFF  A4B,A4F
01166:  MOVFF  A4A,A4E
0116A:  MOVFF  A49,A4D
0116E:  MOVFF  A48,A4C
01172:  CLRF   x53
01174:  CLRF   x52
01176:  CLRF   x51
01178:  MOVLW  0A
0117A:  MOVWF  x50
0117C:  MOVLB  0
0117E:  RCALL  104A
01180:  MOVFF  03,A4B
01184:  MOVFF  02,A4A
01188:  MOVFF  01,A49
0118C:  MOVFF  00,A48
01190:  MOVLB  A
01192:  DECFSZ x46,F
01194:  BRA    10F6
01196:  MOVLB  0
01198:  RETURN 0
0119A:  MOVFF  FEA,A48
0119E:  MOVFF  FE9,A47
011A2:  MOVLB  A
011A4:  SWAPF  x41,W
011A6:  IORLW  F0
011A8:  MOVWF  x43
011AA:  ADDWF  x43,F
011AC:  ADDLW  E2
011AE:  MOVWF  x44
011B0:  ADDLW  32
011B2:  MOVWF  x46
011B4:  MOVF   x41,W
011B6:  ANDLW  0F
011B8:  ADDWF  x44,F
011BA:  ADDWF  x44,F
011BC:  ADDWF  x46,F
011BE:  ADDLW  E9
011C0:  MOVWF  x45
011C2:  ADDWF  x45,F
011C4:  ADDWF  x45,F
011C6:  SWAPF  x40,W
011C8:  ANDLW  0F
011CA:  ADDWF  x45,F
011CC:  ADDWF  x46,F
011CE:  RLCF   x45,F
011D0:  RLCF   x46,F
011D2:  COMF   x46,F
011D4:  RLCF   x46,F
011D6:  MOVF   x40,W
011D8:  ANDLW  0F
011DA:  ADDWF  x46,F
011DC:  RLCF   x43,F
011DE:  MOVLW  07
011E0:  MOVWF  x42
011E2:  MOVLW  0A
011E4:  DECF   x45,F
011E6:  ADDWF  x46,F
011E8:  BNC   11E4
011EA:  DECF   x44,F
011EC:  ADDWF  x45,F
011EE:  BNC   11EA
011F0:  DECF   x43,F
011F2:  ADDWF  x44,F
011F4:  BNC   11F0
011F6:  DECF   x42,F
011F8:  ADDWF  x43,F
011FA:  BNC   11F6
011FC:  MOVLW  0A
011FE:  MOVWF  FEA
01200:  MOVLW  42
01202:  MOVWF  FE9
01204:  MOVLW  07
01206:  ANDWF  x47,W
01208:  BCF    x47.6
0120A:  ADDWF  FE9,F
0120C:  MOVLW  00
0120E:  ADDWFC FEA,F
01210:  MOVF   FE9,W
01212:  SUBLW  46
01214:  BNZ   121E
01216:  MOVF   FEA,W
01218:  SUBLW  0A
0121A:  BNZ   121E
0121C:  BSF    x47.6
0121E:  MOVF   FEF,W
01220:  MOVWF  00
01222:  BNZ   1234
01224:  BTFSC  x47.6
01226:  BRA    1234
01228:  BTFSC  x47.4
0122A:  BRA    1244
0122C:  BTFSC  x47.3
0122E:  BRA    1234
01230:  MOVLW  20
01232:  BRA    123A
01234:  BSF    x47.3
01236:  BCF    x47.4
01238:  MOVLW  30
0123A:  ADDWF  00,F
0123C:  MOVF   00,W
0123E:  BTFSS  F9E.4
01240:  BRA    123E
01242:  MOVWF  FAD
01244:  MOVF   FEE,W
01246:  BTFSS  x47.6
01248:  BRA    1210
0124A:  MOVLB  0
0124C:  RETURN 0
*
01A52:  DATA 40,4C
01A54:  DATA 50,43
01A56:  DATA 2C,25
01A58:  DATA 4C,75
01A5A:  DATA 2C,25
01A5C:  DATA 4C,64
01A5E:  DATA 0D,0A
01A60:  DATA 00,00
01A62:  DATA 40,4D
01A64:  DATA 4D,45
01A66:  DATA 2C,25
01A68:  DATA 75,2C
01A6A:  DATA 25,4C
01A6C:  DATA 64,2C
01A6E:  DATA 25,4C
01A70:  DATA 75,2C
01A72:  DATA 25,4C
01A74:  DATA 75,2C
01A76:  DATA 25,4C
01A78:  DATA 64,2C
01A7A:  DATA 25,4C
01A7C:  DATA 64,0D
01A7E:  DATA 0A,00
01A80:  DATA 56,41
01A82:  DATA 4C,56
01A84:  DATA 45,20
01A86:  DATA 53,54
01A88:  DATA 4F,50
01A8A:  DATA 20,25
01A8C:  DATA 4C,75
01A8E:  DATA 2C,25
01A90:  DATA 4C,75
01A92:  DATA 0D,0A
01A94:  DATA 00,00
01A96:  DATA 69,6E
01A98:  DATA 64,3A
01A9A:  DATA 25,75
01A9C:  DATA 20,2F
01A9E:  DATA 20,70
01AA0:  DATA 68,61
01AA2:  DATA 3A,25
01AA4:  DATA 75,0D
01AA6:  DATA 0A,00
01AA8:  DATA 40,52
01AAA:  DATA 45,43
01AAC:  DATA 20,2D
01AAE:  DATA 20,68
01AB0:  DATA 6F,6D
01AB2:  DATA 69,6E
01AB4:  DATA 67,20
01AB6:  DATA 73,79
01AB8:  DATA 72,69
01ABA:  DATA 6E,67
01ABC:  DATA 65,20
01ABE:  DATA 61,6E
01AC0:  DATA 64,20
01AC2:  DATA 61,6C
01AC4:  DATA 69,67
01AC6:  DATA 6E,69
01AC8:  DATA 6E,67
01ACA:  DATA 20,76
01ACC:  DATA 61,6C
01ACE:  DATA 76,65
01AD0:  DATA 20,74
01AD2:  DATA 6F,20
01AD4:  DATA 70,6F
01AD6:  DATA 72,74
01AD8:  DATA 20,31
01ADA:  DATA 0D,0A
01ADC:  DATA 00,00
01ADE:  DATA 2C,73
01AE0:  DATA 65,72
01AE2:  DATA 69,61
01AE4:  DATA 6C,20
01AE6:  DATA 77,61
01AE8:  DATA 6B,65
01AEA:  DATA 2D,75
01AEC:  DATA 70,2C
01AEE:  DATA 53,44
01AF0:  DATA 20,69
01AF2:  DATA 6E,69
01AF4:  DATA 74,69
01AF6:  DATA 61,6C
01AF8:  DATA 69,7A
01AFA:  DATA 65,64
01AFC:  DATA 0D,0A
01AFE:  DATA 00,00
01B00:  DATA 40,52
01B02:  DATA 53,54
01B04:  DATA 0D,0A
01B06:  DATA 00,00
01B08:  DATA 40,57
01B0A:  DATA 44,54
01B0C:  DATA 0D,0A
01B0E:  DATA 00,00
01B10:  DATA 2C,72
01B12:  DATA 65,73
01B14:  DATA 74,61
01B16:  DATA 72,74
01B18:  DATA 20,63
01B1A:  DATA 61,75
01B1C:  DATA 73,65
01B1E:  DATA 2C,57
01B20:  DATA 44,20
01B22:  DATA 74,69
01B24:  DATA 6D,65
01B26:  DATA 2D,6F
01B28:  DATA 75,74
01B2A:  DATA 0D,0A
01B2C:  DATA 00,00
01B2E:  DATA 40,57
01B30:  DATA 44,53
01B32:  DATA 0D,0A
01B34:  DATA 00,00
01B36:  DATA 2C,72
01B38:  DATA 65,73
01B3A:  DATA 74,61
01B3C:  DATA 72,74
01B3E:  DATA 20,63
01B40:  DATA 61,75
01B42:  DATA 73,65
01B44:  DATA 2C,57
01B46:  DATA 44,20
01B48:  DATA 66,72
01B4A:  DATA 6F,6D
01B4C:  DATA 20,73
01B4E:  DATA 6C,65
01B50:  DATA 65,70
01B52:  DATA 0D,0A
01B54:  DATA 00,00
01B56:  DATA 40,4E
01B58:  DATA 50,55
01B5A:  DATA 0D,0A
01B5C:  DATA 00,00
01B5E:  DATA 2C,69
01B60:  DATA 64,23
01B62:  DATA 5B,25
01B64:  DATA 4C,75
01B66:  DATA 5D,2C
01B68:  DATA 70,6F
01B6A:  DATA 77,65
01B6C:  DATA 72,20
01B6E:  DATA 61,70
01B70:  DATA 70,6C
01B72:  DATA 69,65
01B74:  DATA 64,2C
01B76:  DATA 53,44
01B78:  DATA 20,69
01B7A:  DATA 6E,69
01B7C:  DATA 74,69
01B7E:  DATA 61,6C
01B80:  DATA 69,7A
01B82:  DATA 65,64
01B84:  DATA 0D,0A
01B86:  DATA 00,00
01B88:  DATA 40,52
01B8A:  DATA 53,54
01B8C:  DATA 0D,0A
01B8E:  DATA 00,00
01B90:  DATA 2C,72
01B92:  DATA 65,73
01B94:  DATA 74,61
01B96:  DATA 72,74
01B98:  DATA 20,63
01B9A:  DATA 61,75
01B9C:  DATA 73,65
01B9E:  DATA 2C,72
01BA0:  DATA 65,73
01BA2:  DATA 65,74
01BA4:  DATA 20,69
01BA6:  DATA 6E,73
01BA8:  DATA 74,72
01BAA:  DATA 75,63
01BAC:  DATA 74,69
01BAE:  DATA 6F,6E
01BB0:  DATA 0D,0A
01BB2:  DATA 00,00
01BB4:  DATA 40,42
01BB6:  DATA 4F,52
01BB8:  DATA 0D,0A
01BBA:  DATA 00,00
01BBC:  DATA 2C,72
01BBE:  DATA 65,73
01BC0:  DATA 74,61
01BC2:  DATA 72,74
01BC4:  DATA 20,63
01BC6:  DATA 61,75
01BC8:  DATA 73,65
01BCA:  DATA 2C,62
01BCC:  DATA 72,6F
01BCE:  DATA 77,6E
01BD0:  DATA 2D,6F
01BD2:  DATA 75,74
01BD4:  DATA 0D,0A
01BD6:  DATA 00,00
01BD8:  DATA 40,4D
01BDA:  DATA 52,53
01BDC:  DATA 0D,0A
01BDE:  DATA 00,00
01BE0:  DATA 2C,72
01BE2:  DATA 65,73
01BE4:  DATA 74,61
01BE6:  DATA 72,74
01BE8:  DATA 20,63
01BEA:  DATA 61,75
01BEC:  DATA 73,65
01BEE:  DATA 2C,4D
01BF0:  DATA 43,4C
01BF2:  DATA 52,20
01BF4:  DATA 66,72
01BF6:  DATA 6F,6D
01BF8:  DATA 20,73
01BFA:  DATA 6C,65
01BFC:  DATA 65,70
01BFE:  DATA 0D,0A
01C00:  DATA 00,00
01C02:  DATA 40,4D
01C04:  DATA 52,52
01C06:  DATA 0D,0A
01C08:  DATA 00,00
01C0A:  DATA 2C,72
01C0C:  DATA 65,73
01C0E:  DATA 74,61
01C10:  DATA 72,74
01C12:  DATA 20,63
01C14:  DATA 61,75
01C16:  DATA 73,65
01C18:  DATA 2C,4D
01C1A:  DATA 43,4C
01C1C:  DATA 52,20
01C1E:  DATA 77,68
01C20:  DATA 65,6E
01C22:  DATA 20,72
01C24:  DATA 75,6E
01C26:  DATA 6E,69
01C28:  DATA 6E,67
01C2A:  DATA 0D,0A
01C2C:  DATA 00,00
01C2E:  DATA 4E,4F
01C30:  DATA 33,00
01C32:  DATA 4E,4F
01C34:  DATA 32,00
01C36:  DATA 50,4F
01C38:  DATA 34,00
01C3A:  DATA 4E,48
01C3C:  DATA 34,00
01C3E:  DATA 53,69
01C40:  DATA 4F,00
01C42:  DATA 00,00
01C44:  DATA 40,44
01C46:  DATA 45,54
01C48:  DATA 5B,2F
01C4A:  DATA 25,75
01C4C:  DATA 5D,5B
01C4E:  DATA 25,63
01C50:  DATA 5D,41
01C52:  DATA 52,47
01C54:  DATA 5B,25
01C56:  DATA 4C,75
01C58:  DATA 5D,0D
01C5A:  DATA 0A,00
01C5C:  DATA 20,74
01C5E:  DATA 69,6D
01C60:  DATA 65,2D
01C62:  DATA 6F,75
01C64:  DATA 74,00
01C66:  DATA 20,64
01C68:  DATA 61,74
01C6A:  DATA 61,20
01C6C:  DATA 74,6F
01C6E:  DATA 6F,20
01C70:  DATA 73,68
01C72:  DATA 6F,72
01C74:  DATA 74,00
01C76:  DATA 20,64
01C78:  DATA 61,74
01C7A:  DATA 61,20
01C7C:  DATA 74,6F
01C7E:  DATA 6F,20
01C80:  DATA 6C,6F
01C82:  DATA 6E,67
01C84:  DATA 00,00
01C86:  DATA 2C,64
01C88:  DATA 65,74
01C8A:  DATA 65,63
01C8C:  DATA 74,6F
01C8E:  DATA 72,5B
01C90:  DATA 25,73
01C92:  DATA 5D,2C
01C94:  DATA 6C,65
01C96:  DATA 6E,5B
01C98:  DATA 25,75
01C9A:  DATA 5D,00
01C9C:  DATA 40,52
01C9E:  DATA 54,59
01CA0:  DATA 2C,25
01CA2:  DATA 75,0D
01CA4:  DATA 0A,00
01CA6:  DATA 2C,73
01CA8:  DATA 74,61
01CAA:  DATA 72,74
01CAC:  DATA 20,68
01CAE:  DATA 65,61
01CB0:  DATA 74,69
01CB2:  DATA 6E,67
01CB4:  DATA 2C,74
01CB6:  DATA 61,72
01CB8:  DATA 67,65
01CBA:  DATA 74,5B
01CBC:  DATA 25,4C
01CBE:  DATA 75,5D
01CC0:  DATA 2C,61
01CC2:  DATA 63,74
01CC4:  DATA 75,61
01CC6:  DATA 6C,5B
01CC8:  DATA 25,4C
01CCA:  DATA 75,5D
01CCC:  DATA 2C,72
01CCE:  DATA 65,61
01CD0:  DATA 64,69
01CD2:  DATA 6E,67
01CD4:  DATA 73,5B
01CD6:  DATA 25,4C
01CD8:  DATA 75,5D
01CDA:  DATA 0D,0A
01CDC:  DATA 00,00
01CDE:  DATA 2C,65
01CE0:  DATA 6E,64
01CE2:  DATA 20,68
01CE4:  DATA 65,61
01CE6:  DATA 74,69
01CE8:  DATA 6E,67
01CEA:  DATA 2C,74
01CEC:  DATA 61,72
01CEE:  DATA 67,65
01CF0:  DATA 74,5B
01CF2:  DATA 25,4C
01CF4:  DATA 75,5D
01CF6:  DATA 2C,61
01CF8:  DATA 63,74
01CFA:  DATA 75,61
01CFC:  DATA 6C,5B
01CFE:  DATA 25,4C
01D00:  DATA 75,5D
01D02:  DATA 2C,72
01D04:  DATA 65,61
01D06:  DATA 64,69
01D08:  DATA 6E,67
01D0A:  DATA 73,5B
01D0C:  DATA 25,4C
01D0E:  DATA 75,5D
01D10:  DATA 0D,0A
01D12:  DATA 00,00
01D14:  DATA 4E,4F
01D16:  DATA 33,00
01D18:  DATA 4E,4F
01D1A:  DATA 32,00
01D1C:  DATA 50,4F
01D1E:  DATA 34,00
01D20:  DATA 4E,48
01D22:  DATA 34,00
01D24:  DATA 53,69
01D26:  DATA 4F,00
01D28:  DATA 00,00
01D2A:  DATA 40,44
01D2C:  DATA 41,43
01D2E:  DATA 2C,25
01D30:  DATA 4C,75
01D32:  DATA 2C,25
01D34:  DATA 4C,75
01D36:  DATA 2C,00
01D38:  DATA 40,53
01D3A:  DATA 41,52
01D3C:  DATA 2C,31
01D3E:  DATA 2C,25
01D40:  DATA 4C,75
01D42:  DATA 2C,00
01D44:  DATA 40,56
01D46:  DATA 41,4C
01D48:  DATA 20,00
01D4A:  DATA 40,56
01D4C:  DATA 41,4C
01D4E:  DATA 20,00
01D50:  DATA 40,56
01D52:  DATA 41,4C
01D54:  DATA 20,00
01D56:  DATA 40,56
01D58:  DATA 41,4C
01D5A:  DATA 20,00
01D5C:  DATA 40,53
01D5E:  DATA 4F,4C
01D60:  DATA 5B,2F
01D62:  DATA 31,5D
01D64:  DATA 5B,73
01D66:  DATA 5D,5B
01D68:  DATA 25,4C
01D6A:  DATA 75,5D
01D6C:  DATA 0D,0A
01D6E:  DATA 00,00
01D70:  DATA 2F,31
01D72:  DATA 73,25
01D74:  DATA 4C,75
01D76:  DATA 0D,00
01D78:  DATA 40,53
01D7A:  DATA 4F,4C
01D7C:  DATA 5B,2F
01D7E:  DATA 31,5D
01D80:  DATA 5B,63
01D82:  DATA 5D,5B
01D84:  DATA 25,75
01D86:  DATA 5D,0D
01D88:  DATA 0A,00
01D8A:  DATA 2F,31
01D8C:  DATA 63,25
01D8E:  DATA 75,0D
01D90:  DATA 00,00
01D92:  DATA 2F,31
01D94:  DATA 73,32
01D96:  DATA 35,36
01D98:  DATA 0D,00
01D9A:  DATA 28,49
01D9C:  DATA 30,73
01D9E:  DATA 29,2C
01DA0:  DATA 25,4C
01DA2:  DATA 75,2C
01DA4:  DATA 28,49
01DA6:  DATA 31,73
01DA8:  DATA 29,2C
01DAA:  DATA 25,4C
01DAC:  DATA 75,2C
01DAE:  DATA 28,41
01DB0:  DATA 62,73
01DB2:  DATA 2D,73
01DB4:  DATA 29,2C
01DB6:  DATA 25,31
01DB8:  DATA 2E,34
01DBA:  DATA 67,2C
01DBC:  DATA 28,49
01DBE:  DATA 30,74
01DC0:  DATA 29,2C
01DC2:  DATA 25,4C
01DC4:  DATA 75,2C
01DC6:  DATA 28,49
01DC8:  DATA 31,74
01DCA:  DATA 29,2C
01DCC:  DATA 25,4C
01DCE:  DATA 75,2C
01DD0:  DATA 28,41
01DD2:  DATA 62,73
01DD4:  DATA 2D,74
01DD6:  DATA 29,2C
01DD8:  DATA 25,31
01DDA:  DATA 2E,34
01DDC:  DATA 67,2C
01DDE:  DATA 28,49
01DE0:  DATA 30,72
01DE2:  DATA 29,2C
01DE4:  DATA 25,4C
01DE6:  DATA 75,2C
01DE8:  DATA 28,49
01DEA:  DATA 31,72
01DEC:  DATA 29,2C
01DEE:  DATA 25,4C
01DF0:  DATA 75,2C
01DF2:  DATA 28,41
01DF4:  DATA 62,73
01DF6:  DATA 2D,72
01DF8:  DATA 29,2C
01DFA:  DATA 25,31
01DFC:  DATA 2E,34
01DFE:  DATA 67,00
01E00:  DATA 40,41
01E02:  DATA 62,73
01E04:  DATA 2C,4E
01E06:  DATA 4F,33
01E08:  DATA 2C,25
01E0A:  DATA 73,0D
01E0C:  DATA 0A,00
01E0E:  DATA 28,49
01E10:  DATA 30,73
01E12:  DATA 29,2C
01E14:  DATA 25,4C
01E16:  DATA 75,2C
01E18:  DATA 28,49
01E1A:  DATA 31,73
01E1C:  DATA 29,2C
01E1E:  DATA 25,4C
01E20:  DATA 75,2C
01E22:  DATA 28,41
01E24:  DATA 62,73
01E26:  DATA 2D,73
01E28:  DATA 29,2C
01E2A:  DATA 25,31
01E2C:  DATA 2E,34
01E2E:  DATA 67,2C
01E30:  DATA 28,49
01E32:  DATA 30,74
01E34:  DATA 29,2C
01E36:  DATA 25,4C
01E38:  DATA 75,2C
01E3A:  DATA 28,49
01E3C:  DATA 31,74
01E3E:  DATA 29,2C
01E40:  DATA 25,4C
01E42:  DATA 75,2C
01E44:  DATA 28,41
01E46:  DATA 62,73
01E48:  DATA 2D,74
01E4A:  DATA 29,2C
01E4C:  DATA 25,31
01E4E:  DATA 2E,34
01E50:  DATA 67,2C
01E52:  DATA 28,49
01E54:  DATA 30,72
01E56:  DATA 29,2C
01E58:  DATA 25,4C
01E5A:  DATA 75,2C
01E5C:  DATA 28,49
01E5E:  DATA 31,72
01E60:  DATA 29,2C
01E62:  DATA 25,4C
01E64:  DATA 75,2C
01E66:  DATA 28,41
01E68:  DATA 62,73
01E6A:  DATA 2D,72
01E6C:  DATA 29,2C
01E6E:  DATA 25,31
01E70:  DATA 2E,34
01E72:  DATA 67,00
01E74:  DATA 40,41
01E76:  DATA 62,73
01E78:  DATA 2C,4E
01E7A:  DATA 4F,32
01E7C:  DATA 2C,25
01E7E:  DATA 73,0D
01E80:  DATA 0A,00
01E82:  DATA 28,49
01E84:  DATA 30,73
01E86:  DATA 29,2C
01E88:  DATA 25,4C
01E8A:  DATA 75,2C
01E8C:  DATA 28,49
01E8E:  DATA 31,73
01E90:  DATA 29,2C
01E92:  DATA 25,4C
01E94:  DATA 75,2C
01E96:  DATA 28,41
01E98:  DATA 62,73
01E9A:  DATA 2D,73
01E9C:  DATA 29,2C
01E9E:  DATA 25,31
01EA0:  DATA 2E,34
01EA2:  DATA 67,2C
01EA4:  DATA 28,49
01EA6:  DATA 30,74
01EA8:  DATA 29,2C
01EAA:  DATA 25,4C
01EAC:  DATA 75,2C
01EAE:  DATA 28,49
01EB0:  DATA 31,74
01EB2:  DATA 29,2C
01EB4:  DATA 25,4C
01EB6:  DATA 75,2C
01EB8:  DATA 28,41
01EBA:  DATA 62,73
01EBC:  DATA 2D,74
01EBE:  DATA 29,2C
01EC0:  DATA 25,31
01EC2:  DATA 2E,34
01EC4:  DATA 67,2C
01EC6:  DATA 28,49
01EC8:  DATA 30,72
01ECA:  DATA 29,2C
01ECC:  DATA 25,4C
01ECE:  DATA 75,2C
01ED0:  DATA 28,49
01ED2:  DATA 31,72
01ED4:  DATA 29,2C
01ED6:  DATA 25,4C
01ED8:  DATA 75,2C
01EDA:  DATA 28,41
01EDC:  DATA 62,73
01EDE:  DATA 2D,72
01EE0:  DATA 29,2C
01EE2:  DATA 25,31
01EE4:  DATA 2E,34
01EE6:  DATA 67,00
01EE8:  DATA 40,41
01EEA:  DATA 62,73
01EEC:  DATA 2C,50
01EEE:  DATA 4F,34
01EF0:  DATA 2C,25
01EF2:  DATA 73,0D
01EF4:  DATA 0A,00
01EF6:  DATA 28,49
01EF8:  DATA 30,73
01EFA:  DATA 29,2C
01EFC:  DATA 25,4C
01EFE:  DATA 75,2C
01F00:  DATA 28,49
01F02:  DATA 31,73
01F04:  DATA 29,2C
01F06:  DATA 25,4C
01F08:  DATA 75,2C
01F0A:  DATA 28,41
01F0C:  DATA 62,73
01F0E:  DATA 2D,73
01F10:  DATA 29,2C
01F12:  DATA 25,31
01F14:  DATA 2E,34
01F16:  DATA 67,2C
01F18:  DATA 28,49
01F1A:  DATA 30,74
01F1C:  DATA 29,2C
01F1E:  DATA 25,4C
01F20:  DATA 75,2C
01F22:  DATA 28,49
01F24:  DATA 31,74
01F26:  DATA 29,2C
01F28:  DATA 25,4C
01F2A:  DATA 75,2C
01F2C:  DATA 28,41
01F2E:  DATA 62,73
01F30:  DATA 2D,74
01F32:  DATA 29,2C
01F34:  DATA 25,31
01F36:  DATA 2E,34
01F38:  DATA 67,2C
01F3A:  DATA 28,49
01F3C:  DATA 30,72
01F3E:  DATA 29,2C
01F40:  DATA 25,4C
01F42:  DATA 75,2C
01F44:  DATA 28,49
01F46:  DATA 31,72
01F48:  DATA 29,2C
01F4A:  DATA 25,4C
01F4C:  DATA 75,2C
01F4E:  DATA 28,41
01F50:  DATA 62,73
01F52:  DATA 2D,72
01F54:  DATA 29,2C
01F56:  DATA 25,31
01F58:  DATA 2E,34
01F5A:  DATA 67,00
01F5C:  DATA 40,41
01F5E:  DATA 62,73
01F60:  DATA 2C,4E
01F62:  DATA 48,34
01F64:  DATA 2C,25
01F66:  DATA 73,0D
01F68:  DATA 0A,00
01F6A:  DATA 28,49
01F6C:  DATA 30,73
01F6E:  DATA 29,2C
01F70:  DATA 25,4C
01F72:  DATA 75,2C
01F74:  DATA 28,49
01F76:  DATA 31,73
01F78:  DATA 29,2C
01F7A:  DATA 25,4C
01F7C:  DATA 75,2C
01F7E:  DATA 28,41
01F80:  DATA 62,73
01F82:  DATA 2D,73
01F84:  DATA 29,2C
01F86:  DATA 25,31
01F88:  DATA 2E,34
01F8A:  DATA 67,2C
01F8C:  DATA 28,49
01F8E:  DATA 30,74
01F90:  DATA 29,2C
01F92:  DATA 25,4C
01F94:  DATA 75,2C
01F96:  DATA 28,49
01F98:  DATA 31,74
01F9A:  DATA 29,2C
01F9C:  DATA 25,4C
01F9E:  DATA 75,2C
01FA0:  DATA 28,41
01FA2:  DATA 62,73
01FA4:  DATA 2D,74
01FA6:  DATA 29,2C
01FA8:  DATA 25,31
01FAA:  DATA 2E,34
01FAC:  DATA 67,2C
01FAE:  DATA 28,49
01FB0:  DATA 30,72
01FB2:  DATA 29,2C
01FB4:  DATA 25,4C
01FB6:  DATA 75,2C
01FB8:  DATA 28,49
01FBA:  DATA 31,72
01FBC:  DATA 29,2C
01FBE:  DATA 25,4C
01FC0:  DATA 75,2C
01FC2:  DATA 28,41
01FC4:  DATA 62,73
01FC6:  DATA 2D,72
01FC8:  DATA 29,2C
01FCA:  DATA 25,31
01FCC:  DATA 2E,34
01FCE:  DATA 67,00
01FD0:  DATA 40,41
01FD2:  DATA 42,53
01FD4:  DATA 2C,53
01FD6:  DATA 69,4F
01FD8:  DATA 2C,25
01FDA:  DATA 73,0D
01FDC:  DATA 0A,00
01FDE:  DATA 4E,4F
01FE0:  DATA 33,00
01FE2:  DATA 4E,4F
01FE4:  DATA 32,00
01FE6:  DATA 50,4F
01FE8:  DATA 34,00
01FEA:  DATA 4E,48
01FEC:  DATA 34,00
01FEE:  DATA 53,69
01FF0:  DATA 4F,00
01FF2:  DATA 00,00
01FF4:  DATA 28,6D
01FF6:  DATA 29,2C
01FF8:  DATA 25,33
01FFA:  DATA 2E,33
01FFC:  DATA 67,2C
01FFE:  DATA 28,63
02000:  DATA 29,2C
02002:  DATA 25,33
02004:  DATA 2E,33
02006:  DATA 67,00
02008:  DATA 28,43
0200A:  DATA 73,29
0200C:  DATA 2C,25
0200E:  DATA 33,2E
02010:  DATA 33,67
02012:  DATA 0D,0A
02014:  DATA 00,00
02016:  DATA 40,43
02018:  DATA 4F,4E
0201A:  DATA 2C,4E
0201C:  DATA 4F,33
0201E:  DATA 2C,25
02020:  DATA 73,0D
02022:  DATA 0A,00
02024:  DATA 28,6D
02026:  DATA 29,2C
02028:  DATA 25,33
0202A:  DATA 2E,33
0202C:  DATA 67,2C
0202E:  DATA 28,63
02030:  DATA 29,2C
02032:  DATA 25,33
02034:  DATA 2E,33
02036:  DATA 67,00
02038:  DATA 28,43
0203A:  DATA 73,29
0203C:  DATA 2C,25
0203E:  DATA 33,2E
02040:  DATA 33,67
02042:  DATA 0D,0A
02044:  DATA 00,00
02046:  DATA 40,43
02048:  DATA 4F,4E
0204A:  DATA 2C,50
0204C:  DATA 4F,34
0204E:  DATA 2C,25
02050:  DATA 73,0D
02052:  DATA 0A,00
02054:  DATA 28,6D
02056:  DATA 29,2C
02058:  DATA 25,33
0205A:  DATA 2E,33
0205C:  DATA 67,2C
0205E:  DATA 28,63
02060:  DATA 29,2C
02062:  DATA 25,33
02064:  DATA 2E,33
02066:  DATA 67,00
02068:  DATA 28,43
0206A:  DATA 73,29
0206C:  DATA 2C,25
0206E:  DATA 33,2E
02070:  DATA 33,67
02072:  DATA 0D,0A
02074:  DATA 00,00
02076:  DATA 40,43
02078:  DATA 4F,4E
0207A:  DATA 2C,4E
0207C:  DATA 48,34
0207E:  DATA 2C,25
02080:  DATA 73,0D
02082:  DATA 0A,00
02084:  DATA 28,6D
02086:  DATA 29,2C
02088:  DATA 25,33
0208A:  DATA 2E,33
0208C:  DATA 67,2C
0208E:  DATA 28,63
02090:  DATA 29,2C
02092:  DATA 25,33
02094:  DATA 2E,33
02096:  DATA 67,00
02098:  DATA 28,43
0209A:  DATA 73,29
0209C:  DATA 2C,25
0209E:  DATA 33,2E
020A0:  DATA 33,67
020A2:  DATA 0D,0A
020A4:  DATA 00,00
020A6:  DATA 40,43
020A8:  DATA 4F,4E
020AA:  DATA 2C,53
020AC:  DATA 69,4F
020AE:  DATA 2C,25
020B0:  DATA 73,0D
020B2:  DATA 0A,00
020B4:  DATA 4E,4F
020B6:  DATA 33,00
020B8:  DATA 50,4F
020BA:  DATA 34,00
020BC:  DATA 4E,48
020BE:  DATA 34,00
020C0:  DATA 53,69
020C2:  DATA 4F,00
020C4:  DATA 00,00
020C6:  DATA 4D,45
020C8:  DATA 4D,4F
020CA:  DATA 52,59
020CC:  DATA 20,4F
020CE:  DATA 56,45
020D0:  DATA 52,46
020D2:  DATA 4C,4F
020D4:  DATA 57,20
020D6:  DATA 45,52
020D8:  DATA 52,4F
020DA:  DATA 52,20
020DC:  DATA 40,20
020DE:  DATA 4C,69
020E0:  DATA 6E,65
020E2:  DATA 20,3A
020E4:  DATA 25,4C
020E6:  DATA 75,0A
020E8:  DATA 0D,00
020EA:  DATA 0D,0A
020EC:  DATA 3A,00
020EE:  DATA 0D,0A
020F0:  DATA 57,41
020F2:  DATA 52,4E
020F4:  DATA 49,4E
020F6:  DATA 47,3A
020F8:  DATA 20,49
020FA:  DATA 4E,56
020FC:  DATA 41,4C
020FE:  DATA 49,44
02100:  DATA 20,43
02102:  DATA 4F,4D
02104:  DATA 4D,41
02106:  DATA 4E,44
02108:  DATA 20,49
0210A:  DATA 4E,20
0210C:  DATA 4D,41
0210E:  DATA 43,52
02110:  DATA 4F,21
02112:  DATA 0D,0A
02114:  DATA 00,00
02116:  DATA 42,61
02118:  DATA 64,20
0211A:  DATA 63,6F
0211C:  DATA 6D,6D
0211E:  DATA 61,6E
02120:  DATA 64,20
02122:  DATA 61,74
02124:  DATA 20,6C
02126:  DATA 69,6E
02128:  DATA 65,3A
0212A:  DATA 20,25
0212C:  DATA 4C,64
0212E:  DATA 20,0D
02130:  DATA 0A,00
02132:  DATA 50,6C
02134:  DATA 65,61
02136:  DATA 73,65
02138:  DATA 20,72
0213A:  DATA 65,2D
0213C:  DATA 75,70
0213E:  DATA 6C,6F
02140:  DATA 61,64
02142:  DATA 20,6D
02144:  DATA 61,63
02146:  DATA 72,6F
02148:  DATA 00,00
0214A:  DATA 49,74
0214C:  DATA 65,72
0214E:  DATA 61,74
02150:  DATA 69,6F
02152:  DATA 6E,73
02154:  DATA 20,6C
02156:  DATA 65,66
02158:  DATA 74,3A
0215A:  DATA 20,25
0215C:  DATA 4C,75
0215E:  DATA 0D,0A
02160:  DATA 00,00
02162:  DATA 2C,6D
02164:  DATA 61,63
02166:  DATA 72,6F
02168:  DATA 5B,25
0216A:  DATA 75,5D
0216C:  DATA 2C,73
0216E:  DATA 74,61
02170:  DATA 72,74
02172:  DATA 0D,0A
02174:  DATA 00,00
02176:  DATA 40,4D
02178:  DATA 43,4C
0217A:  DATA 5B,25
0217C:  DATA 63,5D
0217E:  DATA 5B,25
02180:  DATA 4C,75
02182:  DATA 5D,0D
02184:  DATA 0A,00
02186:  DATA 40,4C
02188:  DATA 4E,45
0218A:  DATA 0D,0A
0218C:  DATA 00,00
0218E:  DATA 40,52
02190:  DATA 55,4E
02192:  DATA 0D,0A
02194:  DATA 00,00
02196:  DATA 40,42
02198:  DATA 41,44
0219A:  DATA 0D,0A
0219C:  DATA 00,00
0219E:  DATA 40,54
021A0:  DATA 2F,4F
021A2:  DATA 0D,0A
021A4:  DATA 00,00
021A6:  DATA 40,45
021A8:  DATA 52,52
021AA:  DATA 0D,0A
021AC:  DATA 00,00
021AE:  DATA 40,45
021B0:  DATA 4E,44
021B2:  DATA 0D,0A
021B4:  DATA 00,00
021B6:  DATA 40,48
021B8:  DATA 4C,54
021BA:  DATA 0D,0A
021BC:  DATA 00,00
021BE:  DATA 2C,6D
021C0:  DATA 61,63
021C2:  DATA 72,6F
021C4:  DATA 5B,25
021C6:  DATA 75,5D
021C8:  DATA 2C,73
021CA:  DATA 74,61
021CC:  DATA 74,75
021CE:  DATA 73,5B
021D0:  DATA 25,63
021D2:  DATA 5D,2C
021D4:  DATA 6C,69
021D6:  DATA 6E,65
021D8:  DATA 5B,25
021DA:  DATA 4C,75
021DC:  DATA 5D,0D
021DE:  DATA 0A,00
021E0:  DATA 40,52
021E2:  DATA 75,6E
021E4:  DATA 6E,69
021E6:  DATA 6E,67
021E8:  DATA 20,25
021EA:  DATA 63,25
021EC:  DATA 4C,75
021EE:  DATA 20,0D
021F0:  DATA 0A,00
021F2:  DATA 40,4D
021F4:  DATA 61,63
021F6:  DATA 72,6F
021F8:  DATA 20,25
021FA:  DATA 30,34
021FC:  DATA 4C,75
021FE:  DATA 20,6F
02200:  DATA 66,20
02202:  DATA 25,30
02204:  DATA 34,4C
02206:  DATA 75,0D
02208:  DATA 0A,00
0220A:  DATA 40,4C
0220C:  DATA 4E,45
0220E:  DATA 0D,0A
02210:  DATA 00,00
02212:  DATA 40,52
02214:  DATA 55,4E
02216:  DATA 0D,0A
02218:  DATA 00,00
0221A:  DATA 40,42
0221C:  DATA 41,44
0221E:  DATA 0D,0A
02220:  DATA 00,00
02222:  DATA 40,54
02224:  DATA 2F,4F
02226:  DATA 0D,0A
02228:  DATA 00,00
0222A:  DATA 40,45
0222C:  DATA 52,52
0222E:  DATA 0D,0A
02230:  DATA 00,00
02232:  DATA 40,45
02234:  DATA 4E,44
02236:  DATA 0D,0A
02238:  DATA 00,00
0223A:  DATA 2C,61
0223C:  DATA 75,74
0223E:  DATA 6F,2D
02240:  DATA 73,61
02242:  DATA 6D,70
02244:  DATA 6C,65
02246:  DATA 2C,73
02248:  DATA 61,6D
0224A:  DATA 70,6C
0224C:  DATA 65,5B
0224E:  DATA 25,4C
02250:  DATA 75,5D
02252:  DATA 2C,73
02254:  DATA 74,61
02256:  DATA 72,74
02258:  DATA 0D,0A
0225A:  DATA 00,00
0225C:  DATA 2C,61
0225E:  DATA 75,74
02260:  DATA 6F,2D
02262:  DATA 73,61
02264:  DATA 6D,70
02266:  DATA 6C,65
02268:  DATA 2C,73
0226A:  DATA 61,6D
0226C:  DATA 70,6C
0226E:  DATA 65,5B
02270:  DATA 25,4C
02272:  DATA 75,5D
02274:  DATA 2C,63
02276:  DATA 6F,6D
02278:  DATA 70,6C
0227A:  DATA 65,74
0227C:  DATA 65,0D
0227E:  DATA 0A,00
02280:  DATA 2C,61
02282:  DATA 75,74
02284:  DATA 6F,2D
02286:  DATA 73,61
02288:  DATA 6D,70
0228A:  DATA 6C,65
0228C:  DATA 2C,73
0228E:  DATA 61,6D
02290:  DATA 70,6C
02292:  DATA 65,5B
02294:  DATA 25,4C
02296:  DATA 75,5D
02298:  DATA 2C,65
0229A:  DATA 72,72
0229C:  DATA 6F,72
0229E:  DATA 0D,0A
022A0:  DATA 00,00
022A2:  DATA 2C,61
022A4:  DATA 75,74
022A6:  DATA 6F,2D
022A8:  DATA 73,61
022AA:  DATA 6D,70
022AC:  DATA 6C,65
022AE:  DATA 2C,73
022B0:  DATA 61,6D
022B2:  DATA 70,6C
022B4:  DATA 65,5B
022B6:  DATA 25,4C
022B8:  DATA 75,5D
022BA:  DATA 2C,6D
022BC:  DATA 61,78
022BE:  DATA 20,73
022C0:  DATA 61,6D
022C2:  DATA 70,6C
022C4:  DATA 65,73
022C6:  DATA 0D,0A
022C8:  DATA 00,00
022CA:  DATA 2C,61
022CC:  DATA 75,74
022CE:  DATA 6F,2D
022D0:  DATA 73,61
022D2:  DATA 6D,70
022D4:  DATA 6C,65
022D6:  DATA 2C,73
022D8:  DATA 61,6D
022DA:  DATA 70,6C
022DC:  DATA 65,5B
022DE:  DATA 25,4C
022E0:  DATA 75,5D
022E2:  DATA 2C,73
022E4:  DATA 74,61
022E6:  DATA 72,74
022E8:  DATA 0D,0A
022EA:  DATA 00,00
022EC:  DATA 2C,61
022EE:  DATA 75,74
022F0:  DATA 6F,2D
022F2:  DATA 73,61
022F4:  DATA 6D,70
022F6:  DATA 6C,65
022F8:  DATA 2C,73
022FA:  DATA 61,6D
022FC:  DATA 70,6C
022FE:  DATA 65,5B
02300:  DATA 25,4C
02302:  DATA 75,5D
02304:  DATA 2C,63
02306:  DATA 6F,6D
02308:  DATA 70,6C
0230A:  DATA 65,74
0230C:  DATA 65,0D
0230E:  DATA 0A,00
02310:  DATA 2C,61
02312:  DATA 75,74
02314:  DATA 6F,2D
02316:  DATA 73,61
02318:  DATA 6D,70
0231A:  DATA 6C,65
0231C:  DATA 2C,73
0231E:  DATA 61,6D
02320:  DATA 70,6C
02322:  DATA 65,5B
02324:  DATA 25,4C
02326:  DATA 75,5D
02328:  DATA 2C,73
0232A:  DATA 74,61
0232C:  DATA 72,74
0232E:  DATA 0D,0A
02330:  DATA 00,00
02332:  DATA 2C,61
02334:  DATA 75,74
02336:  DATA 6F,2D
02338:  DATA 73,61
0233A:  DATA 6D,70
0233C:  DATA 6C,65
0233E:  DATA 2C,73
02340:  DATA 61,6D
02342:  DATA 70,6C
02344:  DATA 65,5B
02346:  DATA 25,4C
02348:  DATA 75,5D
0234A:  DATA 2C,63
0234C:  DATA 6F,6D
0234E:  DATA 70,6C
02350:  DATA 65,74
02352:  DATA 65,0D
02354:  DATA 0A,00
02356:  DATA 2C,61
02358:  DATA 75,74
0235A:  DATA 6F,2D
0235C:  DATA 73,61
0235E:  DATA 6D,70
02360:  DATA 6C,65
02362:  DATA 2C,73
02364:  DATA 61,6D
02366:  DATA 70,6C
02368:  DATA 65,5B
0236A:  DATA 25,4C
0236C:  DATA 75,5D
0236E:  DATA 2C,6D
02370:  DATA 61,78
02372:  DATA 20,73
02374:  DATA 61,6D
02376:  DATA 70,6C
02378:  DATA 65,73
0237A:  DATA 0D,0A
0237C:  DATA 00,00
0237E:  DATA 2C,61
02380:  DATA 75,74
02382:  DATA 6F,2D
02384:  DATA 73,61
02386:  DATA 6D,70
02388:  DATA 6C,65
0238A:  DATA 2C,69
0238C:  DATA 6E,69
0238E:  DATA 74,69
02390:  DATA 61,6C
02392:  DATA 69,7A
02394:  DATA 65,0D
02396:  DATA 0A,00
02398:  DATA 2C,68
0239A:  DATA 65,61
0239C:  DATA 64,65
0239E:  DATA 72,2C
023A0:  DATA 69,64
023A2:  DATA 23,5B
023A4:  DATA 25,4C
023A6:  DATA 75,5D
023A8:  DATA 2C,69
023AA:  DATA 6E,74
023AC:  DATA 5B,25
023AE:  DATA 4C,75
023B0:  DATA 5D,2C
023B2:  DATA 6D,61
023B4:  DATA 78,5B
023B6:  DATA 25,4C
023B8:  DATA 75,5D
023BA:  DATA 0D,0A
023BC:  DATA 00,00
023BE:  DATA 2C,61
023C0:  DATA 75,74
023C2:  DATA 6F,2D
023C4:  DATA 73,61
023C6:  DATA 6D,70
023C8:  DATA 6C,65
023CA:  DATA 2C,73
023CC:  DATA 61,6D
023CE:  DATA 70,6C
023D0:  DATA 65,5B
023D2:  DATA 25,4C
023D4:  DATA 75,5D
023D6:  DATA 2C,61
023D8:  DATA 6C,61
023DA:  DATA 72,6D
023DC:  DATA 5B,25
023DE:  DATA 75,5D
023E0:  DATA 0D,0A
023E2:  DATA 00,00
023E4:  DATA 2C,61
023E6:  DATA 75,74
023E8:  DATA 6F,2D
023EA:  DATA 73,61
023EC:  DATA 6D,70
023EE:  DATA 6C,65
023F0:  DATA 2C,73
023F2:  DATA 6C,65
023F4:  DATA 65,70
023F6:  DATA 0D,0A
023F8:  DATA 00,00
023FA:  DATA 74,31
023FC:  DATA 3A,25
023FE:  DATA 4C,75
02400:  DATA 20,74
02402:  DATA 32,3A
02404:  DATA 25,4C
02406:  DATA 75,0D
02408:  DATA 0A,00
0240A:  DATA 40,44
0240C:  DATA 45,54
0240E:  DATA 2C,25
02410:  DATA 4C,75
02412:  DATA 0D,0A
02414:  DATA 00,00
02416:  DATA 4E,4F
02418:  DATA 33,2C
0241A:  DATA 25,31
0241C:  DATA 2E,35
0241E:  DATA 67,2C
02420:  DATA 25,31
02422:  DATA 2E,35
02424:  DATA 67,0D
02426:  DATA 0A,00
02428:  DATA 50,4F
0242A:  DATA 34,2C
0242C:  DATA 25,31
0242E:  DATA 2E,35
02430:  DATA 67,2C
02432:  DATA 25,31
02434:  DATA 2E,35
02436:  DATA 67,0D
02438:  DATA 0A,00
0243A:  DATA 4E,48
0243C:  DATA 34,2C
0243E:  DATA 25,31
02440:  DATA 2E,35
02442:  DATA 67,2C
02444:  DATA 25,31
02446:  DATA 2E,35
02448:  DATA 67,0D
0244A:  DATA 0A,00
0244C:  DATA 53,69
0244E:  DATA 4F,34
02450:  DATA 2C,25
02452:  DATA 31,2E
02454:  DATA 35,67
02456:  DATA 2C,25
02458:  DATA 31,2E
0245A:  DATA 35,67
0245C:  DATA 0D,0A
0245E:  DATA 00,00
02460:  DATA 4E,4F
02462:  DATA 33,28
02464:  DATA 6D,29
02466:  DATA 3A,00
02468:  DATA 4E,4F
0246A:  DATA 33,28
0246C:  DATA 63,29
0246E:  DATA 3A,00
02470:  DATA 50,4F
02472:  DATA 34,28
02474:  DATA 6D,29
02476:  DATA 3A,00
02478:  DATA 50,4F
0247A:  DATA 34,28
0247C:  DATA 63,29
0247E:  DATA 3A,00
02480:  DATA 4E,48
02482:  DATA 34,28
02484:  DATA 6D,29
02486:  DATA 3A,00
02488:  DATA 4E,48
0248A:  DATA 34,28
0248C:  DATA 63,29
0248E:  DATA 3A,00
02490:  DATA 53,69
02492:  DATA 4F,34
02494:  DATA 28,6D
02496:  DATA 29,3A
02498:  DATA 00,00
0249A:  DATA 53,69
0249C:  DATA 4F,34
0249E:  DATA 28,63
024A0:  DATA 29,3A
024A2:  DATA 00,00
024A4:  DATA 41,72
024A6:  DATA 65,20
024A8:  DATA 79,6F
024AA:  DATA 75,20
024AC:  DATA 73,75
024AE:  DATA 72,65
024B0:  DATA 20,79
024B2:  DATA 6F,75
024B4:  DATA 20,77
024B6:  DATA 61,6E
024B8:  DATA 74,20
024BA:  DATA 74,6F
024BC:  DATA 20,65
024BE:  DATA 72,61
024C0:  DATA 73,65
024C2:  DATA 20,74
024C4:  DATA 68,65
024C6:  DATA 20,72
024C8:  DATA 61,77
024CA:  DATA 20,64
024CC:  DATA 61,74
024CE:  DATA 61,20
024D0:  DATA 66,69
024D2:  DATA 6C,65
024D4:  DATA 3F,20
024D6:  DATA 59,20
024D8:  DATA 6F,72
024DA:  DATA 20,4E
024DC:  DATA 21,0D
024DE:  DATA 0A,00
024E0:  DATA 46,69
024E2:  DATA 6C,65
024E4:  DATA 20,64
024E6:  DATA 65,6C
024E8:  DATA 65,74
024EA:  DATA 65,64
024EC:  DATA 21,0A
024EE:  DATA 0D,00
024F0:  DATA 4F,70
024F2:  DATA 65,72
024F4:  DATA 61,74
024F6:  DATA 69,6F
024F8:  DATA 6E,20
024FA:  DATA 63,61
024FC:  DATA 6E,63
024FE:  DATA 65,6C
02500:  DATA 65,64
02502:  DATA 21,0D
02504:  DATA 0A,00
02506:  DATA 41,72
02508:  DATA 65,20
0250A:  DATA 79,6F
0250C:  DATA 75,20
0250E:  DATA 73,75
02510:  DATA 72,65
02512:  DATA 20,79
02514:  DATA 6F,75
02516:  DATA 20,77
02518:  DATA 61,6E
0251A:  DATA 74,20
0251C:  DATA 74,6F
0251E:  DATA 20,65
02520:  DATA 72,61
02522:  DATA 73,65
02524:  DATA 20,74
02526:  DATA 68,65
02528:  DATA 20,63
0252A:  DATA 61,6C
0252C:  DATA 63,75
0252E:  DATA 6C,61
02530:  DATA 74,65
02532:  DATA 64,20
02534:  DATA 64,61
02536:  DATA 74,61
02538:  DATA 20,66
0253A:  DATA 69,6C
0253C:  DATA 65,3F
0253E:  DATA 20,59
02540:  DATA 20,6F
02542:  DATA 72,20
02544:  DATA 4E,21
02546:  DATA 0D,0A
02548:  DATA 00,00
0254A:  DATA 46,69
0254C:  DATA 6C,65
0254E:  DATA 20,64
02550:  DATA 65,6C
02552:  DATA 65,74
02554:  DATA 65,64
02556:  DATA 21,0A
02558:  DATA 0D,00
0255A:  DATA 4F,70
0255C:  DATA 65,72
0255E:  DATA 61,74
02560:  DATA 69,6F
02562:  DATA 6E,20
02564:  DATA 63,61
02566:  DATA 6E,63
02568:  DATA 65,6C
0256A:  DATA 65,64
0256C:  DATA 21,0D
0256E:  DATA 0A,00
02570:  DATA 40,49
02572:  DATA 44,23
02574:  DATA 25,4C
02576:  DATA 75,20
02578:  DATA 49,25
0257A:  DATA 4C,75
0257C:  DATA 20,4E
0257E:  DATA 25,4C
02580:  DATA 75,2F
02582:  DATA 25,4C
02584:  DATA 75,20
02586:  DATA 58,25
02588:  DATA 4C,75
0258A:  DATA 20,55
0258C:  DATA 25,75
0258E:  DATA 20,25
02590:  DATA 34,2E
02592:  DATA 32,77
02594:  DATA 56,0D
02596:  DATA 0A,00
02598:  DATA 40,4D
0259A:  DATA 4F,54
0259C:  DATA 3A,56
0259E:  DATA 41,4C
025A0:  DATA 3D,25
025A2:  DATA 4C,75
025A4:  DATA 20,53
025A6:  DATA 59,52
025A8:  DATA 3D,25
025AA:  DATA 4C,64
025AC:  DATA 0D,0A
025AE:  DATA 00,00
025B0:  DATA 40,50
025B2:  DATA 57,52
025B4:  DATA 3A,25
025B6:  DATA 30,32
025B8:  DATA 75,2F
025BA:  DATA 25,30
025BC:  DATA 32,75
025BE:  DATA 2F,25
025C0:  DATA 30,32
025C2:  DATA 75,20
025C4:  DATA 25,30
025C6:  DATA 32,75
025C8:  DATA 3A,25
025CA:  DATA 30,32
025CC:  DATA 75,3A
025CE:  DATA 25,30
025D0:  DATA 32,75
025D2:  DATA 0D,0A
025D4:  DATA 00,00
025D6:  DATA 40,50
025D8:  DATA 57,52
025DA:  DATA 3A,25
025DC:  DATA 30,32
025DE:  DATA 75,2F
025E0:  DATA 25,30
025E2:  DATA 32,75
025E4:  DATA 2F,25
025E6:  DATA 30,32
025E8:  DATA 75,20
025EA:  DATA 25,30
025EC:  DATA 32,75
025EE:  DATA 3A,25
025F0:  DATA 30,32
025F2:  DATA 75,3A
025F4:  DATA 25,30
025F6:  DATA 32,75
025F8:  DATA 0D,0A
025FA:  DATA 00,00
025FC:  DATA 41,25
025FE:  DATA 4C,75
02600:  DATA 20,49
02602:  DATA 25,4C
02604:  DATA 75,20
02606:  DATA 4C,25
02608:  DATA 4C,75
0260A:  DATA 20,51
0260C:  DATA 25,4C
0260E:  DATA 75,20
02610:  DATA 53,25
02612:  DATA 4C,75
02614:  DATA 20,25
02616:  DATA 34,2E
02618:  DATA 32,77
0261A:  DATA 56,0D
0261C:  DATA 0A,00
0261E:  DATA 40,4D
02620:  DATA 4F,54
02622:  DATA 3A,56
02624:  DATA 41,4C
02626:  DATA 3D,25
02628:  DATA 4C,75
0262A:  DATA 20,53
0262C:  DATA 59,52
0262E:  DATA 3D,25
02630:  DATA 4C,64
02632:  DATA 0D,0A
02634:  DATA 00,00
02636:  DATA 40,50
02638:  DATA 57,52
0263A:  DATA 3A,25
0263C:  DATA 30,32
0263E:  DATA 75,2F
02640:  DATA 25,30
02642:  DATA 32,75
02644:  DATA 2F,25
02646:  DATA 30,32
02648:  DATA 75,20
0264A:  DATA 25,30
0264C:  DATA 32,75
0264E:  DATA 3A,25
02650:  DATA 30,32
02652:  DATA 75,3A
02654:  DATA 25,30
02656:  DATA 32,75
02658:  DATA 0D,0A
0265A:  DATA 00,00
0265C:  DATA 49,25
0265E:  DATA 4C,75
02660:  DATA 20,4E
02662:  DATA 25,4C
02664:  DATA 75,2F
02666:  DATA 25,4C
02668:  DATA 75,20
0266A:  DATA 50,25
0266C:  DATA 4C,75
0266E:  DATA 20,25
02670:  DATA 34,2E
02672:  DATA 32,77
02674:  DATA 56,0D
02676:  DATA 0A,00
02678:  DATA 40,4D
0267A:  DATA 4F,54
0267C:  DATA 3A,53
0267E:  DATA 59,52
02680:  DATA 3D,25
02682:  DATA 4C,64
02684:  DATA 0D,0A
02686:  DATA 00,00
02688:  DATA 40,50
0268A:  DATA 57,52
0268C:  DATA 3A,25
0268E:  DATA 30,32
02690:  DATA 75,2F
02692:  DATA 25,30
02694:  DATA 32,75
02696:  DATA 2F,25
02698:  DATA 30,32
0269A:  DATA 75,20
0269C:  DATA 25,30
0269E:  DATA 32,75
026A0:  DATA 3A,25
026A2:  DATA 30,32
026A4:  DATA 75,3A
026A6:  DATA 25,30
026A8:  DATA 32,75
026AA:  DATA 0D,0A
026AC:  DATA 00,00
026AE:  DATA 40,53
026B0:  DATA 4D,50
026B2:  DATA 20,25
026B4:  DATA 30,34
026B6:  DATA 4C,75
026B8:  DATA 0D,0A
026BA:  DATA 00,00
026BC:  DATA 40,53
026BE:  DATA 4D,50
026C0:  DATA 20,25
026C2:  DATA 30,34
026C4:  DATA 4C,75
026C6:  DATA 0D,0A
026C8:  DATA 00,00
026CA:  DATA 45,6E
026CC:  DATA 74,65
026CE:  DATA 72,20
026D0:  DATA 64,61
026D2:  DATA 74,65
026D4:  DATA 20,66
026D6:  DATA 6F,72
026D8:  DATA 6D,61
026DA:  DATA 74,20
026DC:  DATA 30,3D
026DE:  DATA 4D,4D
026E0:  DATA 2F,44
026E2:  DATA 44,2F
026E4:  DATA 59,59
026E6:  DATA 20,20
026E8:  DATA 31,3D
026EA:  DATA 44,44
026EC:  DATA 2F,4D
026EE:  DATA 4D,2F
026F0:  DATA 59,59
026F2:  DATA 0D,0A
026F4:  DATA 00,00
026F6:  DATA 40,4F
026F8:  DATA 4B,21
026FA:  DATA 0D,0A
026FC:  DATA 20,00
026FE:  DATA 40,45
02700:  DATA 52,52
02702:  DATA 0D,0A
02704:  DATA 00,00
02706:  DATA 40,52
02708:  DATA 55,4E
0270A:  DATA 0D,0A
0270C:  DATA 00,00
0270E:  DATA 5B,6D
02710:  DATA 6F,74
02712:  DATA 6F,72
02714:  DATA 3A,31
02716:  DATA 5D,0D
02718:  DATA 0A,00
0271A:  DATA 5B,6D
0271C:  DATA 6F,74
0271E:  DATA 6F,72
02720:  DATA 3A,32
02722:  DATA 5D,0D
02724:  DATA 0A,00
02726:  DATA 2C,45
02728:  DATA 43,4F
0272A:  DATA 20,6D
0272C:  DATA 6F,64
0272E:  DATA 65,20
02730:  DATA 73,65
02732:  DATA 74,0D
02734:  DATA 0A,00
02736:  DATA 2C,57
02738:  DATA 4D,53
0273A:  DATA 2D,34
0273C:  DATA 2D,53
0273E:  DATA 44,20
02740:  DATA 6D,6F
02742:  DATA 64,65
02744:  DATA 20,73
02746:  DATA 65,74
02748:  DATA 0D,0A
0274A:  DATA 00,00
0274C:  DATA 2C,41
0274E:  DATA 57,53
02750:  DATA 20,6D
02752:  DATA 6F,64
02754:  DATA 65,20
02756:  DATA 73,65
02758:  DATA 74,0D
0275A:  DATA 0A,00
0275C:  DATA 2C,57
0275E:  DATA 4D,53
02760:  DATA 2D,34
02762:  DATA 2D,51
02764:  DATA 45,20
02766:  DATA 6D,6F
02768:  DATA 64,65
0276A:  DATA 20,73
0276C:  DATA 65,74
0276E:  DATA 0D,0A
02770:  DATA 00,00
02772:  DATA 30,37
02774:  DATA 2D,4A
02776:  DATA 75,6C
02778:  DATA 2D,31
0277A:  DATA 37,00
0277C:  DATA 31,31
0277E:  DATA 3A,33
02780:  DATA 31,3A
02782:  DATA 32,31
02784:  DATA 00,00
02786:  DATA 53,45
02788:  DATA 4E,44
0278A:  DATA 20,48
0278C:  DATA 45,58
0278E:  DATA 20,46
02790:  DATA 49,4C
02792:  DATA 45,20
02794:  DATA 28,31
02796:  DATA 39,32
02798:  DATA 30,30
0279A:  DATA 2C,4E
0279C:  DATA 38,31
0279E:  DATA 2C,58
027A0:  DATA 4F,4E
027A2:  DATA 2D,58
027A4:  DATA 4F,46
027A6:  DATA 46,29
027A8:  DATA 0D,0A
027AA:  DATA 00,00
027AC:  DATA 40,4F
027AE:  DATA 4B,21
027B0:  DATA 20,00
027B2:  DATA 40,41
027B4:  DATA 52,47
027B6:  DATA 20,00
027B8:  DATA 40,4F
027BA:  DATA 4B,21
027BC:  DATA 20,00
027BE:  DATA 40,41
027C0:  DATA 52,47
027C2:  DATA 20,00
027C4:  DATA 0D,0A
027C6:  DATA 40,49
027C8:  DATA 4E,56
027CA:  DATA 00,00
027CC:  DATA 0D,0A
027CE:  DATA 40,4F
027D0:  DATA 4B,21
027D2:  DATA 20,00
027D4:  DATA 40,49
027D6:  DATA 4E,56
027D8:  DATA 00,00
027DA:  DATA 40,43
027DC:  DATA 4D,44
027DE:  DATA 00,00
027E0:  DATA 2C,63
027E2:  DATA 6F,6D
027E4:  DATA 6D,61
027E6:  DATA 6E,64
027E8:  DATA 20,70
027EA:  DATA 72,6F
027EC:  DATA 6D,70
027EE:  DATA 74,0D
027F0:  DATA 0A,00
027F2:  DATA 20,20
027F4:  DATA 20,20
027F6:  DATA 20,20
027F8:  DATA 20,20
027FA:  DATA 20,20
027FC:  DATA 20,20
027FE:  DATA 20,20
02800:  DATA 20,20
02802:  DATA 20,20
02804:  DATA 20,20
02806:  DATA 20,20
02808:  DATA 20,20
0280A:  DATA 20,20
0280C:  DATA 20,20
0280E:  DATA 20,20
02810:  DATA 20,20
02812:  DATA 20,20
02814:  DATA 20,20
02816:  DATA 20,20
02818:  DATA 20,00
0281A:  DATA 0D,0A
0281C:  DATA 40,41
0281E:  DATA 52,47
02820:  DATA 20,00
02822:  DATA 40,43
02824:  DATA 4D,44
02826:  DATA 00,00
02828:  DATA 2C,63
0282A:  DATA 6F,6D
0282C:  DATA 6D,61
0282E:  DATA 6E,64
02830:  DATA 20,70
02832:  DATA 72,6F
02834:  DATA 6D,70
02836:  DATA 74,0D
02838:  DATA 0A,00
0283A:  DATA 40,53
0283C:  DATA 44,3D
0283E:  DATA 25,4C
02840:  DATA 75,0D
02842:  DATA 0A,00
02844:  DATA 40,4D
02846:  DATA 43,31
02848:  DATA 2C,25
0284A:  DATA 4C,75
0284C:  DATA 2C,25
0284E:  DATA 4C,64
02850:  DATA 0D,0A
02852:  DATA 00,00
02854:  DATA 40,4D
02856:  DATA 43,32
02858:  DATA 2C,25
0285A:  DATA 4C,75
0285C:  DATA 2C,25
0285E:  DATA 4C,64
02860:  DATA 0D,0A
02862:  DATA 00,00
02864:  DATA 50,72
02866:  DATA 65,73
02868:  DATA 73,20
0286A:  DATA 61,6E
0286C:  DATA 64,20
0286E:  DATA 68,6F
02870:  DATA 6C,64
02872:  DATA 20,74
02874:  DATA 68,65
02876:  DATA 20,45
02878:  DATA 73,63
0287A:  DATA 20,6B
0287C:  DATA 65,79
0287E:  DATA 20,74
02880:  DATA 6F,20
02882:  DATA 72,65
02884:  DATA 74,75
02886:  DATA 72,6E
02888:  DATA 20,74
0288A:  DATA 6F,20
0288C:  DATA 43,6F
0288E:  DATA 6D,6D
02890:  DATA 61,6E
02892:  DATA 64,20
02894:  DATA 4D,6F
02896:  DATA 64,65
02898:  DATA 0D,0A
0289A:  DATA 00,00
0289C:  DATA 52,65
0289E:  DATA 74,75
028A0:  DATA 72,6E
028A2:  DATA 69,6E
028A4:  DATA 67,20
028A6:  DATA 74,6F
028A8:  DATA 20,4C
028AA:  DATA 6F,67
028AC:  DATA 67,69
028AE:  DATA 6E,67
028B0:  DATA 20,4D
028B2:  DATA 6F,64
028B4:  DATA 65,0D
028B6:  DATA 0A,00
*
02CC8:  CLRF   01
02CCA:  CLRF   02
02CCC:  CLRF   00
02CCE:  CLRF   03
02CD0:  MOVLB  8
02CD2:  MOVF   xDE,W
02CD4:  BNZ   2CDA
02CD6:  MOVF   xDD,W
02CD8:  BZ    2D0A
02CDA:  MOVLW  10
02CDC:  MOVWF  xDF
02CDE:  BCF    FD8.0
02CE0:  RLCF   xDB,F
02CE2:  RLCF   xDC,F
02CE4:  RLCF   00,F
02CE6:  RLCF   03,F
02CE8:  MOVF   xDE,W
02CEA:  SUBWF  03,W
02CEC:  BNZ   2CF2
02CEE:  MOVF   xDD,W
02CF0:  SUBWF  00,W
02CF2:  BNC   2D02
02CF4:  MOVF   xDD,W
02CF6:  SUBWF  00,F
02CF8:  BTFSS  FD8.0
02CFA:  DECF   03,F
02CFC:  MOVF   xDE,W
02CFE:  SUBWF  03,F
02D00:  BSF    FD8.0
02D02:  RLCF   01,F
02D04:  RLCF   02,F
02D06:  DECFSZ xDF,F
02D08:  BRA    2CDE
02D0A:  MOVLB  0
02D0C:  RETURN 0
*
0351A:  TSTFSZ 01
0351C:  BRA    3524
0351E:  TSTFSZ 02
03520:  BRA    3526
03522:  BRA    3532
03524:  INCF   02,F
03526:  MOVFF  00,FEE
0352A:  DECFSZ 01,F
0352C:  BRA    3526
0352E:  DECFSZ 02,F
03530:  BRA    3526
03532:  RETURN 0
*
03604:  MOVLB  9
03606:  BTFSC  xED.7
03608:  BRA    362A
0360A:  MOVLW  0F
0360C:  MOVWF  00
0360E:  SWAPF  xEC,W
03610:  ANDWF  00,F
03612:  MOVLW  0A
03614:  SUBWF  00,W
03616:  BC    361E
03618:  MOVLW  30
0361A:  ADDWF  00,F
0361C:  BRA    3622
0361E:  MOVF   xED,W
03620:  ADDWF  00,F
03622:  MOVF   00,W
03624:  BTFSS  F9E.4
03626:  BRA    3624
03628:  MOVWF  FAD
0362A:  MOVLW  0F
0362C:  ANDWF  xEC,F
0362E:  MOVLW  0A
03630:  SUBWF  xEC,W
03632:  BC    3638
03634:  MOVLW  30
03636:  BRA    363C
03638:  BCF    xED.7
0363A:  MOVF   xED,W
0363C:  ADDWF  xEC,F
0363E:  MOVF   xEC,W
03640:  BTFSS  F9E.4
03642:  BRA    3640
03644:  MOVWF  FAD
03646:  MOVLB  0
03648:  RETURN 0
*
047E4:  MOVLB  9
047E6:  CLRF   xFE
047E8:  CLRF   xFF
047EA:  MOVLW  01
047EC:  MOVLB  A
047EE:  MOVWF  x00
047F0:  CLRF   FDA
047F2:  CLRF   FD9
047F4:  MOVLW  09
047F6:  MOVWF  x03
047F8:  MOVLW  F6
047FA:  MOVWF  x02
047FC:  MOVLW  09
047FE:  MOVWF  FEA
04800:  MOVLW  FA
04802:  MOVWF  FE9
04804:  MOVFF  A03,FE2
04808:  MOVFF  A02,FE1
0480C:  MOVFF  A00,A01
04810:  BCF    FD8.0
04812:  MOVF   FE5,W
04814:  MULWF  FEE
04816:  MOVF   FF3,W
04818:  MOVLB  9
0481A:  ADDWFC xFE,F
0481C:  MOVF   FF4,W
0481E:  ADDWFC xFF,F
04820:  MOVLB  A
04822:  DECFSZ x01,F
04824:  BRA    4810
04826:  MOVFF  9FE,FDE
0482A:  MOVFF  9FF,9FE
0482E:  MOVLB  9
04830:  CLRF   xFF
04832:  BTFSC  FD8.0
04834:  INCF   xFF,F
04836:  MOVLB  A
04838:  INCF   x02,F
0483A:  BTFSC  FD8.2
0483C:  INCF   x03,F
0483E:  INCF   x00,F
04840:  MOVF   x00,W
04842:  SUBLW  05
04844:  BNZ   47FC
04846:  MOVLB  0
04848:  RETURN 0
*
05092:  MOVFF  1E,FEA
05096:  MOVFF  1D,FE9
0509A:  MOVLB  8
0509C:  MOVFF  8FF,FEF
050A0:  INCF   FE9,F
050A2:  BTFSC  FD8.2
050A4:  INCF   FEA,F
050A6:  CLRF   FEF
050A8:  INCF   1D,F
050AA:  BTFSC  FD8.2
050AC:  INCF   1E,F
050AE:  MOVLB  0
050B0:  RETURN 0
050B2:  TBLRD*+
050B4:  MOVF   FF5,F
050B6:  BZ    50D8
050B8:  MOVFF  FF6,8EB
050BC:  MOVFF  FF7,8EC
050C0:  MOVFF  FF8,8ED
050C4:  MOVFF  FF5,8FF
050C8:  RCALL  5092
050CA:  MOVFF  8EB,FF6
050CE:  MOVFF  8EC,FF7
050D2:  MOVFF  8ED,FF8
050D6:  BRA    50B2
050D8:  RETURN 0
*
05274:  MOVF   01,W
05276:  CLRF   1B
05278:  BTFSC  FF2.7
0527A:  BSF    1B.7
0527C:  BCF    FF2.7
0527E:  MOVFF  8ED,A42
05282:  MOVLW  64
05284:  MOVLB  A
05286:  MOVWF  x43
05288:  MOVLB  0
0528A:  CALL   0F6E
0528E:  BTFSC  1B.7
05290:  BSF    FF2.7
05292:  MOVFF  00,8ED
05296:  MOVF   01,W
05298:  MOVLW  30
0529A:  BNZ   52AC
0529C:  MOVLB  8
0529E:  BTFSS  xEE.1
052A0:  BRA    52C0
052A2:  BTFSC  xEE.3
052A4:  BRA    52C0
052A6:  BTFSC  xEE.4
052A8:  MOVLW  20
052AA:  BRA    52B4
052AC:  MOVLB  8
052AE:  BCF    xEE.3
052B0:  BCF    xEE.4
052B2:  BSF    xEE.0
052B4:  ADDWF  01,F
052B6:  MOVFF  01,8FF
052BA:  MOVLB  0
052BC:  RCALL  5092
052BE:  MOVLB  8
052C0:  CLRF   1B
052C2:  BTFSC  FF2.7
052C4:  BSF    1B.7
052C6:  BCF    FF2.7
052C8:  MOVFF  8ED,A42
052CC:  MOVLW  0A
052CE:  MOVLB  A
052D0:  MOVWF  x43
052D2:  MOVLB  0
052D4:  CALL   0F6E
052D8:  BTFSC  1B.7
052DA:  BSF    FF2.7
052DC:  MOVFF  00,8ED
052E0:  MOVF   01,W
052E2:  MOVLW  30
052E4:  BNZ   52F6
052E6:  MOVLB  8
052E8:  BTFSC  xEE.3
052EA:  BRA    5300
052EC:  BTFSS  xEE.0
052EE:  BRA    5300
052F0:  BTFSC  xEE.4
052F2:  MOVLW  20
052F4:  MOVLB  0
052F6:  ADDWF  01,F
052F8:  MOVFF  01,8FF
052FC:  RCALL  5092
052FE:  MOVLB  8
05300:  MOVLW  30
05302:  ADDWF  xED,F
05304:  MOVFF  8ED,8FF
05308:  MOVLB  0
0530A:  RCALL  5092
0530C:  RETURN 0
0530E:  MOVF   FE9,W
05310:  MOVLB  8
05312:  MOVWF  xF2
05314:  MOVLW  3B
05316:  MOVWF  xF9
05318:  MOVLW  9A
0531A:  MOVWF  xF8
0531C:  MOVLW  CA
0531E:  MOVWF  xF7
05320:  CLRF   xF6
05322:  MOVLW  0A
05324:  MOVWF  xF4
05326:  MOVF   xF1,W
05328:  BTFSS  FD8.2
0532A:  DECF   xF2,F
0532C:  BSF    FD8.1
0532E:  MOVLW  08
05330:  MOVWF  FEA
05332:  MOVLW  ED
05334:  MOVWF  FE9
05336:  CLRF   1B
05338:  BTFSC  FF2.7
0533A:  BSF    1B.7
0533C:  BCF    FF2.7
0533E:  MOVFF  8F0,A4F
05342:  MOVFF  8EF,A4E
05346:  MOVFF  8EE,A4D
0534A:  MOVFF  8ED,A4C
0534E:  MOVFF  8F9,A53
05352:  MOVFF  8F8,A52
05356:  MOVFF  8F7,A51
0535A:  MOVFF  8F6,A50
0535E:  MOVLB  0
05360:  CALL   104A
05364:  BTFSC  1B.7
05366:  BSF    FF2.7
05368:  MOVF   01,W
0536A:  MOVF   00,F
0536C:  BNZ   5394
0536E:  MOVLB  8
05370:  INCF   xF1,W
05372:  SUBWF  xF4,W
05374:  BTFSS  FD8.2
05376:  BRA    537C
05378:  MOVLB  0
0537A:  BRA    5394
0537C:  MOVF   xF2,W
0537E:  BZ    5398
05380:  ANDLW  0F
05382:  SUBWF  xF4,W
05384:  BZ    5388
05386:  BC    53C4
05388:  BTFSC  xF2.7
0538A:  BRA    53C4
0538C:  BTFSC  xF2.6
0538E:  BRA    5398
05390:  MOVLW  20
05392:  BRA    53B8
05394:  MOVLB  8
05396:  CLRF   xF2
05398:  MOVF   xF1,W
0539A:  SUBWF  xF4,W
0539C:  BNZ   53B6
0539E:  MOVFF  00,8F2
053A2:  MOVLW  2E
053A4:  MOVWF  xFF
053A6:  MOVLB  0
053A8:  RCALL  5092
053AA:  MOVLB  8
053AC:  MOVFF  8F2,00
053B0:  MOVLW  20
053B2:  ANDWF  xF2,F
053B4:  MOVLW  00
053B6:  MOVLW  30
053B8:  ADDWF  00,F
053BA:  MOVFF  00,8FF
053BE:  MOVLB  0
053C0:  RCALL  5092
053C2:  MOVLB  8
053C4:  BCF    FD8.1
053C6:  CLRF   1B
053C8:  BTFSC  FF2.7
053CA:  BSF    1B.7
053CC:  BCF    FF2.7
053CE:  MOVFF  8F9,A4F
053D2:  MOVFF  8F8,A4E
053D6:  MOVFF  8F7,A4D
053DA:  MOVFF  8F6,A4C
053DE:  MOVLB  A
053E0:  CLRF   x53
053E2:  CLRF   x52
053E4:  CLRF   x51
053E6:  MOVLW  0A
053E8:  MOVWF  x50
053EA:  MOVLB  0
053EC:  CALL   104A
053F0:  BTFSC  1B.7
053F2:  BSF    FF2.7
053F4:  MOVFF  03,8F9
053F8:  MOVFF  02,8F8
053FC:  MOVFF  01,8F7
05400:  MOVFF  00,8F6
05404:  MOVLB  8
05406:  DECFSZ xF4,F
05408:  BRA    532C
0540A:  MOVLB  0
0540C:  RETURN 0
*
05C8C:  MOVLB  A
05C8E:  MOVF   x10,W
05C90:  MULWF  x12
05C92:  MOVFF  FF3,01
05C96:  MOVFF  FF4,00
05C9A:  MULWF  x13
05C9C:  MOVF   FF3,W
05C9E:  ADDWF  00,F
05CA0:  MOVF   x11,W
05CA2:  MULWF  x12
05CA4:  MOVF   FF3,W
05CA6:  ADDWFC 00,W
05CA8:  MOVWF  02
05CAA:  MOVLB  0
05CAC:  RETURN 0
*
0798A:  MOVF   FEF,F
0798C:  BZ    79AE
0798E:  MOVFF  FEA,9B1
07992:  MOVFF  FE9,9B0
07996:  MOVF   FEF,W
07998:  BTFSS  F9E.4
0799A:  BRA    7998
0799C:  MOVWF  FAD
0799E:  MOVFF  9B1,FEA
079A2:  MOVFF  9B0,FE9
079A6:  INCF   FE9,F
079A8:  BTFSC  FD8.2
079AA:  INCF   FEA,F
079AC:  BRA    798A
079AE:  RETURN 0
*
08FD8:  MOVFF  FEA,8F8
08FDC:  MOVFF  FE9,8F7
08FE0:  MOVLB  8
08FE2:  BTFSS  xF1.7
08FE4:  BRA    8FF6
08FE6:  BSF    xF7.7
08FE8:  BTFSS  xF7.4
08FEA:  INCF   xF7,F
08FEC:  COMF   xF0,F
08FEE:  COMF   xF1,F
08FF0:  INCF   xF0,F
08FF2:  BTFSC  FD8.2
08FF4:  INCF   xF1,F
08FF6:  SWAPF  xF1,W
08FF8:  IORLW  F0
08FFA:  MOVWF  xF3
08FFC:  ADDWF  xF3,F
08FFE:  ADDLW  E2
09000:  MOVWF  xF4
09002:  ADDLW  32
09004:  MOVWF  xF6
09006:  MOVF   xF1,W
09008:  ANDLW  0F
0900A:  ADDWF  xF4,F
0900C:  ADDWF  xF4,F
0900E:  ADDWF  xF6,F
09010:  ADDLW  E9
09012:  MOVWF  xF5
09014:  ADDWF  xF5,F
09016:  ADDWF  xF5,F
09018:  SWAPF  xF0,W
0901A:  ANDLW  0F
0901C:  ADDWF  xF5,F
0901E:  ADDWF  xF6,F
09020:  RLCF   xF5,F
09022:  RLCF   xF6,F
09024:  COMF   xF6,F
09026:  RLCF   xF6,F
09028:  MOVF   xF0,W
0902A:  ANDLW  0F
0902C:  ADDWF  xF6,F
0902E:  RLCF   xF3,F
09030:  MOVLW  07
09032:  MOVWF  xF2
09034:  MOVLW  0A
09036:  DECF   xF5,F
09038:  ADDWF  xF6,F
0903A:  BNC   9036
0903C:  DECF   xF4,F
0903E:  ADDWF  xF5,F
09040:  BNC   903C
09042:  DECF   xF3,F
09044:  ADDWF  xF4,F
09046:  BNC   9042
09048:  DECF   xF2,F
0904A:  ADDWF  xF3,F
0904C:  BNC   9048
0904E:  MOVLW  08
09050:  MOVWF  FEA
09052:  MOVLW  F2
09054:  MOVWF  FE9
09056:  MOVLW  07
09058:  ANDWF  xF7,W
0905A:  BCF    xF7.6
0905C:  MOVF   FED,F
0905E:  ANDWF  xF7,W
09060:  BNZ   9070
09062:  BTFSC  xF7.4
09064:  MOVF   FEE,F
09066:  BTFSC  xF7.4
09068:  BRA    9070
0906A:  MOVLW  20
0906C:  MOVWF  00
0906E:  BRA    90B2
09070:  ADDWF  FE9,F
09072:  MOVLW  00
09074:  ADDWFC FEA,F
09076:  MOVF   FE9,W
09078:  SUBLW  F6
0907A:  BNZ   9084
0907C:  MOVF   FEA,W
0907E:  SUBLW  08
09080:  BNZ   9084
09082:  BSF    xF7.6
09084:  MOVF   FEF,W
09086:  MOVWF  00
09088:  BNZ   909A
0908A:  BTFSC  xF7.6
0908C:  BRA    909A
0908E:  BTFSC  xF7.4
09090:  BRA    90BA
09092:  BTFSC  xF7.3
09094:  BRA    909A
09096:  MOVLW  20
09098:  BRA    90B0
0909A:  BTFSS  xF7.7
0909C:  BRA    90AA
0909E:  MOVLW  2D
090A0:  MOVWF  00
090A2:  MOVF   FED,W
090A4:  BCF    xF7.6
090A6:  BCF    xF7.7
090A8:  BRA    90B2
090AA:  BSF    xF7.3
090AC:  BCF    xF7.4
090AE:  MOVLW  30
090B0:  ADDWF  00,F
090B2:  MOVF   00,W
090B4:  BTFSS  F9E.4
090B6:  BRA    90B4
090B8:  MOVWF  FAD
090BA:  MOVF   FEE,W
090BC:  BTFSS  xF7.6
090BE:  BRA    9076
090C0:  MOVLB  0
090C2:  RETURN 0
*
09558:  MOVF   FE9,W
0955A:  MOVLB  8
0955C:  MOVWF  xF6
0955E:  BTFSS  xF5.7
09560:  BRA    957C
09562:  DECF   xF6,F
09564:  BSF    xF6.5
09566:  COMF   xF2,F
09568:  COMF   xF3,F
0956A:  COMF   xF4,F
0956C:  COMF   xF5,F
0956E:  INCF   xF2,F
09570:  BTFSC  FD8.2
09572:  INCF   xF3,F
09574:  BTFSC  FD8.2
09576:  INCF   xF4,F
09578:  BTFSC  FD8.2
0957A:  INCF   xF5,F
0957C:  MOVLW  3B
0957E:  MOVWF  xFD
09580:  MOVLW  9A
09582:  MOVWF  xFC
09584:  MOVLW  CA
09586:  MOVWF  xFB
09588:  CLRF   xFA
0958A:  MOVLW  0A
0958C:  MOVWF  xF8
0958E:  BSF    FD8.1
09590:  MOVLW  08
09592:  MOVWF  FEA
09594:  MOVLW  F2
09596:  MOVWF  FE9
09598:  CLRF   1B
0959A:  BTFSC  FF2.7
0959C:  BSF    1B.7
0959E:  BCF    FF2.7
095A0:  MOVFF  8F5,A4F
095A4:  MOVFF  8F4,A4E
095A8:  MOVFF  8F3,A4D
095AC:  MOVFF  8F2,A4C
095B0:  MOVFF  8FD,A53
095B4:  MOVFF  8FC,A52
095B8:  MOVFF  8FB,A51
095BC:  MOVFF  8FA,A50
095C0:  MOVLB  0
095C2:  CALL   104A
095C6:  BTFSC  1B.7
095C8:  BSF    FF2.7
095CA:  MOVF   01,W
095CC:  MOVF   00,F
095CE:  BNZ   95F6
095D0:  MOVLB  8
095D2:  MOVF   xF8,W
095D4:  XORLW  01
095D6:  BTFSS  FD8.2
095D8:  BRA    95DE
095DA:  MOVLB  0
095DC:  BRA    95F6
095DE:  MOVF   xF6,W
095E0:  BZ    95FC
095E2:  ANDLW  0F
095E4:  SUBWF  xF8,W
095E6:  BZ    95EA
095E8:  BC    963A
095EA:  BTFSC  xF6.7
095EC:  BRA    963A
095EE:  BTFSC  xF6.6
095F0:  BRA    95FC
095F2:  MOVLW  20
095F4:  BRA    9630
095F6:  MOVLW  20
095F8:  MOVLB  8
095FA:  ANDWF  xF6,F
095FC:  BTFSS  xF6.5
095FE:  BRA    9614
09600:  BCF    xF6.5
09602:  MOVFF  00,8F6
09606:  MOVLW  2D
09608:  BTFSS  F9E.4
0960A:  BRA    9608
0960C:  MOVWF  FAD
0960E:  MOVFF  8F6,00
09612:  CLRF   xF6
09614:  MOVLW  30
09616:  BTFSS  xF6.5
09618:  BRA    9630
0961A:  BCF    xF6.5
0961C:  MOVFF  00,8F6
09620:  MOVLW  2D
09622:  BTFSS  F9E.4
09624:  BRA    9622
09626:  MOVWF  FAD
09628:  MOVFF  8F6,00
0962C:  CLRF   xF6
0962E:  MOVLW  30
09630:  ADDWF  00,F
09632:  MOVF   00,W
09634:  BTFSS  F9E.4
09636:  BRA    9634
09638:  MOVWF  FAD
0963A:  BCF    FD8.1
0963C:  CLRF   1B
0963E:  BTFSC  FF2.7
09640:  BSF    1B.7
09642:  BCF    FF2.7
09644:  MOVFF  8FD,A4F
09648:  MOVFF  8FC,A4E
0964C:  MOVFF  8FB,A4D
09650:  MOVFF  8FA,A4C
09654:  MOVLB  A
09656:  CLRF   x53
09658:  CLRF   x52
0965A:  CLRF   x51
0965C:  MOVLW  0A
0965E:  MOVWF  x50
09660:  MOVLB  0
09662:  CALL   104A
09666:  BTFSC  1B.7
09668:  BSF    FF2.7
0966A:  MOVFF  03,8FD
0966E:  MOVFF  02,8FC
09672:  MOVFF  01,8FB
09676:  MOVFF  00,8FA
0967A:  MOVLB  8
0967C:  DECFSZ xF8,F
0967E:  BRA    958E
09680:  MOVLB  0
09682:  RETURN 0
*
0A74C:  ADDWF  FE8,W
0A74E:  CLRF   FF7
0A750:  RLCF   FF7,F
0A752:  ADDLW  6D
0A754:  MOVWF  FF6
0A756:  MOVLW  A7
0A758:  ADDWFC FF7,F
0A75A:  MOVLW  00
0A75C:  MOVWF  FF8
0A75E:  MOVWF  FFB
0A760:  TBLRD*-
0A762:  MOVF   FF5,W
0A764:  MOVWF  FFA
0A766:  TBLRD*
0A768:  MOVF   FF5,W
0A76A:  MOVWF  FF9
0A76C:  DATA A8,A0
0A76E:  DATA C8,A0
0A770:  DATA F0,A0
0A772:  DATA 20,A1
0A774:  DATA 48,A1
*
0AAC0:  TBLRD*+
0AAC2:  MOVFF  FF6,8EC
0AAC6:  MOVFF  FF7,8ED
0AACA:  MOVFF  FF8,8EE
0AACE:  MOVFF  FF5,8FF
0AAD2:  CALL   5092
0AAD6:  MOVFF  8EC,FF6
0AADA:  MOVFF  8ED,FF7
0AADE:  MOVFF  8EE,FF8
0AAE2:  MOVLB  8
0AAE4:  DECFSZ xEB,F
0AAE6:  BRA    AAEA
0AAE8:  BRA    AAEE
0AAEA:  MOVLB  0
0AAEC:  BRA    AAC0
0AAEE:  MOVLB  0
0AAF0:  RETURN 0
0AAF2:  MOVFF  FEA,8FE
0AAF6:  MOVFF  FE9,8FD
0AAFA:  MOVLB  8
0AAFC:  SWAPF  xF7,W
0AAFE:  IORLW  F0
0AB00:  MOVWF  xF9
0AB02:  ADDWF  xF9,F
0AB04:  ADDLW  E2
0AB06:  MOVWF  xFA
0AB08:  ADDLW  32
0AB0A:  MOVWF  xFC
0AB0C:  MOVF   xF7,W
0AB0E:  ANDLW  0F
0AB10:  ADDWF  xFA,F
0AB12:  ADDWF  xFA,F
0AB14:  ADDWF  xFC,F
0AB16:  ADDLW  E9
0AB18:  MOVWF  xFB
0AB1A:  ADDWF  xFB,F
0AB1C:  ADDWF  xFB,F
0AB1E:  SWAPF  xF6,W
0AB20:  ANDLW  0F
0AB22:  ADDWF  xFB,F
0AB24:  ADDWF  xFC,F
0AB26:  RLCF   xFB,F
0AB28:  RLCF   xFC,F
0AB2A:  COMF   xFC,F
0AB2C:  RLCF   xFC,F
0AB2E:  MOVF   xF6,W
0AB30:  ANDLW  0F
0AB32:  ADDWF  xFC,F
0AB34:  RLCF   xF9,F
0AB36:  MOVLW  07
0AB38:  MOVWF  xF8
0AB3A:  MOVLW  0A
0AB3C:  DECF   xFB,F
0AB3E:  ADDWF  xFC,F
0AB40:  BNC   AB3C
0AB42:  DECF   xFA,F
0AB44:  ADDWF  xFB,F
0AB46:  BNC   AB42
0AB48:  DECF   xF9,F
0AB4A:  ADDWF  xFA,F
0AB4C:  BNC   AB48
0AB4E:  DECF   xF8,F
0AB50:  ADDWF  xF9,F
0AB52:  BNC   AB4E
0AB54:  MOVLW  08
0AB56:  MOVWF  FEA
0AB58:  MOVLW  F8
0AB5A:  MOVWF  FE9
0AB5C:  MOVLW  07
0AB5E:  ANDWF  xFD,W
0AB60:  BCF    xFD.6
0AB62:  ADDWF  FE9,F
0AB64:  MOVLW  00
0AB66:  ADDWFC FEA,F
0AB68:  MOVF   FE9,W
0AB6A:  SUBLW  FC
0AB6C:  BNZ   AB76
0AB6E:  MOVF   FEA,W
0AB70:  SUBLW  08
0AB72:  BNZ   AB76
0AB74:  BSF    xFD.6
0AB76:  MOVF   FEF,W
0AB78:  MOVWF  00
0AB7A:  BNZ   AB8C
0AB7C:  BTFSC  xFD.6
0AB7E:  BRA    AB8C
0AB80:  BTFSC  xFD.4
0AB82:  BRA    ABB0
0AB84:  BTFSC  xFD.3
0AB86:  BRA    AB8C
0AB88:  MOVLW  20
0AB8A:  BRA    AB92
0AB8C:  BSF    xFD.3
0AB8E:  BCF    xFD.4
0AB90:  MOVLW  30
0AB92:  ADDWF  00,F
0AB94:  MOVFF  FEA,8F7
0AB98:  MOVFF  FE9,8F6
0AB9C:  MOVFF  00,8FF
0ABA0:  MOVLB  0
0ABA2:  CALL   5092
0ABA6:  MOVFF  8F7,FEA
0ABAA:  MOVFF  8F6,FE9
0ABAE:  MOVLB  8
0ABB0:  MOVF   FEE,W
0ABB2:  BTFSS  xFD.6
0ABB4:  BRA    AB68
0ABB6:  MOVLB  0
0ABB8:  RETURN 0
*
0ADE0:  ADDWF  FE8,W
0ADE2:  CLRF   FF7
0ADE4:  RLCF   FF7,F
0ADE6:  ADDLW  01
0ADE8:  MOVWF  FF6
0ADEA:  MOVLW  AE
0ADEC:  ADDWFC FF7,F
0ADEE:  MOVLW  00
0ADF0:  MOVWF  FF8
0ADF2:  MOVWF  FFB
0ADF4:  TBLRD*-
0ADF6:  MOVF   FF5,W
0ADF8:  MOVWF  FFA
0ADFA:  TBLRD*
0ADFC:  MOVF   FF5,W
0ADFE:  MOVWF  FF9
0AE00:  DATA B4,AC
0AE02:  DATA DC,AD
0AE04:  DATA DC,AD
0AE06:  DATA 14,AC
0AE08:  DATA DC,AD
0AE0A:  DATA DC,AD
0AE0C:  DATA DC,AD
0AE0E:  DATA D8,AB
0AE10:  DATA DC,AD
0AE12:  DATA DC,AD
0AE14:  DATA DC,AD
0AE16:  DATA 2A,AD
0AE18:  DATA 50,AC
0AE1A:  DATA DC,AD
0AE1C:  DATA EE,AC
0AE1E:  DATA 84,AD
*
0AE7A:  TBLRD*+
0AE7C:  MOVF   FF5,F
0AE7E:  BZ    AEA2
0AE80:  MOVFF  FF6,885
0AE84:  MOVFF  FF7,886
0AE88:  MOVFF  FF8,887
0AE8C:  MOVF   FF5,W
0AE8E:  BTFSS  F9E.4
0AE90:  BRA    AE8E
0AE92:  MOVWF  FAD
0AE94:  MOVFF  885,FF6
0AE98:  MOVFF  886,FF7
0AE9C:  MOVFF  887,FF8
0AEA0:  BRA    AE7A
0AEA2:  RETURN 0
*
0C2B8:  MOVLB  9
0C2BA:  MOVF   x13,W
0C2BC:  BTFSC  FD8.2
0C2BE:  BRA    C3A2
0C2C0:  MOVWF  00
0C2C2:  MOVF   x17,W
0C2C4:  BTFSC  FD8.2
0C2C6:  BRA    C3A2
0C2C8:  ADDWF  00,F
0C2CA:  BNC   C2D4
0C2CC:  MOVLW  81
0C2CE:  ADDWF  00,F
0C2D0:  BC    C3A2
0C2D2:  BRA    C2DC
0C2D4:  MOVLW  7F
0C2D6:  SUBWF  00,F
0C2D8:  BNC   C3A2
0C2DA:  BZ    C3A2
0C2DC:  MOVFF  914,91B
0C2E0:  MOVF   x18,W
0C2E2:  XORWF  x1B,F
0C2E4:  BSF    x14.7
0C2E6:  BSF    x18.7
0C2E8:  MOVF   x16,W
0C2EA:  MULWF  x1A
0C2EC:  MOVFF  FF4,91D
0C2F0:  MOVF   x15,W
0C2F2:  MULWF  x19
0C2F4:  MOVFF  FF4,03
0C2F8:  MOVFF  FF3,91C
0C2FC:  MULWF  x1A
0C2FE:  MOVF   FF3,W
0C300:  ADDWF  x1D,F
0C302:  MOVF   FF4,W
0C304:  ADDWFC x1C,F
0C306:  MOVLW  00
0C308:  ADDWFC 03,F
0C30A:  MOVF   x16,W
0C30C:  MULWF  x19
0C30E:  MOVF   FF3,W
0C310:  ADDWF  x1D,F
0C312:  MOVF   FF4,W
0C314:  ADDWFC x1C,F
0C316:  MOVLW  00
0C318:  CLRF   02
0C31A:  ADDWFC 03,F
0C31C:  ADDWFC 02,F
0C31E:  MOVF   x14,W
0C320:  MULWF  x1A
0C322:  MOVF   FF3,W
0C324:  ADDWF  x1C,F
0C326:  MOVF   FF4,W
0C328:  ADDWFC 03,F
0C32A:  MOVLW  00
0C32C:  ADDWFC 02,F
0C32E:  MOVF   x14,W
0C330:  MULWF  x19
0C332:  MOVF   FF3,W
0C334:  ADDWF  03,F
0C336:  MOVF   FF4,W
0C338:  ADDWFC 02,F
0C33A:  MOVLW  00
0C33C:  CLRF   01
0C33E:  ADDWFC 01,F
0C340:  MOVF   x16,W
0C342:  MULWF  x18
0C344:  MOVF   FF3,W
0C346:  ADDWF  x1C,F
0C348:  MOVF   FF4,W
0C34A:  ADDWFC 03,F
0C34C:  MOVLW  00
0C34E:  ADDWFC 02,F
0C350:  ADDWFC 01,F
0C352:  MOVF   x15,W
0C354:  MULWF  x18
0C356:  MOVF   FF3,W
0C358:  ADDWF  03,F
0C35A:  MOVF   FF4,W
0C35C:  ADDWFC 02,F
0C35E:  MOVLW  00
0C360:  ADDWFC 01,F
0C362:  MOVF   x14,W
0C364:  MULWF  x18
0C366:  MOVF   FF3,W
0C368:  ADDWF  02,F
0C36A:  MOVF   FF4,W
0C36C:  ADDWFC 01,F
0C36E:  INCF   00,F
0C370:  BTFSC  01.7
0C372:  BRA    C37E
0C374:  RLCF   x1C,F
0C376:  RLCF   03,F
0C378:  RLCF   02,F
0C37A:  RLCF   01,F
0C37C:  DECF   00,F
0C37E:  MOVLW  00
0C380:  BTFSS  x1C.7
0C382:  BRA    C398
0C384:  INCF   03,F
0C386:  ADDWFC 02,F
0C388:  ADDWFC 01,F
0C38A:  MOVF   01,W
0C38C:  BNZ   C398
0C38E:  MOVF   02,W
0C390:  BNZ   C398
0C392:  MOVF   03,W
0C394:  BNZ   C398
0C396:  INCF   00,F
0C398:  BTFSC  x1B.7
0C39A:  BSF    01.7
0C39C:  BTFSS  x1B.7
0C39E:  BCF    01.7
0C3A0:  BRA    C3AA
0C3A2:  CLRF   00
0C3A4:  CLRF   01
0C3A6:  CLRF   02
0C3A8:  CLRF   03
0C3AA:  MOVLB  0
0C3AC:  RETURN 0
0C3AE:  MOVLW  80
0C3B0:  BTFSS  FD8.1
0C3B2:  BRA    C3B8
0C3B4:  MOVLB  9
0C3B6:  XORWF  x1C,F
0C3B8:  MOVLB  9
0C3BA:  CLRF   x21
0C3BC:  CLRF   x22
0C3BE:  MOVFF  918,920
0C3C2:  MOVF   x1C,W
0C3C4:  XORWF  x20,F
0C3C6:  MOVF   x17,W
0C3C8:  BTFSC  FD8.2
0C3CA:  BRA    C58A
0C3CC:  MOVWF  x1F
0C3CE:  MOVWF  00
0C3D0:  MOVF   x1B,W
0C3D2:  BTFSC  FD8.2
0C3D4:  BRA    C59C
0C3D6:  SUBWF  x1F,F
0C3D8:  BTFSC  FD8.2
0C3DA:  BRA    C4E2
0C3DC:  BNC   C45A
0C3DE:  MOVFF  91C,925
0C3E2:  BSF    x25.7
0C3E4:  MOVFF  91D,924
0C3E8:  MOVFF  91E,923
0C3EC:  CLRF   x22
0C3EE:  BCF    FD8.0
0C3F0:  RRCF   x25,F
0C3F2:  RRCF   x24,F
0C3F4:  RRCF   x23,F
0C3F6:  RRCF   x22,F
0C3F8:  DECFSZ x1F,F
0C3FA:  BRA    C3EC
0C3FC:  BTFSS  x20.7
0C3FE:  BRA    C406
0C400:  BSF    x21.0
0C402:  BRA    C5C4
0C404:  BCF    x21.0
0C406:  BCF    x1F.0
0C408:  BSF    x21.4
0C40A:  MOVLW  09
0C40C:  MOVWF  FEA
0C40E:  MOVLW  1A
0C410:  MOVWF  FE9
0C412:  BRA    C5EA
0C414:  BCF    x21.4
0C416:  BTFSC  x20.7
0C418:  BRA    C42E
0C41A:  BTFSS  x1F.0
0C41C:  BRA    C444
0C41E:  RRCF   x25,F
0C420:  RRCF   x24,F
0C422:  RRCF   x23,F
0C424:  RRCF   x22,F
0C426:  INCF   00,F
0C428:  BTFSC  FD8.2
0C42A:  BRA    C5BA
0C42C:  BRA    C444
0C42E:  BTFSC  x25.7
0C430:  BRA    C44A
0C432:  BCF    FD8.0
0C434:  RLCF   x22,F
0C436:  RLCF   x23,F
0C438:  RLCF   x24,F
0C43A:  RLCF   x25,F
0C43C:  DECF   00,F
0C43E:  BTFSC  FD8.2
0C440:  BRA    C5BA
0C442:  BRA    C42E
0C444:  BSF    x21.6
0C446:  BRA    C522
0C448:  BCF    x21.6
0C44A:  MOVFF  918,920
0C44E:  BTFSS  x18.7
0C450:  BRA    C456
0C452:  BSF    x25.7
0C454:  BRA    C5AC
0C456:  BCF    x25.7
0C458:  BRA    C5AC
0C45A:  MOVFF  91B,91F
0C45E:  MOVFF  91B,00
0C462:  MOVF   x17,W
0C464:  SUBWF  x1F,F
0C466:  MOVFF  918,925
0C46A:  BSF    x25.7
0C46C:  MOVFF  919,924
0C470:  MOVFF  91A,923
0C474:  CLRF   x22
0C476:  BCF    FD8.0
0C478:  RRCF   x25,F
0C47A:  RRCF   x24,F
0C47C:  RRCF   x23,F
0C47E:  RRCF   x22,F
0C480:  DECFSZ x1F,F
0C482:  BRA    C474
0C484:  BTFSS  x20.7
0C486:  BRA    C48E
0C488:  BSF    x21.1
0C48A:  BRA    C5C4
0C48C:  BCF    x21.1
0C48E:  BCF    x1F.0
0C490:  BSF    x21.5
0C492:  MOVLW  09
0C494:  MOVWF  FEA
0C496:  MOVLW  1E
0C498:  MOVWF  FE9
0C49A:  BRA    C5EA
0C49C:  BCF    x21.5
0C49E:  BTFSC  x20.7
0C4A0:  BRA    C4B6
0C4A2:  BTFSS  x1F.0
0C4A4:  BRA    C4CC
0C4A6:  RRCF   x25,F
0C4A8:  RRCF   x24,F
0C4AA:  RRCF   x23,F
0C4AC:  RRCF   x22,F
0C4AE:  INCF   00,F
0C4B0:  BTFSC  FD8.2
0C4B2:  BRA    C5BA
0C4B4:  BRA    C4CC
0C4B6:  BTFSC  x25.7
0C4B8:  BRA    C4D2
0C4BA:  BCF    FD8.0
0C4BC:  RLCF   x22,F
0C4BE:  RLCF   x23,F
0C4C0:  RLCF   x24,F
0C4C2:  RLCF   x25,F
0C4C4:  DECF   00,F
0C4C6:  BTFSC  FD8.2
0C4C8:  BRA    C5BA
0C4CA:  BRA    C4B6
0C4CC:  BSF    x21.7
0C4CE:  BRA    C522
0C4D0:  BCF    x21.7
0C4D2:  MOVFF  91C,920
0C4D6:  BTFSS  x1C.7
0C4D8:  BRA    C4DE
0C4DA:  BSF    x25.7
0C4DC:  BRA    C5AC
0C4DE:  BCF    x25.7
0C4E0:  BRA    C5AC
0C4E2:  MOVFF  91C,925
0C4E6:  BSF    x25.7
0C4E8:  MOVFF  91D,924
0C4EC:  MOVFF  91E,923
0C4F0:  BTFSS  x20.7
0C4F2:  BRA    C4FC
0C4F4:  BCF    x25.7
0C4F6:  BSF    x21.2
0C4F8:  BRA    C5C4
0C4FA:  BCF    x21.2
0C4FC:  CLRF   x22
0C4FE:  BCF    x1F.0
0C500:  MOVLW  09
0C502:  MOVWF  FEA
0C504:  MOVLW  1A
0C506:  MOVWF  FE9
0C508:  BRA    C5EA
0C50A:  BTFSC  x20.7
0C50C:  BRA    C546
0C50E:  MOVFF  918,920
0C512:  BTFSS  x1F.0
0C514:  BRA    C522
0C516:  RRCF   x25,F
0C518:  RRCF   x24,F
0C51A:  RRCF   x23,F
0C51C:  RRCF   x22,F
0C51E:  INCF   00,F
0C520:  BZ    C5BA
0C522:  BTFSS  x22.7
0C524:  BRA    C53C
0C526:  INCF   x23,F
0C528:  BNZ   C53C
0C52A:  INCF   x24,F
0C52C:  BNZ   C53C
0C52E:  INCF   x25,F
0C530:  BNZ   C53C
0C532:  RRCF   x25,F
0C534:  RRCF   x24,F
0C536:  RRCF   x23,F
0C538:  INCF   00,F
0C53A:  BZ    C5BA
0C53C:  BTFSC  x21.6
0C53E:  BRA    C448
0C540:  BTFSC  x21.7
0C542:  BRA    C4D0
0C544:  BRA    C57E
0C546:  MOVLW  80
0C548:  XORWF  x25,F
0C54A:  BTFSS  x25.7
0C54C:  BRA    C556
0C54E:  BRA    C5C4
0C550:  MOVFF  91C,920
0C554:  BRA    C56A
0C556:  MOVFF  918,920
0C55A:  MOVF   x25,F
0C55C:  BNZ   C56A
0C55E:  MOVF   x24,F
0C560:  BNZ   C56A
0C562:  MOVF   x23,F
0C564:  BNZ   C56A
0C566:  CLRF   00
0C568:  BRA    C5AC
0C56A:  BTFSC  x25.7
0C56C:  BRA    C57E
0C56E:  BCF    FD8.0
0C570:  RLCF   x22,F
0C572:  RLCF   x23,F
0C574:  RLCF   x24,F
0C576:  RLCF   x25,F
0C578:  DECFSZ 00,F
0C57A:  BRA    C56A
0C57C:  BRA    C5BA
0C57E:  BTFSS  x20.7
0C580:  BRA    C586
0C582:  BSF    x25.7
0C584:  BRA    C5AC
0C586:  BCF    x25.7
0C588:  BRA    C5AC
0C58A:  MOVFF  91B,00
0C58E:  MOVFF  91C,925
0C592:  MOVFF  91D,924
0C596:  MOVFF  91E,923
0C59A:  BRA    C5AC
0C59C:  MOVFF  917,00
0C5A0:  MOVFF  918,925
0C5A4:  MOVFF  919,924
0C5A8:  MOVFF  91A,923
0C5AC:  MOVFF  925,01
0C5B0:  MOVFF  924,02
0C5B4:  MOVFF  923,03
0C5B8:  BRA    C622
0C5BA:  CLRF   00
0C5BC:  CLRF   01
0C5BE:  CLRF   02
0C5C0:  CLRF   03
0C5C2:  BRA    C622
0C5C4:  CLRF   x22
0C5C6:  COMF   x23,F
0C5C8:  COMF   x24,F
0C5CA:  COMF   x25,F
0C5CC:  COMF   x22,F
0C5CE:  INCF   x22,F
0C5D0:  BNZ   C5DC
0C5D2:  INCF   x23,F
0C5D4:  BNZ   C5DC
0C5D6:  INCF   x24,F
0C5D8:  BNZ   C5DC
0C5DA:  INCF   x25,F
0C5DC:  BTFSC  x21.0
0C5DE:  BRA    C404
0C5E0:  BTFSC  x21.1
0C5E2:  BRA    C48C
0C5E4:  BTFSC  x21.2
0C5E6:  BRA    C4FA
0C5E8:  BRA    C550
0C5EA:  MOVF   FEF,W
0C5EC:  ADDWF  x23,F
0C5EE:  BNC   C5FA
0C5F0:  INCF   x24,F
0C5F2:  BNZ   C5FA
0C5F4:  INCF   x25,F
0C5F6:  BTFSC  FD8.2
0C5F8:  BSF    x1F.0
0C5FA:  MOVF   FED,F
0C5FC:  MOVF   FEF,W
0C5FE:  ADDWF  x24,F
0C600:  BNC   C608
0C602:  INCF   x25,F
0C604:  BTFSC  FD8.2
0C606:  BSF    x1F.0
0C608:  MOVF   FED,F
0C60A:  MOVF   FEF,W
0C60C:  BTFSC  FEF.7
0C60E:  BRA    C612
0C610:  XORLW  80
0C612:  ADDWF  x25,F
0C614:  BTFSC  FD8.0
0C616:  BSF    x1F.0
0C618:  BTFSC  x21.4
0C61A:  BRA    C414
0C61C:  BTFSC  x21.5
0C61E:  BRA    C49C
0C620:  BRA    C50A
0C622:  MOVLB  0
0C624:  RETURN 0
0C626:  MOVLB  8
0C628:  MOVF   xDC,W
0C62A:  SUBLW  B6
0C62C:  MOVWF  xDC
0C62E:  CLRF   03
0C630:  MOVFF  8DD,8E0
0C634:  BSF    xDD.7
0C636:  BCF    FD8.0
0C638:  RRCF   xDD,F
0C63A:  RRCF   xDE,F
0C63C:  RRCF   xDF,F
0C63E:  RRCF   03,F
0C640:  RRCF   02,F
0C642:  RRCF   01,F
0C644:  RRCF   00,F
0C646:  DECFSZ xDC,F
0C648:  BRA    C636
0C64A:  BTFSS  xE0.7
0C64C:  BRA    C664
0C64E:  COMF   00,F
0C650:  COMF   01,F
0C652:  COMF   02,F
0C654:  COMF   03,F
0C656:  INCF   00,F
0C658:  BTFSC  FD8.2
0C65A:  INCF   01,F
0C65C:  BTFSC  FD8.2
0C65E:  INCF   02,F
0C660:  BTFSC  FD8.2
0C662:  INCF   03,F
0C664:  MOVLB  0
0C666:  RETURN 0
0C668:  MOVF   FE9,W
0C66A:  MOVLB  8
0C66C:  MOVWF  x8A
0C66E:  MOVF   x89,W
0C670:  MOVWF  x8C
0C672:  BZ    C6AC
0C674:  MOVFF  888,916
0C678:  MOVFF  887,915
0C67C:  MOVFF  886,914
0C680:  MOVFF  885,913
0C684:  MOVLB  9
0C686:  CLRF   x1A
0C688:  CLRF   x19
0C68A:  MOVLW  20
0C68C:  MOVWF  x18
0C68E:  MOVLW  82
0C690:  MOVWF  x17
0C692:  MOVLB  0
0C694:  RCALL  C2B8
0C696:  MOVFF  03,888
0C69A:  MOVFF  02,887
0C69E:  MOVFF  01,886
0C6A2:  MOVFF  00,885
0C6A6:  MOVLB  8
0C6A8:  DECFSZ x8C,F
0C6AA:  BRA    C674
0C6AC:  MOVLW  7E
0C6AE:  MOVWF  00
0C6B0:  CLRF   01
0C6B2:  BTFSC  x86.7
0C6B4:  BSF    01.7
0C6B6:  CLRF   02
0C6B8:  CLRF   03
0C6BA:  BCF    FD8.1
0C6BC:  MOVFF  888,91A
0C6C0:  MOVFF  887,919
0C6C4:  MOVFF  886,918
0C6C8:  MOVFF  885,917
0C6CC:  MOVFF  03,91E
0C6D0:  MOVFF  02,91D
0C6D4:  MOVFF  01,91C
0C6D8:  MOVFF  FE8,91B
0C6DC:  MOVLB  0
0C6DE:  RCALL  C3AE
0C6E0:  MOVFF  03,888
0C6E4:  MOVFF  02,887
0C6E8:  MOVFF  01,886
0C6EC:  MOVFF  00,885
0C6F0:  MOVFF  888,8DF
0C6F4:  MOVFF  887,8DE
0C6F8:  MOVFF  886,8DD
0C6FC:  MOVFF  885,8DC
0C700:  RCALL  C626
0C702:  MOVFF  03,888
0C706:  MOVFF  02,887
0C70A:  MOVFF  01,886
0C70E:  MOVFF  00,885
0C712:  MOVLB  8
0C714:  BTFSS  x88.7
0C716:  BRA    C732
0C718:  DECF   x8A,F
0C71A:  BSF    x8A.5
0C71C:  COMF   x85,F
0C71E:  COMF   x86,F
0C720:  COMF   x87,F
0C722:  COMF   x88,F
0C724:  INCF   x85,F
0C726:  BTFSC  FD8.2
0C728:  INCF   x86,F
0C72A:  BTFSC  FD8.2
0C72C:  INCF   x87,F
0C72E:  BTFSC  FD8.2
0C730:  INCF   x88,F
0C732:  MOVLW  3B
0C734:  MOVWF  x91
0C736:  MOVLW  9A
0C738:  MOVWF  x90
0C73A:  MOVLW  CA
0C73C:  MOVWF  x8F
0C73E:  CLRF   x8E
0C740:  MOVLW  0A
0C742:  MOVWF  x8C
0C744:  MOVF   x89,W
0C746:  BTFSC  FD8.2
0C748:  INCF   x8A,F
0C74A:  BSF    FD8.1
0C74C:  MOVLW  08
0C74E:  MOVWF  FEA
0C750:  MOVLW  85
0C752:  MOVWF  FE9
0C754:  CLRF   1B
0C756:  BTFSC  FF2.7
0C758:  BSF    1B.7
0C75A:  BCF    FF2.7
0C75C:  MOVFF  888,A4F
0C760:  MOVFF  887,A4E
0C764:  MOVFF  886,A4D
0C768:  MOVFF  885,A4C
0C76C:  MOVFF  891,A53
0C770:  MOVFF  890,A52
0C774:  MOVFF  88F,A51
0C778:  MOVFF  88E,A50
0C77C:  MOVLB  0
0C77E:  CALL   104A
0C782:  BTFSC  1B.7
0C784:  BSF    FF2.7
0C786:  MOVF   01,W
0C788:  MOVF   00,F
0C78A:  BNZ   C7B2
0C78C:  MOVLB  8
0C78E:  INCF   x89,W
0C790:  SUBWF  x8C,W
0C792:  BTFSS  FD8.2
0C794:  BRA    C79A
0C796:  MOVLB  0
0C798:  BRA    C7B2
0C79A:  MOVF   x8A,W
0C79C:  BZ    C7B8
0C79E:  ANDLW  0F
0C7A0:  SUBWF  x8C,W
0C7A2:  BZ    C7A6
0C7A4:  BC    C81E
0C7A6:  BTFSC  x8A.7
0C7A8:  BRA    C81E
0C7AA:  BTFSC  x8A.6
0C7AC:  BRA    C7B8
0C7AE:  MOVLW  20
0C7B0:  BRA    C814
0C7B2:  MOVLW  20
0C7B4:  MOVLB  8
0C7B6:  ANDWF  x8A,F
0C7B8:  BTFSS  x8A.5
0C7BA:  BRA    C7D6
0C7BC:  BCF    x8A.5
0C7BE:  MOVF   x89,W
0C7C0:  BTFSS  FD8.2
0C7C2:  DECF   x8A,F
0C7C4:  MOVF   00,W
0C7C6:  MOVWF  x8A
0C7C8:  MOVLW  2D
0C7CA:  BTFSS  F9E.4
0C7CC:  BRA    C7CA
0C7CE:  MOVWF  FAD
0C7D0:  MOVF   x8A,W
0C7D2:  MOVWF  00
0C7D4:  CLRF   x8A
0C7D6:  MOVF   x89,W
0C7D8:  SUBWF  x8C,W
0C7DA:  BNZ   C7F2
0C7DC:  MOVF   00,W
0C7DE:  MOVWF  x8A
0C7E0:  MOVLW  2E
0C7E2:  BTFSS  F9E.4
0C7E4:  BRA    C7E2
0C7E6:  MOVWF  FAD
0C7E8:  MOVF   x8A,W
0C7EA:  MOVWF  00
0C7EC:  MOVLW  20
0C7EE:  ANDWF  x8A,F
0C7F0:  MOVLW  00
0C7F2:  MOVLW  30
0C7F4:  BTFSS  x8A.5
0C7F6:  BRA    C814
0C7F8:  BCF    x8A.5
0C7FA:  MOVF   x89,W
0C7FC:  BTFSS  FD8.2
0C7FE:  DECF   x8A,F
0C800:  MOVF   00,W
0C802:  MOVWF  x8A
0C804:  MOVLW  2D
0C806:  BTFSS  F9E.4
0C808:  BRA    C806
0C80A:  MOVWF  FAD
0C80C:  MOVF   x8A,W
0C80E:  MOVWF  00
0C810:  CLRF   x8A
0C812:  MOVLW  30
0C814:  ADDWF  00,F
0C816:  MOVF   00,W
0C818:  BTFSS  F9E.4
0C81A:  BRA    C818
0C81C:  MOVWF  FAD
0C81E:  BCF    FD8.1
0C820:  CLRF   1B
0C822:  BTFSC  FF2.7
0C824:  BSF    1B.7
0C826:  BCF    FF2.7
0C828:  MOVFF  891,A4F
0C82C:  MOVFF  890,A4E
0C830:  MOVFF  88F,A4D
0C834:  MOVFF  88E,A4C
0C838:  MOVLB  A
0C83A:  CLRF   x53
0C83C:  CLRF   x52
0C83E:  CLRF   x51
0C840:  MOVLW  0A
0C842:  MOVWF  x50
0C844:  MOVLB  0
0C846:  CALL   104A
0C84A:  BTFSC  1B.7
0C84C:  BSF    FF2.7
0C84E:  MOVFF  03,891
0C852:  MOVFF  02,890
0C856:  MOVFF  01,88F
0C85A:  MOVFF  00,88E
0C85E:  MOVLB  8
0C860:  DECFSZ x8C,F
0C862:  BRA    C74A
0C864:  MOVLB  0
0C866:  RETURN 0
*
0C8EA:  MOVLW  8E
0C8EC:  MOVWF  00
0C8EE:  MOVFF  918,01
0C8F2:  MOVFF  917,02
0C8F6:  CLRF   03
0C8F8:  MOVF   01,F
0C8FA:  BNZ   C90E
0C8FC:  MOVFF  02,01
0C900:  CLRF   02
0C902:  MOVLW  08
0C904:  SUBWF  00,F
0C906:  MOVF   01,F
0C908:  BNZ   C90E
0C90A:  CLRF   00
0C90C:  BRA    C91E
0C90E:  BCF    FD8.0
0C910:  BTFSC  01.7
0C912:  BRA    C91C
0C914:  RLCF   02,F
0C916:  RLCF   01,F
0C918:  DECF   00,F
0C91A:  BRA    C90E
0C91C:  BCF    01.7
0C91E:  RETURN 0
0C920:  MOVLB  8
0C922:  MOVF   xFB,W
0C924:  BTFSC  FD8.2
0C926:  BRA    CA90
0C928:  MOVLB  9
0C92A:  MOVWF  x07
0C92C:  MOVLB  8
0C92E:  MOVF   xFF,W
0C930:  BTFSC  FD8.2
0C932:  BRA    CA90
0C934:  MOVLB  9
0C936:  SUBWF  x07,F
0C938:  BNC   C948
0C93A:  MOVLW  7F
0C93C:  ADDWF  x07,F
0C93E:  BTFSS  FD8.0
0C940:  BRA    C946
0C942:  MOVLB  8
0C944:  BRA    CA90
0C946:  BRA    C95C
0C948:  MOVLW  81
0C94A:  SUBWF  x07,F
0C94C:  BTFSC  FD8.0
0C94E:  BRA    C954
0C950:  MOVLB  8
0C952:  BRA    CA90
0C954:  BTFSS  FD8.2
0C956:  BRA    C95C
0C958:  MOVLB  8
0C95A:  BRA    CA90
0C95C:  MOVFF  907,00
0C960:  CLRF   01
0C962:  CLRF   02
0C964:  CLRF   03
0C966:  CLRF   x06
0C968:  MOVFF  8FC,905
0C96C:  BSF    x05.7
0C96E:  MOVFF  8FD,904
0C972:  MOVFF  8FE,903
0C976:  MOVLW  19
0C978:  MOVWF  x07
0C97A:  MOVF   x02,W
0C97C:  SUBWF  x03,F
0C97E:  BC    C99A
0C980:  MOVLW  01
0C982:  SUBWF  x04,F
0C984:  BC    C99A
0C986:  SUBWF  x05,F
0C988:  BC    C99A
0C98A:  SUBWF  x06,F
0C98C:  BC    C99A
0C98E:  INCF   x06,F
0C990:  INCF   x05,F
0C992:  INCF   x04,F
0C994:  MOVF   x02,W
0C996:  ADDWF  x03,F
0C998:  BRA    C9EA
0C99A:  MOVF   x01,W
0C99C:  SUBWF  x04,F
0C99E:  BC    C9C4
0C9A0:  MOVLW  01
0C9A2:  SUBWF  x05,F
0C9A4:  BC    C9C4
0C9A6:  SUBWF  x06,F
0C9A8:  BC    C9C4
0C9AA:  INCF   x06,F
0C9AC:  INCF   x05,F
0C9AE:  MOVF   x01,W
0C9B0:  ADDWF  x04,F
0C9B2:  MOVF   x02,W
0C9B4:  ADDWF  x03,F
0C9B6:  BNC   C9EA
0C9B8:  INCF   x04,F
0C9BA:  BNZ   C9EA
0C9BC:  INCF   x05,F
0C9BE:  BNZ   C9EA
0C9C0:  INCF   x06,F
0C9C2:  BRA    C9EA
0C9C4:  MOVF   x00,W
0C9C6:  IORLW  80
0C9C8:  SUBWF  x05,F
0C9CA:  BC    C9E8
0C9CC:  MOVLW  01
0C9CE:  SUBWF  x06,F
0C9D0:  BC    C9E8
0C9D2:  INCF   x06,F
0C9D4:  MOVF   x00,W
0C9D6:  IORLW  80
0C9D8:  ADDWF  x05,F
0C9DA:  MOVF   x01,W
0C9DC:  ADDWF  x04,F
0C9DE:  BNC   C9B2
0C9E0:  INCF   x05,F
0C9E2:  BNZ   C9B2
0C9E4:  INCF   x06,F
0C9E6:  BRA    C9B2
0C9E8:  BSF    03.0
0C9EA:  DECFSZ x07,F
0C9EC:  BRA    C9F0
0C9EE:  BRA    CA06
0C9F0:  BCF    FD8.0
0C9F2:  RLCF   x03,F
0C9F4:  RLCF   x04,F
0C9F6:  RLCF   x05,F
0C9F8:  RLCF   x06,F
0C9FA:  BCF    FD8.0
0C9FC:  RLCF   03,F
0C9FE:  RLCF   02,F
0CA00:  RLCF   01,F
0CA02:  RLCF   x08,F
0CA04:  BRA    C97A
0CA06:  BTFSS  x08.0
0CA08:  BRA    CA16
0CA0A:  BCF    FD8.0
0CA0C:  RRCF   01,F
0CA0E:  RRCF   02,F
0CA10:  RRCF   03,F
0CA12:  RRCF   x08,F
0CA14:  BRA    CA1E
0CA16:  DECFSZ 00,F
0CA18:  BRA    CA1E
0CA1A:  MOVLB  8
0CA1C:  BRA    CA90
0CA1E:  BTFSC  x08.7
0CA20:  BRA    CA5E
0CA22:  BCF    FD8.0
0CA24:  RLCF   x03,F
0CA26:  RLCF   x04,F
0CA28:  RLCF   x05,F
0CA2A:  RLCF   x06,F
0CA2C:  MOVF   x02,W
0CA2E:  SUBWF  x03,F
0CA30:  BC    CA40
0CA32:  MOVLW  01
0CA34:  SUBWF  x04,F
0CA36:  BC    CA40
0CA38:  SUBWF  x05,F
0CA3A:  BC    CA40
0CA3C:  SUBWF  x06,F
0CA3E:  BNC   CA7A
0CA40:  MOVF   x01,W
0CA42:  SUBWF  x04,F
0CA44:  BC    CA50
0CA46:  MOVLW  01
0CA48:  SUBWF  x05,F
0CA4A:  BC    CA50
0CA4C:  SUBWF  x06,F
0CA4E:  BNC   CA7A
0CA50:  MOVF   x00,W
0CA52:  IORLW  80
0CA54:  SUBWF  x05,F
0CA56:  BC    CA5E
0CA58:  MOVLW  01
0CA5A:  SUBWF  x06,F
0CA5C:  BNC   CA7A
0CA5E:  INCF   03,F
0CA60:  BNZ   CA7A
0CA62:  INCF   02,F
0CA64:  BNZ   CA7A
0CA66:  INCF   01,F
0CA68:  BNZ   CA7A
0CA6A:  INCF   00,F
0CA6C:  BTFSS  FD8.2
0CA6E:  BRA    CA74
0CA70:  MOVLB  8
0CA72:  BRA    CA90
0CA74:  RRCF   01,F
0CA76:  RRCF   02,F
0CA78:  RRCF   03,F
0CA7A:  MOVFF  8FC,907
0CA7E:  MOVF   x00,W
0CA80:  XORWF  x07,F
0CA82:  BTFSS  x07.7
0CA84:  BRA    CA8A
0CA86:  BSF    01.7
0CA88:  BRA    CA9A
0CA8A:  BCF    01.7
0CA8C:  BRA    CA9A
0CA8E:  MOVLB  8
0CA90:  CLRF   00
0CA92:  CLRF   01
0CA94:  CLRF   02
0CA96:  CLRF   03
0CA98:  MOVLB  9
0CA9A:  MOVLB  0
0CA9C:  RETURN 0
*
0D530:  MOVFF  FEA,8C9
0D534:  MOVFF  FE9,8C8
0D538:  MOVLB  8
0D53A:  BTFSS  xC2.7
0D53C:  BRA    D54E
0D53E:  BSF    xC8.7
0D540:  BTFSS  xC8.4
0D542:  INCF   xC8,F
0D544:  COMF   xC1,F
0D546:  COMF   xC2,F
0D548:  INCF   xC1,F
0D54A:  BTFSC  FD8.2
0D54C:  INCF   xC2,F
0D54E:  SWAPF  xC2,W
0D550:  IORLW  F0
0D552:  MOVWF  xC4
0D554:  ADDWF  xC4,F
0D556:  ADDLW  E2
0D558:  MOVWF  xC5
0D55A:  ADDLW  32
0D55C:  MOVWF  xC7
0D55E:  MOVF   xC2,W
0D560:  ANDLW  0F
0D562:  ADDWF  xC5,F
0D564:  ADDWF  xC5,F
0D566:  ADDWF  xC7,F
0D568:  ADDLW  E9
0D56A:  MOVWF  xC6
0D56C:  ADDWF  xC6,F
0D56E:  ADDWF  xC6,F
0D570:  SWAPF  xC1,W
0D572:  ANDLW  0F
0D574:  ADDWF  xC6,F
0D576:  ADDWF  xC7,F
0D578:  RLCF   xC6,F
0D57A:  RLCF   xC7,F
0D57C:  COMF   xC7,F
0D57E:  RLCF   xC7,F
0D580:  MOVF   xC1,W
0D582:  ANDLW  0F
0D584:  ADDWF  xC7,F
0D586:  RLCF   xC4,F
0D588:  MOVLW  07
0D58A:  MOVWF  xC3
0D58C:  MOVLW  0A
0D58E:  DECF   xC6,F
0D590:  ADDWF  xC7,F
0D592:  BNC   D58E
0D594:  DECF   xC5,F
0D596:  ADDWF  xC6,F
0D598:  BNC   D594
0D59A:  DECF   xC4,F
0D59C:  ADDWF  xC5,F
0D59E:  BNC   D59A
0D5A0:  DECF   xC3,F
0D5A2:  ADDWF  xC4,F
0D5A4:  BNC   D5A0
0D5A6:  MOVLW  08
0D5A8:  MOVWF  FEA
0D5AA:  MOVLW  C3
0D5AC:  MOVWF  FE9
0D5AE:  MOVLW  07
0D5B0:  ANDWF  xC8,W
0D5B2:  BCF    xC8.6
0D5B4:  MOVF   FED,F
0D5B6:  ANDWF  xC8,W
0D5B8:  BNZ   D5C8
0D5BA:  BTFSC  xC8.4
0D5BC:  MOVF   FEE,F
0D5BE:  BTFSC  xC8.4
0D5C0:  BRA    D5C8
0D5C2:  MOVLW  20
0D5C4:  MOVWF  00
0D5C6:  BRA    D60A
0D5C8:  ADDWF  FE9,F
0D5CA:  MOVLW  00
0D5CC:  ADDWFC FEA,F
0D5CE:  MOVF   FE9,W
0D5D0:  SUBLW  C7
0D5D2:  BNZ   D5DC
0D5D4:  MOVF   FEA,W
0D5D6:  SUBLW  08
0D5D8:  BNZ   D5DC
0D5DA:  BSF    xC8.6
0D5DC:  MOVF   FEF,W
0D5DE:  MOVWF  00
0D5E0:  BNZ   D5F2
0D5E2:  BTFSC  xC8.6
0D5E4:  BRA    D5F2
0D5E6:  BTFSC  xC8.4
0D5E8:  BRA    D626
0D5EA:  BTFSC  xC8.3
0D5EC:  BRA    D5F2
0D5EE:  MOVLW  20
0D5F0:  BRA    D608
0D5F2:  BTFSS  xC8.7
0D5F4:  BRA    D602
0D5F6:  MOVLW  2D
0D5F8:  MOVWF  00
0D5FA:  MOVF   FED,W
0D5FC:  BCF    xC8.6
0D5FE:  BCF    xC8.7
0D600:  BRA    D60A
0D602:  BSF    xC8.3
0D604:  BCF    xC8.4
0D606:  MOVLW  30
0D608:  ADDWF  00,F
0D60A:  MOVFF  FEA,8C2
0D60E:  MOVFF  FE9,8C1
0D612:  MOVFF  00,8FF
0D616:  MOVLB  0
0D618:  CALL   5092
0D61C:  MOVFF  8C2,FEA
0D620:  MOVFF  8C1,FE9
0D624:  MOVLB  8
0D626:  MOVF   FEE,W
0D628:  BTFSS  xC8.6
0D62A:  BRA    D5CE
0D62C:  MOVLB  0
0D62E:  GOTO   D752 (RETURN)
*
0D9D6:  ADDWF  FE8,W
0D9D8:  CLRF   FF7
0D9DA:  RLCF   FF7,F
0D9DC:  ADDLW  F7
0D9DE:  MOVWF  FF6
0D9E0:  MOVLW  D9
0D9E2:  ADDWFC FF7,F
0D9E4:  MOVLW  00
0D9E6:  MOVWF  FF8
0D9E8:  MOVWF  FFB
0D9EA:  TBLRD*-
0D9EC:  MOVF   FF5,W
0D9EE:  MOVWF  FFA
0D9F0:  TBLRD*
0D9F2:  MOVF   FF5,W
0D9F4:  MOVWF  FF9
0D9F6:  DATA 08,D9
0D9F8:  DATA 30,D9
0D9FA:  DATA 50,D9
0D9FC:  DATA 70,D9
0D9FE:  DATA 90,D9
0DA00:  DATA B0,D9
*
0DA80:  TBLRD*+
0DA82:  MOVFF  FF6,8B9
0DA86:  MOVFF  FF7,8BA
0DA8A:  MOVFF  FF8,8BB
0DA8E:  MOVF   FF5,W
0DA90:  BTFSS  FA4.4
0DA92:  BRA    DA90
0DA94:  MOVLB  F
0DA96:  MOVWF  x1C
0DA98:  MOVFF  8B9,FF6
0DA9C:  MOVFF  8BA,FF7
0DAA0:  MOVFF  8BB,FF8
0DAA4:  MOVLB  8
0DAA6:  DECFSZ xB8,F
0DAA8:  BRA    DAAC
0DAAA:  BRA    DAB0
0DAAC:  MOVLB  0
0DAAE:  BRA    DA80
0DAB0:  MOVLB  0
0DAB2:  RETURN 0
0DAB4:  MOVF   01,W
0DAB6:  CLRF   1B
0DAB8:  BTFSC  FF2.7
0DABA:  BSF    1B.7
0DABC:  BCF    FF2.7
0DABE:  MOVFF  8F3,A42
0DAC2:  MOVLW  64
0DAC4:  MOVLB  A
0DAC6:  MOVWF  x43
0DAC8:  MOVLB  0
0DACA:  CALL   0F6E
0DACE:  BTFSC  1B.7
0DAD0:  BSF    FF2.7
0DAD2:  MOVFF  00,8F3
0DAD6:  MOVF   01,W
0DAD8:  MOVLW  30
0DADA:  BNZ   DAEC
0DADC:  MOVLB  8
0DADE:  BTFSS  xF4.1
0DAE0:  BRA    DB02
0DAE2:  BTFSC  xF4.3
0DAE4:  BRA    DB02
0DAE6:  BTFSC  xF4.4
0DAE8:  MOVLW  20
0DAEA:  BRA    DAF4
0DAEC:  MOVLB  8
0DAEE:  BCF    xF4.3
0DAF0:  BCF    xF4.4
0DAF2:  BSF    xF4.0
0DAF4:  ADDWF  01,F
0DAF6:  MOVF   01,W
0DAF8:  BTFSS  FA4.4
0DAFA:  BRA    DAF8
0DAFC:  MOVLB  F
0DAFE:  MOVWF  x1C
0DB00:  MOVLB  8
0DB02:  CLRF   1B
0DB04:  BTFSC  FF2.7
0DB06:  BSF    1B.7
0DB08:  BCF    FF2.7
0DB0A:  MOVFF  8F3,A42
0DB0E:  MOVLW  0A
0DB10:  MOVLB  A
0DB12:  MOVWF  x43
0DB14:  MOVLB  0
0DB16:  CALL   0F6E
0DB1A:  BTFSC  1B.7
0DB1C:  BSF    FF2.7
0DB1E:  MOVFF  00,8F3
0DB22:  MOVF   01,W
0DB24:  MOVLW  30
0DB26:  BNZ   DB38
0DB28:  MOVLB  8
0DB2A:  BTFSC  xF4.3
0DB2C:  BRA    DB46
0DB2E:  BTFSS  xF4.0
0DB30:  BRA    DB46
0DB32:  BTFSC  xF4.4
0DB34:  MOVLW  20
0DB36:  MOVLB  0
0DB38:  ADDWF  01,F
0DB3A:  MOVF   01,W
0DB3C:  BTFSS  FA4.4
0DB3E:  BRA    DB3C
0DB40:  MOVLB  F
0DB42:  MOVWF  x1C
0DB44:  MOVLB  8
0DB46:  MOVLW  30
0DB48:  ADDWF  xF3,F
0DB4A:  MOVF   xF3,W
0DB4C:  BTFSS  FA4.4
0DB4E:  BRA    DB4C
0DB50:  MOVLB  F
0DB52:  MOVWF  x1C
0DB54:  MOVLB  0
0DB56:  RETURN 0
*
0DB7A:  TBLRD*+
0DB7C:  MOVF   FF5,F
0DB7E:  BZ    DBA6
0DB80:  MOVFF  FF6,8B7
0DB84:  MOVFF  FF7,8B8
0DB88:  MOVFF  FF8,8B9
0DB8C:  MOVF   FF5,W
0DB8E:  BTFSS  FA4.4
0DB90:  BRA    DB8E
0DB92:  MOVLB  F
0DB94:  MOVWF  x1C
0DB96:  MOVFF  8B7,FF6
0DB9A:  MOVFF  8B8,FF7
0DB9E:  MOVFF  8B9,FF8
0DBA2:  MOVLB  0
0DBA4:  BRA    DB7A
0DBA6:  GOTO   DC68 (RETURN)
*
0E182:  MOVF   FE9,W
0E184:  MOVLB  8
0E186:  MOVWF  x8C
0E188:  MOVLW  3B
0E18A:  MOVWF  x93
0E18C:  MOVLW  9A
0E18E:  MOVWF  x92
0E190:  MOVLW  CA
0E192:  MOVWF  x91
0E194:  CLRF   x90
0E196:  MOVLW  0A
0E198:  MOVWF  x8E
0E19A:  MOVF   x8B,W
0E19C:  BTFSS  FD8.2
0E19E:  DECF   x8C,F
0E1A0:  BSF    FD8.1
0E1A2:  MOVLW  08
0E1A4:  MOVWF  FEA
0E1A6:  MOVLW  87
0E1A8:  MOVWF  FE9
0E1AA:  CLRF   1B
0E1AC:  BTFSC  FF2.7
0E1AE:  BSF    1B.7
0E1B0:  BCF    FF2.7
0E1B2:  MOVFF  88A,A4F
0E1B6:  MOVFF  889,A4E
0E1BA:  MOVFF  888,A4D
0E1BE:  MOVFF  887,A4C
0E1C2:  MOVFF  893,A53
0E1C6:  MOVFF  892,A52
0E1CA:  MOVFF  891,A51
0E1CE:  MOVFF  890,A50
0E1D2:  MOVLB  0
0E1D4:  CALL   104A
0E1D8:  BTFSC  1B.7
0E1DA:  BSF    FF2.7
0E1DC:  MOVF   01,W
0E1DE:  MOVF   00,F
0E1E0:  BNZ   E208
0E1E2:  MOVLB  8
0E1E4:  INCF   x8B,W
0E1E6:  SUBWF  x8E,W
0E1E8:  BTFSS  FD8.2
0E1EA:  BRA    E1F0
0E1EC:  MOVLB  0
0E1EE:  BRA    E208
0E1F0:  MOVF   x8C,W
0E1F2:  BZ    E20C
0E1F4:  ANDLW  0F
0E1F6:  SUBWF  x8E,W
0E1F8:  BZ    E1FC
0E1FA:  BC    E234
0E1FC:  BTFSC  x8C.7
0E1FE:  BRA    E234
0E200:  BTFSC  x8C.6
0E202:  BRA    E20C
0E204:  MOVLW  20
0E206:  BRA    E22A
0E208:  MOVLB  8
0E20A:  CLRF   x8C
0E20C:  MOVF   x8B,W
0E20E:  SUBWF  x8E,W
0E210:  BNZ   E228
0E212:  MOVFF  00,88C
0E216:  MOVLW  2E
0E218:  BTFSS  F9E.4
0E21A:  BRA    E218
0E21C:  MOVWF  FAD
0E21E:  MOVFF  88C,00
0E222:  MOVLW  20
0E224:  ANDWF  x8C,F
0E226:  MOVLW  00
0E228:  MOVLW  30
0E22A:  ADDWF  00,F
0E22C:  MOVF   00,W
0E22E:  BTFSS  F9E.4
0E230:  BRA    E22E
0E232:  MOVWF  FAD
0E234:  BCF    FD8.1
0E236:  CLRF   1B
0E238:  BTFSC  FF2.7
0E23A:  BSF    1B.7
0E23C:  BCF    FF2.7
0E23E:  MOVFF  893,A4F
0E242:  MOVFF  892,A4E
0E246:  MOVFF  891,A4D
0E24A:  MOVFF  890,A4C
0E24E:  MOVLB  A
0E250:  CLRF   x53
0E252:  CLRF   x52
0E254:  CLRF   x51
0E256:  MOVLW  0A
0E258:  MOVWF  x50
0E25A:  MOVLB  0
0E25C:  CALL   104A
0E260:  BTFSC  1B.7
0E262:  BSF    FF2.7
0E264:  MOVFF  03,893
0E268:  MOVFF  02,892
0E26C:  MOVFF  01,891
0E270:  MOVFF  00,890
0E274:  MOVLB  8
0E276:  DECFSZ x8E,F
0E278:  BRA    E1A0
0E27A:  MOVLB  0
0E27C:  RETURN 0
*
0F316:  MOVF   FE9,W
0F318:  MOVLB  8
0F31A:  MOVWF  xF7
0F31C:  MOVLW  3B
0F31E:  MOVWF  xFE
0F320:  MOVLW  9A
0F322:  MOVWF  xFD
0F324:  MOVLW  CA
0F326:  MOVWF  xFC
0F328:  CLRF   xFB
0F32A:  MOVLW  0A
0F32C:  MOVWF  xF9
0F32E:  BSF    FD8.1
0F330:  MOVLW  08
0F332:  MOVWF  FEA
0F334:  MOVLW  F3
0F336:  MOVWF  FE9
0F338:  CLRF   1B
0F33A:  BTFSC  FF2.7
0F33C:  BSF    1B.7
0F33E:  BCF    FF2.7
0F340:  MOVFF  8F6,A4F
0F344:  MOVFF  8F5,A4E
0F348:  MOVFF  8F4,A4D
0F34C:  MOVFF  8F3,A4C
0F350:  MOVFF  8FE,A53
0F354:  MOVFF  8FD,A52
0F358:  MOVFF  8FC,A51
0F35C:  MOVFF  8FB,A50
0F360:  MOVLB  0
0F362:  CALL   104A
0F366:  BTFSC  1B.7
0F368:  BSF    FF2.7
0F36A:  MOVF   01,W
0F36C:  MOVF   00,F
0F36E:  BNZ   F396
0F370:  MOVLB  8
0F372:  MOVF   xF9,W
0F374:  XORLW  01
0F376:  BTFSS  FD8.2
0F378:  BRA    F37E
0F37A:  MOVLB  0
0F37C:  BRA    F396
0F37E:  MOVF   xF7,W
0F380:  BZ    F39A
0F382:  ANDLW  0F
0F384:  SUBWF  xF9,W
0F386:  BZ    F38A
0F388:  BC    F3AA
0F38A:  BTFSC  xF7.7
0F38C:  BRA    F3AA
0F38E:  BTFSC  xF7.6
0F390:  BRA    F39A
0F392:  MOVLW  20
0F394:  BRA    F39C
0F396:  MOVLB  8
0F398:  CLRF   xF7
0F39A:  MOVLW  30
0F39C:  ADDWF  00,F
0F39E:  MOVF   00,W
0F3A0:  BTFSS  FA4.4
0F3A2:  BRA    F3A0
0F3A4:  MOVLB  F
0F3A6:  MOVWF  x1C
0F3A8:  MOVLB  8
0F3AA:  BCF    FD8.1
0F3AC:  CLRF   1B
0F3AE:  BTFSC  FF2.7
0F3B0:  BSF    1B.7
0F3B2:  BCF    FF2.7
0F3B4:  MOVFF  8FE,A4F
0F3B8:  MOVFF  8FD,A4E
0F3BC:  MOVFF  8FC,A4D
0F3C0:  MOVFF  8FB,A4C
0F3C4:  MOVLB  A
0F3C6:  CLRF   x53
0F3C8:  CLRF   x52
0F3CA:  CLRF   x51
0F3CC:  MOVLW  0A
0F3CE:  MOVWF  x50
0F3D0:  MOVLB  0
0F3D2:  CALL   104A
0F3D6:  BTFSC  1B.7
0F3D8:  BSF    FF2.7
0F3DA:  MOVFF  03,8FE
0F3DE:  MOVFF  02,8FD
0F3E2:  MOVFF  01,8FC
0F3E6:  MOVFF  00,8FB
0F3EA:  MOVLB  8
0F3EC:  DECFSZ xF9,F
0F3EE:  BRA    F32E
0F3F0:  MOVLB  0
0F3F2:  GOTO   F51C (RETURN)
*
0F5EC:  ADDWF  FE8,W
0F5EE:  CLRF   FF7
0F5F0:  RLCF   FF7,F
0F5F2:  ADDLW  0D
0F5F4:  MOVWF  FF6
0F5F6:  MOVLW  F6
0F5F8:  ADDWFC FF7,F
0F5FA:  MOVLW  00
0F5FC:  MOVWF  FF8
0F5FE:  MOVWF  FFB
0F600:  TBLRD*-
0F602:  MOVF   FF5,W
0F604:  MOVWF  FFA
0F606:  TBLRD*
0F608:  MOVF   FF5,W
0F60A:  MOVWF  FF9
0F60C:  DATA AC,F5
0F60E:  DATA B4,F5
0F610:  DATA BC,F5
0F612:  DATA C4,F5
*
0FE30:  MOVF   FEF,F
0FE32:  BZ    FE54
0FE34:  MOVFF  FEA,8EC
0FE38:  MOVFF  FE9,8EB
0FE3C:  MOVFF  FEF,8FF
0FE40:  CALL   5092
0FE44:  MOVFF  8EC,FEA
0FE48:  MOVFF  8EB,FE9
0FE4C:  INCF   FE9,F
0FE4E:  BTFSC  FD8.2
0FE50:  INCF   FEA,F
0FE52:  BRA    FE30
0FE54:  RETURN 0
0FE56:  MOVFF  FEA,FE2
0FE5A:  MOVFF  FE9,FE1
0FE5E:  CLRF   01
0FE60:  BSF    00.0
0FE62:  TBLRD*+
0FE64:  MOVF   FF5,W
0FE66:  BTFSS  00.0
0FE68:  BRA    FE74
0FE6A:  SUBWF  FEE,W
0FE6C:  BNZ   FE74
0FE6E:  MOVF   FF5,F
0FE70:  BNZ   FE62
0FE72:  BRA    FE8E
0FE74:  BCF    00.0
0FE76:  MOVF   FF5,F
0FE78:  BNZ   FE62
0FE7A:  INCF   01,F
0FE7C:  BSF    00.0
0FE7E:  MOVFF  FE2,FEA
0FE82:  MOVFF  FE1,FE9
0FE86:  TBLRD*
0FE88:  MOVF   FF5,F
0FE8A:  BNZ   FE62
0FE8C:  SETF   01
0FE8E:  RETURN 0
*
1075E:  MOVFF  914,91B
10762:  MOVLB  9
10764:  MOVF   x18,W
10766:  XORWF  x1B,F
10768:  BTFSS  x1B.7
1076A:  BRA    10776
1076C:  BCF    FD8.2
1076E:  BCF    FD8.0
10770:  BTFSC  x14.7
10772:  BSF    FD8.0
10774:  BRA    107D4
10776:  MOVFF  914,91B
1077A:  MOVFF  917,91C
1077E:  MOVF   x13,W
10780:  SUBWF  x1C,F
10782:  BZ    10790
10784:  BTFSS  x1B.7
10786:  BRA    107D4
10788:  MOVF   FD8,W
1078A:  XORLW  01
1078C:  MOVWF  FD8
1078E:  BRA    107D4
10790:  MOVFF  918,91C
10794:  MOVF   x14,W
10796:  SUBWF  x1C,F
10798:  BZ    107A6
1079A:  BTFSS  x1B.7
1079C:  BRA    107D4
1079E:  MOVF   FD8,W
107A0:  XORLW  01
107A2:  MOVWF  FD8
107A4:  BRA    107D4
107A6:  MOVFF  919,91C
107AA:  MOVF   x15,W
107AC:  SUBWF  x1C,F
107AE:  BZ    107BC
107B0:  BTFSS  x1B.7
107B2:  BRA    107D4
107B4:  MOVF   FD8,W
107B6:  XORLW  01
107B8:  MOVWF  FD8
107BA:  BRA    107D4
107BC:  MOVFF  91A,91C
107C0:  MOVF   x16,W
107C2:  SUBWF  x1C,F
107C4:  BZ    107D2
107C6:  BTFSS  x1B.7
107C8:  BRA    107D4
107CA:  MOVF   FD8,W
107CC:  XORLW  01
107CE:  MOVWF  FD8
107D0:  BRA    107D4
107D2:  BCF    FD8.0
107D4:  MOVLB  0
107D6:  RETURN 0
107D8:  MOVLW  8E
107DA:  MOVWF  00
107DC:  MOVFF  8ED,01
107E0:  MOVFF  8EC,02
107E4:  CLRF   03
107E6:  BTFSS  01.7
107E8:  BRA    107F4
107EA:  COMF   01,F
107EC:  COMF   02,F
107EE:  INCF   02,F
107F0:  BNZ   107F4
107F2:  INCF   01,F
107F4:  MOVF   01,F
107F6:  BNZ   1080A
107F8:  MOVFF  02,01
107FC:  CLRF   02
107FE:  MOVLW  08
10800:  SUBWF  00,F
10802:  MOVF   01,F
10804:  BNZ   1080A
10806:  CLRF   00
10808:  BRA    10826
1080A:  BCF    FD8.0
1080C:  BTFSC  01.7
1080E:  BRA    10818
10810:  RLCF   02,F
10812:  RLCF   01,F
10814:  DECF   00,F
10816:  BRA    1080A
10818:  MOVLB  8
1081A:  BTFSS  xED.7
1081C:  BRA    10822
1081E:  MOVLB  0
10820:  BRA    10826
10822:  BCF    01.7
10824:  MOVLB  0
10826:  RETURN 0
*
10C28:  MOVF   FE9,W
10C2A:  MOVLB  8
10C2C:  MOVWF  xD4
10C2E:  MOVF   xD3,W
10C30:  MOVWF  xD6
10C32:  BZ    10C6E
10C34:  MOVFF  8D2,916
10C38:  MOVFF  8D1,915
10C3C:  MOVFF  8D0,914
10C40:  MOVFF  8CF,913
10C44:  MOVLB  9
10C46:  CLRF   x1A
10C48:  CLRF   x19
10C4A:  MOVLW  20
10C4C:  MOVWF  x18
10C4E:  MOVLW  82
10C50:  MOVWF  x17
10C52:  MOVLB  0
10C54:  CALL   C2B8
10C58:  MOVFF  03,8D2
10C5C:  MOVFF  02,8D1
10C60:  MOVFF  01,8D0
10C64:  MOVFF  00,8CF
10C68:  MOVLB  8
10C6A:  DECFSZ xD6,F
10C6C:  BRA    10C34
10C6E:  MOVLW  7E
10C70:  MOVWF  00
10C72:  CLRF   01
10C74:  BTFSC  xD0.7
10C76:  BSF    01.7
10C78:  CLRF   02
10C7A:  CLRF   03
10C7C:  BCF    FD8.1
10C7E:  MOVFF  8D2,91A
10C82:  MOVFF  8D1,919
10C86:  MOVFF  8D0,918
10C8A:  MOVFF  8CF,917
10C8E:  MOVFF  03,91E
10C92:  MOVFF  02,91D
10C96:  MOVFF  01,91C
10C9A:  MOVFF  FE8,91B
10C9E:  MOVLB  0
10CA0:  CALL   C3AE
10CA4:  MOVFF  03,8D2
10CA8:  MOVFF  02,8D1
10CAC:  MOVFF  01,8D0
10CB0:  MOVFF  00,8CF
10CB4:  MOVFF  8D2,8DF
10CB8:  MOVFF  8D1,8DE
10CBC:  MOVFF  8D0,8DD
10CC0:  MOVFF  8CF,8DC
10CC4:  CALL   C626
10CC8:  MOVFF  03,8D2
10CCC:  MOVFF  02,8D1
10CD0:  MOVFF  01,8D0
10CD4:  MOVFF  00,8CF
10CD8:  MOVLB  8
10CDA:  BTFSS  xD2.7
10CDC:  BRA    10CF8
10CDE:  DECF   xD4,F
10CE0:  BSF    xD4.5
10CE2:  COMF   xCF,F
10CE4:  COMF   xD0,F
10CE6:  COMF   xD1,F
10CE8:  COMF   xD2,F
10CEA:  INCF   xCF,F
10CEC:  BTFSC  FD8.2
10CEE:  INCF   xD0,F
10CF0:  BTFSC  FD8.2
10CF2:  INCF   xD1,F
10CF4:  BTFSC  FD8.2
10CF6:  INCF   xD2,F
10CF8:  MOVLW  3B
10CFA:  MOVWF  xDB
10CFC:  MOVLW  9A
10CFE:  MOVWF  xDA
10D00:  MOVLW  CA
10D02:  MOVWF  xD9
10D04:  CLRF   xD8
10D06:  MOVLW  0A
10D08:  MOVWF  xD6
10D0A:  MOVF   xD3,W
10D0C:  BTFSC  FD8.2
10D0E:  INCF   xD4,F
10D10:  BSF    FD8.1
10D12:  MOVLW  08
10D14:  MOVWF  FEA
10D16:  MOVLW  CF
10D18:  MOVWF  FE9
10D1A:  CLRF   1B
10D1C:  BTFSC  FF2.7
10D1E:  BSF    1B.7
10D20:  BCF    FF2.7
10D22:  MOVFF  8D2,A4F
10D26:  MOVFF  8D1,A4E
10D2A:  MOVFF  8D0,A4D
10D2E:  MOVFF  8CF,A4C
10D32:  MOVFF  8DB,A53
10D36:  MOVFF  8DA,A52
10D3A:  MOVFF  8D9,A51
10D3E:  MOVFF  8D8,A50
10D42:  MOVLB  0
10D44:  CALL   104A
10D48:  BTFSC  1B.7
10D4A:  BSF    FF2.7
10D4C:  MOVF   01,W
10D4E:  MOVF   00,F
10D50:  BNZ   10D78
10D52:  MOVLB  8
10D54:  INCF   xD3,W
10D56:  SUBWF  xD6,W
10D58:  BTFSS  FD8.2
10D5A:  BRA    10D60
10D5C:  MOVLB  0
10D5E:  BRA    10D78
10D60:  MOVF   xD4,W
10D62:  BZ    10D7E
10D64:  ANDLW  0F
10D66:  SUBWF  xD6,W
10D68:  BZ    10D6C
10D6A:  BC    10DF4
10D6C:  BTFSC  xD4.7
10D6E:  BRA    10DF4
10D70:  BTFSC  xD4.6
10D72:  BRA    10D7E
10D74:  MOVLW  20
10D76:  BRA    10DE6
10D78:  MOVLW  20
10D7A:  MOVLB  8
10D7C:  ANDWF  xD4,F
10D7E:  BTFSS  xD4.5
10D80:  BRA    10DA0
10D82:  BCF    xD4.5
10D84:  MOVF   xD3,W
10D86:  BTFSS  FD8.2
10D88:  DECF   xD4,F
10D8A:  MOVF   00,W
10D8C:  MOVWF  xD4
10D8E:  MOVLW  2D
10D90:  MOVWF  xFF
10D92:  MOVLB  0
10D94:  CALL   5092
10D98:  MOVLB  8
10D9A:  MOVF   xD4,W
10D9C:  MOVWF  00
10D9E:  CLRF   xD4
10DA0:  MOVF   xD3,W
10DA2:  SUBWF  xD6,W
10DA4:  BNZ   10DC0
10DA6:  MOVF   00,W
10DA8:  MOVWF  xD4
10DAA:  MOVLW  2E
10DAC:  MOVWF  xFF
10DAE:  MOVLB  0
10DB0:  CALL   5092
10DB4:  MOVLB  8
10DB6:  MOVF   xD4,W
10DB8:  MOVWF  00
10DBA:  MOVLW  20
10DBC:  ANDWF  xD4,F
10DBE:  MOVLW  00
10DC0:  MOVLW  30
10DC2:  BTFSS  xD4.5
10DC4:  BRA    10DE6
10DC6:  BCF    xD4.5
10DC8:  MOVF   xD3,W
10DCA:  BTFSS  FD8.2
10DCC:  DECF   xD4,F
10DCE:  MOVF   00,W
10DD0:  MOVWF  xD4
10DD2:  MOVLW  2D
10DD4:  MOVWF  xFF
10DD6:  MOVLB  0
10DD8:  CALL   5092
10DDC:  MOVLB  8
10DDE:  MOVF   xD4,W
10DE0:  MOVWF  00
10DE2:  CLRF   xD4
10DE4:  MOVLW  30
10DE6:  ADDWF  00,F
10DE8:  MOVFF  00,8FF
10DEC:  MOVLB  0
10DEE:  CALL   5092
10DF2:  MOVLB  8
10DF4:  BCF    FD8.1
10DF6:  CLRF   1B
10DF8:  BTFSC  FF2.7
10DFA:  BSF    1B.7
10DFC:  BCF    FF2.7
10DFE:  MOVFF  8DB,A4F
10E02:  MOVFF  8DA,A4E
10E06:  MOVFF  8D9,A4D
10E0A:  MOVFF  8D8,A4C
10E0E:  MOVLB  A
10E10:  CLRF   x53
10E12:  CLRF   x52
10E14:  CLRF   x51
10E16:  MOVLW  0A
10E18:  MOVWF  x50
10E1A:  MOVLB  0
10E1C:  CALL   104A
10E20:  BTFSC  1B.7
10E22:  BSF    FF2.7
10E24:  MOVFF  03,8DB
10E28:  MOVFF  02,8DA
10E2C:  MOVFF  01,8D9
10E30:  MOVFF  00,8D8
10E34:  MOVLB  8
10E36:  DECFSZ xD6,F
10E38:  BRA    10D10
10E3A:  MOVLB  0
10E3C:  RETURN 0
*
12740:  ADDWF  FE8,W
12742:  CLRF   FF7
12744:  RLCF   FF7,F
12746:  ADDLW  61
12748:  MOVWF  FF6
1274A:  MOVLW  27
1274C:  ADDWFC FF7,F
1274E:  MOVLW  01
12750:  MOVWF  FF8
12752:  MOVWF  FFB
12754:  TBLRD*-
12756:  MOVF   FF5,W
12758:  MOVWF  FFA
1275A:  TBLRD*
1275C:  MOVF   FF5,W
1275E:  MOVWF  FF9
12760:  DATA 04,27
12762:  DATA 0C,27
12764:  DATA 12,27
12766:  DATA 18,27
*
127F8:  MOVLW  8E
127FA:  MOVWF  00
127FC:  MOVLB  9
127FE:  MOVF   x13,W
12800:  SUBWF  00,F
12802:  MOVFF  914,02
12806:  MOVFF  915,01
1280A:  BSF    02.7
1280C:  MOVF   00,F
1280E:  BZ    12822
12810:  BCF    FD8.0
12812:  MOVF   02,F
12814:  BNZ   1281A
12816:  MOVF   01,F
12818:  BZ    12822
1281A:  RRCF   02,F
1281C:  RRCF   01,F
1281E:  DECFSZ 00,F
12820:  BRA    12810
12822:  BTFSS  x14.7
12824:  BRA    12830
12826:  COMF   01,F
12828:  COMF   02,F
1282A:  INCF   01,F
1282C:  BTFSC  FD8.2
1282E:  INCF   02,F
12830:  MOVLB  0
12832:  RETURN 0
*
132F0:  ADDWF  FE8,W
132F2:  CLRF   FF7
132F4:  RLCF   FF7,F
132F6:  ADDLW  11
132F8:  MOVWF  FF6
132FA:  MOVLW  33
132FC:  ADDWFC FF7,F
132FE:  MOVLW  01
13300:  MOVWF  FF8
13302:  MOVWF  FFB
13304:  TBLRD*-
13306:  MOVF   FF5,W
13308:  MOVWF  FFA
1330A:  TBLRD*
1330C:  MOVF   FF5,W
1330E:  MOVWF  FF9
13310:  DATA 2C,31
13312:  DATA 32,31
13314:  DATA 50,31
13316:  DATA 6E,31
*
13388:  MOVLB  8
1338A:  MOVF   xDD,W
1338C:  XORWF  xDF,W
1338E:  ANDLW  80
13390:  MOVWF  xE1
13392:  BTFSS  xDD.7
13394:  BRA    133A0
13396:  COMF   xDC,F
13398:  COMF   xDD,F
1339A:  INCF   xDC,F
1339C:  BTFSC  FD8.2
1339E:  INCF   xDD,F
133A0:  BTFSS  xDF.7
133A2:  BRA    133AE
133A4:  COMF   xDE,F
133A6:  COMF   xDF,F
133A8:  INCF   xDE,F
133AA:  BTFSC  FD8.2
133AC:  INCF   xDF,F
133AE:  MOVF   xDC,W
133B0:  MULWF  xDE
133B2:  MOVFF  FF3,01
133B6:  MOVFF  FF4,00
133BA:  MULWF  xDF
133BC:  MOVF   FF3,W
133BE:  ADDWF  00,F
133C0:  MOVF   xDD,W
133C2:  MULWF  xDE
133C4:  MOVF   FF3,W
133C6:  ADDWFC 00,W
133C8:  MOVWF  02
133CA:  BTFSS  xE1.7
133CC:  BRA    133D8
133CE:  COMF   01,F
133D0:  COMF   02,F
133D2:  INCF   01,F
133D4:  BTFSC  FD8.2
133D6:  INCF   02,F
133D8:  MOVLB  0
133DA:  GOTO   134B8 (RETURN)
*
14276:  ADDWF  FE8,W
14278:  CLRF   FF7
1427A:  RLCF   FF7,F
1427C:  ADDLW  97
1427E:  MOVWF  FF6
14280:  MOVLW  42
14282:  ADDWFC FF7,F
14284:  MOVLW  01
14286:  MOVWF  FF8
14288:  MOVWF  FFB
1428A:  TBLRD*-
1428C:  MOVF   FF5,W
1428E:  MOVWF  FFA
14290:  TBLRD*
14292:  MOVF   FF5,W
14294:  MOVWF  FF9
14296:  DATA 2C,41
14298:  DATA 6A,42
1429A:  DATA 58,41
1429C:  DATA 6A,42
1429E:  DATA 22,40
142A0:  DATA 6A,42
142A2:  DATA 6A,42
142A4:  DATA 6A,42
142A6:  DATA 6A,42
142A8:  DATA 6A,42
142AA:  DATA 6A,42
142AC:  DATA 6A,42
142AE:  DATA 6A,42
142B0:  DATA 6A,42
142B2:  DATA 6A,42
142B4:  DATA 6A,42
142B6:  DATA 62,42
142B8:  DATA 6A,42
142BA:  DATA 6A,42
142BC:  DATA 6A,42
142BE:  DATA 6A,42
142C0:  DATA 6A,42
142C2:  DATA C2,3F
142C4:  DATA 6A,42
142C6:  DATA F6,3F
142C8:  DATA FE,3F
142CA:  DATA 6A,42
142CC:  DATA 12,40
142CE:  DATA 84,41
142D0:  DATA 46,40
142D2:  DATA 6A,42
142D4:  DATA 6A,42
142D6:  DATA D8,40
142D8:  DATA BA,40
142DA:  DATA 6A,42
142DC:  DATA 6A,42
142DE:  DATA 6A,42
142E0:  DATA 9E,41
142E2:  DATA CA,41
142E4:  DATA F6,41
142E6:  DATA F4,40
142E8:  DATA 22,41
142EA:  DATA 6A,42
142EC:  DATA 6A,42
142EE:  DATA 6A,42
142F0:  DATA 6A,42
142F2:  DATA 22,42
142F4:  DATA 6A,42
142F6:  DATA 6A,42
142F8:  DATA 6A,42
142FA:  DATA 6A,42
142FC:  DATA 6A,42
142FE:  DATA 6A,42
14300:  DATA 6A,42
14302:  DATA 6A,42
14304:  DATA 6A,42
14306:  DATA 6A,42
14308:  DATA 2E,40
1430A:  DATA 6A,42
1430C:  DATA 6A,42
1430E:  DATA 6A,42
14310:  DATA 6A,42
14312:  DATA 5E,40
14314:  DATA 6A,42
14316:  DATA 6A,42
14318:  DATA 84,40
1431A:  DATA 6A,42
1431C:  DATA 6A,42
1431E:  DATA 6A,42
14320:  DATA D2,3F
14322:  DATA 6A,42
14324:  DATA 6A,42
14326:  DATA 6A,42
14328:  DATA 6A,42
1432A:  DATA 6A,42
1432C:  DATA 4C,42
*
143E2:  MOVFF  FEA,8C0
143E6:  MOVFF  FE9,8BF
143EA:  MOVLB  8
143EC:  SWAPF  xB9,W
143EE:  IORLW  F0
143F0:  MOVWF  xBB
143F2:  ADDWF  xBB,F
143F4:  ADDLW  E2
143F6:  MOVWF  xBC
143F8:  ADDLW  32
143FA:  MOVWF  xBE
143FC:  MOVF   xB9,W
143FE:  ANDLW  0F
14400:  ADDWF  xBC,F
14402:  ADDWF  xBC,F
14404:  ADDWF  xBE,F
14406:  ADDLW  E9
14408:  MOVWF  xBD
1440A:  ADDWF  xBD,F
1440C:  ADDWF  xBD,F
1440E:  SWAPF  xB8,W
14410:  ANDLW  0F
14412:  ADDWF  xBD,F
14414:  ADDWF  xBE,F
14416:  RLCF   xBD,F
14418:  RLCF   xBE,F
1441A:  COMF   xBE,F
1441C:  RLCF   xBE,F
1441E:  MOVF   xB8,W
14420:  ANDLW  0F
14422:  ADDWF  xBE,F
14424:  RLCF   xBB,F
14426:  MOVLW  07
14428:  MOVWF  xBA
1442A:  MOVLW  0A
1442C:  DECF   xBD,F
1442E:  ADDWF  xBE,F
14430:  BNC   1442C
14432:  DECF   xBC,F
14434:  ADDWF  xBD,F
14436:  BNC   14432
14438:  DECF   xBB,F
1443A:  ADDWF  xBC,F
1443C:  BNC   14438
1443E:  DECF   xBA,F
14440:  ADDWF  xBB,F
14442:  BNC   1443E
14444:  MOVLW  08
14446:  MOVWF  FEA
14448:  MOVLW  BA
1444A:  MOVWF  FE9
1444C:  MOVLW  07
1444E:  ANDWF  xBF,W
14450:  BCF    xBF.6
14452:  ADDWF  FE9,F
14454:  MOVLW  00
14456:  ADDWFC FEA,F
14458:  MOVF   FE9,W
1445A:  SUBLW  BE
1445C:  BNZ   14466
1445E:  MOVF   FEA,W
14460:  SUBLW  08
14462:  BNZ   14466
14464:  BSF    xBF.6
14466:  MOVF   FEF,W
14468:  MOVWF  00
1446A:  BNZ   1447C
1446C:  BTFSC  xBF.6
1446E:  BRA    1447C
14470:  BTFSC  xBF.4
14472:  BRA    14490
14474:  BTFSC  xBF.3
14476:  BRA    1447C
14478:  MOVLW  20
1447A:  BRA    14482
1447C:  BSF    xBF.3
1447E:  BCF    xBF.4
14480:  MOVLW  30
14482:  ADDWF  00,F
14484:  MOVF   00,W
14486:  BTFSS  FA4.4
14488:  BRA    14486
1448A:  MOVLB  F
1448C:  MOVWF  x1C
1448E:  MOVLB  8
14490:  MOVF   FEE,W
14492:  BTFSS  xBF.6
14494:  BRA    14458
14496:  MOVLB  0
14498:  GOTO   14534 (RETURN)
*
14978:  ADDWF  FE8,W
1497A:  CLRF   FF7
1497C:  RLCF   FF7,F
1497E:  ADDLW  99
14980:  MOVWF  FF6
14982:  MOVLW  49
14984:  ADDWFC FF7,F
14986:  MOVLW  01
14988:  MOVWF  FF8
1498A:  MOVWF  FFB
1498C:  TBLRD*-
1498E:  MOVF   FF5,W
14990:  MOVWF  FFA
14992:  TBLRD*
14994:  MOVF   FF5,W
14996:  MOVWF  FF9
14998:  DATA 64,45
1499A:  DATA C4,45
1499C:  DATA E0,45
1499E:  DATA FC,45
149A0:  DATA 18,46
149A2:  DATA 34,46
149A4:  DATA 50,46
149A6:  DATA 6C,46
149A8:  DATA 88,46
149AA:  DATA A4,46
149AC:  DATA C0,46
149AE:  DATA DC,46
149B0:  DATA F8,46
149B2:  DATA 14,47
149B4:  DATA 30,47
149B6:  DATA 4C,47
149B8:  DATA 68,47
149BA:  DATA 84,47
149BC:  DATA A0,47
149BE:  DATA BC,47
149C0:  DATA D8,47
149C2:  DATA F4,47
149C4:  DATA 10,48
149C6:  DATA 2C,48
149C8:  DATA 48,48
149CA:  DATA 64,48
149CC:  DATA 80,48
149CE:  DATA 9C,48
149D0:  DATA B8,48
149D2:  DATA D4,48
149D4:  DATA F0,48
149D6:  DATA 0C,49
149D8:  DATA 28,49
*
151C6:  ADDWF  FE8,W
151C8:  CLRF   FF7
151CA:  RLCF   FF7,F
151CC:  ADDLW  E7
151CE:  MOVWF  FF6
151D0:  MOVLW  51
151D2:  ADDWFC FF7,F
151D4:  MOVLW  01
151D6:  MOVWF  FF8
151D8:  MOVWF  FFB
151DA:  TBLRD*-
151DC:  MOVF   FF5,W
151DE:  MOVWF  FFA
151E0:  TBLRD*
151E2:  MOVF   FF5,W
151E4:  MOVWF  FF9
151E6:  DATA BA,4D
151E8:  DATA FA,4E
151EA:  DATA E6,4D
151EC:  DATA FA,4E
151EE:  DATA AC,4C
151F0:  DATA FA,4E
151F2:  DATA FA,4E
151F4:  DATA FA,4E
151F6:  DATA FA,4E
151F8:  DATA FA,4E
151FA:  DATA FA,4E
151FC:  DATA FA,4E
151FE:  DATA FA,4E
15200:  DATA FA,4E
15202:  DATA FA,4E
15204:  DATA FA,4E
15206:  DATA F2,4E
15208:  DATA FA,4E
1520A:  DATA FA,4E
1520C:  DATA FA,4E
1520E:  DATA FA,4E
15210:  DATA FA,4E
15212:  DATA B6,4A
15214:  DATA FA,4E
15216:  DATA EA,4A
15218:  DATA 88,4C
1521A:  DATA FA,4E
1521C:  DATA 9C,4C
1521E:  DATA 12,4E
15220:  DATA D0,4C
15222:  DATA FA,4E
15224:  DATA FA,4E
15226:  DATA 62,4D
15228:  DATA 44,4D
1522A:  DATA FA,4E
1522C:  DATA FA,4E
1522E:  DATA FA,4E
15230:  DATA 2C,4E
15232:  DATA 58,4E
15234:  DATA 84,4E
15236:  DATA 7E,4D
15238:  DATA AE,4D
1523A:  DATA FA,4E
1523C:  DATA FA,4E
1523E:  DATA FA,4E
15240:  DATA FA,4E
15242:  DATA B0,4E
15244:  DATA FA,4E
15246:  DATA FA,4E
15248:  DATA FA,4E
1524A:  DATA FA,4E
1524C:  DATA FA,4E
1524E:  DATA FA,4E
15250:  DATA FA,4E
15252:  DATA FA,4E
15254:  DATA FA,4E
15256:  DATA FA,4E
15258:  DATA B8,4C
1525A:  DATA FA,4E
1525C:  DATA FA,4E
1525E:  DATA FA,4E
15260:  DATA FA,4E
15262:  DATA E8,4C
15264:  DATA FA,4E
15266:  DATA FA,4E
15268:  DATA 0E,4D
1526A:  DATA FA,4E
1526C:  DATA FA,4E
1526E:  DATA FA,4E
15270:  DATA C6,4A
15272:  DATA FA,4E
15274:  DATA F2,4A
15276:  DATA FA,4E
15278:  DATA FA,4E
1527A:  DATA FA,4E
1527C:  DATA DA,4E
*
156E0:  ADDWF  FE8,W
156E2:  CLRF   FF7
156E4:  RLCF   FF7,F
156E6:  ADDLW  01
156E8:  MOVWF  FF6
156EA:  MOVLW  57
156EC:  ADDWFC FF7,F
156EE:  MOVLW  01
156F0:  MOVWF  FF8
156F2:  MOVWF  FFB
156F4:  TBLRD*-
156F6:  MOVF   FF5,W
156F8:  MOVWF  FFA
156FA:  TBLRD*
156FC:  MOVF   FF5,W
156FE:  MOVWF  FF9
15700:  DATA 52,55
15702:  DATA 72,55
15704:  DATA 92,55
15706:  DATA B2,55
15708:  DATA D2,55
1570A:  DATA F2,55
1570C:  DATA 12,56
*
1B21C:  ADDWF  FE8,W
1B21E:  CLRF   FF7
1B220:  RLCF   FF7,F
1B222:  ADDLW  3D
1B224:  MOVWF  FF6
1B226:  MOVLW  B2
1B228:  ADDWFC FF7,F
1B22A:  MOVLW  01
1B22C:  MOVWF  FF8
1B22E:  MOVWF  FFB
1B230:  TBLRD*-
1B232:  MOVF   FF5,W
1B234:  MOVWF  FFA
1B236:  TBLRD*
1B238:  MOVF   FF5,W
1B23A:  MOVWF  FF9
1B23C:  DATA 96,B0
1B23E:  DATA 18,B2
1B240:  DATA 9C,B0
1B242:  DATA 90,B0
1B244:  DATA 18,B2
1B246:  DATA 18,B2
1B248:  DATA 18,B2
1B24A:  DATA A2,B0
1B24C:  DATA 56,B1
1B24E:  DATA 18,B2
1B250:  DATA 72,B1
1B252:  DATA 18,B2
1B254:  DATA A8,B0
1B256:  DATA 18,B2
1B258:  DATA 18,B2
1B25A:  DATA 18,B2
1B25C:  DATA 18,B2
1B25E:  DATA 18,B2
1B260:  DATA 18,B2
1B262:  DATA 18,B2
1B264:  DATA 18,B2
1B266:  DATA 18,B2
1B268:  DATA 18,B2
1B26A:  DATA 18,B2
1B26C:  DATA 18,B2
1B26E:  DATA 18,B2
1B270:  DATA 18,B2
1B272:  DATA 18,B2
1B274:  DATA 18,B2
1B276:  DATA 18,B2
1B278:  DATA AE,B0
1B27A:  DATA B4,B0
1B27C:  DATA BA,B0
1B27E:  DATA C0,B0
1B280:  DATA C6,B0
1B282:  DATA CC,B0
1B284:  DATA D2,B0
1B286:  DATA D8,B0
1B288:  DATA DE,B0
1B28A:  DATA E4,B0
1B28C:  DATA EA,B0
1B28E:  DATA F0,B0
1B290:  DATA F6,B0
1B292:  DATA 02,B1
1B294:  DATA 08,B1
1B296:  DATA 0E,B1
1B298:  DATA 14,B1
1B29A:  DATA 1A,B1
1B29C:  DATA 20,B1
1B29E:  DATA 26,B1
1B2A0:  DATA 2C,B1
1B2A2:  DATA 32,B1
1B2A4:  DATA 38,B1
1B2A6:  DATA 3E,B1
1B2A8:  DATA 44,B1
1B2AA:  DATA 4A,B1
1B2AC:  DATA 18,B2
1B2AE:  DATA 18,B2
1B2B0:  DATA 18,B2
1B2B2:  DATA 50,B1
1B2B4:  DATA 18,B2
1B2B6:  DATA 18,B2
1B2B8:  DATA 8E,B1
1B2BA:  DATA 94,B1
1B2BC:  DATA 9A,B1
1B2BE:  DATA A0,B1
1B2C0:  DATA A6,B1
1B2C2:  DATA AC,B1
1B2C4:  DATA B2,B1
1B2C6:  DATA B8,B1
1B2C8:  DATA BE,B1
1B2CA:  DATA C4,B1
1B2CC:  DATA CA,B1
1B2CE:  DATA D0,B1
1B2D0:  DATA D6,B1
1B2D2:  DATA DC,B1
1B2D4:  DATA E2,B1
1B2D6:  DATA E8,B1
1B2D8:  DATA EE,B1
1B2DA:  DATA F4,B1
1B2DC:  DATA F8,B1
1B2DE:  DATA FC,B1
1B2E0:  DATA 00,B2
1B2E2:  DATA 04,B2
1B2E4:  DATA 0A,B2
1B2E6:  DATA 0E,B2
1B2E8:  DATA 12,B2
1B2EA:  DATA 16,B2
*
1F80A:  DATA 44,4E
1F80C:  DATA 0D,00
1F80E:  DATA 43,53
1F810:  DATA 0D,00
1F812:  DATA 57,52
1F814:  DATA 2C,20
1F816:  DATA 30,78
1F818:  DATA 25,6C
1F81A:  DATA 78,2C
1F81C:  DATA 20,25
1F81E:  DATA 75,2C
1F820:  DATA 20,00
1F822:  DATA 41,43
1F824:  DATA 4B,0D
1F826:  DATA 00,00
1F828:  DATA 4E,41
1F82A:  DATA 43,4B
1F82C:  DATA 0D,00
1F82E:  DATA 48,41
1F830:  DATA 2C,20
1F832:  DATA 30,78
1F834:  DATA 25,78
1F836:  DATA 0D,00
1F838:  DATA 0D,0A
1F83A:  DATA 40,46
1F83C:  DATA 57,55
1F83E:  DATA 0D,0A
1F840:  DATA 0A,00
*
1F8B0:  TBLRD*+
1F8B2:  MOVF   FF5,F
1F8B4:  BZ    1F8D8
1F8B6:  MOVFF  FF6,8F4
1F8BA:  MOVFF  FF7,8F5
1F8BE:  MOVFF  FF8,8F6
1F8C2:  MOVF   FF5,W
1F8C4:  BTFSS  F9E.4
1F8C6:  BRA    1F8C4
1F8C8:  MOVWF  FAD
1F8CA:  MOVFF  8F4,FF6
1F8CE:  MOVFF  8F5,FF7
1F8D2:  MOVFF  8F6,FF8
1F8D6:  BRA    1F8B0
1F8D8:  RETURN 0
1F8DA:  TBLRD*+
1F8DC:  MOVFF  FF6,8F5
1F8E0:  MOVFF  FF7,8F6
1F8E4:  MOVFF  FF8,8F7
1F8E8:  MOVF   FF5,W
1F8EA:  BTFSS  F9E.4
1F8EC:  BRA    1F8EA
1F8EE:  MOVWF  FAD
1F8F0:  MOVFF  8F5,FF6
1F8F4:  MOVFF  8F6,FF7
1F8F8:  MOVFF  8F7,FF8
1F8FC:  MOVLB  8
1F8FE:  DECFSZ xF4,F
1F900:  BRA    1F904
1F902:  BRA    1F908
1F904:  MOVLB  0
1F906:  BRA    1F8DA
1F908:  MOVLB  0
1F90A:  RETURN 0
1F90C:  MOVLB  8
1F90E:  BTFSC  xF5.7
1F910:  BRA    1F932
1F912:  MOVLW  0F
1F914:  MOVWF  00
1F916:  SWAPF  xF4,W
1F918:  ANDWF  00,F
1F91A:  MOVLW  0A
1F91C:  SUBWF  00,W
1F91E:  BC    1F926
1F920:  MOVLW  30
1F922:  ADDWF  00,F
1F924:  BRA    1F92A
1F926:  MOVF   xF5,W
1F928:  ADDWF  00,F
1F92A:  MOVF   00,W
1F92C:  BTFSS  F9E.4
1F92E:  BRA    1F92C
1F930:  MOVWF  FAD
1F932:  MOVLW  0F
1F934:  ANDWF  xF4,F
1F936:  MOVLW  0A
1F938:  SUBWF  xF4,W
1F93A:  BC    1F940
1F93C:  MOVLW  30
1F93E:  BRA    1F944
1F940:  BCF    xF5.7
1F942:  MOVF   xF5,W
1F944:  ADDWF  xF4,F
1F946:  MOVF   xF4,W
1F948:  BTFSS  F9E.4
1F94A:  BRA    1F948
1F94C:  MOVWF  FAD
1F94E:  MOVLB  0
1F950:  RETURN 0
1F952:  MOVLB  8
1F954:  MOVF   xF7,W
1F956:  CLRF   01
1F958:  SUBWF  xF6,W
1F95A:  BC    1F962
1F95C:  MOVFF  8F6,00
1F960:  BRA    1F97A
1F962:  CLRF   00
1F964:  MOVLW  08
1F966:  MOVWF  xF8
1F968:  RLCF   xF6,F
1F96A:  RLCF   00,F
1F96C:  MOVF   xF7,W
1F96E:  SUBWF  00,W
1F970:  BTFSC  FD8.0
1F972:  MOVWF  00
1F974:  RLCF   01,F
1F976:  DECFSZ xF8,F
1F978:  BRA    1F968
1F97A:  MOVLB  0
1F97C:  RETURN 0
1F97E:  MOVF   01,W
1F980:  MOVFF  8F4,8F6
1F984:  MOVLW  64
1F986:  MOVLB  8
1F988:  MOVWF  xF7
1F98A:  MOVLB  0
1F98C:  RCALL  1F952
1F98E:  MOVFF  00,8F4
1F992:  MOVF   01,W
1F994:  MOVLW  30
1F996:  BNZ   1F9A8
1F998:  MOVLB  8
1F99A:  BTFSS  xF5.1
1F99C:  BRA    1F9BA
1F99E:  BTFSC  xF5.3
1F9A0:  BRA    1F9BA
1F9A2:  BTFSC  xF5.4
1F9A4:  MOVLW  20
1F9A6:  BRA    1F9B0
1F9A8:  MOVLB  8
1F9AA:  BCF    xF5.3
1F9AC:  BCF    xF5.4
1F9AE:  BSF    xF5.0
1F9B0:  ADDWF  01,F
1F9B2:  MOVF   01,W
1F9B4:  BTFSS  F9E.4
1F9B6:  BRA    1F9B4
1F9B8:  MOVWF  FAD
1F9BA:  MOVFF  8F4,8F6
1F9BE:  MOVLW  0A
1F9C0:  MOVWF  xF7
1F9C2:  MOVLB  0
1F9C4:  RCALL  1F952
1F9C6:  MOVFF  00,8F4
1F9CA:  MOVF   01,W
1F9CC:  MOVLW  30
1F9CE:  BNZ   1F9E0
1F9D0:  MOVLB  8
1F9D2:  BTFSC  xF5.3
1F9D4:  BRA    1F9EC
1F9D6:  BTFSS  xF5.0
1F9D8:  BRA    1F9EC
1F9DA:  BTFSC  xF5.4
1F9DC:  MOVLW  20
1F9DE:  MOVLB  0
1F9E0:  ADDWF  01,F
1F9E2:  MOVF   01,W
1F9E4:  BTFSS  F9E.4
1F9E6:  BRA    1F9E4
1F9E8:  MOVWF  FAD
1F9EA:  MOVLB  8
1F9EC:  MOVLW  30
1F9EE:  ADDWF  xF4,F
1F9F0:  MOVF   xF4,W
1F9F2:  BTFSS  F9E.4
1F9F4:  BRA    1F9F2
1F9F6:  MOVWF  FAD
1F9F8:  MOVLB  0
1F9FA:  RETURN 0
1F9FC:  MOVF   FF2,W
1F9FE:  MOVWF  03
1FA00:  BCF    FF2.7
1FA02:  BSF    F7F.7
1FA04:  BSF    F7F.2
1FA06:  MOVLB  F
1FA08:  MOVLW  55
1FA0A:  MOVWF  F7E
1FA0C:  MOVLW  AA
1FA0E:  MOVWF  F7E
1FA10:  BSF    F7F.1
1FA12:  NOP   
1FA14:  MOVF   03,W
1FA16:  IORWF  FF2,F
1FA18:  MOVLB  0
1FA1A:  RETURN 0
1FA1C:  BCF    F7F.6
1FA1E:  MOVF   FF6,W
1FA20:  ANDLW  7F
1FA22:  MOVWF  00
1FA24:  MOVLW  80
1FA26:  ANDWF  FF6,F
1FA28:  TBLRD*-
1FA2A:  MOVFF  8F4,01
1FA2E:  TSTFSZ 00
1FA30:  BRA    1FA40
1FA32:  MOVFF  FEE,FF5
1FA36:  MOVF   01,F
1FA38:  BZ    1FA42
1FA3A:  TBLWT+*
1FA3C:  DECF   01,F
1FA3E:  BRA    1FA46
1FA40:  DECF   00,F
1FA42:  TBLRD+*
1FA44:  TBLWT*
1FA46:  MOVLW  7F
1FA48:  ANDWF  FF6,W
1FA4A:  XORLW  7F
1FA4C:  BNZ   1FA2E
1FA4E:  BSF    F7F.4
1FA50:  RCALL  1F9FC
1FA52:  RCALL  1F9FC
1FA54:  TSTFSZ 01
1FA56:  BRA    1FA2E
1FA58:  CLRF   FF8
1FA5A:  RETURN 0
1FA5C:  MOVFF  8F5,01
1FA60:  MOVFF  8F4,00
1FA64:  TSTFSZ 00
1FA66:  INCF   01,F
1FA68:  TBLRD*+
1FA6A:  MOVFF  FF5,FEE
1FA6E:  DECFSZ 00,F
1FA70:  BRA    1FA68
1FA72:  DECFSZ 01,F
1FA74:  BRA    1FA68
1FA76:  CLRF   FF8
1FA78:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... #CASE 
....................  
.................... //#define DEBUG_MODE  // comment-out for stand-alone operation 
....................  
.................... #ifdef DEBUG_MODE 
....................    #device ICD=TRUE 
.................... #endif 
....................  
.................... //#ifdef DEBUG_MODE 
....................    #FUSES MCLR 
.................... //#else 
....................    //#FUSES NOMCLR 
.................... //#endif 
....................  
.................... #device adc=12 
....................  
.................... // *** Watchdog Timer *** // 
.................... // WDT resolution    = 4ms 
.................... // WDT post-scalers  = 256   512,  1024  2048  4096   8192   16384  32768 
.................... // WDT time-outs     = 1.024 2.048 4.096 8.192 16.384 32.768 65.536 131.027 sec 
.................... #FUSES WDT1024                   // WDT = 1024 * 4 ms = 4.0960 sec. 
.................... #FUSES WDT_SW   
.................... //#use delay(clock=2000000) 
....................  
.................... #FUSES NOWDT 
....................  
....................  
.................... #FUSES SOSC_DIG                  // Enables C0 & C1 as digital I/O 
.................... #FUSES NOXINST                   // Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PUT                       // Power Up Timer 
.................... #FUSES NOBROWNOUT                // No brownout reset 
.................... #FUSES NOEXTADDRSFT 
....................  
.................... #FUSES NOPROTECT                 //Code not protected from reading 
.................... #FUSES NOCPD                     //No EE protection 
.................... #FUSES STVREN                    //Stack full/underflow will cause reset 
.................... #FUSES NOWRT                     //Program memory not write protected 
....................  
.................... #FUSES NOEBTR                    //Memory not protected from table reads 
.................... #FUSES NOWRTD                    //Data EEPROM not write protected 
.................... #FUSES NOWRTC                    //configuration not registers write protected 
....................  
.................... #FUSES BBSIZ2K                   //2K words Boot Block size 
.................... #FUSES NOCPB                     //No Boot Block code protection 
.................... #FUSES NOWRTB                    //Boot block not write protected 
.................... #FUSES NOEBTRB                   //Boot block not protected from table reads 
....................  
.................... #FUSES RTCOSC_INT 
....................  
.................... #use delay(internal=64mhz) 
*
02904:  MOVLW  09
02906:  MOVWF  FEA
02908:  MOVLW  EC
0290A:  MOVWF  FE9
0290C:  MOVF   FEF,W
0290E:  BZ    292C
02910:  MOVLW  14
02912:  MOVWF  01
02914:  CLRF   00
02916:  DECFSZ 00,F
02918:  BRA    2916
0291A:  DECFSZ 01,F
0291C:  BRA    2914
0291E:  MOVLW  BF
02920:  MOVWF  00
02922:  DECFSZ 00,F
02924:  BRA    2922
02926:  BRA    2928
02928:  DECFSZ FEF,F
0292A:  BRA    2910
0292C:  RETURN 0
....................  
.................... // check tris statements in init_hw.c 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
.................... #use fast_io(H) 
.................... #use fast_io(J) 
....................  
.................... #use rs232(UART1, baud=19200,parity=N,xmit=PIN_C6,rcv=PIN_C7,stream=COM_A,errors) 
*
00E2C:  BTFSS  F9E.5
00E2E:  BRA    0E2C
00E30:  MOVFF  FAB,1C
00E34:  MOVFF  FAE,01
00E38:  BTFSS  1C.1
00E3A:  BRA    0E40
00E3C:  BCF    FAB.4
00E3E:  BSF    FAB.4
00E40:  RETURN 0
*
0AEAC:  BTFSS  F9E.4
0AEAE:  BRA    AEAC
0AEB0:  MOVWF  FAD
0AEB2:  RETURN 0
.................... #use rs232(UART2, baud=9600,parity=N,xmit=PIN_G1,rcv=PIN_G2,stream=COM_B,errors) 
*
12E1E:  BTFSS  FA4.5
12E20:  BRA    12E1E
12E22:  MOVLB  F
12E24:  MOVFF  F22,1C
12E28:  MOVFF  F1D,01
12E2C:  BTFSS  1C.1
12E2E:  BRA    12E34
12E30:  BCF    x22.4
12E32:  BSF    x22.4
12E34:  MOVLB  0
12E36:  RETURN 0
*
16F4C:  BTFSS  FA4.4
16F4E:  BRA    16F4C
16F50:  MOVLB  F
16F52:  MOVWF  x1C
16F54:  MOVLB  0
16F56:  GOTO   16FFA (RETURN)
....................  
.................... // --------------------------------------------------------------------// 
.................... #define VERSION         "V2.125" 
.................... // --------------------------------------------------------------------// 
.................... #include "includes.h"    
.................... // --------------------------------------------------------------------// 
.................... // standard library code 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "firmware.c" 
.................... /* Downloads firmware over RS232 and writes it to flash  
....................   
....................    Based on the CCS supplied example loader.c, modified to only work  
....................    for 18 series  
....................   
....................    After each good line, the loader sends an ACKLOD character.  The  
....................    driver uses XON/XOFF flow control.  Also, any buffer on the PC   
....................    UART must be turned off, or to its lowest setting, otherwise it  
....................    will miss data.   
.................... */  
....................  
.................... // Some useful debugging lines  
.................... //fprintf(SENSM_STRM,"Loader End 0x%lx, Loader Size 0x%lx, Loader Addr 0x%lx\r", LOADER_END, LOADER_SIZE, LOADER_ADDR);  
.................... //fprintf(SENSM_STRM,"Flash erase size 0x%lx, Flash write size 0x%lx\r", getenv("FLASH_ERASE_SIZE"), getenv("FLASH_WRITE_SIZE"));  
....................  
.................... // Define the size of the loader in ROM and the address to write it to  
.................... //#ifndef LOADER_END  
....................    #define LOADER_END   getenv("PROGRAM_MEMORY")-1                         ///< Get the end of the program memory and put the loader there  
....................    #define LOADER_SIZE  0x7FF                                              ///< Size of the loader functions  
.................... //#endif  
.................... #define LOADER_ADDR     ( LOADER_END - LOADER_SIZE )                       ///< Address of the loader  
....................  
.................... // Set all the functions following this directive to be included in the  
.................... // loader ROM area  
.................... #pragma ORG LOADER_ADDR+10, LOADER_END default 
....................  
.................... // Serial port stream specific to this area to make the compiler create  
.................... // specific specific serial functions stored in the #ORG  
.................... #pragma use rs232(baud=19200, parity=N, UART1, bits=8, stream=LOADER_STRM)  
*
1F842:  BTFSS  F9E.4
1F844:  BRA    1F842
1F846:  MOVWF  FAD
1F848:  RETURN 0
....................  
.................... // Definitions  
.................... #define BUFFER_LEN_LOD  64     //< Length of a line in an Intel 8-bit hex file  
.................... #define ACKLOD 0x06            //< Acknowledge the last line  
.................... #define XON    0x11            //< Turn transmission on  
.................... #define XOFF   0x13            //< Turn transmission off  
....................  
.................... #define uint1_t unsigned short 
.................... #define uint8_t unsigned int 
.................... #define int8_t  signed int 
.................... #define char_t  char 
.................... #define uint16_t unsigned long  
.................... #define uint32_t unsigned long long 
....................  
.................... //******************************************************************************  
.................... /// Convert two hex chars to a byte  
.................... /*!  
.................... * \param[in] s String 2 chars long  
.................... * \return Byte value from hex  
.................... */  
.................... #pragma SEPARATE                  // The SEPARATE directive tells the compiler not to inline this function, this reduces the ROM space required  
.................... uint8_t atoi_b16(char_t *s)  
1F84A:  MOVLB  8
1F84C:  CLRF   xFA
.................... {   
....................    uint8_t result = 0;  
....................    uint8_t i;  
....................  
....................    for (i=0; i<2; i++,s++)  
1F84E:  CLRF   xFB
1F850:  MOVF   xFB,W
1F852:  SUBLW  01
1F854:  BNC   1F8A8
....................    {  
....................       if (*s >= 'A')  
1F856:  MOVFF  8F9,03
1F85A:  MOVFF  8F8,FE9
1F85E:  MOVFF  8F9,FEA
1F862:  MOVF   FEF,W
1F864:  SUBLW  40
1F866:  BC    1F884
....................       {  
....................          result = 16*result + (*s) - 'A' + 10;  
1F868:  MOVF   xFA,W
1F86A:  MULLW  10
1F86C:  MOVFF  FF3,8FC
1F870:  MOVFF  8F8,FE9
1F874:  MOVFF  8F9,FEA
1F878:  MOVF   FEF,W
1F87A:  ADDWF  xFC,W
1F87C:  ADDLW  BF
1F87E:  ADDLW  0A
1F880:  MOVWF  xFA
....................       }  
1F882:  BRA    1F89C
....................       else  
....................       {  
....................          result = 16*result + (*s) - '0';  
1F884:  MOVF   xFA,W
1F886:  MULLW  10
1F888:  MOVFF  FF3,8FC
1F88C:  MOVFF  8F8,FE9
1F890:  MOVFF  8F9,FEA
1F894:  MOVF   FEF,W
1F896:  ADDWF  xFC,W
1F898:  ADDLW  D0
1F89A:  MOVWF  xFA
....................       }  
1F89C:  MOVF   xFB,W
1F89E:  INCF   xFB,F
1F8A0:  INCF   xF8,F
1F8A2:  BTFSC  FD8.2
1F8A4:  INCF   xF9,F
1F8A6:  BRA    1F850
....................    }  
....................  
....................    return(result);  
1F8A8:  MOVFF  8FA,01
1F8AC:  MOVLB  0
1F8AE:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// Copy of the string compare function  
.................... /*!  
.................... * This does not get inlined by the compiler so I have made a copy of the CCS supplied  
.................... * library function that gets included in the #org section  
.................... * \param[in] s1 Pointer to the first string  
.................... * \param[in] s2 Pointer to the second string  
.................... * \param[in] n Number of characters to compare  
.................... * \return 0 for equal, negative or positive for not equal  
.................... */  
.................... int8_t ldr_strncmp(char_t *s1, char_t *s2, uint8_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
*
1FA7A:  MOVLB  8
1FA7C:  MOVF   xF8,F
1FA7E:  BZ    1FB02
....................    {  
....................       if (*s1 != *s2) return((*s1 <*s2) ? -1: 1);  
1FA80:  MOVFF  8F5,03
1FA84:  MOVFF  8F4,FE9
1FA88:  MOVFF  8F5,FEA
1FA8C:  MOVFF  FEF,8F9
1FA90:  MOVFF  8F7,03
1FA94:  MOVFF  8F6,FE9
1FA98:  MOVFF  8F7,FEA
1FA9C:  MOVF   FEF,W
1FA9E:  SUBWF  xF9,W
1FAA0:  BZ    1FAD0
1FAA2:  MOVFF  8F5,03
1FAA6:  MOVFF  8F4,FE9
1FAAA:  MOVFF  8F5,FEA
1FAAE:  MOVFF  FEF,8F9
1FAB2:  MOVFF  8F7,03
1FAB6:  MOVFF  8F6,FE9
1FABA:  MOVFF  8F7,FEA
1FABE:  MOVF   FEF,W
1FAC0:  SUBWF  xF9,W
1FAC2:  BC    1FAC8
1FAC4:  MOVLW  FF
1FAC6:  BRA    1FACA
1FAC8:  MOVLW  01
1FACA:  MOVWF  01
1FACC:  BRA    1FB06
1FACE:  BRA    1FAE6
....................       else if (*s1 == '\0') return(0);  
1FAD0:  MOVFF  8F5,03
1FAD4:  MOVFF  8F4,FE9
1FAD8:  MOVFF  8F5,FEA
1FADC:  MOVF   FEF,F
1FADE:  BNZ   1FAE6
1FAE0:  MOVLW  00
1FAE2:  MOVWF  01
1FAE4:  BRA    1FB06
1FAE6:  MOVFF  8F5,03
1FAEA:  MOVF   xF4,W
1FAEC:  INCF   xF4,F
1FAEE:  BTFSC  FD8.2
1FAF0:  INCF   xF5,F
1FAF2:  MOVFF  8F7,03
1FAF6:  MOVF   xF6,W
1FAF8:  INCF   xF6,F
1FAFA:  BTFSC  FD8.2
1FAFC:  INCF   xF7,F
1FAFE:  DECF   xF8,F
1FB00:  BRA    1FA7C
....................    }  
....................    return(0);  
1FB02:  MOVLW  00
1FB04:  MOVWF  01
1FB06:  MOVLB  0
1FB08:  RETURN 0
.................... }  
....................  
.................... //******************************************************************************  
.................... /// The firmware loader  
.................... /*!  
.................... * Real load function could be sat anywhere inside the #org area  
.................... */  
.................... void real_load_program (void)  
1FB0A:  MOVLB  8
1FB0C:  BCF    x85.1
1FB0E:  CLRF   x8F
1FB10:  CLRF   x8E
.................... {  
....................    uint1_t  do_ACKLOD, done=FALSE;  
....................    uint8_t  checksum, line_type, dataidx, i, count, buffidx;  
....................    uint16_t l_addr, h_addr=0;  
....................    uint32_t addr;  
....................      
....................    // Buffers  
....................    uint8_t  data[32];  
....................    uint8_t buffer[BUFFER_LEN_LOD];  
....................  
....................    // Only required for parts where the flash erase and write sizes are different 
....................    #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
....................       uint32_t next_addr = 0;  
....................    #endif  
....................     
....................    setup_uart(19200, LOADER_STRM); 
1FB12:  BSF    F65.3
1FB14:  MOVLW  40
1FB16:  MOVWF  FAF
1FB18:  MOVLW  03
1FB1A:  MOVWF  FD4
1FB1C:  MOVLW  A6
1FB1E:  MOVWF  FAC
1FB20:  MOVLW  90
1FB22:  MOVWF  FAB
....................    delay_ms(5); 
1FB24:  MOVLW  05
1FB26:  MOVLB  9
1FB28:  MOVWF  xEC
1FB2A:  MOVLB  0
1FB2C:  CALL   2904
....................  
....................    while (!done)  // Loop until the entire program is downloaded  
1FB30:  MOVLB  8
1FB32:  BTFSC  x85.1
1FB34:  BRA    1FE6A
....................    {  
....................       buffidx = 0;  // Read into the buffer until 0x0D ('\r') is received or the buffer is full  
1FB36:  CLRF   x8B
....................       do  
....................       {  
....................          buffer[buffidx] = fgetc(LOADER_STRM);  
1FB38:  CLRF   03
1FB3A:  MOVF   x8B,W
1FB3C:  ADDLW  B4
1FB3E:  MOVWF  FE9
1FB40:  MOVLW  08
1FB42:  ADDWFC 03,W
1FB44:  MOVWF  FEA
1FB46:  BTFSS  F9E.5
1FB48:  BRA    1FB46
1FB4A:  MOVFF  FAE,FEF
....................       } while ( (buffer[buffidx++] != 0x0D) && (buffidx <= BUFFER_LEN_LOD) );  
1FB4E:  MOVF   x8B,W
1FB50:  INCF   x8B,F
1FB52:  CLRF   03
1FB54:  ADDLW  B4
1FB56:  MOVWF  FE9
1FB58:  MOVLW  08
1FB5A:  ADDWFC 03,W
1FB5C:  MOVWF  FEA
1FB5E:  MOVF   FEF,W
1FB60:  SUBLW  0D
1FB62:  BZ    1FB6A
1FB64:  MOVF   x8B,W
1FB66:  SUBLW  40
1FB68:  BC    1FB38
....................  
....................       fputc(XOFF, LOADER_STRM);                                                  // Suspend sender  
1FB6A:  MOVLW  13
1FB6C:  MOVLB  0
1FB6E:  RCALL  1F842
....................       do_ACKLOD = TRUE;                                                          // Flag to indicate this is a sentence we should acknowledge  
1FB70:  MOVLB  8
1FB72:  BSF    x85.0
....................  
....................       // Only process data blocks that start with ':'  
....................       if (buffer[0] == ':')  
1FB74:  MOVF   xB4,W
1FB76:  SUBLW  3A
1FB78:  BTFSS  FD8.2
1FB7A:  BRA    1FE54
....................       {  
....................          count = atoi_b16(&buffer[1]);                                           // Get the number of bytes from the buffer  
1FB7C:  MOVLW  08
1FB7E:  MOVWF  xF9
1FB80:  MOVLW  B5
1FB82:  MOVWF  xF8
1FB84:  MOVLB  0
1FB86:  RCALL  1F84A
1FB88:  MOVFF  01,88A
....................          l_addr = make16(atoi_b16(&buffer[3]),atoi_b16(&buffer[5]));             // Get the lower 16 bits of address  
1FB8C:  MOVLW  08
1FB8E:  MOVLB  8
1FB90:  MOVWF  xF9
1FB92:  MOVLW  B7
1FB94:  MOVWF  xF8
1FB96:  MOVLB  0
1FB98:  RCALL  1F84A
1FB9A:  MOVFF  01,8F4
1FB9E:  MOVLW  08
1FBA0:  MOVLB  8
1FBA2:  MOVWF  xF9
1FBA4:  MOVLW  B9
1FBA6:  MOVWF  xF8
1FBA8:  MOVLB  0
1FBAA:  RCALL  1F84A
1FBAC:  MOVFF  8F4,88D
1FBB0:  MOVFF  01,88C
....................          line_type = atoi_b16(&buffer[7]);                                       // Get the line type code from the string  
1FBB4:  MOVLW  08
1FBB6:  MOVLB  8
1FBB8:  MOVWF  xF9
1FBBA:  MOVLW  BB
1FBBC:  MOVWF  xF8
1FBBE:  MOVLB  0
1FBC0:  RCALL  1F84A
1FBC2:  MOVFF  01,887
....................          addr = make32(h_addr,l_addr);                                           // At the first time through h_addr is zero as we are assuming the high bytes of the addr are zero until we get a type 4 command  
1FBC6:  MOVFF  88E,892
1FBCA:  MOVFF  88F,893
1FBCE:  MOVFF  88C,890
1FBD2:  MOVFF  88D,891
....................  
....................          if (line_type == 1)                                                     // If the line type is 1, then data is done being sent  
1FBD6:  MOVLB  8
1FBD8:  DECFSZ x87,W
1FBDA:  BRA    1FBF4
....................          {  
....................             done = TRUE;  
1FBDC:  BSF    x85.1
....................             fprintf(LOADER_STRM,"DN\r");  
1FBDE:  MOVLW  0A
1FBE0:  MOVWF  FF6
1FBE2:  MOVLW  F8
1FBE4:  MOVWF  FF7
1FBE6:  MOVLW  01
1FBE8:  MOVWF  FF8
1FBEA:  MOVLB  0
1FBEC:  RCALL  1F8B0
....................             do_ACKLOD = FALSE;  
1FBEE:  MOVLB  8
1FBF0:  BCF    x85.0
....................          }  
1FBF2:  BRA    1FE54
....................          else if ((addr < LOADER_ADDR || addr > LOADER_END) && addr < 0x300000)  // Don't try to overwrite the loader  
1FBF4:  MOVF   x93,F
1FBF6:  BNZ   1FC06
1FBF8:  MOVF   x92,W
1FBFA:  SUBLW  01
1FBFC:  BNC   1FC06
1FBFE:  BNZ   1FC12
1FC00:  MOVF   x91,W
1FC02:  SUBLW  F7
1FC04:  BC    1FC12
1FC06:  MOVF   x93,F
1FC08:  BNZ   1FC12
1FC0A:  MOVF   x92,W
1FC0C:  SUBLW  01
1FC0E:  BTFSC  FD8.0
1FC10:  BRA    1FE54
1FC12:  MOVF   x93,F
1FC14:  BTFSS  FD8.2
1FC16:  BRA    1FE54
1FC18:  MOVF   x92,W
1FC1A:  SUBLW  2F
1FC1C:  BTFSS  FD8.0
1FC1E:  BRA    1FE54
....................          {  
....................             checksum = 0;                                                        // Sum the bytes to find the check sum value  
1FC20:  CLRF   x86
....................             for (i=1; i<(buffidx-3); i+=2)  
1FC22:  MOVLW  01
1FC24:  MOVWF  x89
1FC26:  MOVLW  03
1FC28:  SUBWF  x8B,W
1FC2A:  SUBWF  x89,W
1FC2C:  BC    1FC5A
....................             {  
....................                checksum += atoi_b16 (&buffer[i]);  
1FC2E:  CLRF   03
1FC30:  MOVF   x89,W
1FC32:  ADDLW  B4
1FC34:  MOVWF  01
1FC36:  MOVLW  08
1FC38:  ADDWFC 03,F
1FC3A:  MOVFF  01,8F4
1FC3E:  MOVFF  03,8F5
1FC42:  MOVFF  03,8F9
1FC46:  MOVFF  01,8F8
1FC4A:  MOVLB  0
1FC4C:  RCALL  1F84A
1FC4E:  MOVF   01,W
1FC50:  MOVLB  8
1FC52:  ADDWF  x86,F
1FC54:  MOVLW  02
1FC56:  ADDWF  x89,F
1FC58:  BRA    1FC26
....................             }  
....................             checksum = 0xFF - checksum + 1;  
1FC5A:  MOVLW  FF
1FC5C:  BSF    FD8.0
1FC5E:  SUBFWB x86,W
1FC60:  ADDLW  01
1FC62:  MOVWF  x86
....................  
....................             if (checksum != atoi_b16 (&buffer[buffidx-3]))  
1FC64:  MOVLW  03
1FC66:  SUBWF  x8B,W
1FC68:  CLRF   03
1FC6A:  ADDLW  B4
1FC6C:  MOVWF  01
1FC6E:  MOVLW  08
1FC70:  ADDWFC 03,F
1FC72:  MOVFF  01,8F4
1FC76:  MOVFF  03,8F5
1FC7A:  MOVFF  03,8F9
1FC7E:  MOVFF  01,8F8
1FC82:  MOVLB  0
1FC84:  RCALL  1F84A
1FC86:  MOVF   01,W
1FC88:  MOVLB  8
1FC8A:  SUBWF  x86,W
1FC8C:  BZ    1FCA4
....................             {  
....................                fprintf(LOADER_STRM,"CS\r");                                      // Test the CheckSum and report failure  
1FC8E:  MOVLW  0E
1FC90:  MOVWF  FF6
1FC92:  MOVLW  F8
1FC94:  MOVWF  FF7
1FC96:  MOVLW  01
1FC98:  MOVWF  FF8
1FC9A:  MOVLB  0
1FC9C:  RCALL  1F8B0
....................                do_ACKLOD = FALSE;  
1FC9E:  MOVLB  8
1FCA0:  BCF    x85.0
....................             }  
1FCA2:  BRA    1FE54
....................             else  
....................             {  
....................                if (line_type == 0)  
1FCA4:  MOVF   x87,F
1FCA6:  BTFSS  FD8.2
1FCA8:  BRA    1FDF8
....................                {  
....................                   // Loops through all of the data and stores it in data  
....................                   // The last 2 bytes are the check sum, hence buffidx-3  
....................                   for (i = 9,dataidx=0; i < buffidx-3; i += 2)  
1FCAA:  MOVLW  09
1FCAC:  MOVWF  x89
1FCAE:  CLRF   x88
1FCB0:  MOVLW  03
1FCB2:  SUBWF  x8B,W
1FCB4:  SUBWF  x89,W
1FCB6:  BC    1FD02
....................                   {  
....................                      data[dataidx++] = atoi_b16(&buffer[i]);  
1FCB8:  MOVF   x88,W
1FCBA:  INCF   x88,F
1FCBC:  CLRF   03
1FCBE:  ADDLW  94
1FCC0:  MOVWF  01
1FCC2:  MOVLW  08
1FCC4:  ADDWFC 03,F
1FCC6:  MOVFF  01,8F4
1FCCA:  MOVFF  03,8F5
1FCCE:  CLRF   03
1FCD0:  MOVF   x89,W
1FCD2:  ADDLW  B4
1FCD4:  MOVWF  01
1FCD6:  MOVLW  08
1FCD8:  ADDWFC 03,F
1FCDA:  MOVFF  01,8F6
1FCDE:  MOVFF  03,8F7
1FCE2:  MOVFF  03,8F9
1FCE6:  MOVFF  01,8F8
1FCEA:  MOVLB  0
1FCEC:  RCALL  1F84A
1FCEE:  MOVFF  8F5,FEA
1FCF2:  MOVFF  8F4,FE9
1FCF6:  MOVFF  01,FEF
....................                   }  
....................  
....................                   #if (getenv("FLASH_ERASE_SIZE") > getenv("FLASH_WRITE_SIZE"))  
1FCFA:  MOVLW  02
1FCFC:  MOVLB  8
1FCFE:  ADDWF  x89,F
1FD00:  BRA    1FCB0
....................                      fprintf(LOADER_STRM,"ES\r");  
....................                      if ((addr!=next_addr)&&(addr&(getenv("FLASH_ERASE_SIZE")/2-1)!=0))  
....................                      {  
....................                         erase_program_eeprom(addr);  
....................                      }  
....................                      next_addr = addr + 1;  
....................                   #endif  
....................  
....................                   fprintf(LOADER_STRM,"WR, 0x%lx, %u, ", addr, count);  
1FD02:  MOVLW  12
1FD04:  MOVWF  FF6
1FD06:  MOVLW  F8
1FD08:  MOVWF  FF7
1FD0A:  MOVLW  01
1FD0C:  MOVWF  FF8
1FD0E:  MOVLW  06
1FD10:  MOVWF  xF4
1FD12:  MOVLB  0
1FD14:  RCALL  1F8DA
1FD16:  MOVFF  893,8F4
1FD1A:  MOVLW  57
1FD1C:  MOVLB  8
1FD1E:  MOVWF  xF5
1FD20:  MOVLB  0
1FD22:  RCALL  1F90C
1FD24:  MOVFF  892,8F4
1FD28:  MOVLW  57
1FD2A:  MOVLB  8
1FD2C:  MOVWF  xF5
1FD2E:  MOVLB  0
1FD30:  RCALL  1F90C
1FD32:  MOVFF  891,8F4
1FD36:  MOVLW  57
1FD38:  MOVLB  8
1FD3A:  MOVWF  xF5
1FD3C:  MOVLB  0
1FD3E:  RCALL  1F90C
1FD40:  MOVFF  890,8F4
1FD44:  MOVLW  57
1FD46:  MOVLB  8
1FD48:  MOVWF  xF5
1FD4A:  MOVLB  0
1FD4C:  RCALL  1F90C
1FD4E:  MOVLW  2C
1FD50:  BTFSS  F9E.4
1FD52:  BRA    1FD50
1FD54:  MOVWF  FAD
1FD56:  MOVLW  20
1FD58:  BTFSS  F9E.4
1FD5A:  BRA    1FD58
1FD5C:  MOVWF  FAD
1FD5E:  MOVFF  88A,8F4
1FD62:  MOVLW  1B
1FD64:  MOVLB  8
1FD66:  MOVWF  xF5
1FD68:  MOVLB  0
1FD6A:  RCALL  1F97E
1FD6C:  MOVLW  2C
1FD6E:  BTFSS  F9E.4
1FD70:  BRA    1FD6E
1FD72:  MOVWF  FAD
1FD74:  MOVLW  20
1FD76:  BTFSS  F9E.4
1FD78:  BRA    1FD76
1FD7A:  MOVWF  FAD
....................                   write_program_memory(addr, data, count);                             // Attempt a write to the program memory  
1FD7C:  MOVFF  892,FF8
1FD80:  MOVFF  891,FF7
1FD84:  MOVFF  890,FF6
1FD88:  MOVLW  08
1FD8A:  MOVWF  FEA
1FD8C:  MOVLW  94
1FD8E:  MOVWF  FE9
1FD90:  MOVFF  88A,8F4
1FD94:  RCALL  1FA1C
....................  
....................                   read_program_memory(addr, buffer, count);                            // Read the program memory we just wrote into the incoming string buffer to avoid having two data buffers  
1FD96:  MOVFF  892,FF8
1FD9A:  MOVFF  891,FF7
1FD9E:  MOVFF  890,FF6
1FDA2:  MOVLW  08
1FDA4:  MOVWF  FEA
1FDA6:  MOVLW  B4
1FDA8:  MOVWF  FE9
1FDAA:  MOVLB  8
1FDAC:  CLRF   xF5
1FDAE:  MOVFF  88A,8F4
1FDB2:  MOVLB  0
1FDB4:  RCALL  1FA5C
....................                   if( ldr_strncmp(data, buffer, count) == 0) fprintf(LOADER_STRM,"ACK\r"); // Test the data data  
1FDB6:  MOVLW  08
1FDB8:  MOVLB  8
1FDBA:  MOVWF  xF5
1FDBC:  MOVLW  94
1FDBE:  MOVWF  xF4
1FDC0:  MOVLW  08
1FDC2:  MOVWF  xF7
1FDC4:  MOVLW  B4
1FDC6:  MOVWF  xF6
1FDC8:  MOVFF  88A,8F8
1FDCC:  MOVLB  0
1FDCE:  RCALL  1FA7A
1FDD0:  MOVF   01,F
1FDD2:  BNZ   1FDE4
1FDD4:  MOVLW  22
1FDD6:  MOVWF  FF6
1FDD8:  MOVLW  F8
1FDDA:  MOVWF  FF7
1FDDC:  MOVLW  01
1FDDE:  MOVWF  FF8
1FDE0:  RCALL  1F8B0
1FDE2:  BRA    1FDF2
....................                   else fprintf(LOADER_STRM,"NACK\r");  
1FDE4:  MOVLW  28
1FDE6:  MOVWF  FF6
1FDE8:  MOVLW  F8
1FDEA:  MOVWF  FF7
1FDEC:  MOVLW  01
1FDEE:  MOVWF  FF8
1FDF0:  RCALL  1F8B0
....................                   do_ACKLOD = FALSE;  
1FDF2:  MOVLB  8
1FDF4:  BCF    x85.0
....................                }  
1FDF6:  BRA    1FE54
....................                else if (line_type == 4)  
1FDF8:  MOVF   x87,W
1FDFA:  SUBLW  04
1FDFC:  BNZ   1FE54
....................                {  
....................                   h_addr = make16(atoi_b16(&buffer[9]), atoi_b16(&buffer[11]));  
1FDFE:  MOVLW  08
1FE00:  MOVWF  xF9
1FE02:  MOVLW  BD
1FE04:  MOVWF  xF8
1FE06:  MOVLB  0
1FE08:  RCALL  1F84A
1FE0A:  MOVFF  01,8F4
1FE0E:  MOVLW  08
1FE10:  MOVLB  8
1FE12:  MOVWF  xF9
1FE14:  MOVLW  BF
1FE16:  MOVWF  xF8
1FE18:  MOVLB  0
1FE1A:  RCALL  1F84A
1FE1C:  MOVFF  8F4,88F
1FE20:  MOVFF  01,88E
....................                   fprintf(LOADER_STRM,"HA, 0x%x\r", h_addr);  
1FE24:  MOVLW  2E
1FE26:  MOVWF  FF6
1FE28:  MOVLW  F8
1FE2A:  MOVWF  FF7
1FE2C:  MOVLW  01
1FE2E:  MOVWF  FF8
1FE30:  MOVLW  06
1FE32:  MOVLB  8
1FE34:  MOVWF  xF4
1FE36:  MOVLB  0
1FE38:  RCALL  1F8DA
1FE3A:  MOVFF  88E,8F4
1FE3E:  MOVLW  57
1FE40:  MOVLB  8
1FE42:  MOVWF  xF5
1FE44:  MOVLB  0
1FE46:  RCALL  1F90C
1FE48:  MOVLW  0D
1FE4A:  BTFSS  F9E.4
1FE4C:  BRA    1FE4A
1FE4E:  MOVWF  FAD
....................                   do_ACKLOD = FALSE;  
1FE50:  MOVLB  8
1FE52:  BCF    x85.0
....................                }  
....................             }  
....................          }  
....................       }  
....................  
....................       if (do_ACKLOD)                     // Only do this for sentences we have not already responded to  
1FE54:  BTFSS  x85.0
1FE56:  BRA    1FE60
....................       {  
....................          fputc(ACKLOD, LOADER_STRM);  
1FE58:  MOVLW  06
1FE5A:  MOVLB  0
1FE5C:  RCALL  1F842
1FE5E:  MOVLB  8
....................       }  
....................       fputc(XON, LOADER_STRM);           // Renable transmission from the terminal program  
1FE60:  MOVLW  11
1FE62:  MOVLB  0
1FE64:  RCALL  1F842
1FE66:  BRA    1FB30
1FE68:  MOVLB  8
....................       //restart_wdt();  
....................    }  
....................  
....................    fputc(ACKLOD, LOADER_STRM);  
1FE6A:  MOVLW  06
1FE6C:  MOVLB  0
1FE6E:  RCALL  1F842
....................    fputc(XON, LOADER_STRM);  
1FE70:  MOVLW  11
1FE72:  RCALL  1F842
....................  
....................    printf("\r\n@FWU\r\n\n"); 
1FE74:  MOVLW  38
1FE76:  MOVWF  FF6
1FE78:  MOVLW  F8
1FE7A:  MOVWF  FF7
1FE7C:  MOVLW  01
1FE7E:  MOVWF  FF8
1FE80:  RCALL  1F8B0
....................    delay_ms(4000); 
1FE82:  MOVLW  10
1FE84:  MOVLB  8
1FE86:  MOVWF  xF4
1FE88:  MOVLW  FA
1FE8A:  MOVLB  9
1FE8C:  MOVWF  xEC
1FE8E:  MOVLB  0
1FE90:  CALL   2904
1FE94:  MOVLB  8
1FE96:  DECFSZ xF4,F
1FE98:  BRA    1FE88
....................    reset_cpu();                          // After writing a new program we always want to reset the CPU 
1FE9A:  RESET
1FE9C:  MOVLB  0
1FE9E:  RETURN 0
.................... }  
....................  
.................... // This #ORG ends the section holding the loader (default causes all functions within  
.................... // the declaration to be put in the ROM section)  
.................... #pragma ORG default  
....................  
.................... //******************************************************************************  
.................... /// Stub load function  
.................... /*!  
.................... * Set a stub function at a specific address so we can jump to it by changing the PC  
.................... * We must always use this as the new application version that overwrites the code won't  
.................... * necessarily have the same layout  
.................... */  
.................... #pragma ORG LOADER_ADDR, LOADER_ADDR+9  
.................... void load_program(void)  
.................... {  
....................    real_load_program();  
*
1F800:  RCALL  1FB0A
1F802:  RETURN 0
.................... }  
....................  
....................  
.................... #include "define.h" 
.................... #define  SOH                1 
.................... #define  STX                2 
.................... #define  ETX                3 
.................... #define  EOT                4 
.................... #define  ENQ                5 
.................... #define  ACK                6 
.................... #define  BEL                7 
.................... #define  BS                 8 
.................... #define  TAB                9 
.................... #define  LINE_FEED          10 
.................... #define  VT                 11 
.................... #define  FF                 12 
.................... #define  CARRIAGE_RET       13 
.................... #define  SO                 14 
.................... #define  SI                 15 
.................... #define  DLE                16 
.................... #define  DEVICE_CNTRL_1     17 
.................... #define  DEVICE_CNTRL_2     18 
.................... #define  DEVICE_CNTRL_3     19 
.................... #define  DEVICE_CNTRL_4     20 
.................... #define  NAK                21 
.................... #define  SYN                22 
.................... #define  ETB                23 
.................... #define  CAN                24 
.................... #define  EM                 25 
.................... #define  SUB                26 
.................... #define  ESCAPE             27 
.................... #define  FS                 28 
.................... #define  GS                 29 
.................... #define  RS                 30 
.................... #define  US                 31 
.................... #define  SPACE              32 
.................... #define  EXCLAMATION        33 
.................... #define  DOUBLE_QUOT        34 
.................... #define  HASH_SIGN          35 
.................... #define  DOLLAR_SIGN        36 
.................... #define  PERCENT_SIGN       37 
.................... #define  AMPERSAND          38 
.................... #define  SINGLE_QUOT        39 
.................... #define  LFT_PARANT         40 
.................... #define  RGT_PARAN          41 
.................... #define  ASTERIX            42 
.................... #define  PLUS_SIGN          43 
.................... #define  COMA               44 
.................... #define  DASH               45 
.................... #define  PRIOD              46 
.................... #define  SLASH              47 
.................... #define  ZERO               48 
.................... #define  NINE               57 
.................... #define  COLON              58 
.................... #define  QUESTION_MRK       63 
.................... #define  AT_SIGN            64 
.................... #define  TILDA              126 
.................... #define  ERR_MSG_LENGTH     20 
.................... #define  MAX_CMD_SIZE       80 
....................  
....................  
.................... enum rcvd_data_type_e 
.................... { 
....................     NO_DATA, 
....................     SOME_DATA, 
....................     DATA_COMPLETE, 
....................     RCV_TIMEOUT, 
....................     SHORT_DATA, 
....................     LONG_DATA 
.................... }; 
.................... typedef enum rcvd_data_type_e rcvd_data_type_t; 
....................  
.................... enum serial_wakeup_reason_e 
.................... { 
....................    WAKE_UP_NONE, 
....................    WAKE_UP_FALSE, 
....................    WAKE_UP_GOOD 
.................... }; 
.................... typedef enum serial_wakeup_reason_e serial_wakeup_reason_t; 
....................  
.................... #define ECO  0 
.................... #define WMS4 1 
.................... #define AWS  2 
.................... #define WMS2 3 
....................  
.................... #define TIMER0_PRESET   3036  
.................... // *** timer4 *** // 
.................... #define T4_MID_VAL 249 
.................... /*  
....................                          Freq 
....................         ------------------------------------------ = 1ms 
....................          (timer4 prescaler) * 4 * (T4_MID_VAL + 1) 
....................   
....................   
....................    So for 64MHz clock 
....................    (1 / 64000000) * 4 * 4 * 250 * 16 = 1ms 
....................   
.................... */ 
....................  
.................... #define STEP_INTERVAL 63936 
....................  
.................... // ********** MEMORY ********** // 
.................... // Stored in internal EEPROM 
.................... // UNIVERSAL VARIABLES 
.................... #define ADDR_SERIALNO          0 
.................... #define ADDR_CMD_MODE          2 
.................... #define ADDR_ALARM_YR          4 
.................... #define ADDR_LAST_MONTH        6 
.................... #define ADDR_LAST_DAY          8  
....................  
.................... #define ADDR_LAST_YEAR        10 
.................... #define ADDR_LAST_HOUR        12 
.................... #define ADDR_LAST_MIN         14 
.................... #define ADDR_LAST_SEC         16 
.................... #define ADDR_ELAPSED          18 
....................  
.................... #define ADDR_INTERVAL         20 
.................... #define ADDR_SAMPLE           22 
.................... #define ADDR_MAX_SAMPLES      24 
.................... #define ADDR_RTCfmt           26 
.................... #define ADDR_REPORT_MODE      28 
....................  
.................... #define ADDR_PRODUCT          30 
.................... #define ADDR_MACRO_MODE       32 
.................... #define ADDR_VOLUME           34 
.................... #define ADDR_PORT             36 
....................  
.................... #define ADDR_DET_TYPE         38 
....................  
.................... #define ADDR_MaxSamples       40 
....................  
.................... #define ADDR_MACRO_STEP       58 
.................... #define ADDR_COM_ERR          60 
.................... #define ADDR_SD_STATUS        62 
....................  
.................... #define ADDR_D1_TEMP          64 
.................... #define ADDR_D2_TEMP          66 
....................  
.................... #define ADDR_CAL_M1           68 
.................... #define ADDR_CAL_C1           72 
.................... #define ADDR_CAL_M2           76 
.................... #define ADDR_CAL_C2           82 
.................... #define ADDR_CAL_M3           86 
.................... #define ADDR_CAL_C3           90 
.................... #define ADDR_CAL_M4           94 
.................... #define ADDR_CAL_C4           98 
....................  
....................  
.................... // motor variables start at 110 
....................  
.................... // ********** DATA ********** // 
....................  
.................... #define SLAVE_REPLY_CHARS     81 
.................... #define SLAVE_CMD_CHARS       21 
....................  
.................... // ********** SERIAL ********* // 
....................  
.................... #define GETC_TIMEOUT 300000 
.................... #define BUFFER_SIZE 64 
.................... /* 
.................... TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
.................... bit 1 = TRMT: Transmit Shift Register Status bit 
.................... 1 = TSRx empty 
.................... 0 = TSRx full 
.................... TXSTA2 addr = 0xF21 
.................... */ 
.................... #byte TXSTA2 = 0xF21 
.................... #bit  TRMT2  = TXSTA2.1  
....................  
.................... // ********** SPI BUS ********** // 
.................... /* 
.................... SPI Mode | MOTOROLA | MICROCHIP | CCS 
.................... ----------------------------------------------------------------  
....................          | CPOL CPHA|  CKP CKE  |  
....................    0     |  0    0  |   0   1   | SPI_L_TO_H | SPI_XMIT_L_TO_H  
....................    1     |  0    1  |   0   0   | SPI_L_TO_H  
....................    2     |  1    0  |   1   1   | SPI_H_TO_L  
....................    3     |  1    1  |   1   0   | SPI_H_TO_L | SPI_XMIT_L_TO_H  
.................... */ 
....................  
.................... #define SPI_MODE_0_0 (SPI_L_TO_H | SPI_XMIT_L_TO_H)  
.................... #define SPI_MODE_0_1 (SPI_L_TO_H)  
.................... #define SPI_MODE_1_0 (SPI_H_TO_L)  
.................... #define SPI_MODE_1_1 (SPI_H_TO_L | SPI_XMIT_L_TO_H) 
....................  
.................... // *** SD PLATFORM *** // 
.................... #define BUFFER_LEN           160 
.................... #define   SD_CS        LATJ, 1    // SD/MMC Chip Select Active low 
.................... //#byte     PORTJ      = 0x0F88 
.................... #byte     LATJ         = 0x0F91 
.................... //#byte     LATB       = 0x0F8A 
.................... //#byte     INTCON     = 0x0FF2 
.................... //#byte     TMR0L      = 0x0FD6 
.................... //#define   TMR0IF     2 
.................... #byte     SSP1STAT     = 0xFC7   // SSP1 reg - slew-rate control = bit 7 
.................... #define   SMP          7         // Slew Rate Control 100kHz (1), 400kHz (0)  
....................  
.................... // ********** PINS ********** // 
....................  
.................... // LED 
.................... #define BOARD_LED    PIN_A4 
.................... #define PANEL_LED    PIN_H6 
.................... // SERIAL 
.................... #define TX1          PIN_C6 
.................... #define RX1          PIN_C7 
.................... #define TX2          PIN_G1 
.................... #define RX2          PIN_G2 
.................... // RS232 
.................... #define MD1_SHDN     PIN_J4 
.................... #define MD1_TXEN     PIN_J5 
.................... #define MD1_REN      PIN_J6 
.................... #define MD2_SHDN     PIN_G0 
.................... #define MD2_TXEN     PIN_G3 
.................... #define MD2_REN      PIN_G4 
.................... // SPI DEVICES 
.................... //#define SPI_SCK1     PIN_C3 
.................... //#define SPI_SDI1     PIN_C4 
.................... //#define SPI_SDO1     PIN_C5 
.................... #define SD1_CS       PIN_J1 
.................... #define EEP_CS       PIN_J2 
.................... #define EEP_WP       PIN_J3 
.................... #define RTC_CS       PIN_J0 
.................... // Power Switches 
.................... #define VMOT         PIN_F1 
.................... #define VDET         PIN_H7 
.................... #define VENC1        PIN_F6 
.................... #define VENC2        PIN_F7 
.................... #define VHBRDG       PIN_F2 
.................... // H-Bridge 
.................... #define HB_EN        PIN_F3 
.................... #define HB_IN1       PIN_F4 
.................... #define HB_IN2       PIN_F5 
.................... // Colorimeter 
.................... #define HSW1         PIN_D0       
.................... #define HSW2         PIN_D1       
.................... #define DAC_CL       PIN_D2 
.................... #define DAC_CS       PIN_D3 
....................  
.................... // *** DEFINE PIN STATUS *** // 
....................  
.................... // e.g. use = output_bit(RS485_FLAG, READY); 
.................... #define ON           1 
.................... #define OFF          0 
.................... #define READY        1 
.................... #define BUSY         0 
.................... #define SELECT       0 
.................... #define DESELECT     1 
.................... //#define WRITE        1 
.................... //#define PROTECT      0 
.................... #define ENABLE       0 
.................... #define DISABLE      1 
.................... #define CLEAR        0 
....................  
.................... // *** INTERRUPT / WAKE-UP MODES *** // 
.................... #define WAKEON_RTC             0 
.................... #define WAKEON_COM_A           1 
.................... #define WAKEON_COM_B           2 
.................... #define WAKEON_BAD             9 
....................  
.................... // *** DATA FILE CONSTANTS *** // 
.................... #define ROOT_DIR " " 
.................... #define DATA_RAW_ALL " draw_all.csv" 
.................... #define DATA_RAW_NEW " draw_new.csv" 
.................... #define DATA_REL_ALL " drel_all.csv" 
.................... #define DATA_REL_NEW " drel_new.csv" 
.................... #define EVENT_FILE   " events.txt" 
....................  
.................... // *** SERIAL INTERRUPT (FROM SLEEP) *** // 
.................... #BYTE    INTCON = 0x0FF2 
.................... #DEFINE  PEIE    6 
.................... #DEFINE  GIE     7 
.................... #BYTE    RCON  = 0x0FD0 
.................... #DEFINE  IPEN    7 
.................... #BYTE    PIR1  = 0x0F9E 
.................... #DEFINE  RC1IF   5 
.................... #BYTE    PIE1  = 0x0F9D 
.................... #DEFINE  RC1IE   5 
.................... #BYTE    BAUDCON1 = 0x0F65 
.................... #DEFINE  WUE     1 
....................  
....................  
....................  
....................  
....................   
....................     
....................  
....................     
....................  
....................  
....................  
.................... #include "global.h" 
.................... // 
....................  
.................... // non-volatile 
....................  
.................... // user settings 
.................... int16 nv_report_mode;               // verbose / debug feedback 
.................... int16 nv_sample;                    // sample counter 
.................... int16 nv_interval;                  // sample interval (mins) 
.................... int16 nv_serial;                    // unit serial number 
.................... int16 nv_max_samples;               // max number of samples 
.................... int16 nv_macro_mode;                // WMS hard/user macros 
.................... int16 nv_volume;                    // WMS syringe steps per sample 
.................... int16 nv_port;                       // WMS port 
.................... // code settings 
.................... int16 nv_product;                   // type of product (EcoLAB, etc.) 
.................... int16 nv_cmd_mode;                  // command mode or sampling mode 
.................... int16 MaxSamples;                   // Max Sample counter flag 
.................... int16 nv_elapsed;                   // time elapsed since last sample 
.................... int16 nv_macro_step;                // step counter for master macro 
.................... int16 valve_align_timeout = -1; 
.................... int16 valve_align_counter = -1; 
.................... // stepper 
.................... int16 nv_com_err;                    // invalid comm response counter  
.................... // sd card 
.................... int16 nv_sd_status; 
.................... int16 nv_d1_temp; 
.................... int16 nv_d2_temp; 
.................... int16 nv_det_type = 1;                  // 1=RS232 / 2=ATD(SIMPLE) / 3=MCL(SAR)  
....................  
.................... // volatile 
....................  
.................... char cmd; 
.................... int32 arg; 
.................... int8 com_echo = TRUE; 
.................... int1 rtc_alarm = FALSE; 
.................... int8 busy_status; 
.................... int1 sleep_mode = FALSE; 
.................... int1 RTC_read_flags_running = FALSE; 
.................... int8 RTCfmt; 
.................... int8 user_quit; 
.................... int8 cmd_set; 
.................... //int8 wakeup_mode;  // Mo previously removed with new RTC interrupt code 
....................  
.................... char sub_string[20]; 
.................... int8 buffer_select = 0;                 // indicates buffer to SD card append 
.................... char data_buffer[BUFFER_LEN];           // buffer_select = 0 
.................... char event_buffer[BUFFER_LEN];          // buffer select = 1 
.................... char event_str[BUFFER_LEN];  
.................... char slave_reply[SLAVE_REPLY_CHARS]; 
.................... int8 string_pos; 
.................... char time_stmp_str[30]; 
.................... char proc_time_stmp_str[30]; 
....................  
.................... int8 detector; 
.................... int8 detector_ch; 
.................... int16 detector_li; 
.................... int8 LightTargetFlag=1; 
....................  
....................  
.................... // WMS 
.................... int8 start_even_port; 
.................... int8 end_even_port; 
....................  
.................... // sd card 
.................... int8 sd_status; 
.................... char file_ptr_raw_all[14] = DATA_RAW_ALL; 
.................... char file_ptr_raw_new[14] = DATA_RAW_NEW; 
.................... char file_ptr_rel_all[14] = DATA_REL_ALL; 
.................... char file_ptr_rel_new[14] = DATA_REL_NEW;   
.................... char file_ptr_events[14]  = EVENT_FILE;  
....................  
.................... // volatile 
.................... int16 macro_flag; 
.................... char flag_str[20]; 
.................... char comma[2] ={',','\0'}; 
.................... int8 data_available = FALSE; 
....................  
.................... // chem, analysis & reading type vars 
.................... int8 channel; 
.................... char chem[5]; 
.................... char anal[4]; 
.................... char read_t[4]; 
.................... int8 read_i; 
.................... // data arrays for Abs/Conc. 
.................... // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
.................... int16 NO3_array[9]; 
.................... int16 NO2_array[9]; 
.................... int16 PO4_array[9]; 
.................... int16 NH4_array[9]; 
.................... int16 SiO_array[9]; 
.................... // calculated data arrays 
.................... float NO3_abs_array[4]; 
.................... float NO2_abs_array[4]; 
.................... float PO4_abs_array[4]; 
.................... float NH4_abs_array[4]; 
.................... float SiO_abs_array[4]; 
.................... // coeffs 
.................... float NO3_slope; 
.................... float NO3_inter; 
.................... float PO4_slope; 
.................... float PO4_inter; 
.................... float NH4_slope; 
.................... float NH4_inter; 
.................... float SiO_slope; 
.................... float SiO_inter; 
.................... // concentrations 
.................... float NO3_smp_conc; 
.................... float PO4_smp_conc; 
.................... float NH4_smp_conc; 
.................... float SiO_smp_conc; 
.................... // strings for "rel" data file 
.................... char abs_str[68]; 
.................... char coeff_str[30]; 
.................... char real_str[30]; 
....................  
.................... int16 ADC_val[8];                     // ADC result 
.................... int8  heater_stat; 
....................  
.................... // AWS 
.................... int8 bus_pwr_status; 
.................... int8 valve_status[33]; 
....................  
....................  
....................  
.................... #include "heartbeat.c" 
.................... /*  
....................    Stops timer isr from servicing WD. If heartbeat(TRUE) is not called 
....................    within 4 seconds WD will bark (=reset_cpu) 
.................... */ 
.................... void suspend_heartbeat() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
05548:  BCF    FF2.5
....................    restart_wdt(); 
0554A:  CLRWDT
0554C:  RETURN 0
.................... } 
....................  
.................... //enable timer1 int, clear t1 int, pre-set timer 
.................... void setup_led_pulse() 
.................... { 
....................    set_timer1(0); 
0554E:  CLRF   FCF
05550:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
05552:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
05554:  MOVF   2F,W
05556:  SUBLW  02
05558:  BNZ   5560
0555A:  MOVF   30,F
0555C:  BNZ   5560
0555E:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
05560:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
05562:  BSF    F9D.0
05564:  GOTO   5578 (RETURN)
.................... } 
....................  
.................... /* 
....................    Restarts servicing of WD with timer0 
.................... */ 
.................... void restart_heartbeat() 
.................... { 
....................    // pre-sets timer0, resets WDT, LED ON, clear t0 int 
....................    set_timer0(TIMER0_PRESET); 
05568:  MOVLW  0B
0556A:  MOVWF  FD7
0556C:  MOVLW  DC
0556E:  MOVWF  FD6
....................    restart_wdt(); 
05570:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
05572:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
05574:  BSF    FF2.5
....................    setup_led_pulse(); 
05576:  BRA    554E
05578:  RETURN 0
.................... } 
....................  
.................... void heartbeat(int8 beating) 
.................... { 
....................    switch(beating){ 
0557A:  MOVLB  8
0557C:  MOVF   xED,W
0557E:  XORLW  00
05580:  MOVLB  0
05582:  BZ    558A
05584:  XORLW  01
05586:  BZ    558E
05588:  BRA    5590
....................       case 0 : suspend_heartbeat(); 
0558A:  RCALL  5548
....................          break; 
0558C:  BRA    5590
....................       case 1 : restart_heartbeat(); 
0558E:  RCALL  5568
....................          break; 
....................    } 
05590:  RETURN 0
.................... } 
....................  
.................... void kill_wd() 
.................... { 
....................    disable_interrupts(INT_TIMER0); 
*
030EA:  BCF    FF2.5
....................    setup_wdt(WDT_OFF); 
030EC:  BCF    FD1.0
030EE:  RETURN 0
.................... } 
....................  
.................... void start_heartbeat() 
.................... { 
....................    set_timer0(TIMER0_PRESET);     // Preset e.g. 3036 for 1.000000 sec intervals 
*
028F4:  MOVLW  0B
028F6:  MOVWF  FD7
028F8:  MOVLW  DC
028FA:  MOVWF  FD6
....................    clear_interrupt(INT_TIMER0); 
028FC:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
028FE:  BSF    FF2.5
....................    setup_wdt(WDT_ON); 
02900:  BSF    FD1.0
02902:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
078FC:  MOVFF  9B1,9B7
07900:  MOVFF  9B0,9B6
07904:  MOVLB  9
07906:  MOVF   xB4,F
07908:  BNZ   790E
0790A:  MOVF   xB5,F
0790C:  BZ    7958
0790E:  MOVFF  9B3,03
07912:  MOVFF  9B2,FE9
07916:  MOVFF  9B3,FEA
0791A:  MOVF   FEF,F
0791C:  BZ    7958
....................      *s++ = *s2++; 
0791E:  MOVFF  9B7,9B9
07922:  MOVF   xB6,W
07924:  INCF   xB6,F
07926:  BTFSC  FD8.2
07928:  INCF   xB7,F
0792A:  MOVWF  xB8
0792C:  MOVFF  9B3,03
07930:  MOVF   xB2,W
07932:  INCF   xB2,F
07934:  BTFSC  FD8.2
07936:  INCF   xB3,F
07938:  MOVWF  FE9
0793A:  MOVFF  03,FEA
0793E:  MOVFF  FEF,9BA
07942:  MOVFF  9B9,FEA
07946:  MOVFF  9B8,FE9
0794A:  MOVFF  9BA,FEF
0794E:  MOVF   xB4,W
07950:  BTFSC  FD8.2
07952:  DECF   xB5,F
07954:  DECF   xB4,F
07956:  BRA    7906
....................   for (; n > 0; n--) 
07958:  MOVF   xB4,F
0795A:  BNZ   7960
0795C:  MOVF   xB5,F
0795E:  BZ    797E
....................      *s++ = '\0'; 
07960:  MOVFF  9B7,03
07964:  MOVF   xB6,W
07966:  INCF   xB6,F
07968:  BTFSC  FD8.2
0796A:  INCF   xB7,F
0796C:  MOVWF  FE9
0796E:  MOVFF  03,FEA
07972:  CLRF   FEF
07974:  MOVF   xB4,W
07976:  BTFSC  FD8.2
07978:  DECF   xB5,F
0797A:  DECF   xB4,F
0797C:  BRA    7958
....................  
....................   return(s1); 
0797E:  MOVFF  9B0,01
07982:  MOVFF  9B1,02
07986:  MOVLB  0
07988:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
054D2:  MOVFF  8F9,8FD
054D6:  MOVFF  8F8,8FC
054DA:  MOVFF  8FD,03
054DE:  MOVLB  8
054E0:  MOVFF  8FC,FE9
054E4:  MOVFF  8FD,FEA
054E8:  MOVF   FEF,F
054EA:  BZ    54F8
054EC:  INCF   xFC,F
054EE:  BTFSC  FD8.2
054F0:  INCF   xFD,F
054F2:  MOVLB  0
054F4:  BRA    54DA
054F6:  MOVLB  8
....................    while(*s2 != '\0') 
054F8:  MOVFF  8FB,03
054FC:  MOVFF  8FA,FE9
05500:  MOVFF  8FB,FEA
05504:  MOVF   FEF,F
05506:  BZ    5532
....................    { 
....................       *s = *s2; 
05508:  MOVFF  8FA,FE9
0550C:  MOVFF  8FB,FEA
05510:  MOVFF  FEF,900
05514:  MOVLB  9
05516:  MOVFF  8FD,FEA
0551A:  MOVFF  8FC,FE9
0551E:  MOVFF  900,FEF
....................       ++s; 
05522:  MOVLB  8
05524:  INCF   xFC,F
05526:  BTFSC  FD8.2
05528:  INCF   xFD,F
....................       ++s2; 
0552A:  INCF   xFA,F
0552C:  BTFSC  FD8.2
0552E:  INCF   xFB,F
05530:  BRA    54F8
....................    } 
....................  
....................    *s = '\0'; 
05532:  MOVFF  8FC,FE9
05536:  MOVFF  8FD,FEA
0553A:  CLRF   FEF
....................    return(s1); 
0553C:  MOVFF  8F8,01
05540:  MOVFF  8F9,02
05544:  MOVLB  0
05546:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
12D9A:  MOVFF  8EE,8F4
12D9E:  MOVFF  8ED,8F3
12DA2:  MOVFF  8F4,03
12DA6:  MOVLB  8
12DA8:  MOVFF  8F3,FE9
12DAC:  MOVFF  8F4,FEA
12DB0:  MOVF   FEF,F
12DB2:  BZ    12DC0
12DB4:  INCF   xF3,F
12DB6:  BTFSC  FD8.2
12DB8:  INCF   xF4,F
12DBA:  MOVLB  0
12DBC:  BRA    12DA2
12DBE:  MOVLB  8
....................    while(*s2 != '\0' && 0<n) 
12DC0:  MOVFF  8F0,03
12DC4:  MOVFF  8EF,FE9
12DC8:  MOVFF  8F0,FEA
12DCC:  MOVF   FEF,F
12DCE:  BZ    12E08
12DD0:  MOVF   xF2,F
12DD2:  BNZ   12DDA
12DD4:  MOVF   xF1,W
12DD6:  SUBLW  00
12DD8:  BC    12E08
....................    { 
....................       *s = *s2; 
12DDA:  MOVFF  8EF,FE9
12DDE:  MOVFF  8F0,FEA
12DE2:  MOVFF  FEF,8F7
12DE6:  MOVFF  8F4,FEA
12DEA:  MOVFF  8F3,FE9
12DEE:  MOVFF  8F7,FEF
....................       ++s; 
12DF2:  INCF   xF3,F
12DF4:  BTFSC  FD8.2
12DF6:  INCF   xF4,F
....................       ++s2; 
12DF8:  INCF   xEF,F
12DFA:  BTFSC  FD8.2
12DFC:  INCF   xF0,F
....................       --n; 
12DFE:  MOVF   xF1,W
12E00:  BTFSC  FD8.2
12E02:  DECF   xF2,F
12E04:  DECF   xF1,F
12E06:  BRA    12DC0
....................    } 
....................  
....................    *s = '\0'; 
12E08:  MOVFF  8F3,FE9
12E0C:  MOVFF  8F4,FEA
12E10:  CLRF   FEF
....................    return(s1); 
12E12:  MOVFF  8ED,01
12E16:  MOVFF  8EE,02
12E1A:  MOVLB  0
12E1C:  RETURN 0
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
04600:  MOVFF  9EA,9F0
04604:  MOVFF  9E9,9EF
04608:  MOVFF  9EC,9F2
0460C:  MOVFF  9EB,9F1
04610:  MOVLB  9
04612:  MOVF   xEE,F
04614:  BNZ   461C
04616:  MOVF   xED,W
04618:  SUBLW  00
0461A:  BC    467C
.................... { 
....................    if(*su1!=*su2) 
0461C:  MOVFF  9EF,FE9
04620:  MOVFF  9F0,FEA
04624:  MOVFF  FEF,9F3
04628:  MOVFF  9F2,03
0462C:  MOVFF  9F1,FE9
04630:  MOVFF  9F2,FEA
04634:  MOVF   FEF,W
04636:  SUBWF  xF3,W
04638:  BZ    4666
....................       return ((*su1<*su2)?-1:1); 
0463A:  MOVFF  9F0,03
0463E:  MOVFF  9EF,FE9
04642:  MOVFF  03,FEA
04646:  MOVFF  FEF,9F3
0464A:  MOVFF  9F2,03
0464E:  MOVFF  9F1,FE9
04652:  MOVFF  9F2,FEA
04656:  MOVF   FEF,W
04658:  SUBWF  xF3,W
0465A:  BC    4660
0465C:  MOVLW  FF
0465E:  BRA    4662
04660:  MOVLW  01
04662:  MOVWF  01
04664:  BRA    4680
04666:  INCF   xEF,F
04668:  BTFSC  FD8.2
0466A:  INCF   xF0,F
0466C:  INCF   xF1,F
0466E:  BTFSC  FD8.2
04670:  INCF   xF2,F
04672:  MOVF   xED,W
04674:  BTFSC  FD8.2
04676:  DECF   xEE,F
04678:  DECF   xED,F
0467A:  BRA    4612
.................... } 
.................... return 0; 
0467C:  MOVLW  00
0467E:  MOVWF  01
04680:  MOVLB  0
04682:  RETURN 0
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
12D5E:  MOVFF  8EC,8EE
12D62:  MOVFF  8EB,8ED
12D66:  MOVFF  8EE,03
12D6A:  MOVLB  8
12D6C:  MOVFF  8ED,FE9
12D70:  MOVFF  8EE,FEA
12D74:  MOVF   FEF,F
12D76:  BZ    12D84
12D78:  INCF   xED,F
12D7A:  BTFSC  FD8.2
12D7C:  INCF   xEE,F
12D7E:  MOVLB  0
12D80:  BRA    12D66
12D82:  MOVLB  8
....................    return(sc - s); 
12D84:  MOVF   xEB,W
12D86:  SUBWF  xED,W
12D88:  MOVWF  00
12D8A:  MOVF   xEC,W
12D8C:  SUBWFB xEE,W
12D8E:  MOVWF  03
12D90:  MOVFF  00,01
12D94:  MOVWF  02
12D96:  MOVLB  0
12D98:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
133DE:  MOVLB  8
133E0:  CLRF   xDA
....................    sign = 0; 
133E2:  CLRF   xD8
....................    base = 10; 
133E4:  MOVLW  0A
133E6:  MOVWF  xD9
....................    result = 0; 
133E8:  CLRF   xD7
133EA:  CLRF   xD6
....................  
....................    if (!s) 
133EC:  MOVF   xD4,W
133EE:  IORWF  xD5,W
133F0:  BNZ   133FA
....................       return 0; 
133F2:  MOVLW  00
133F4:  MOVWF  01
133F6:  MOVWF  02
133F8:  BRA    135BE
....................    c = s[index++]; 
133FA:  MOVF   xDA,W
133FC:  INCF   xDA,F
133FE:  ADDWF  xD4,W
13400:  MOVWF  FE9
13402:  MOVLW  00
13404:  ADDWFC xD5,W
13406:  MOVWF  FEA
13408:  MOVFF  FEF,8DB
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
1340C:  MOVF   xDB,W
1340E:  SUBLW  2D
13410:  BNZ   1342A
....................    { 
....................       sign = 1;         // Set the sign to negative 
13412:  MOVLW  01
13414:  MOVWF  xD8
....................       c = s[index++]; 
13416:  MOVF   xDA,W
13418:  INCF   xDA,F
1341A:  ADDWF  xD4,W
1341C:  MOVWF  FE9
1341E:  MOVLW  00
13420:  ADDWFC xD5,W
13422:  MOVWF  FEA
13424:  MOVFF  FEF,8DB
....................    } 
13428:  BRA    13442
....................    else if (c == '+') 
1342A:  MOVF   xDB,W
1342C:  SUBLW  2B
1342E:  BNZ   13442
....................    { 
....................       c = s[index++]; 
13430:  MOVF   xDA,W
13432:  INCF   xDA,F
13434:  ADDWF  xD4,W
13436:  MOVWF  FE9
13438:  MOVLW  00
1343A:  ADDWFC xD5,W
1343C:  MOVWF  FEA
1343E:  MOVFF  FEF,8DB
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
13442:  MOVF   xDB,W
13444:  SUBLW  2F
13446:  BTFSC  FD8.0
13448:  BRA    135A2
1344A:  MOVF   xDB,W
1344C:  SUBLW  39
1344E:  BTFSS  FD8.0
13450:  BRA    135A2
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
13452:  MOVF   xDB,W
13454:  SUBLW  30
13456:  BNZ   13494
13458:  MOVF   xDA,W
1345A:  ADDWF  xD4,W
1345C:  MOVWF  FE9
1345E:  MOVLW  00
13460:  ADDWFC xD5,W
13462:  MOVWF  FEA
13464:  MOVF   FEF,W
13466:  SUBLW  78
13468:  BZ    1347C
1346A:  MOVF   xDA,W
1346C:  ADDWF  xD4,W
1346E:  MOVWF  FE9
13470:  MOVLW  00
13472:  ADDWFC xD5,W
13474:  MOVWF  FEA
13476:  MOVF   FEF,W
13478:  SUBLW  58
1347A:  BNZ   13494
....................       { 
....................          base = 16; 
1347C:  MOVLW  10
1347E:  MOVWF  xD9
....................          index++; 
13480:  INCF   xDA,F
....................          c = s[index++]; 
13482:  MOVF   xDA,W
13484:  INCF   xDA,F
13486:  ADDWF  xD4,W
13488:  MOVWF  FE9
1348A:  MOVLW  00
1348C:  ADDWFC xD5,W
1348E:  MOVWF  FEA
13490:  MOVFF  FEF,8DB
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
13494:  MOVF   xD9,W
13496:  SUBLW  0A
13498:  BNZ   134DE
....................       { 
....................          while (c >= '0' && c <= '9') 
1349A:  MOVF   xDB,W
1349C:  SUBLW  2F
1349E:  BC    134DC
134A0:  MOVF   xDB,W
134A2:  SUBLW  39
134A4:  BNC   134DC
....................          { 
....................             result = 10*result + (c - '0'); 
134A6:  CLRF   xDD
134A8:  MOVLW  0A
134AA:  MOVWF  xDC
134AC:  MOVFF  8D7,8DF
134B0:  MOVFF  8D6,8DE
134B4:  MOVLB  0
134B6:  BRA    13388
134B8:  MOVLW  30
134BA:  MOVLB  8
134BC:  SUBWF  xDB,W
134BE:  ADDWF  01,W
134C0:  MOVWF  xD6
134C2:  MOVLW  00
134C4:  ADDWFC 02,W
134C6:  MOVWF  xD7
....................             c = s[index++]; 
134C8:  MOVF   xDA,W
134CA:  INCF   xDA,F
134CC:  ADDWF  xD4,W
134CE:  MOVWF  FE9
134D0:  MOVLW  00
134D2:  ADDWFC xD5,W
134D4:  MOVWF  FEA
134D6:  MOVFF  FEF,8DB
134DA:  BRA    1349A
....................          } 
....................       } 
134DC:  BRA    135A2
....................       else if (base == 16)    // The number is a hexa number 
134DE:  MOVF   xD9,W
134E0:  SUBLW  10
134E2:  BNZ   135A2
....................       { 
....................          c = toupper(c); 
134E4:  MOVF   xDB,W
134E6:  SUBLW  60
134E8:  BC    134F6
134EA:  MOVF   xDB,W
134EC:  SUBLW  7A
134EE:  BNC   134F6
134F0:  MOVF   xDB,W
134F2:  ANDLW  DF
134F4:  BRA    134F8
134F6:  MOVF   xDB,W
134F8:  MOVWF  xDB
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
134FA:  MOVF   xDB,W
134FC:  SUBLW  2F
134FE:  BC    13506
13500:  MOVF   xDB,W
13502:  SUBLW  39
13504:  BC    13512
13506:  MOVF   xDB,W
13508:  SUBLW  40
1350A:  BC    135A2
1350C:  MOVF   xDB,W
1350E:  SUBLW  46
13510:  BNC   135A2
....................          { 
....................             if (c >= '0' && c <= '9') 
13512:  MOVF   xDB,W
13514:  SUBLW  2F
13516:  BC    1354C
13518:  MOVF   xDB,W
1351A:  SUBLW  39
1351C:  BNC   1354C
....................                result = (result << 4) + (c - '0'); 
1351E:  RLCF   xD6,W
13520:  MOVWF  xDC
13522:  RLCF   xD7,W
13524:  MOVWF  xDD
13526:  RLCF   xDC,F
13528:  RLCF   xDD,F
1352A:  RLCF   xDC,F
1352C:  RLCF   xDD,F
1352E:  RLCF   xDC,F
13530:  RLCF   xDD,F
13532:  MOVLW  F0
13534:  ANDWF  xDC,F
13536:  MOVLW  30
13538:  SUBWF  xDB,W
1353A:  ADDWF  xDC,W
1353C:  MOVWF  01
1353E:  MOVLW  00
13540:  ADDWFC xDD,W
13542:  MOVWF  03
13544:  MOVFF  01,8D6
13548:  MOVWF  xD7
1354A:  BRA    13578
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
1354C:  RLCF   xD6,W
1354E:  MOVWF  xDC
13550:  RLCF   xD7,W
13552:  MOVWF  xDD
13554:  RLCF   xDC,F
13556:  RLCF   xDD,F
13558:  RLCF   xDC,F
1355A:  RLCF   xDD,F
1355C:  RLCF   xDC,F
1355E:  RLCF   xDD,F
13560:  MOVLW  F0
13562:  ANDWF  xDC,F
13564:  MOVLW  41
13566:  SUBWF  xDB,W
13568:  ADDLW  0A
1356A:  ADDWF  xDC,W
1356C:  MOVWF  01
1356E:  MOVLW  00
13570:  ADDWFC xDD,W
13572:  MOVFF  01,8D6
13576:  MOVWF  xD7
....................  
....................             c = s[index++];c = toupper(c); 
13578:  MOVF   xDA,W
1357A:  INCF   xDA,F
1357C:  ADDWF  xD4,W
1357E:  MOVWF  FE9
13580:  MOVLW  00
13582:  ADDWFC xD5,W
13584:  MOVWF  FEA
13586:  MOVFF  FEF,8DB
1358A:  MOVF   xDB,W
1358C:  SUBLW  60
1358E:  BC    1359C
13590:  MOVF   xDB,W
13592:  SUBLW  7A
13594:  BNC   1359C
13596:  MOVF   xDB,W
13598:  ANDLW  DF
1359A:  BRA    1359E
1359C:  MOVF   xDB,W
1359E:  MOVWF  xDB
135A0:  BRA    134FA
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
135A2:  MOVF   xD9,W
135A4:  SUBLW  0A
135A6:  BNZ   135B6
135A8:  DECFSZ xD8,W
135AA:  BRA    135B6
....................       result = -result; 
135AC:  COMF   xD6,F
135AE:  COMF   xD7,F
135B0:  INCF   xD6,F
135B2:  BTFSC  FD8.2
135B4:  INCF   xD7,F
....................  
....................    return(result); 
135B6:  MOVFF  8D6,01
135BA:  MOVFF  8D7,02
135BE:  MOVLB  0
135C0:  RETURN 0
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0AEB4:  MOVLB  8
0AEB6:  CLRF   x8D
....................    sign = 0; 
0AEB8:  CLRF   x8B
....................    base = 10; 
0AEBA:  MOVLW  0A
0AEBC:  MOVWF  x8C
....................    result = 0; 
0AEBE:  CLRF   x8A
0AEC0:  CLRF   x89
0AEC2:  CLRF   x88
0AEC4:  CLRF   x87
....................  
....................    if (!s) 
0AEC6:  MOVF   x85,W
0AEC8:  IORWF  x86,W
0AECA:  BNZ   AED6
....................       return 0; 
0AECC:  CLRF   00
0AECE:  CLRF   01
0AED0:  CLRF   02
0AED2:  CLRF   03
0AED4:  BRA    B144
....................    c = s[index++]; 
0AED6:  MOVF   x8D,W
0AED8:  INCF   x8D,F
0AEDA:  ADDWF  x85,W
0AEDC:  MOVWF  FE9
0AEDE:  MOVLW  00
0AEE0:  ADDWFC x86,W
0AEE2:  MOVWF  FEA
0AEE4:  MOVFF  FEF,88E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0AEE8:  MOVF   x8E,W
0AEEA:  SUBLW  2D
0AEEC:  BNZ   AF06
....................    { 
....................       sign = 1;         // Set the sign to negative 
0AEEE:  MOVLW  01
0AEF0:  MOVWF  x8B
....................       c = s[index++]; 
0AEF2:  MOVF   x8D,W
0AEF4:  INCF   x8D,F
0AEF6:  ADDWF  x85,W
0AEF8:  MOVWF  FE9
0AEFA:  MOVLW  00
0AEFC:  ADDWFC x86,W
0AEFE:  MOVWF  FEA
0AF00:  MOVFF  FEF,88E
....................    } 
0AF04:  BRA    AF1E
....................    else if (c == '+') 
0AF06:  MOVF   x8E,W
0AF08:  SUBLW  2B
0AF0A:  BNZ   AF1E
....................    { 
....................       c = s[index++]; 
0AF0C:  MOVF   x8D,W
0AF0E:  INCF   x8D,F
0AF10:  ADDWF  x85,W
0AF12:  MOVWF  FE9
0AF14:  MOVLW  00
0AF16:  ADDWFC x86,W
0AF18:  MOVWF  FEA
0AF1A:  MOVFF  FEF,88E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0AF1E:  MOVF   x8E,W
0AF20:  SUBLW  2F
0AF22:  BTFSC  FD8.0
0AF24:  BRA    B114
0AF26:  MOVF   x8E,W
0AF28:  SUBLW  39
0AF2A:  BTFSS  FD8.0
0AF2C:  BRA    B114
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0AF2E:  MOVF   x8E,W
0AF30:  SUBLW  30
0AF32:  BNZ   AF70
0AF34:  MOVF   x8D,W
0AF36:  ADDWF  x85,W
0AF38:  MOVWF  FE9
0AF3A:  MOVLW  00
0AF3C:  ADDWFC x86,W
0AF3E:  MOVWF  FEA
0AF40:  MOVF   FEF,W
0AF42:  SUBLW  78
0AF44:  BZ    AF58
0AF46:  MOVF   x8D,W
0AF48:  ADDWF  x85,W
0AF4A:  MOVWF  FE9
0AF4C:  MOVLW  00
0AF4E:  ADDWFC x86,W
0AF50:  MOVWF  FEA
0AF52:  MOVF   FEF,W
0AF54:  SUBLW  58
0AF56:  BNZ   AF70
....................       { 
....................          base = 16; 
0AF58:  MOVLW  10
0AF5A:  MOVWF  x8C
....................          index++; 
0AF5C:  INCF   x8D,F
....................          c = s[index++]; 
0AF5E:  MOVF   x8D,W
0AF60:  INCF   x8D,F
0AF62:  ADDWF  x85,W
0AF64:  MOVWF  FE9
0AF66:  MOVLW  00
0AF68:  ADDWFC x86,W
0AF6A:  MOVWF  FEA
0AF6C:  MOVFF  FEF,88E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0AF70:  MOVF   x8C,W
0AF72:  SUBLW  0A
0AF74:  BNZ   AFFC
....................       { 
....................          while (c >= '0' && c <= '9') { 
0AF76:  MOVF   x8E,W
0AF78:  SUBLW  2F
0AF7A:  BC    AFFA
0AF7C:  MOVF   x8E,W
0AF7E:  SUBLW  39
0AF80:  BNC   AFFA
....................             result = (result << 1) + (result << 3);  // result *= 10; 
0AF82:  BCF    FD8.0
0AF84:  RLCF   x87,W
0AF86:  MOVWF  x90
0AF88:  RLCF   x88,W
0AF8A:  MOVWF  x91
0AF8C:  RLCF   x89,W
0AF8E:  MOVWF  x92
0AF90:  RLCF   x8A,W
0AF92:  MOVWF  x93
0AF94:  RLCF   x87,W
0AF96:  MOVWF  00
0AF98:  RLCF   x88,W
0AF9A:  MOVWF  01
0AF9C:  RLCF   x89,W
0AF9E:  MOVWF  02
0AFA0:  RLCF   x8A,W
0AFA2:  MOVWF  03
0AFA4:  RLCF   00,F
0AFA6:  RLCF   01,F
0AFA8:  RLCF   02,F
0AFAA:  RLCF   03,F
0AFAC:  RLCF   00,F
0AFAE:  RLCF   01,F
0AFB0:  RLCF   02,F
0AFB2:  RLCF   03,F
0AFB4:  MOVLW  F8
0AFB6:  ANDWF  00,F
0AFB8:  MOVF   x90,W
0AFBA:  ADDWF  00,F
0AFBC:  MOVF   x91,W
0AFBE:  ADDWFC 01,F
0AFC0:  MOVF   x92,W
0AFC2:  ADDWFC 02,F
0AFC4:  MOVF   x93,W
0AFC6:  ADDWFC 03,F
0AFC8:  MOVFF  03,88A
0AFCC:  MOVFF  02,889
0AFD0:  MOVFF  01,888
0AFD4:  MOVFF  00,887
....................             result += (c - '0'); 
0AFD8:  MOVLW  30
0AFDA:  SUBWF  x8E,W
0AFDC:  ADDWF  x87,F
0AFDE:  MOVLW  00
0AFE0:  ADDWFC x88,F
0AFE2:  ADDWFC x89,F
0AFE4:  ADDWFC x8A,F
....................             c = s[index++]; 
0AFE6:  MOVF   x8D,W
0AFE8:  INCF   x8D,F
0AFEA:  ADDWF  x85,W
0AFEC:  MOVWF  FE9
0AFEE:  MOVLW  00
0AFF0:  ADDWFC x86,W
0AFF2:  MOVWF  FEA
0AFF4:  MOVFF  FEF,88E
0AFF8:  BRA    AF76
....................          } 
....................       } 
0AFFA:  BRA    B114
....................       else if (base == 16)    // The number is a hexa number 
0AFFC:  MOVF   x8C,W
0AFFE:  SUBLW  10
0B000:  BTFSS  FD8.2
0B002:  BRA    B114
....................       { 
....................          c = toupper(c); 
0B004:  MOVF   x8E,W
0B006:  SUBLW  60
0B008:  BC    B016
0B00A:  MOVF   x8E,W
0B00C:  SUBLW  7A
0B00E:  BNC   B016
0B010:  MOVF   x8E,W
0B012:  ANDLW  DF
0B014:  BRA    B018
0B016:  MOVF   x8E,W
0B018:  MOVWF  x8E
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
0B01A:  MOVF   x8E,W
0B01C:  SUBLW  2F
0B01E:  BC    B026
0B020:  MOVF   x8E,W
0B022:  SUBLW  39
0B024:  BC    B034
0B026:  MOVF   x8E,W
0B028:  SUBLW  40
0B02A:  BTFSC  FD8.0
0B02C:  BRA    B114
0B02E:  MOVF   x8E,W
0B030:  SUBLW  46
0B032:  BNC   B114
....................          { 
....................             if (c >= '0' && c <= '9') 
0B034:  MOVF   x8E,W
0B036:  SUBLW  2F
0B038:  BC    B096
0B03A:  MOVF   x8E,W
0B03C:  SUBLW  39
0B03E:  BNC   B096
....................                result = (result << 4) + (c - '0'); 
0B040:  RLCF   x87,W
0B042:  MOVWF  x90
0B044:  RLCF   x88,W
0B046:  MOVWF  x91
0B048:  RLCF   x89,W
0B04A:  MOVWF  x92
0B04C:  RLCF   x8A,W
0B04E:  MOVWF  x93
0B050:  RLCF   x90,F
0B052:  RLCF   x91,F
0B054:  RLCF   x92,F
0B056:  RLCF   x93,F
0B058:  RLCF   x90,F
0B05A:  RLCF   x91,F
0B05C:  RLCF   x92,F
0B05E:  RLCF   x93,F
0B060:  RLCF   x90,F
0B062:  RLCF   x91,F
0B064:  RLCF   x92,F
0B066:  RLCF   x93,F
0B068:  MOVLW  F0
0B06A:  ANDWF  x90,F
0B06C:  MOVLW  30
0B06E:  SUBWF  x8E,W
0B070:  ADDWF  x90,W
0B072:  MOVWF  00
0B074:  MOVLW  00
0B076:  ADDWFC x91,W
0B078:  MOVWF  01
0B07A:  MOVLW  00
0B07C:  ADDWFC x92,W
0B07E:  MOVWF  02
0B080:  MOVLW  00
0B082:  ADDWFC x93,W
0B084:  MOVWF  03
0B086:  MOVWF  x8A
0B088:  MOVFF  02,889
0B08C:  MOVFF  01,888
0B090:  MOVFF  00,887
0B094:  BRA    B0EA
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B096:  RLCF   x87,W
0B098:  MOVWF  x90
0B09A:  RLCF   x88,W
0B09C:  MOVWF  x91
0B09E:  RLCF   x89,W
0B0A0:  MOVWF  x92
0B0A2:  RLCF   x8A,W
0B0A4:  MOVWF  x93
0B0A6:  RLCF   x90,F
0B0A8:  RLCF   x91,F
0B0AA:  RLCF   x92,F
0B0AC:  RLCF   x93,F
0B0AE:  RLCF   x90,F
0B0B0:  RLCF   x91,F
0B0B2:  RLCF   x92,F
0B0B4:  RLCF   x93,F
0B0B6:  RLCF   x90,F
0B0B8:  RLCF   x91,F
0B0BA:  RLCF   x92,F
0B0BC:  RLCF   x93,F
0B0BE:  MOVLW  F0
0B0C0:  ANDWF  x90,F
0B0C2:  MOVLW  41
0B0C4:  SUBWF  x8E,W
0B0C6:  ADDLW  0A
0B0C8:  ADDWF  x90,W
0B0CA:  MOVWF  00
0B0CC:  MOVLW  00
0B0CE:  ADDWFC x91,W
0B0D0:  MOVWF  01
0B0D2:  MOVLW  00
0B0D4:  ADDWFC x92,W
0B0D6:  MOVWF  02
0B0D8:  MOVLW  00
0B0DA:  ADDWFC x93,W
0B0DC:  MOVWF  x8A
0B0DE:  MOVFF  02,889
0B0E2:  MOVFF  01,888
0B0E6:  MOVFF  00,887
....................  
....................             c = s[index++];c = toupper(c); 
0B0EA:  MOVF   x8D,W
0B0EC:  INCF   x8D,F
0B0EE:  ADDWF  x85,W
0B0F0:  MOVWF  FE9
0B0F2:  MOVLW  00
0B0F4:  ADDWFC x86,W
0B0F6:  MOVWF  FEA
0B0F8:  MOVFF  FEF,88E
0B0FC:  MOVF   x8E,W
0B0FE:  SUBLW  60
0B100:  BC    B10E
0B102:  MOVF   x8E,W
0B104:  SUBLW  7A
0B106:  BNC   B10E
0B108:  MOVF   x8E,W
0B10A:  ANDLW  DF
0B10C:  BRA    B110
0B10E:  MOVF   x8E,W
0B110:  MOVWF  x8E
0B112:  BRA    B01A
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
0B114:  MOVF   x8C,W
0B116:  SUBLW  0A
0B118:  BNZ   B134
0B11A:  DECFSZ x8B,W
0B11C:  BRA    B134
....................       result = -result; 
0B11E:  COMF   x87,F
0B120:  COMF   x88,F
0B122:  COMF   x89,F
0B124:  COMF   x8A,F
0B126:  INCF   x87,F
0B128:  BTFSC  FD8.2
0B12A:  INCF   x88,F
0B12C:  BTFSC  FD8.2
0B12E:  INCF   x89,F
0B130:  BTFSC  FD8.2
0B132:  INCF   x8A,F
....................  
....................    return(result); 
0B134:  MOVFF  887,00
0B138:  MOVFF  888,01
0B13C:  MOVFF  889,02
0B140:  MOVFF  88A,03
0B144:  MOVLB  0
0B146:  GOTO   1B502 (RETURN)
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
0CA9E:  MOVLB  8
0CAA0:  CLRF   xA4
0CAA2:  CLRF   xA3
0CAA4:  CLRF   xA2
0CAA6:  MOVLW  7F
0CAA8:  MOVWF  xA1
0CAAA:  CLRF   xA8
0CAAC:  CLRF   xA7
0CAAE:  CLRF   xA6
0CAB0:  CLRF   xA5
0CAB2:  BSF    xA9.0
0CAB4:  BCF    xA9.1
0CAB6:  BCF    xA9.2
0CAB8:  CLRF   xAB
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
0CABA:  MOVF   x9D,W
0CABC:  IORWF  x9E,W
0CABE:  BNZ   CACA
....................       return 0; 
0CAC0:  CLRF   00
0CAC2:  CLRF   01
0CAC4:  CLRF   02
0CAC6:  CLRF   03
0CAC8:  BRA    CCF4
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
0CACA:  MOVF   xAB,W
0CACC:  INCF   xAB,F
0CACE:  ADDWF  x9D,W
0CAD0:  MOVWF  FE9
0CAD2:  MOVLW  00
0CAD4:  ADDWFC x9E,W
0CAD6:  MOVWF  FEA
0CAD8:  MOVFF  FEF,8AA
0CADC:  MOVF   xAA,F
0CADE:  BTFSC  FD8.2
0CAE0:  BRA    CC76
....................    { 
....................       if (skip && !isspace(c)) 
0CAE2:  BTFSS  xA9.0
0CAE4:  BRA    CB04
0CAE6:  MOVF   xAA,W
0CAE8:  SUBLW  20
0CAEA:  BZ    CB04
....................       { 
....................          skip = 0; 
0CAEC:  BCF    xA9.0
....................          if (c == '+') 
0CAEE:  MOVF   xAA,W
0CAF0:  SUBLW  2B
0CAF2:  BNZ   CAFA
....................          { 
....................             sign = 0; 
0CAF4:  BCF    xA9.1
....................             continue; 
0CAF6:  BRA    CC5E
....................          }             
0CAF8:  BRA    CB04
....................          else if (c == '-') 
0CAFA:  MOVF   xAA,W
0CAFC:  SUBLW  2D
0CAFE:  BNZ   CB04
....................          { 
....................             sign = 1; 
0CB00:  BSF    xA9.1
....................             continue; 
0CB02:  BRA    CC5E
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
0CB04:  BTFSC  xA9.0
0CB06:  BRA    CB16
0CB08:  MOVF   xAA,W
0CB0A:  SUBLW  2E
0CB0C:  BNZ   CB16
0CB0E:  BTFSC  xA9.2
0CB10:  BRA    CB16
....................          point = 1; 
0CB12:  BSF    xA9.2
0CB14:  BRA    CC5E
....................       else if (!skip && isdigit(c)) 
0CB16:  BTFSC  xA9.0
0CB18:  BRA    CC58
0CB1A:  MOVF   xAA,W
0CB1C:  SUBLW  2F
0CB1E:  BTFSC  FD8.0
0CB20:  BRA    CC58
0CB22:  MOVF   xAA,W
0CB24:  SUBLW  39
0CB26:  BTFSS  FD8.0
0CB28:  BRA    CC58
....................       { 
....................          c -= '0'; 
0CB2A:  MOVLW  30
0CB2C:  SUBWF  xAA,F
....................          if (point) 
0CB2E:  BTFSS  xA9.2
0CB30:  BRA    CBDE
....................          { 
....................             pow10 = pow10 * 10.0; 
0CB32:  MOVFF  8A4,916
0CB36:  MOVFF  8A3,915
0CB3A:  MOVFF  8A2,914
0CB3E:  MOVFF  8A1,913
0CB42:  MOVLB  9
0CB44:  CLRF   x1A
0CB46:  CLRF   x19
0CB48:  MOVLW  20
0CB4A:  MOVWF  x18
0CB4C:  MOVLW  82
0CB4E:  MOVWF  x17
0CB50:  MOVLB  0
0CB52:  CALL   C2B8
0CB56:  MOVFF  03,8A4
0CB5A:  MOVFF  02,8A3
0CB5E:  MOVFF  01,8A2
0CB62:  MOVFF  00,8A1
....................             result += (float)c / pow10;    
0CB66:  MOVLB  9
0CB68:  CLRF   x18
0CB6A:  MOVFF  8AA,917
0CB6E:  MOVLB  0
0CB70:  RCALL  C8EA
0CB72:  MOVFF  03,8AF
0CB76:  MOVFF  02,8AE
0CB7A:  MOVFF  01,8AD
0CB7E:  MOVFF  00,8AC
0CB82:  MOVFF  03,8FE
0CB86:  MOVFF  02,8FD
0CB8A:  MOVFF  01,8FC
0CB8E:  MOVFF  00,8FB
0CB92:  MOVFF  8A4,902
0CB96:  MOVFF  8A3,901
0CB9A:  MOVFF  8A2,900
0CB9E:  MOVFF  8A1,8FF
0CBA2:  RCALL  C920
0CBA4:  BCF    FD8.1
0CBA6:  MOVFF  8A8,91A
0CBAA:  MOVFF  8A7,919
0CBAE:  MOVFF  8A6,918
0CBB2:  MOVFF  8A5,917
0CBB6:  MOVFF  03,91E
0CBBA:  MOVFF  02,91D
0CBBE:  MOVFF  01,91C
0CBC2:  MOVFF  00,91B
0CBC6:  CALL   C3AE
0CBCA:  MOVFF  03,8A8
0CBCE:  MOVFF  02,8A7
0CBD2:  MOVFF  01,8A6
0CBD6:  MOVFF  00,8A5
....................          } 
0CBDA:  BRA    CC54
0CBDC:  MOVLB  8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0CBDE:  MOVLB  9
0CBE0:  CLRF   x16
0CBE2:  CLRF   x15
0CBE4:  MOVLW  20
0CBE6:  MOVWF  x14
0CBE8:  MOVLW  82
0CBEA:  MOVWF  x13
0CBEC:  MOVFF  8A8,91A
0CBF0:  MOVFF  8A7,919
0CBF4:  MOVFF  8A6,918
0CBF8:  MOVFF  8A5,917
0CBFC:  MOVLB  0
0CBFE:  CALL   C2B8
0CC02:  MOVFF  03,8AF
0CC06:  MOVFF  02,8AE
0CC0A:  MOVFF  01,8AD
0CC0E:  MOVFF  00,8AC
0CC12:  MOVLB  9
0CC14:  CLRF   x18
0CC16:  MOVFF  8AA,917
0CC1A:  MOVLB  0
0CC1C:  RCALL  C8EA
0CC1E:  BCF    FD8.1
0CC20:  MOVFF  8AF,91A
0CC24:  MOVFF  8AE,919
0CC28:  MOVFF  8AD,918
0CC2C:  MOVFF  8AC,917
0CC30:  MOVFF  03,91E
0CC34:  MOVFF  02,91D
0CC38:  MOVFF  01,91C
0CC3C:  MOVFF  00,91B
0CC40:  CALL   C3AE
0CC44:  MOVFF  03,8A8
0CC48:  MOVFF  02,8A7
0CC4C:  MOVFF  01,8A6
0CC50:  MOVFF  00,8A5
....................          } 
....................       } 
0CC54:  BRA    CC60
0CC56:  MOVLB  8
....................       else if (!skip) 
0CC58:  BTFSC  xA9.0
0CC5A:  BRA    CC5E
....................          break; 
0CC5C:  BRA    CC76
0CC5E:  MOVLB  0
0CC60:  MOVLB  8
0CC62:  MOVF   xAB,W
0CC64:  INCF   xAB,F
0CC66:  ADDWF  x9D,W
0CC68:  MOVWF  FE9
0CC6A:  MOVLW  00
0CC6C:  ADDWFC x9E,W
0CC6E:  MOVWF  FEA
0CC70:  MOVFF  FEF,8AA
0CC74:  BRA    CADC
....................    } 
....................  
....................    if (sign) 
0CC76:  BTFSS  xA9.1
0CC78:  BRA    CCB0
....................       result = -1*result; 
0CC7A:  MOVLB  9
0CC7C:  CLRF   x16
0CC7E:  CLRF   x15
0CC80:  MOVLW  80
0CC82:  MOVWF  x14
0CC84:  MOVLW  7F
0CC86:  MOVWF  x13
0CC88:  MOVFF  8A8,91A
0CC8C:  MOVFF  8A7,919
0CC90:  MOVFF  8A6,918
0CC94:  MOVFF  8A5,917
0CC98:  MOVLB  0
0CC9A:  CALL   C2B8
0CC9E:  MOVFF  03,8A8
0CCA2:  MOVFF  02,8A7
0CCA6:  MOVFF  01,8A6
0CCAA:  MOVFF  00,8A5
0CCAE:  MOVLB  8
....................        
....................    if(endptr) 
0CCB0:  MOVF   x9F,W
0CCB2:  IORWF  xA0,W
0CCB4:  BZ    CCE4
....................    { 
....................       if (ptr) { 
0CCB6:  MOVF   xAB,F
0CCB8:  BZ    CCD2
....................          ptr--; 
0CCBA:  DECF   xAB,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0CCBC:  MOVFF  89F,FE9
0CCC0:  MOVFF  8A0,FEA
0CCC4:  MOVF   xAB,W
0CCC6:  ADDWF  x9D,W
0CCC8:  MOVWF  FEF
0CCCA:  MOVLW  00
0CCCC:  ADDWFC x9E,W
0CCCE:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0CCD0:  BRA    CCE4
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0CCD2:  MOVFF  89F,FE9
0CCD6:  MOVFF  8A0,FEA
0CCDA:  MOVFF  89E,FEC
0CCDE:  MOVF   FED,F
0CCE0:  MOVFF  89D,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0CCE4:  MOVFF  8A5,00
0CCE8:  MOVFF  8A6,01
0CCEC:  MOVFF  8A7,02
0CCF0:  MOVFF  8A8,03
0CCF4:  MOVLB  0
0CCF6:  GOTO   CD1E (RETURN)
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
12834:  MOVLB  9
12836:  BCF    x12.0
....................    y = x; 
12838:  MOVFF  906,90B
1283C:  MOVFF  905,90A
12840:  MOVFF  904,909
12844:  MOVFF  903,908
....................  
....................    if (x < 0) 
12848:  MOVFF  906,916
1284C:  MOVFF  905,915
12850:  MOVFF  904,914
12854:  MOVFF  903,913
12858:  CLRF   x1A
1285A:  CLRF   x19
1285C:  CLRF   x18
1285E:  CLRF   x17
12860:  MOVLB  0
12862:  CALL   1075E
12866:  BNC   12874
....................    { 
....................       s = 1; 
12868:  MOVLB  9
1286A:  BSF    x12.0
....................       y = -y; 
1286C:  MOVF   x09,W
1286E:  XORLW  80
12870:  MOVWF  x09
12872:  MOVLB  0
....................    } 
....................  
....................    if (y <= 32768.0) 
12874:  MOVFF  90B,916
12878:  MOVFF  90A,915
1287C:  MOVFF  909,914
12880:  MOVFF  908,913
12884:  MOVLB  9
12886:  CLRF   x1A
12888:  CLRF   x19
1288A:  CLRF   x18
1288C:  MOVLW  8E
1288E:  MOVWF  x17
12890:  MOVLB  0
12892:  CALL   1075E
12896:  BC    1289A
12898:  BNZ   128CA
....................       res = (float32)(unsigned int16)y; 
1289A:  MOVFF  90B,916
1289E:  MOVFF  90A,915
128A2:  MOVFF  909,914
128A6:  MOVFF  908,913
128AA:  RCALL  127F8
128AC:  MOVFF  02,918
128B0:  MOVFF  01,917
128B4:  CALL   C8EA
128B8:  MOVFF  03,90F
128BC:  MOVFF  02,90E
128C0:  MOVFF  01,90D
128C4:  MOVFF  00,90C
128C8:  BRA    12A6C
....................  
....................  else if (y < 10000000.0) 
128CA:  MOVFF  90B,916
128CE:  MOVFF  90A,915
128D2:  MOVFF  909,914
128D6:  MOVFF  908,913
128DA:  MOVLW  80
128DC:  MOVLB  9
128DE:  MOVWF  x1A
128E0:  MOVLW  96
128E2:  MOVWF  x19
128E4:  MOVLW  18
128E6:  MOVWF  x18
128E8:  MOVLW  96
128EA:  MOVWF  x17
128EC:  MOVLB  0
128EE:  CALL   1075E
128F2:  BTFSS  FD8.0
128F4:  BRA    12A5C
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
128F6:  MOVFF  90B,916
128FA:  MOVFF  90A,915
128FE:  MOVFF  909,914
12902:  MOVFF  908,913
12906:  MOVLB  9
12908:  CLRF   x1A
1290A:  CLRF   x19
1290C:  CLRF   x18
1290E:  MOVLW  70
12910:  MOVWF  x17
12912:  MOVLB  0
12914:  CALL   C2B8
12918:  MOVFF  03,916
1291C:  MOVFF  02,915
12920:  MOVFF  01,914
12924:  MOVFF  00,913
12928:  RCALL  127F8
1292A:  MOVFF  02,911
1292E:  MOVFF  01,910
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
12932:  MOVFF  90B,916
12936:  MOVFF  90A,915
1293A:  MOVFF  909,914
1293E:  MOVFF  908,913
12942:  MOVLB  9
12944:  CLRF   x1A
12946:  CLRF   x19
12948:  CLRF   x18
1294A:  MOVLW  70
1294C:  MOVWF  x17
1294E:  MOVLB  0
12950:  CALL   C2B8
12954:  MOVFF  03,916
12958:  MOVFF  02,915
1295C:  MOVFF  01,914
12960:  MOVFF  00,913
12964:  MOVFF  911,918
12968:  MOVFF  910,917
1296C:  CALL   C8EA
12970:  BSF    FD8.1
12972:  MOVFF  916,91A
12976:  MOVFF  915,919
1297A:  MOVFF  914,918
1297E:  MOVFF  913,917
12982:  MOVFF  03,91E
12986:  MOVFF  02,91D
1298A:  MOVFF  01,91C
1298E:  MOVFF  00,91B
12992:  CALL   C3AE
12996:  MOVLB  9
12998:  CLRF   x16
1299A:  CLRF   x15
1299C:  CLRF   x14
1299E:  MOVLW  8E
129A0:  MOVWF  x13
129A2:  MOVFF  03,91A
129A6:  MOVFF  02,919
129AA:  MOVFF  01,918
129AE:  MOVFF  00,917
129B2:  MOVLB  0
129B4:  CALL   C2B8
129B8:  MOVFF  03,90B
129BC:  MOVFF  02,90A
129C0:  MOVFF  01,909
129C4:  MOVFF  00,908
....................       res = 32768.0*(float32)l; 
129C8:  MOVFF  911,918
129CC:  MOVFF  910,917
129D0:  CALL   C8EA
129D4:  MOVLB  9
129D6:  CLRF   x16
129D8:  CLRF   x15
129DA:  CLRF   x14
129DC:  MOVLW  8E
129DE:  MOVWF  x13
129E0:  MOVFF  03,91A
129E4:  MOVFF  02,919
129E8:  MOVFF  01,918
129EC:  MOVFF  00,917
129F0:  MOVLB  0
129F2:  CALL   C2B8
129F6:  MOVFF  03,90F
129FA:  MOVFF  02,90E
129FE:  MOVFF  01,90D
12A02:  MOVFF  00,90C
....................       res += (float32)(unsigned int16)y; 
12A06:  MOVFF  90B,916
12A0A:  MOVFF  90A,915
12A0E:  MOVFF  909,914
12A12:  MOVFF  908,913
12A16:  RCALL  127F8
12A18:  MOVFF  02,918
12A1C:  MOVFF  01,917
12A20:  CALL   C8EA
12A24:  BCF    FD8.1
12A26:  MOVFF  90F,91A
12A2A:  MOVFF  90E,919
12A2E:  MOVFF  90D,918
12A32:  MOVFF  90C,917
12A36:  MOVFF  03,91E
12A3A:  MOVFF  02,91D
12A3E:  MOVFF  01,91C
12A42:  MOVFF  00,91B
12A46:  CALL   C3AE
12A4A:  MOVFF  03,90F
12A4E:  MOVFF  02,90E
12A52:  MOVFF  01,90D
12A56:  MOVFF  00,90C
....................    } 
12A5A:  BRA    12A6C
....................  
....................  else 
....................   res = y; 
12A5C:  MOVFF  90B,90F
12A60:  MOVFF  90A,90E
12A64:  MOVFF  909,90D
12A68:  MOVFF  908,90C
....................  
....................  y = y - (float32)(unsigned int16)y; 
12A6C:  MOVFF  90B,916
12A70:  MOVFF  90A,915
12A74:  MOVFF  909,914
12A78:  MOVFF  908,913
12A7C:  RCALL  127F8
12A7E:  MOVFF  02,918
12A82:  MOVFF  01,917
12A86:  CALL   C8EA
12A8A:  BSF    FD8.1
12A8C:  MOVFF  90B,91A
12A90:  MOVFF  90A,919
12A94:  MOVFF  909,918
12A98:  MOVFF  908,917
12A9C:  MOVFF  03,91E
12AA0:  MOVFF  02,91D
12AA4:  MOVFF  01,91C
12AA8:  MOVFF  00,91B
12AAC:  CALL   C3AE
12AB0:  MOVFF  03,90B
12AB4:  MOVFF  02,90A
12AB8:  MOVFF  01,909
12ABC:  MOVFF  00,908
....................  
....................  if (s) 
12AC0:  MOVLB  9
12AC2:  BTFSS  x12.0
12AC4:  BRA    12ACC
....................   res = -res; 
12AC6:  MOVF   x0D,W
12AC8:  XORLW  80
12ACA:  MOVWF  x0D
....................  
....................  if (y != 0) 
12ACC:  MOVFF  90B,916
12AD0:  MOVFF  90A,915
12AD4:  MOVFF  909,914
12AD8:  MOVFF  908,913
12ADC:  CLRF   x1A
12ADE:  CLRF   x19
12AE0:  CLRF   x18
12AE2:  CLRF   x17
12AE4:  MOVLB  0
12AE6:  CALL   1075E
12AEA:  BZ    12B64
....................  { 
....................   if (s == 1 && n == 0) 
12AEC:  MOVLB  9
12AEE:  BTFSS  x12.0
12AF0:  BRA    12B2A
12AF2:  MOVF   x07,F
12AF4:  BNZ   12B2A
....................    res -= 1.0; 
12AF6:  BSF    FD8.1
12AF8:  MOVFF  90F,91A
12AFC:  MOVFF  90E,919
12B00:  MOVFF  90D,918
12B04:  MOVFF  90C,917
12B08:  CLRF   x1E
12B0A:  CLRF   x1D
12B0C:  CLRF   x1C
12B0E:  MOVLW  7F
12B10:  MOVWF  x1B
12B12:  MOVLB  0
12B14:  CALL   C3AE
12B18:  MOVFF  03,90F
12B1C:  MOVFF  02,90E
12B20:  MOVFF  01,90D
12B24:  MOVFF  00,90C
12B28:  MOVLB  9
....................  
....................   if (s == 0 && n == 1) 
12B2A:  BTFSC  x12.0
12B2C:  BRA    12B66
12B2E:  DECFSZ x07,W
12B30:  BRA    12B66
....................    res += 1.0; 
12B32:  BCF    FD8.1
12B34:  MOVFF  90F,91A
12B38:  MOVFF  90E,919
12B3C:  MOVFF  90D,918
12B40:  MOVFF  90C,917
12B44:  CLRF   x1E
12B46:  CLRF   x1D
12B48:  CLRF   x1C
12B4A:  MOVLW  7F
12B4C:  MOVWF  x1B
12B4E:  MOVLB  0
12B50:  CALL   C3AE
12B54:  MOVFF  03,90F
12B58:  MOVFF  02,90E
12B5C:  MOVFF  01,90D
12B60:  MOVFF  00,90C
12B64:  MOVLB  9
....................  } 
....................  if (x == 0) 
12B66:  MOVFF  906,916
12B6A:  MOVFF  905,915
12B6E:  MOVFF  904,914
12B72:  MOVFF  903,913
12B76:  CLRF   x1A
12B78:  CLRF   x19
12B7A:  CLRF   x18
12B7C:  CLRF   x17
12B7E:  MOVLB  0
12B80:  CALL   1075E
12B84:  BNZ   12B92
....................     res = 0; 
12B86:  MOVLB  9
12B88:  CLRF   x0F
12B8A:  CLRF   x0E
12B8C:  CLRF   x0D
12B8E:  CLRF   x0C
12B90:  MOVLB  0
....................  
....................  return (res); 
12B92:  MOVFF  90C,00
12B96:  MOVFF  90D,01
12B9A:  MOVFF  90E,02
12B9E:  MOVFF  90F,03
12BA2:  RETURN 0
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
12BC2:  MOVFF  902,906
12BC6:  MOVFF  901,905
12BCA:  MOVFF  900,904
12BCE:  MOVFF  8FF,903
12BD2:  MOVLB  9
12BD4:  CLRF   x07
12BD6:  MOVLB  0
12BD8:  RCALL  12834
12BDA:  GOTO   12CE6 (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
12BA4:  MOVFF  902,906
12BA8:  MOVFF  901,905
12BAC:  MOVFF  900,904
12BB0:  MOVFF  8FF,903
12BB4:  MOVLW  01
12BB6:  MOVLB  9
12BB8:  MOVWF  x07
12BBA:  MOVLB  0
12BBC:  RCALL  12834
12BBE:  GOTO   12C9E (RETURN)
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
*
12BDE:  MOVFF  8F6,916
12BE2:  MOVFF  8F5,915
12BE6:  MOVFF  8F4,914
12BEA:  MOVFF  8F3,913
12BEE:  MOVLB  9
12BF0:  CLRF   x1A
12BF2:  CLRF   x19
12BF4:  CLRF   x18
12BF6:  CLRF   x17
12BF8:  MOVLB  0
12BFA:  CALL   1075E
12BFE:  BTFSC  FD8.2
12C00:  BRA    12D42
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
12C02:  MOVFF  8F2,8FE
12C06:  MOVFF  8F1,8FD
12C0A:  MOVFF  8F0,8FC
12C0E:  MOVFF  8EF,8FB
12C12:  MOVFF  8F6,902
12C16:  MOVFF  8F5,901
12C1A:  MOVFF  8F4,900
12C1E:  MOVFF  8F3,8FF
12C22:  CALL   C920
12C26:  MOVFF  03,8FE
12C2A:  MOVFF  02,8FD
12C2E:  MOVFF  01,8FC
12C32:  MOVFF  00,8FB
12C36:  MOVFF  03,916
12C3A:  MOVFF  02,915
12C3E:  MOVFF  01,914
12C42:  MOVFF  00,913
12C46:  MOVLB  9
12C48:  CLRF   x1A
12C4A:  CLRF   x19
12C4C:  CLRF   x18
12C4E:  CLRF   x17
12C50:  MOVLB  0
12C52:  CALL   1075E
12C56:  BNC   12CA0
12C58:  MOVFF  8F2,8FE
12C5C:  MOVFF  8F1,8FD
12C60:  MOVFF  8F0,8FC
12C64:  MOVFF  8EF,8FB
12C68:  MOVFF  8F6,902
12C6C:  MOVFF  8F5,901
12C70:  MOVFF  8F4,900
12C74:  MOVFF  8F3,8FF
12C78:  CALL   C920
12C7C:  MOVFF  03,8FE
12C80:  MOVFF  02,8FD
12C84:  MOVFF  01,8FC
12C88:  MOVFF  00,8FB
12C8C:  MOVFF  03,902
12C90:  MOVFF  02,901
12C94:  MOVFF  01,900
12C98:  MOVFF  00,8FF
12C9C:  BRA    12BA4
12C9E:  BRA    12CE6
12CA0:  MOVFF  8F2,8FE
12CA4:  MOVFF  8F1,8FD
12CA8:  MOVFF  8F0,8FC
12CAC:  MOVFF  8EF,8FB
12CB0:  MOVFF  8F6,902
12CB4:  MOVFF  8F5,901
12CB8:  MOVFF  8F4,900
12CBC:  MOVFF  8F3,8FF
12CC0:  CALL   C920
12CC4:  MOVFF  03,8FE
12CC8:  MOVFF  02,8FD
12CCC:  MOVFF  01,8FC
12CD0:  MOVFF  00,8FB
12CD4:  MOVFF  03,902
12CD8:  MOVFF  02,901
12CDC:  MOVFF  01,900
12CE0:  MOVFF  00,8FF
12CE4:  BRA    12BC2
12CE6:  MOVFF  03,8FA
12CEA:  MOVFF  02,8F9
12CEE:  MOVFF  01,8F8
12CF2:  MOVFF  00,8F7
....................       return(x-(i*y)); 
12CF6:  MOVFF  8FA,916
12CFA:  MOVFF  8F9,915
12CFE:  MOVFF  8F8,914
12D02:  MOVFF  8F7,913
12D06:  MOVFF  8F6,91A
12D0A:  MOVFF  8F5,919
12D0E:  MOVFF  8F4,918
12D12:  MOVFF  8F3,917
12D16:  CALL   C2B8
12D1A:  BSF    FD8.1
12D1C:  MOVFF  8F2,91A
12D20:  MOVFF  8F1,919
12D24:  MOVFF  8F0,918
12D28:  MOVFF  8EF,917
12D2C:  MOVFF  03,91E
12D30:  MOVFF  02,91D
12D34:  MOVFF  01,91C
12D38:  MOVFF  00,91B
12D3C:  CALL   C3AE
12D40:  BRA    12D42
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
12D42:  GOTO   12FDA (RETURN)
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
*
10828:  MOVFF  8DA,8DE
1082C:  MOVFF  8D9,8DD
10830:  MOVFF  8D8,8DC
10834:  MOVFF  8D7,8DB
....................  
....................    if (y != 1.0) 
10838:  MOVFF  8DE,916
1083C:  MOVFF  8DD,915
10840:  MOVFF  8DC,914
10844:  MOVFF  8DB,913
10848:  MOVLB  9
1084A:  CLRF   x1A
1084C:  CLRF   x19
1084E:  CLRF   x18
10850:  MOVLW  7F
10852:  MOVWF  x17
10854:  MOVLB  0
10856:  RCALL  1075E
10858:  BTFSC  FD8.2
1085A:  BRA    10B9C
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
1085C:  MOVLW  08
1085E:  MOVLB  8
10860:  MOVWF  xED
10862:  MOVLW  DB
10864:  MOVWF  FE9
10866:  MOVFF  8ED,FEA
1086A:  MOVLW  7E
1086C:  MOVWF  FEF
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
1086E:  BSF    FD8.1
10870:  MOVFF  8DE,91A
10874:  MOVFF  8DD,919
10878:  MOVFF  8DC,918
1087C:  MOVFF  8DB,917
10880:  MOVLB  9
10882:  CLRF   x1E
10884:  CLRF   x1D
10886:  CLRF   x1C
10888:  MOVLW  7F
1088A:  MOVWF  x1B
1088C:  MOVLB  0
1088E:  CALL   C3AE
10892:  MOVFF  03,8EF
10896:  MOVFF  02,8EE
1089A:  MOVFF  01,8ED
1089E:  MOVFF  00,8EC
108A2:  BCF    FD8.1
108A4:  MOVFF  8DE,91A
108A8:  MOVFF  8DD,919
108AC:  MOVFF  8DC,918
108B0:  MOVFF  8DB,917
108B4:  MOVLB  9
108B6:  CLRF   x1E
108B8:  CLRF   x1D
108BA:  CLRF   x1C
108BC:  MOVLW  7F
108BE:  MOVWF  x1B
108C0:  MOVLB  0
108C2:  CALL   C3AE
108C6:  MOVFF  8EF,8FE
108CA:  MOVFF  8EE,8FD
108CE:  MOVFF  8ED,8FC
108D2:  MOVFF  8EC,8FB
108D6:  MOVFF  03,902
108DA:  MOVFF  02,901
108DE:  MOVFF  01,900
108E2:  MOVFF  00,8FF
108E6:  CALL   C920
108EA:  MOVFF  03,8DE
108EE:  MOVFF  02,8DD
108F2:  MOVFF  01,8DC
108F6:  MOVFF  00,8DB
....................  
....................       y2=y*y; 
108FA:  MOVFF  8DE,916
108FE:  MOVFF  8DD,915
10902:  MOVFF  8DC,914
10906:  MOVFF  8DB,913
1090A:  MOVFF  8DE,91A
1090E:  MOVFF  8DD,919
10912:  MOVFF  8DC,918
10916:  MOVFF  8DB,917
1091A:  CALL   C2B8
1091E:  MOVFF  03,8EA
10922:  MOVFF  02,8E9
10926:  MOVFF  01,8E8
1092A:  MOVFF  00,8E7
....................  
....................       res = pl[0]*y2 + pl[1]; 
1092E:  MOVLW  99
10930:  MOVLB  9
10932:  MOVWF  x16
10934:  MOVLW  47
10936:  MOVWF  x15
10938:  MOVLW  8A
1093A:  MOVWF  x14
1093C:  MOVLW  7F
1093E:  MOVWF  x13
10940:  MOVFF  8EA,91A
10944:  MOVFF  8E9,919
10948:  MOVFF  8E8,918
1094C:  MOVFF  8E7,917
10950:  MOVLB  0
10952:  CALL   C2B8
10956:  MOVFF  03,8EF
1095A:  MOVFF  02,8EE
1095E:  MOVFF  01,8ED
10962:  MOVFF  00,8EC
10966:  BCF    FD8.1
10968:  MOVFF  03,91A
1096C:  MOVFF  02,919
10970:  MOVFF  01,918
10974:  MOVFF  00,917
10978:  MOVLB  9
1097A:  CLRF   x1E
1097C:  CLRF   x1D
1097E:  CLRF   x1C
10980:  MOVLW  80
10982:  MOVWF  x1B
10984:  MOVLB  0
10986:  CALL   C3AE
1098A:  MOVFF  03,8E2
1098E:  MOVFF  02,8E1
10992:  MOVFF  01,8E0
10996:  MOVFF  00,8DF
....................  
....................       r = ql[0]*y2 + ql[1]; 
1099A:  MOVLW  4C
1099C:  MOVLB  9
1099E:  MOVWF  x16
109A0:  MOVLW  F3
109A2:  MOVWF  x15
109A4:  MOVLW  3A
109A6:  MOVWF  x14
109A8:  MOVLW  7B
109AA:  MOVWF  x13
109AC:  MOVFF  8EA,91A
109B0:  MOVFF  8E9,919
109B4:  MOVFF  8E8,918
109B8:  MOVFF  8E7,917
109BC:  MOVLB  0
109BE:  CALL   C2B8
109C2:  MOVFF  03,8EF
109C6:  MOVFF  02,8EE
109CA:  MOVFF  01,8ED
109CE:  MOVFF  00,8EC
109D2:  BCF    FD8.1
109D4:  MOVFF  03,91A
109D8:  MOVFF  02,919
109DC:  MOVFF  01,918
109E0:  MOVFF  00,917
109E4:  MOVLW  2B
109E6:  MOVLB  9
109E8:  MOVWF  x1E
109EA:  MOVLW  9D
109EC:  MOVWF  x1D
109EE:  MOVLW  DF
109F0:  MOVWF  x1C
109F2:  MOVLW  7E
109F4:  MOVWF  x1B
109F6:  MOVLB  0
109F8:  CALL   C3AE
109FC:  MOVFF  03,8E6
10A00:  MOVFF  02,8E5
10A04:  MOVFF  01,8E4
10A08:  MOVFF  00,8E3
....................       r = r*y2 + 1.0; 
10A0C:  MOVFF  8E6,916
10A10:  MOVFF  8E5,915
10A14:  MOVFF  8E4,914
10A18:  MOVFF  8E3,913
10A1C:  MOVFF  8EA,91A
10A20:  MOVFF  8E9,919
10A24:  MOVFF  8E8,918
10A28:  MOVFF  8E7,917
10A2C:  CALL   C2B8
10A30:  MOVFF  03,8EF
10A34:  MOVFF  02,8EE
10A38:  MOVFF  01,8ED
10A3C:  MOVFF  00,8EC
10A40:  BCF    FD8.1
10A42:  MOVFF  03,91A
10A46:  MOVFF  02,919
10A4A:  MOVFF  01,918
10A4E:  MOVFF  00,917
10A52:  MOVLB  9
10A54:  CLRF   x1E
10A56:  CLRF   x1D
10A58:  CLRF   x1C
10A5A:  MOVLW  7F
10A5C:  MOVWF  x1B
10A5E:  MOVLB  0
10A60:  CALL   C3AE
10A64:  MOVFF  03,8E6
10A68:  MOVFF  02,8E5
10A6C:  MOVFF  01,8E4
10A70:  MOVFF  00,8E3
....................  
....................       res = y*res/r; 
10A74:  MOVFF  8DE,916
10A78:  MOVFF  8DD,915
10A7C:  MOVFF  8DC,914
10A80:  MOVFF  8DB,913
10A84:  MOVFF  8E2,91A
10A88:  MOVFF  8E1,919
10A8C:  MOVFF  8E0,918
10A90:  MOVFF  8DF,917
10A94:  CALL   C2B8
10A98:  MOVFF  03,8EF
10A9C:  MOVFF  02,8EE
10AA0:  MOVFF  01,8ED
10AA4:  MOVFF  00,8EC
10AA8:  MOVFF  03,8FE
10AAC:  MOVFF  02,8FD
10AB0:  MOVFF  01,8FC
10AB4:  MOVFF  00,8FB
10AB8:  MOVFF  8E6,902
10ABC:  MOVFF  8E5,901
10AC0:  MOVFF  8E4,900
10AC4:  MOVFF  8E3,8FF
10AC8:  CALL   C920
10ACC:  MOVFF  03,8E2
10AD0:  MOVFF  02,8E1
10AD4:  MOVFF  01,8E0
10AD8:  MOVFF  00,8DF
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
10ADC:  MOVLW  08
10ADE:  MOVLB  8
10AE0:  MOVWF  xED
10AE2:  MOVLW  D7
10AE4:  MOVWF  FE9
10AE6:  MOVFF  8ED,FEA
10AEA:  MOVLW  7E
10AEC:  SUBWF  FEF,W
10AEE:  MOVWF  xEB
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
10AF0:  BTFSS  xEB.7
10AF2:  BRA    10B1C
....................          r = -(float32)-n; 
10AF4:  MOVLW  00
10AF6:  BSF    FD8.0
10AF8:  SUBFWB xEB,W
10AFA:  CLRF   xED
10AFC:  MOVWF  xEC
10AFE:  BTFSC  xEC.7
10B00:  DECF   xED,F
10B02:  MOVLB  0
10B04:  RCALL  107D8
10B06:  MOVFF  00,8E3
10B0A:  MOVF   01,W
10B0C:  XORLW  80
10B0E:  MOVLB  8
10B10:  MOVWF  xE4
10B12:  MOVFF  02,8E5
10B16:  MOVFF  03,8E6
10B1A:  BRA    10B3C
....................       else 
....................          r = (float32)n; 
10B1C:  CLRF   xED
10B1E:  MOVFF  8EB,8EC
10B22:  BTFSC  xEC.7
10B24:  DECF   xED,F
10B26:  MOVLB  0
10B28:  RCALL  107D8
10B2A:  MOVFF  03,8E6
10B2E:  MOVFF  02,8E5
10B32:  MOVFF  01,8E4
10B36:  MOVFF  00,8E3
10B3A:  MOVLB  8
....................  
....................       res += r*LN2; 
10B3C:  MOVFF  8E6,916
10B40:  MOVFF  8E5,915
10B44:  MOVFF  8E4,914
10B48:  MOVFF  8E3,913
10B4C:  MOVLW  18
10B4E:  MOVLB  9
10B50:  MOVWF  x1A
10B52:  MOVLW  72
10B54:  MOVWF  x19
10B56:  MOVLW  31
10B58:  MOVWF  x18
10B5A:  MOVLW  7E
10B5C:  MOVWF  x17
10B5E:  MOVLB  0
10B60:  CALL   C2B8
10B64:  BCF    FD8.1
10B66:  MOVFF  8E2,91A
10B6A:  MOVFF  8E1,919
10B6E:  MOVFF  8E0,918
10B72:  MOVFF  8DF,917
10B76:  MOVFF  03,91E
10B7A:  MOVFF  02,91D
10B7E:  MOVFF  01,91C
10B82:  MOVFF  00,91B
10B86:  CALL   C3AE
10B8A:  MOVFF  03,8E2
10B8E:  MOVFF  02,8E1
10B92:  MOVFF  01,8E0
10B96:  MOVFF  00,8DF
....................    } 
10B9A:  BRA    10BA8
....................  
....................    else 
....................       res = 0.0; 
10B9C:  MOVLB  8
10B9E:  CLRF   xE2
10BA0:  CLRF   xE1
10BA2:  CLRF   xE0
10BA4:  CLRF   xDF
10BA6:  MOVLB  0
....................  
....................    return(res); 
10BA8:  MOVFF  8DF,00
10BAC:  MOVFF  8E0,01
10BB0:  MOVFF  8E1,02
10BB4:  MOVFF  8E2,03
10BB8:  GOTO   10BCE (RETURN)
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
10BBC:  MOVFF  8D2,8DA
10BC0:  MOVFF  8D1,8D9
10BC4:  MOVFF  8D0,8D8
10BC8:  MOVFF  8CF,8D7
10BCC:  BRA    10828
10BCE:  MOVFF  03,8D6
10BD2:  MOVFF  02,8D5
10BD6:  MOVFF  01,8D4
10BDA:  MOVFF  00,8D3
....................    r = r*LN10_INV; 
10BDE:  MOVFF  8D6,916
10BE2:  MOVFF  8D5,915
10BE6:  MOVFF  8D4,914
10BEA:  MOVFF  8D3,913
10BEE:  MOVLW  D9
10BF0:  MOVLB  9
10BF2:  MOVWF  x1A
10BF4:  MOVLW  5B
10BF6:  MOVWF  x19
10BF8:  MOVLW  5E
10BFA:  MOVWF  x18
10BFC:  MOVLW  7D
10BFE:  MOVWF  x17
10C00:  MOVLB  0
10C02:  CALL   C2B8
10C06:  MOVFF  03,8D6
10C0A:  MOVFF  02,8D5
10C0E:  MOVFF  01,8D4
10C12:  MOVFF  00,8D3
....................    return(r); 
10C16:  MOVFF  8D3,00
10C1A:  MOVFF  8D4,01
10C1E:  MOVFF  8D5,02
10C22:  MOVFF  8D6,03
10C26:  RETURN 0
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "25LC512_wdt.c" 
.................... // 25LC512 = 512k bits / 8 = 64k bytes = 16 bit address 
....................  
.................... #define EEPROM_ADDRESS int16 
.................... #define EEPROM_SIZE    65536      
....................  
.................... void init_ext_eeprom()  
.................... {  
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
*
105B6:  BCF    FC6.5
105B8:  MOVLW  21
105BA:  MOVWF  FC6
105BC:  MOVLW  40
105BE:  MOVWF  FC7
....................     
....................    output_high(EEP_CS); 
105C0:  BSF    F91.2
....................    output_high(EEP_WP); 
105C2:  BSF    F91.3
105C4:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... int8 ext_eeprom_ready(void)  
.................... {  
....................    int8 data;  
....................     
....................    output_low(EEP_CS);  
105C6:  BCF    F91.2
....................    spi_write(0x05);  
105C8:  MOVF   FC9,W
105CA:  MOVLW  05
105CC:  MOVWF  FC9
105CE:  RRCF   FC7,W
105D0:  BNC   105CE
....................    data = spi_read(0);  
105D2:  MOVF   FC9,W
105D4:  CLRF   FC9
105D6:  RRCF   FC7,W
105D8:  BNC   105D6
105DA:  MOVFF  FC9,8CE
....................    output_high(EEP_CS);  
105DE:  BSF    F91.2
....................     
....................    return(!bit_test(data, 0));  
105E0:  MOVLW  00
105E2:  MOVLB  8
105E4:  BTFSS  xCE.0
105E6:  MOVLW  01
105E8:  MOVWF  01
105EA:  MOVLB  0
105EC:  RETURN 0
.................... }  
....................  
.................... //--------------------------------  
.................... void write_ext_eeprom(EEPROM_ADDRESS address, BYTE data)  
.................... {  
....................    heartbeat(FALSE); 
*
1803E:  MOVLB  8
18040:  CLRF   xED
18042:  MOVLB  0
18044:  CALL   557A
....................       while(!ext_eeprom_ready()); 
18048:  CALL   105C6
1804C:  MOVF   01,F
1804E:  BZ    18048
....................     
....................       output_low(EEP_CS);  
18050:  BCF    F91.2
....................       spi_write(0x06);  
18052:  MOVF   FC9,W
18054:  MOVLW  06
18056:  MOVWF  FC9
18058:  RRCF   FC7,W
1805A:  BNC   18058
....................       output_high(EEP_CS);  
1805C:  BSF    F91.2
....................        
....................       output_low(EEP_CS);  
1805E:  BCF    F91.2
....................       spi_write(0x02);  
18060:  MOVF   FC9,W
18062:  MOVLW  02
18064:  MOVWF  FC9
18066:  RRCF   FC7,W
18068:  BNC   18066
....................       spi_write(address >> 8);  
1806A:  MOVFF  8A8,8AA
1806E:  MOVLB  8
18070:  CLRF   xAB
18072:  MOVF   FC9,W
18074:  MOVFF  8A8,FC9
18078:  RRCF   FC7,W
1807A:  BNC   18078
....................       spi_write(address);  
1807C:  MOVF   FC9,W
1807E:  MOVFF  8A7,FC9
18082:  RRCF   FC7,W
18084:  BNC   18082
....................       spi_write(data);  
18086:  MOVF   FC9,W
18088:  MOVFF  8A9,FC9
1808C:  RRCF   FC7,W
1808E:  BNC   1808C
....................       output_high(EEP_CS);  
18090:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
18092:  MOVLW  01
18094:  MOVWF  xED
18096:  MOVLB  0
18098:  CALL   557A
1809C:  RETURN 0
.................... }  
.................... //--------------------------------  
....................  
.................... BYTE read_ext_eeprom(EEPROM_ADDRESS address)  
.................... {  
....................    int8 data;  
....................     
....................    heartbeat(FALSE); 
*
105EE:  MOVLB  8
105F0:  CLRF   xED
105F2:  MOVLB  0
105F4:  CALL   557A
....................     
....................       while(!ext_eeprom_ready()); 
105F8:  RCALL  105C6
105FA:  MOVF   01,F
105FC:  BZ    105F8
....................        
....................       output_low(EEP_CS);  
105FE:  BCF    F91.2
....................       spi_write(0x03);  
10600:  MOVF   FC9,W
10602:  MOVLW  03
10604:  MOVWF  FC9
10606:  RRCF   FC7,W
10608:  BNC   10606
....................       spi_write(address >> 8);  
1060A:  MOVFF  8CC,8CE
1060E:  MOVLB  8
10610:  CLRF   xCF
10612:  MOVF   FC9,W
10614:  MOVFF  8CC,FC9
10618:  RRCF   FC7,W
1061A:  BNC   10618
....................       spi_write(address);  
1061C:  MOVF   FC9,W
1061E:  MOVFF  8CB,FC9
10622:  RRCF   FC7,W
10624:  BNC   10622
....................        
....................       data = spi_read(0);  
10626:  MOVF   FC9,W
10628:  CLRF   FC9
1062A:  RRCF   FC7,W
1062C:  BNC   1062A
1062E:  MOVFF  FC9,8CD
....................       output_high(EEP_CS);  
10632:  BSF    F91.2
....................        
....................    heartbeat(TRUE);   
10634:  MOVLW  01
10636:  MOVWF  xED
10638:  MOVLB  0
1063A:  CALL   557A
....................     
....................    return(data);  
1063E:  MOVLB  8
10640:  MOVFF  8CD,01
10644:  MOVLB  0
10646:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "eeprom.c" 
.................... // *** INTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write8(int8 addr, int8 data) 
.................... { 
....................    write_eeprom(addr, data); 
*
03406:  MOVF   FF2,W
03408:  MOVWF  00
0340A:  BCF    FF2.7
0340C:  CLRF   F63
0340E:  MOVFF  889,F62
03412:  MOVFF  88A,F61
03416:  BCF    F7F.6
03418:  BCF    F7F.7
0341A:  BSF    F7F.2
0341C:  MOVLB  F
0341E:  MOVLW  55
03420:  MOVWF  F7E
03422:  MOVLW  AA
03424:  MOVWF  F7E
03426:  BSF    F7F.1
03428:  BTFSC  F7F.1
0342A:  BRA    3428
0342C:  BCF    F7F.2
0342E:  MOVF   00,W
03430:  IORWF  FF2,F
03432:  MOVLB  0
03434:  RETURN 0
.................... } 
....................  
.................... int8 read8(int8 addr) 
*
02A18:  MOVLB  8
02A1A:  CLRF   xB8
.................... { 
....................    int8 data = 0; 
....................    data = read_eeprom(addr); 
02A1C:  MOVFF  FF2,8B9
02A20:  BCF    FF2.7
02A22:  CLRF   F63
02A24:  MOVFF  8B7,F62
02A28:  BCF    F7F.6
02A2A:  BCF    F7F.7
02A2C:  BSF    F7F.0
02A2E:  MOVF   F61,W
02A30:  BTFSC  xB9.7
02A32:  BSF    FF2.7
02A34:  MOVWF  xB8
....................    return(data); 
02A36:  MOVFF  8B8,01
02A3A:  MOVLB  0
02A3C:  RETURN 0
.................... } 
....................  
.................... void write16(int8 addr, int16 data)  
.................... {  
....................     int i;  
....................     for (i = 0; i < 2; i++)  
*
04FC8:  MOVLB  8
04FCA:  CLRF   xF1
04FCC:  MOVF   xF1,W
04FCE:  SUBLW  01
04FD0:  BNC   502A
....................     {  
....................         write_eeprom(i + addr, *((int8*)&data + i) ) ;  
04FD2:  MOVF   xEE,W
04FD4:  ADDWF  xF1,W
04FD6:  MOVWF  xF2
04FD8:  MOVLW  08
04FDA:  MOVWF  xF4
04FDC:  MOVLW  EF
04FDE:  MOVWF  xF3
04FE0:  MOVF   xF1,W
04FE2:  ADDWF  xF3,W
04FE4:  MOVWF  01
04FE6:  MOVLW  00
04FE8:  ADDWFC xF4,W
04FEA:  MOVWF  03
04FEC:  MOVF   01,W
04FEE:  MOVWF  FE9
04FF0:  MOVFF  03,FEA
04FF4:  MOVFF  FEF,8F3
04FF8:  MOVF   FF2,W
04FFA:  MOVWF  00
04FFC:  BCF    FF2.7
04FFE:  CLRF   F63
05000:  MOVFF  8F2,F62
05004:  MOVFF  8F3,F61
05008:  BCF    F7F.6
0500A:  BCF    F7F.7
0500C:  BSF    F7F.2
0500E:  MOVLB  F
05010:  MOVLW  55
05012:  MOVWF  F7E
05014:  MOVLW  AA
05016:  MOVWF  F7E
05018:  BSF    F7F.1
0501A:  BTFSC  F7F.1
0501C:  BRA    501A
0501E:  BCF    F7F.2
05020:  MOVF   00,W
05022:  IORWF  FF2,F
05024:  MOVLB  8
05026:  INCF   xF1,F
05028:  BRA    4FCC
....................     }  
0502A:  MOVLB  0
0502C:  RETURN 0
.................... }  
....................  
.................... int16 read16(int8 addr)  
*
029BE:  MOVLB  8
029C0:  CLRF   x9A
029C2:  CLRF   x99
.................... {  
....................    int i;  
....................    int16 data = 0; 
....................    for (i = 0; i < 2; i++) 
029C4:  CLRF   x98
029C6:  MOVF   x98,W
029C8:  SUBLW  01
029CA:  BNC   2A0C
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
029CC:  MOVLW  08
029CE:  MOVWF  x9C
029D0:  MOVLW  99
029D2:  MOVWF  x9B
029D4:  MOVF   x98,W
029D6:  ADDWF  x9B,W
029D8:  MOVWF  01
029DA:  MOVLW  00
029DC:  ADDWFC x9C,W
029DE:  MOVWF  03
029E0:  MOVF   01,W
029E2:  MOVWF  FE9
029E4:  MOVFF  03,FEA
029E8:  MOVF   x97,W
029EA:  ADDWF  x98,W
029EC:  MOVWF  x9D
029EE:  MOVFF  FF2,89E
029F2:  BCF    FF2.7
029F4:  CLRF   F63
029F6:  MOVFF  89D,F62
029FA:  BCF    F7F.6
029FC:  BCF    F7F.7
029FE:  BSF    F7F.0
02A00:  MOVF   F61,W
02A02:  BTFSC  x9E.7
02A04:  BSF    FF2.7
02A06:  MOVWF  FEF
02A08:  INCF   x98,F
02A0A:  BRA    29C6
....................    } 
....................  
....................    return(data);  
02A0C:  MOVFF  899,01
02A10:  MOVFF  89A,02
02A14:  MOVLB  0
02A16:  RETURN 0
.................... } 
....................  
.................... void write_float(int16 addr, float data) {  
....................    int i; 
....................  
....................    for (i = 0; i < 4; i++) 
*
0CD40:  MOVLB  8
0CD42:  CLRF   x8B
0CD44:  MOVF   x8B,W
0CD46:  SUBLW  03
0CD48:  BNC   CDAA
....................    { 
....................       write_eeprom(i + addr, *((int8*)&data + i) ) ;  
0CD4A:  MOVF   x8B,W
0CD4C:  ADDWF  x85,W
0CD4E:  MOVWF  x8C
0CD50:  MOVLW  00
0CD52:  ADDWFC x86,W
0CD54:  MOVWF  x8D
0CD56:  MOVLW  08
0CD58:  MOVWF  x8F
0CD5A:  MOVLW  87
0CD5C:  MOVWF  x8E
0CD5E:  MOVF   x8B,W
0CD60:  ADDWF  x8E,W
0CD62:  MOVWF  01
0CD64:  MOVLW  00
0CD66:  ADDWFC x8F,W
0CD68:  MOVWF  03
0CD6A:  MOVF   01,W
0CD6C:  MOVWF  FE9
0CD6E:  MOVFF  03,FEA
0CD72:  MOVFF  FEF,88E
0CD76:  MOVF   FF2,W
0CD78:  MOVWF  00
0CD7A:  BCF    FF2.7
0CD7C:  MOVFF  88D,F63
0CD80:  MOVFF  88C,F62
0CD84:  MOVFF  88E,F61
0CD88:  BCF    F7F.6
0CD8A:  BCF    F7F.7
0CD8C:  BSF    F7F.2
0CD8E:  MOVLB  F
0CD90:  MOVLW  55
0CD92:  MOVWF  F7E
0CD94:  MOVLW  AA
0CD96:  MOVWF  F7E
0CD98:  BSF    F7F.1
0CD9A:  BTFSC  F7F.1
0CD9C:  BRA    CD9A
0CD9E:  BCF    F7F.2
0CDA0:  MOVF   00,W
0CDA2:  IORWF  FF2,F
0CDA4:  MOVLB  8
0CDA6:  INCF   x8B,F
0CDA8:  BRA    CD44
....................    } 
0CDAA:  MOVLB  0
0CDAC:  RETURN 0
.................... } 
....................  
.................... float read_float(int16 addr) {  
*
02A3E:  MOVLB  8
02A40:  CLRF   x8B
02A42:  CLRF   x8A
02A44:  CLRF   x89
02A46:  CLRF   x88
....................    int i;  
....................    float data = 0; 
....................  
....................    for (i = 0; i < 4; i++) 
02A48:  CLRF   x87
02A4A:  MOVF   x87,W
02A4C:  SUBLW  03
02A4E:  BNC   2A98
....................    { 
....................       *((int8*)&data + i) = read_eeprom(i + addr); 
02A50:  MOVLW  08
02A52:  MOVWF  x8D
02A54:  MOVLW  88
02A56:  MOVWF  x8C
02A58:  MOVF   x87,W
02A5A:  ADDWF  x8C,W
02A5C:  MOVWF  01
02A5E:  MOVLW  00
02A60:  ADDWFC x8D,W
02A62:  MOVWF  03
02A64:  MOVF   01,W
02A66:  MOVWF  FE9
02A68:  MOVFF  03,FEA
02A6C:  MOVF   x87,W
02A6E:  ADDWF  x85,W
02A70:  MOVWF  x8E
02A72:  MOVLW  00
02A74:  ADDWFC x86,W
02A76:  MOVWF  x8F
02A78:  MOVFF  FF2,890
02A7C:  BCF    FF2.7
02A7E:  MOVFF  88F,F63
02A82:  MOVFF  88E,F62
02A86:  BCF    F7F.6
02A88:  BCF    F7F.7
02A8A:  BSF    F7F.0
02A8C:  MOVF   F61,W
02A8E:  BTFSC  x90.7
02A90:  BSF    FF2.7
02A92:  MOVWF  FEF
02A94:  INCF   x87,F
02A96:  BRA    2A4A
....................    } 
....................  
....................    return(data);  
02A98:  MOVFF  888,00
02A9C:  MOVFF  889,01
02AA0:  MOVFF  88A,02
02AA4:  MOVFF  88B,03
02AA8:  MOVLB  0
02AAA:  RETURN 0
.................... } 
....................  
.................... // *** ENTERNAL EEPROM FUNCTIONS *** // 
....................  
.................... void write16_ext_eeprom(int16 addr, int16 data)  
.................... {  
....................     int i;  
....................     
....................     for (i = 0; i < 2; i++) 
*
1827E:  MOVLB  8
18280:  CLRF   xA3
18282:  MOVF   xA3,W
18284:  SUBLW  01
18286:  BNC   182C4
....................     {  
....................         write_ext_eeprom(i + addr, *((int8*)&data + i) ) ;  
18288:  MOVF   xA3,W
1828A:  ADDWF  x9F,W
1828C:  MOVWF  xA4
1828E:  MOVLW  00
18290:  ADDWFC xA0,W
18292:  MOVWF  xA5
18294:  MOVLW  08
18296:  MOVWF  xA7
18298:  MOVLW  A1
1829A:  MOVWF  xA6
1829C:  MOVF   xA3,W
1829E:  ADDWF  xA6,W
182A0:  MOVWF  01
182A2:  MOVLW  00
182A4:  ADDWFC xA7,W
182A6:  MOVWF  03
182A8:  MOVFF  01,FE9
182AC:  MOVWF  FEA
182AE:  MOVFF  FEF,8A9
182B2:  MOVFF  8A5,8A8
182B6:  MOVFF  8A4,8A7
182BA:  MOVLB  0
182BC:  RCALL  1803E
182BE:  MOVLB  8
182C0:  INCF   xA3,F
182C2:  BRA    18282
....................     }  
182C4:  MOVLB  0
182C6:  GOTO   18336 (RETURN)
.................... }  
....................  
.................... int16 read16_ext_eeprom(int16 addr)  
*
10702:  MOVLB  8
10704:  CLRF   xC6
10706:  CLRF   xC5
.................... {  
....................    int i;  
....................    int16 data = 0;  
....................  
....................    for (i = 0; i < 2; i++) 
10708:  CLRF   xC4
1070A:  MOVF   xC4,W
1070C:  SUBLW  01
1070E:  BNC   10752
....................    { 
....................       *((int8*)&data + i) = read_ext_eeprom(i + addr);  
10710:  MOVLW  08
10712:  MOVWF  xC8
10714:  MOVLW  C5
10716:  MOVWF  xC7
10718:  MOVF   xC4,W
1071A:  ADDWF  xC7,W
1071C:  MOVWF  01
1071E:  MOVLW  00
10720:  ADDWFC xC8,W
10722:  MOVWF  03
10724:  MOVFF  01,8C7
10728:  MOVWF  xC8
1072A:  MOVF   xC4,W
1072C:  ADDWF  xC2,W
1072E:  MOVWF  xC9
10730:  MOVLW  00
10732:  ADDWFC xC3,W
10734:  MOVWF  xCA
10736:  MOVWF  xCC
10738:  MOVFF  8C9,8CB
1073C:  MOVLB  0
1073E:  RCALL  105EE
10740:  MOVFF  8C8,FEA
10744:  MOVFF  8C7,FE9
10748:  MOVFF  01,FEF
1074C:  MOVLB  8
1074E:  INCF   xC4,F
10750:  BRA    1070A
....................    } 
....................    return(data);  
10752:  MOVFF  8C5,01
10756:  MOVFF  8C6,02
1075A:  MOVLB  0
1075C:  RETURN 0
.................... } 
....................  
.................... void eeprom_test() 
.................... {  
....................    int8 data;  
....................    int8 wrote;  
....................    int32 addr;  
....................    int16 errors = 0;  
....................           
....................    init_ext_eeprom();  
....................           
....................    // Fill eeprom with random data.  
....................    printf("\n\r");  
....................    printf("writing");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        write_ext_eeprom(addr, (int8)rand());  
....................        //comment out above and use line below for PIC16 
....................        //write_ext_eeprom(addr, 0x88); 
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    // Read the eeprom and check for errors.  
....................    printf("\n\r");  
....................    printf("reading");  
....................     
....................    // comment out for PIC16 
....................    srand(0x55); 
....................     
....................    for(addr = 0; addr < EEPROM_SIZE; addr++)  
....................       {  
....................        data = read_ext_eeprom(addr);  
....................        wrote = (int8)rand();  
....................        //comment out above and use line below for PIC16 
....................        //wrote = 0x88;  
....................        if(data != wrote)  
....................          {  
....................           printf("%lx: read %x, should be %x\n\r", addr, data, wrote);  
....................           errors++;  
....................           if(errors >= 10)  
....................              break;  
....................          }  
....................     
....................        if((int8)addr == 0)  
....................           putc('.');  
....................       }  
....................     
....................    output_low(EEP_WP); 
....................     
....................    printf("\n\r"); 
....................    printf("done\n\r");  
.................... } 
....................  
.................... #include "messages.c" 
.................... void blip() 
.................... { 
....................    output_bit(BOARD_LED, ON); 
*
15CEA:  BSF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, ON);  
15CEC:  MOVF   2F,W
15CEE:  SUBLW  02
15CF0:  BNZ   15CF8
15CF2:  MOVF   30,F
15CF4:  BNZ   15CF8
15CF6:  BSF    F90.6
....................    delay_ms(32); 
15CF8:  MOVLW  20
15CFA:  MOVLB  9
15CFC:  MOVWF  xEC
15CFE:  MOVLB  0
15D00:  CALL   2904
....................    output_bit(BOARD_LED, OFF); 
15D04:  BCF    F89.4
....................    if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
15D06:  MOVF   2F,W
15D08:  SUBLW  02
15D0A:  BNZ   15D12
15D0C:  MOVF   30,F
15D0E:  BNZ   15D12
15D10:  BCF    F90.6
....................    delay_ms(32); 
15D12:  MOVLW  20
15D14:  MOVLB  9
15D16:  MOVWF  xEC
15D18:  MOVLB  0
15D1A:  CALL   2904
15D1E:  RETURN 0
.................... } 
....................  
.................... void signon() 
.................... { 
....................    switch(nv_product){ 
*
0313C:  MOVF   2F,W
0313E:  MOVWF  00
03140:  MOVF   30,W
03142:  MOVWF  03
03144:  BNZ   314A
03146:  MOVF   00,F
03148:  BZ    316C
0314A:  MOVF   03,W
0314C:  BNZ   3154
0314E:  MOVLW  01
03150:  SUBWF  00,W
03152:  BZ    31BE
03154:  MOVF   03,W
03156:  BNZ   315E
03158:  MOVLW  02
0315A:  SUBWF  00,W
0315C:  BZ    3210
0315E:  MOVF   03,W
03160:  BNZ   316A
03162:  MOVLW  03
03164:  SUBWF  00,W
03166:  BTFSC  FD8.2
03168:  BRA    3262
0316A:  BRA    32B4
....................       case ECO : fprintf(COM_A, "ECO-2 %s\r\n", VERSION); 
0316C:  MOVLW  BE
0316E:  MOVWF  FF6
03170:  MOVLW  05
03172:  MOVWF  FF7
03174:  MOVLW  00
03176:  MOVWF  FF8
03178:  CLRF   1B
0317A:  BTFSC  FF2.7
0317C:  BSF    1B.7
0317E:  BCF    FF2.7
03180:  MOVLW  06
03182:  MOVLB  A
03184:  MOVWF  x40
03186:  MOVLB  0
03188:  CALL   1018
0318C:  BTFSC  1B.7
0318E:  BSF    FF2.7
03190:  MOVLW  CA
03192:  MOVWF  FF6
03194:  MOVLW  05
03196:  MOVWF  FF7
03198:  MOVLW  00
0319A:  MOVWF  FF8
0319C:  CLRF   1B
0319E:  BTFSC  FF2.7
031A0:  BSF    1B.7
031A2:  BCF    FF2.7
031A4:  CALL   0E42
031A8:  BTFSC  1B.7
031AA:  BSF    FF2.7
031AC:  MOVLW  0D
031AE:  BTFSS  F9E.4
031B0:  BRA    31AE
031B2:  MOVWF  FAD
031B4:  MOVLW  0A
031B6:  BTFSS  F9E.4
031B8:  BRA    31B6
031BA:  MOVWF  FAD
....................          break; 
031BC:  BRA    3304
....................       case WMS4 : fprintf(COM_A, "WMS-4-SD %s\r\n", VERSION); 
031BE:  MOVLW  D2
031C0:  MOVWF  FF6
031C2:  MOVLW  05
031C4:  MOVWF  FF7
031C6:  MOVLW  00
031C8:  MOVWF  FF8
031CA:  CLRF   1B
031CC:  BTFSC  FF2.7
031CE:  BSF    1B.7
031D0:  BCF    FF2.7
031D2:  MOVLW  09
031D4:  MOVLB  A
031D6:  MOVWF  x40
031D8:  MOVLB  0
031DA:  CALL   1018
031DE:  BTFSC  1B.7
031E0:  BSF    FF2.7
031E2:  MOVLW  E0
031E4:  MOVWF  FF6
031E6:  MOVLW  05
031E8:  MOVWF  FF7
031EA:  MOVLW  00
031EC:  MOVWF  FF8
031EE:  CLRF   1B
031F0:  BTFSC  FF2.7
031F2:  BSF    1B.7
031F4:  BCF    FF2.7
031F6:  CALL   0E42
031FA:  BTFSC  1B.7
031FC:  BSF    FF2.7
031FE:  MOVLW  0D
03200:  BTFSS  F9E.4
03202:  BRA    3200
03204:  MOVWF  FAD
03206:  MOVLW  0A
03208:  BTFSS  F9E.4
0320A:  BRA    3208
0320C:  MOVWF  FAD
....................          break;  
0320E:  BRA    3304
....................       case AWS : fprintf(COM_A, "AWS-1 %s\r\n", VERSION); 
03210:  MOVLW  E8
03212:  MOVWF  FF6
03214:  MOVLW  05
03216:  MOVWF  FF7
03218:  MOVLW  00
0321A:  MOVWF  FF8
0321C:  CLRF   1B
0321E:  BTFSC  FF2.7
03220:  BSF    1B.7
03222:  BCF    FF2.7
03224:  MOVLW  06
03226:  MOVLB  A
03228:  MOVWF  x40
0322A:  MOVLB  0
0322C:  CALL   1018
03230:  BTFSC  1B.7
03232:  BSF    FF2.7
03234:  MOVLW  F4
03236:  MOVWF  FF6
03238:  MOVLW  05
0323A:  MOVWF  FF7
0323C:  MOVLW  00
0323E:  MOVWF  FF8
03240:  CLRF   1B
03242:  BTFSC  FF2.7
03244:  BSF    1B.7
03246:  BCF    FF2.7
03248:  CALL   0E42
0324C:  BTFSC  1B.7
0324E:  BSF    FF2.7
03250:  MOVLW  0D
03252:  BTFSS  F9E.4
03254:  BRA    3252
03256:  MOVWF  FAD
03258:  MOVLW  0A
0325A:  BTFSS  F9E.4
0325C:  BRA    325A
0325E:  MOVWF  FAD
....................          break; 
03260:  BRA    3304
....................       case WMS2 : fprintf(COM_A, "WMS-4-QE %s\r\n", VERSION); 
03262:  MOVLW  FC
03264:  MOVWF  FF6
03266:  MOVLW  05
03268:  MOVWF  FF7
0326A:  MOVLW  00
0326C:  MOVWF  FF8
0326E:  CLRF   1B
03270:  BTFSC  FF2.7
03272:  BSF    1B.7
03274:  BCF    FF2.7
03276:  MOVLW  09
03278:  MOVLB  A
0327A:  MOVWF  x40
0327C:  MOVLB  0
0327E:  CALL   1018
03282:  BTFSC  1B.7
03284:  BSF    FF2.7
03286:  MOVLW  0A
03288:  MOVWF  FF6
0328A:  MOVLW  06
0328C:  MOVWF  FF7
0328E:  MOVLW  00
03290:  MOVWF  FF8
03292:  CLRF   1B
03294:  BTFSC  FF2.7
03296:  BSF    1B.7
03298:  BCF    FF2.7
0329A:  CALL   0E42
0329E:  BTFSC  1B.7
032A0:  BSF    FF2.7
032A2:  MOVLW  0D
032A4:  BTFSS  F9E.4
032A6:  BRA    32A4
032A8:  MOVWF  FAD
032AA:  MOVLW  0A
032AC:  BTFSS  F9E.4
032AE:  BRA    32AC
032B0:  MOVWF  FAD
....................          break;           
032B2:  BRA    3304
....................       default : fprintf(COM_A, "XXX-0 %s\r\n", VERSION); 
032B4:  MOVLW  12
032B6:  MOVWF  FF6
032B8:  MOVLW  06
032BA:  MOVWF  FF7
032BC:  MOVLW  00
032BE:  MOVWF  FF8
032C0:  CLRF   1B
032C2:  BTFSC  FF2.7
032C4:  BSF    1B.7
032C6:  BCF    FF2.7
032C8:  MOVLW  06
032CA:  MOVLB  A
032CC:  MOVWF  x40
032CE:  MOVLB  0
032D0:  CALL   1018
032D4:  BTFSC  1B.7
032D6:  BSF    FF2.7
032D8:  MOVLW  1E
032DA:  MOVWF  FF6
032DC:  MOVLW  06
032DE:  MOVWF  FF7
032E0:  MOVLW  00
032E2:  MOVWF  FF8
032E4:  CLRF   1B
032E6:  BTFSC  FF2.7
032E8:  BSF    1B.7
032EA:  BCF    FF2.7
032EC:  CALL   0E42
032F0:  BTFSC  1B.7
032F2:  BSF    FF2.7
032F4:  MOVLW  0D
032F6:  BTFSS  F9E.4
032F8:  BRA    32F6
032FA:  MOVWF  FAD
032FC:  MOVLW  0A
032FE:  BTFSS  F9E.4
03300:  BRA    32FE
03302:  MOVWF  FAD
....................          break; 
....................    } 
03304:  RETURN 0
.................... } 
....................  
.................... void cmd_inv() 
.................... { 
....................    fprintf(COM_A, "@INV\r\n"); 
*
1772E:  MOVLW  26
17730:  MOVWF  FF6
17732:  MOVLW  06
17734:  MOVWF  FF7
17736:  MOVLW  00
17738:  MOVWF  FF8
1773A:  CLRF   1B
1773C:  BTFSC  FF2.7
1773E:  BSF    1B.7
17740:  BCF    FF2.7
17742:  CALL   0E42
17746:  BTFSC  1B.7
17748:  BSF    FF2.7
1774A:  GOTO   17AF4 (RETURN)
.................... } 
....................  
.................... void cmd_arg() 
.................... { 
....................    fprintf(COM_A, "@ARG\r\n"); 
*
0B2F2:  MOVLW  2E
0B2F4:  MOVWF  FF6
0B2F6:  MOVLW  06
0B2F8:  MOVWF  FF7
0B2FA:  MOVLW  00
0B2FC:  MOVWF  FF8
0B2FE:  CLRF   1B
0B300:  BTFSC  FF2.7
0B302:  BSF    1B.7
0B304:  BCF    FF2.7
0B306:  CALL   0E42
0B30A:  BTFSC  1B.7
0B30C:  BSF    FF2.7
0B30E:  RETURN 0
.................... } 
....................  
.................... void cmd_err() 
.................... { 
....................    fprintf(COM_A, "@ERR\r\n"); 
*
0BFB4:  MOVLW  36
0BFB6:  MOVWF  FF6
0BFB8:  MOVLW  06
0BFBA:  MOVWF  FF7
0BFBC:  MOVLW  00
0BFBE:  MOVWF  FF8
0BFC0:  CLRF   1B
0BFC2:  BTFSC  FF2.7
0BFC4:  BSF    1B.7
0BFC6:  BCF    FF2.7
0BFC8:  CALL   0E42
0BFCC:  BTFSC  1B.7
0BFCE:  BSF    FF2.7
0BFD0:  RETURN 0
.................... } 
....................  
.................... void cmd_ok() 
.................... { 
....................    fprintf(COM_A, "@OK!\r\n"); 
.................... } 
....................  
.................... void cmd_res() 
.................... { 
....................    fprintf(COM_A, "@RES\r\n"); 
.................... } 
....................  
.................... void msg_card_ok() 
.................... { 
....................    fprintf(COM_A, "@SD1\r\n"); 
*
0364A:  MOVLW  4E
0364C:  MOVWF  FF6
0364E:  MOVLW  06
03650:  MOVWF  FF7
03652:  MOVLW  00
03654:  MOVWF  FF8
03656:  CLRF   1B
03658:  BTFSC  FF2.7
0365A:  BSF    1B.7
0365C:  BCF    FF2.7
0365E:  CALL   0E42
03662:  BTFSC  1B.7
03664:  BSF    FF2.7
03666:  GOTO   43BC (RETURN)
.................... } 
....................  
.................... void msg_card_fail() 
.................... { 
....................    fprintf(COM_A, "@SD_\r\n"); 
*
05074:  MOVLW  56
05076:  MOVWF  FF6
05078:  MOVLW  06
0507A:  MOVWF  FF7
0507C:  MOVLW  00
0507E:  MOVWF  FF8
05080:  CLRF   1B
05082:  BTFSC  FF2.7
05084:  BSF    1B.7
05086:  BCF    FF2.7
05088:  CALL   0E42
0508C:  BTFSC  1B.7
0508E:  BSF    FF2.7
05090:  RETURN 0
.................... } 
....................  
.................... void msg_max() 
.................... { 
....................    fprintf(COM_A, "@MAX\r\n"); 
*
16224:  MOVLW  5E
16226:  MOVWF  FF6
16228:  MOVLW  06
1622A:  MOVWF  FF7
1622C:  MOVLW  00
1622E:  MOVWF  FF8
16230:  CLRF   1B
16232:  BTFSC  FF2.7
16234:  BSF    1B.7
16236:  BCF    FF2.7
16238:  CALL   0E42
1623C:  BTFSC  1B.7
1623E:  BSF    FF2.7
16240:  RETURN 0
.................... } 
....................  
.................... void msg_busy() 
.................... { 
....................    if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
*
0B14A:  DECFSZ 4E,W
0B14C:  BRA    B16C
0B14E:  MOVLW  66
0B150:  MOVWF  FF6
0B152:  MOVLW  06
0B154:  MOVWF  FF7
0B156:  MOVLW  00
0B158:  MOVWF  FF8
0B15A:  CLRF   1B
0B15C:  BTFSC  FF2.7
0B15E:  BSF    1B.7
0B160:  BCF    FF2.7
0B162:  CALL   0E42
0B166:  BTFSC  1B.7
0B168:  BSF    FF2.7
0B16A:  BRA    B188
....................    else fprintf(COM_A, "@RDY\r\n"); 
0B16C:  MOVLW  6E
0B16E:  MOVWF  FF6
0B170:  MOVLW  06
0B172:  MOVWF  FF7
0B174:  MOVLW  00
0B176:  MOVWF  FF8
0B178:  CLRF   1B
0B17A:  BTFSC  FF2.7
0B17C:  BSF    1B.7
0B17E:  BCF    FF2.7
0B180:  CALL   0E42
0B184:  BTFSC  1B.7
0B186:  BSF    FF2.7
0B188:  GOTO   1B520 (RETURN)
.................... } 
....................  
....................  
.................... #include "sd_min.c" 
.................... //   Main File for the SD/MMC File System Demonstration 
....................  
.................... /* 
....................    Modifications: 
....................  
....................    dir_list() - removed 
....................    SD_Explore() - removed 
....................    etc. 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Specify the file system mode 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define USE_FAT_LITE // configure the filesystem for FAT Lite operation 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... // define Software RTC data structure 
....................  
.................... struct _rtc { 
....................    BYTE   ms100;      // number of 100ms ticks 0..9 
....................    BYTE   sec;        // 0..59 
....................    BYTE   min;        // 0..59 
....................    BYTE   hour;       // 0..23 
....................    BYTE   day;        // 1..31 
....................    BYTE   month;      // 1..12 
....................    BYTE   year;       // 0..99 
....................    WORD   DOY;        // 1..366 
....................    } rtc; 
....................  
....................    // define constants to derive the 1ms system clock. This clock will 
....................    // eventually need to be synchronized to the hardware RTC when implemented 
.................... #define C_TMR0_1ms   256 - (XTAL_FREQ/(64*4*1000)) 
.................... #define CTMR_Activity 2 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // include the FAT file system 
.................... #include <ff_min.h>               // include the SD Card file system 
.................... //   ff.h include file FatFs - FAT file system module include file 
....................  
.................... /* 
....................    Modifications 
....................     
....................    f_chmod() - removed 
....................    f_rename() - removed 
....................  
.................... */ 
....................  
....................  
.................... #ifndef _FAT_FS 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "media_io.h" 
.................... //   media_io.h include file with low level SD/MMC Card I/O functions 
....................  
.................... #ifndef _DISKIF 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Debug Defines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //#define SD_INIT_TRACE TRUE 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................    // Define the SD/MMS assignments 
.................... #define SelectSD bit_clear(SD_CS)  
.................... #define DeselectSD bit_set(SD_CS)  
....................  
.................... typedef unsigned char   DSTATUS; 
.................... typedef unsigned char   DRESULT; 
....................  
.................... #ifndef DWORD 
....................    #define DWORD int32 
.................... #endif 
....................  
.................... #ifndef WORD 
....................    #define WORD int16 
.................... #endif 
....................  
.................... enum FAT_type {FatUnknown, Fat12, Fat16, Fat32}; 
.................... enum Card_type {None, Unknown, MMC, SDv1, SDSC, SDHC}; 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   External platform specific user function to return a FAT Time 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... DWORD get_fattime(void); 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Prototypes for disk control functions  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_spi_read spi_read 
.................... #define SD_spi_write spi_write 
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void); 
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void); 
....................  
.................... #separate 
.................... DSTATUS disk_status(void); 
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount); 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address); 
....................  
.................... #ifndef   _READONLY 
....................    #separate 
....................    DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount); 
.................... #endif 
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff); 
....................  
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token); 
....................  
.................... BYTE wait_ready (void); 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Define constants 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #define SD_MAX_DIR_NAME_LENGTH      64         // maximum directory name length 
....................     
....................    // Results of Disk Functions (DRESULT)  
.................... #define RES_OK         0      // Successful  
.................... #define   RES_ERROR      1      // R/W Error  
.................... #define   RES_WRPRT      2      // Write Protected  
.................... #define   RES_NOTRDY      3      // Not Ready  
.................... #define   RES_PARERR      4      // Invalid Parameter  
....................  
....................  
....................    // Disk Status Bits (DSTATUS)  
.................... #define STA_NOINIT      0x01   // Drive not initialized  
.................... #define STA_NODISK      0x02   // No medium in the drive  
.................... #define STA_PROTECT      0x04   // Write protected  
....................  
.................... // Disk Response Codes 
.................... #define SD_GOOD_RESPONSE         0x00 
.................... #define SD_IN_IDLE_STATE         0x01 
.................... #define SD_INVALID_BLOCK_SIZE      0x40 
.................... #define SD_INVALID_RESPONSE         0xFF 
....................  
....................    // Command code for disk_ioctrl()  
....................    // Generic Commands 
.................... #define CTRL_SYNC         0 
.................... #define GET_SECTOR_COUNT   1 
.................... #define GET_SECTOR_SIZE      2 
.................... #define GET_BLOCK_SIZE      3 
....................    // SD/MMC commands 
.................... #define SD_GET_TYPE         10 
.................... #define SD_GET_CSD         11 
.................... #define SD_GET_CID         12 
.................... #define SD_GET_OCR         13 
.................... #define SD_GET_SDSTAT      14 
....................    // ATA/CF commands 
.................... #define ATA_GET_REV         20 
.................... #define ATA_GET_MODEL      21 
.................... #define ATA_GET_SN         22 
....................  
....................  
.................... // Define SD command constants 
.................... #define SD_CMD_GO_IDLE_STATE      0x40   // CMD0 
.................... #define SD_CMD_SEND_OP_COND         0x41   // CMD1 
.................... #define SD_CMD_SEND_IF_COND         0x48   // CMD8 
.................... #define SD_CMD_SEND_CSD            0x49   // CMD9 
.................... #define SD_CMD_SEND_CID            0x4A   // CMD10 
.................... #define SD_CMD_STOP_TX            0x4C   // CMD12 
.................... #define SD_CMD_SEND_STATUS         0x4D   // CMD13 
.................... #define SD_CMD_SET_BLOCKLEN         0x50   // CMD16 
.................... #define SD_CMD_READ_BLOCK         0x51   // CMD17 
.................... #define SD_CMD_READ_MULTIBLOCK      0x52   // CMD18 
.................... #define SD_CMD_SET_BLOCK_COUNT      0x57   // CMD23 (MMC) 
.................... #define SD_CMD_WRITE_BLOCK         0x58   // CMD24 
.................... #define SD_CMD_WRITE_MULTIBLOCK      0x59   // CMD25 
.................... #define SD_CMD_SD_SEND_OP_COND      0x69   // CMD41 
.................... #define SD_CMD_APPL_CMD            0x77   // CMD55 SD application command prefix 
.................... #define SD_CMD_SEND_OCR            0x7A   // CMD58 
....................  
....................  
.................... #define SD_ACMD13               0x4D    // ACMD13 SD_STATUS (SDC) 
.................... #define SD_ACMD23               0x57   // ACMD23 SET_WR_BLK_ERASE_COUNT (SDC) 
.................... #define SD_ACMD41               0x69   // ACMD41 SEND_OP_COND (SDC) 
....................  
....................  
.................... #define SD_BlockSize 512 
.................... #define MaxSectorCount 1 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //      Declare Driver Variables 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... Card_type Card = None; 
.................... FAT_type fat;            // type of FAT system installed 
.................... DWORD block_size;          // current MMC block size 
.................... static volatile DSTATUS Media_Status = STA_NOINIT;   // Media Status  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #separate 
.................... BYTE SD_cmd(BYTE sdcmd, DWORD address) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Send commands to the SD card via the SPI bus 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //      The SD must be selected (CS must be asserted) prior to calling 
.................... //      this function 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE i; 
....................    BYTE response; 
....................    BYTE *value; 
....................  
....................    value = (BYTE *)&address; 
*
03534:  MOVLW  0A
03536:  MOVLB  A
03538:  MOVWF  x35
0353A:  MOVLW  2C
0353C:  MOVFF  A35,A33
03540:  MOVWF  x32
....................  
....................    // dummy write to ensure SD/MMC in sync with SPI bus 
....................    SD_spi_read(0xFF); 
03542:  MOVF   FC9,W
03544:  SETF   FC9
03546:  RRCF   FC7,W
03548:  BNC   3546
....................    SD_spi_read(sdcmd); 
0354A:  MOVF   FC9,W
0354C:  MOVFF  A2B,FC9
03550:  RRCF   FC7,W
03552:  BNC   3550
....................    SD_spi_read(value[3]); 
03554:  MOVLW  03
03556:  ADDWF  x32,W
03558:  MOVWF  FE9
0355A:  MOVLW  00
0355C:  ADDWFC x33,W
0355E:  MOVWF  FEA
03560:  MOVFF  FEF,A34
03564:  MOVF   FC9,W
03566:  MOVFF  A34,FC9
0356A:  RRCF   FC7,W
0356C:  BNC   356A
....................    SD_spi_read(value[2]); 
0356E:  MOVLW  02
03570:  ADDWF  x32,W
03572:  MOVWF  FE9
03574:  MOVLW  00
03576:  ADDWFC x33,W
03578:  MOVWF  FEA
0357A:  MOVFF  FEF,A34
0357E:  MOVF   FC9,W
03580:  MOVFF  A34,FC9
03584:  RRCF   FC7,W
03586:  BNC   3584
....................    SD_spi_read(value[1]); 
03588:  MOVLW  01
0358A:  ADDWF  x32,W
0358C:  MOVWF  FE9
0358E:  MOVLW  00
03590:  ADDWFC x33,W
03592:  MOVWF  FEA
03594:  MOVFF  FEF,A34
03598:  MOVF   FC9,W
0359A:  MOVFF  A34,FC9
0359E:  RRCF   FC7,W
035A0:  BNC   359E
....................    SD_spi_read(value[0]); 
035A2:  MOVFF  A32,FE9
035A6:  MOVFF  A33,FEA
035AA:  MOVFF  FEF,A34
035AE:  MOVF   FC9,W
035B0:  MOVFF  A34,FC9
035B4:  RRCF   FC7,W
035B6:  BNC   35B4
....................    if (sdcmd == SD_CMD_SEND_IF_COND) 
035B8:  MOVF   x2B,W
035BA:  SUBLW  48
035BC:  BNZ   35CA
....................       SD_spi_read(0x87);   // valid CRC for SD_CMD_SEND_IF_COND 0x1aa (CMD8) 
035BE:  MOVF   FC9,W
035C0:  MOVLW  87
035C2:  MOVWF  FC9
035C4:  RRCF   FC7,W
035C6:  BNC   35C4
035C8:  BRA    35D4
....................    else 
....................       SD_spi_read(0x95); // valid crc for put card in SPI command (0x40) 
035CA:  MOVF   FC9,W
035CC:  MOVLW  95
035CE:  MOVWF  FC9
035D0:  RRCF   FC7,W
035D2:  BNC   35D0
....................  
....................    // NCR - Maximum number of cycles between command and response is 64 clock cycles (8 bytes) 
....................    i = 0; 
035D4:  CLRF   x30
....................    response = SD_spi_read(0xFF); 
035D6:  MOVF   FC9,W
035D8:  SETF   FC9
035DA:  RRCF   FC7,W
035DC:  BNC   35DA
035DE:  MOVFF  FC9,A31
....................    while ((response == 0xFF) && (i < 100)) 
035E2:  INCFSZ x31,W
035E4:  BRA    35FC
035E6:  MOVF   x30,W
035E8:  SUBLW  63
035EA:  BNC   35FC
....................       { 
....................       i++; 
035EC:  INCF   x30,F
....................       response = SD_spi_read(0xFF); 
035EE:  MOVF   FC9,W
035F0:  SETF   FC9
035F2:  RRCF   FC7,W
035F4:  BNC   35F2
035F6:  MOVFF  FC9,A31
035FA:  BRA    35E2
....................       } 
....................  
....................  
....................    // Error free response should be 0x00 to acknowledge the  
....................    // command or 0xFF if no response was detected from the card 
....................    return(response); 
035FC:  MOVFF  A31,01
03600:  MOVLB  0
03602:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... BYTE SD_set_BLOCKLEN( DWORD size) 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... //      Set the media block length 
.................... // 
.................... // Entry: 
.................... //      size in the range of 1 to 512 
.................... ////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (SD_cmd(SD_CMD_SET_BLOCKLEN, size)) 
*
043C8:  MOVLW  50
043CA:  MOVLB  A
043CC:  MOVWF  x2B
043CE:  MOVFF  A2A,A2F
043D2:  MOVFF  A29,A2E
043D6:  MOVFF  A28,A2D
043DA:  MOVFF  A27,A2C
043DE:  MOVLB  0
043E0:  CALL   3534
043E4:  MOVF   01,W
043E6:  BZ    43EE
043E8:  XORLW  40
043EA:  BZ    4404
043EC:  BRA    440A
....................       {    
....................       case 0x00 : // done: 
....................          block_size=size; //// assign global block size 
043EE:  MOVFF  A2A,4EC
043F2:  MOVFF  A29,4EB
043F6:  MOVFF  A28,4EA
043FA:  MOVFF  A27,4E9
....................          return(TRUE); 
043FE:  MOVLW  01
04400:  MOVWF  01
04402:  BRA    440E
....................  
....................       case 0x40 : // invalid block size request 
....................          // Parameter Rejected 
....................          return(FALSE); 
04404:  MOVLW  00
04406:  MOVWF  01
04408:  BRA    440E
....................  
....................       default : 
....................          // Unexpected response from SET_BLOCKLEN 
....................          return(FALSE); 
0440A:  MOVLW  00
0440C:  MOVWF  01
....................       } 
0440E:  GOTO   44F2 (RETURN)
....................    } 
....................  
....................  
.................... #define MaxReceiveDataTimeout 10000 
.................... BYTE SD_receive_data(BYTE *ptr, DWORD size)  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read data block from Card to memory 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Read class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns 0 on success, 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD i; 
....................    BYTE response; 
....................  
....................     // poll for start token 
....................    response = SD_spi_read(0xFF); 
04412:  MOVF   FC9,W
04414:  SETF   FC9
04416:  RRCF   FC7,W
04418:  BNC   4416
0441A:  MOVFF  FC9,A2F
....................    for(i=0; (i < MaxReceiveDataTimeout) && (response == 0xFF); i++) 
0441E:  MOVLB  A
04420:  CLRF   x2E
04422:  CLRF   x2D
04424:  MOVF   x2E,W
04426:  SUBLW  27
04428:  BNC   4452
0442A:  BNZ   4432
0442C:  MOVF   x2D,W
0442E:  SUBLW  0F
04430:  BNC   4452
04432:  INCFSZ x2F,W
04434:  BRA    4452
....................       { 
....................       delay_us(10); 
04436:  MOVLW  35
04438:  MOVWF  00
0443A:  DECFSZ 00,F
0443C:  BRA    443A
....................       response = SD_spi_read(0xFF);  
0443E:  MOVF   FC9,W
04440:  SETF   FC9
04442:  RRCF   FC7,W
04444:  BNC   4442
04446:  MOVFF  FC9,A2F
0444A:  INCF   x2D,F
0444C:  BTFSC  FD8.2
0444E:  INCF   x2E,F
04450:  BRA    4424
....................       } 
....................  
....................    // start token? 
....................    if (response != 0xFE) 
04452:  MOVF   x2F,W
04454:  SUBLW  FE
04456:  BZ    4466
....................       { 
....................       if (!response) 
04458:  MOVF   x2F,F
0445A:  BNZ   4460
....................          response = 0xFE; 
0445C:  MOVLW  FE
0445E:  MOVWF  x2F
....................       return(response); 
04460:  MOVFF  A2F,01
04464:  BRA    44BC
....................       } 
....................  
....................    // found start token, read the data 
....................    for (i=0; i < size; i++)  
04466:  CLRF   x2E
04468:  CLRF   x2D
0446A:  MOVF   x2C,F
0446C:  BNZ   4480
0446E:  MOVF   x2B,F
04470:  BNZ   4480
04472:  MOVF   x2E,W
04474:  SUBWF  x2A,W
04476:  BNC   44A0
04478:  BNZ   4480
0447A:  MOVF   x29,W
0447C:  SUBWF  x2D,W
0447E:  BC    44A0
....................       ptr[i]=SD_spi_read(0xFF); 
04480:  MOVF   x27,W
04482:  ADDWF  x2D,W
04484:  MOVWF  FE9
04486:  MOVF   x28,W
04488:  ADDWFC x2E,W
0448A:  MOVWF  FEA
0448C:  MOVF   FC9,W
0448E:  SETF   FC9
04490:  RRCF   FC7,W
04492:  BNC   4490
04494:  MOVFF  FC9,FEF
04498:  INCF   x2D,F
0449A:  BTFSC  FD8.2
0449C:  INCF   x2E,F
0449E:  BRA    446A
....................  
....................    // Discard the CRC 
....................    SD_spi_read(0xFF); 
044A0:  MOVF   FC9,W
044A2:  SETF   FC9
044A4:  RRCF   FC7,W
044A6:  BNC   44A4
....................    SD_spi_read(0xFF); 
044A8:  MOVF   FC9,W
044AA:  SETF   FC9
044AC:  RRCF   FC7,W
044AE:  BNC   44AC
....................  
....................    // clear the card 
....................    SD_spi_read(0xFF); 
044B0:  MOVF   FC9,W
044B2:  SETF   FC9
044B4:  RRCF   FC7,W
044B6:  BNC   44B4
....................    return(0); 
044B8:  MOVLW  00
044BA:  MOVWF  01
044BC:  MOVLB  0
044BE:  RETURN 0
....................    } 
....................  
....................  
.................... // Wait for card ready  
.................... BYTE wait_ready (void) 
....................    { 
....................    BYTE response; 
....................    WORD Timer; 
....................  
....................    Timer = 50000;         // Maximum wait for ready in timeout of 500ms  
*
0583A:  MOVLW  C3
0583C:  MOVLB  A
0583E:  MOVWF  x2F
05840:  MOVLW  50
05842:  MOVWF  x2E
....................    SD_spi_read(0xFF); 
05844:  MOVF   FC9,W
05846:  SETF   FC9
05848:  RRCF   FC7,W
0584A:  BNC   5848
....................    do 
....................       { 
....................       delay_us(10); 
0584C:  MOVLW  35
0584E:  MOVWF  00
05850:  DECFSZ 00,F
05852:  BRA    5850
....................       response = SD_spi_read(0xFF); 
05854:  MOVF   FC9,W
05856:  SETF   FC9
05858:  RRCF   FC7,W
0585A:  BNC   5858
0585C:  MOVFF  FC9,A2D
....................       Timer--; 
05860:  MOVF   x2E,W
05862:  BTFSC  FD8.2
05864:  DECF   x2F,F
05866:  DECF   x2E,F
....................       } 
....................    while ((response != 0xFF) && Timer) 
05868:  INCFSZ x2D,W
0586A:  BRA    586E
0586C:  BRA    5874
0586E:  MOVF   x2E,W
05870:  IORWF  x2F,W
05872:  BNZ   584C
....................       ; 
....................  
....................    return (response); 
05874:  MOVFF  A2D,01
05878:  MOVLB  0
0587A:  GOTO   588A (RETURN)
....................    } 
....................  
....................  
.................... #ifndef _READONLY 
.................... #separate 
.................... BOOLEAN SD_write_data(BYTE *ptr, BYTE token)  
0587E:  MOVLW  02
05880:  MOVLB  A
05882:  MOVWF  x2C
05884:  CLRF   x2B
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Write a data block from memory to the Card 
.................... //   Maximum block access time = 100ms 
.................... // 
.................... // Entry 
.................... //      Ensure Memory Card is deselected before calling 
.................... //      Write class command issued to card and acknowledged 
.................... // 
.................... //   Exit 
.................... //      Returns TRUE on success, 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE response; 
....................    WORD WriteCount = 512; 
....................  
....................    if (wait_ready() != 0xFF)  
05886:  MOVLB  0
05888:  BRA    583A
0588A:  INCFSZ 01,W
0588C:  BRA    5890
0588E:  BRA    5896
....................       return (FALSE); 
05890:  MOVLW  00
05892:  MOVWF  01
05894:  BRA    5930
....................  
....................    SD_spi_write(token);               // transmit data token 
05896:  MOVF   FC9,W
05898:  MOVFF  A29,FC9
0589C:  RRCF   FC7,W
0589E:  BNC   589C
....................    if (token != 0xFD) 
058A0:  MOVLB  A
058A2:  MOVF   x29,W
058A4:  SUBLW  FD
058A6:  BZ    592A
....................       { 
....................       // here if a data token    
....................       while (WriteCount--)             // transmit the 512 byte data block tothe card 
058A8:  MOVFF  A2C,03
058AC:  MOVF   x2B,W
058AE:  BTFSC  FD8.2
058B0:  DECF   x2C,F
058B2:  DECF   x2B,F
058B4:  IORWF  03,W
058B6:  BZ    58DA
....................          SD_spi_write(*ptr++); 
058B8:  MOVFF  A28,03
058BC:  MOVF   x27,W
058BE:  INCF   x27,F
058C0:  BTFSC  FD8.2
058C2:  INCF   x28,F
058C4:  MOVWF  FE9
058C6:  MOVFF  03,FEA
058CA:  MOVFF  FEF,A2D
058CE:  MOVF   FC9,W
058D0:  MOVFF  A2D,FC9
058D4:  RRCF   FC7,W
058D6:  BNC   58D4
058D8:  BRA    58A8
....................  
....................       SD_spi_write(0xFF);               // CRC (not used) 
058DA:  MOVF   FC9,W
058DC:  SETF   FC9
058DE:  RRCF   FC7,W
058E0:  BNC   58DE
....................       SD_spi_write(0xFF);               // Dummy clocks to force card to process the command 
058E2:  MOVF   FC9,W
058E4:  SETF   FC9
058E6:  RRCF   FC7,W
058E8:  BNC   58E6
....................       response = SD_spi_read(0xFF);      // Receive data response 
058EA:  MOVF   FC9,W
058EC:  SETF   FC9
058EE:  RRCF   FC7,W
058F0:  BNC   58EE
058F2:  MOVFF  FC9,A2A
....................  
....................  
....................       for( WriteCount=0; WriteCount < 50000; WriteCount++) 
058F6:  CLRF   x2C
058F8:  CLRF   x2B
058FA:  MOVF   x2C,W
058FC:  SUBLW  C3
058FE:  BNC   592A
05900:  BNZ   5908
05902:  MOVF   x2B,W
05904:  SUBLW  4F
05906:  BNC   592A
....................          { 
....................          delay_us(10); 
05908:  MOVLW  35
0590A:  MOVWF  00
0590C:  DECFSZ 00,F
0590E:  BRA    590C
....................          response = SD_spi_read(0xFF);   // digest prior operation 
05910:  MOVF   FC9,W
05912:  SETF   FC9
05914:  RRCF   FC7,W
05916:  BNC   5914
05918:  MOVFF  FC9,A2A
....................          if (response != 0x00) 
0591C:  MOVF   x2A,F
0591E:  BZ    5922
....................             break; 
05920:  BRA    592A
05922:  INCF   x2B,F
05924:  BTFSC  FD8.2
05926:  INCF   x2C,F
05928:  BRA    58FA
....................          } 
....................  
....................       } 
....................    return(TRUE); 
0592A:  MOVLW  01
0592C:  MOVWF  01
0592E:  MOVLB  0
05930:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_write (BYTE *Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Writes SectorCount Sectors to the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the write buffer 
.................... //  SectorNumber      Sector number to write to 
.................... //  SectorCount        Number of sectors to write (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
05932:  MOVLB  4
05934:  BTFSS  xED.0
05936:  BRA    593E
....................       return (RES_NOTRDY); 
05938:  MOVLW  03
0593A:  MOVWF  01
0593C:  BRA    5A72
....................  
....................    if (Media_Status & STA_PROTECT) 
0593E:  BTFSS  xED.2
05940:  BRA    5948
....................       return (RES_WRPRT); 
05942:  MOVLW  02
05944:  MOVWF  01
05946:  BRA    5A72
....................  
....................    if (!SectorCount) 
05948:  MOVLB  A
0594A:  MOVF   x26,F
0594C:  BNZ   5958
....................       return (RES_PARERR); 
0594E:  MOVLW  04
05950:  MOVWF  01
05952:  MOVLB  4
05954:  BRA    5A72
05956:  MOVLB  A
....................  
....................    SelectSD; 
05958:  BCF    F91.1
....................  
....................    if (Card != SDHC) 
0595A:  MOVLB  4
0595C:  MOVF   xE7,W
0595E:  SUBLW  05
05960:  BZ    597C
....................       SectorNumber *= 512; 
05962:  BCF    FD8.0
05964:  MOVFF  A24,A25
05968:  MOVFF  A23,A24
0596C:  MOVFF  A22,A23
05970:  MOVLB  A
05972:  CLRF   x22
05974:  RLCF   x23,F
05976:  RLCF   x24,F
05978:  RLCF   x25,F
0597A:  MOVLB  4
....................  
....................    if (SectorCount == 1)   // Single block write  
0597C:  MOVLB  A
0597E:  DECFSZ x26,W
05980:  BRA    59C0
....................       { 
....................       if (SD_cmd(SD_CMD_WRITE_BLOCK, SectorNumber) == 0) 
05982:  MOVLW  58
05984:  MOVWF  x2B
05986:  MOVFF  A25,A2F
0598A:  MOVFF  A24,A2E
0598E:  MOVFF  A23,A2D
05992:  MOVFF  A22,A2C
05996:  MOVLB  0
05998:  CALL   3534
0599C:  MOVF   01,F
0599E:  BNZ   59BC
....................          if (SD_write_data(Buffer, 0xFE)) 
059A0:  MOVFF  A21,A28
059A4:  MOVFF  A20,A27
059A8:  MOVLW  FE
059AA:  MOVLB  A
059AC:  MOVWF  x29
059AE:  MOVLB  0
059B0:  RCALL  587E
059B2:  MOVF   01,F
059B4:  BZ    59BC
....................             SectorCount = 0; 
059B6:  MOVLB  A
059B8:  CLRF   x26
059BA:  MOVLB  0
....................       } 
059BC:  BRA    5A58
059BE:  MOVLB  A
....................    else  
....................       {   // Multiple block write  
....................       if (Card & (SDv1 || SDHC || SDSC))  
059C0:  MOVLB  4
059C2:  MOVF   xE7,W
059C4:  ANDLW  03
059C6:  BZ    59F4
....................          { 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
059C8:  MOVLW  77
059CA:  MOVLB  A
059CC:  MOVWF  x2B
059CE:  CLRF   x2F
059D0:  CLRF   x2E
059D2:  CLRF   x2D
059D4:  CLRF   x2C
059D6:  MOVLB  0
059D8:  CALL   3534
....................          SD_cmd(SD_ACMD23, SectorCount); 
059DC:  MOVLW  57
059DE:  MOVLB  A
059E0:  MOVWF  x2B
059E2:  CLRF   x2F
059E4:  CLRF   x2E
059E6:  CLRF   x2D
059E8:  MOVFF  A26,A2C
059EC:  MOVLB  0
059EE:  CALL   3534
059F2:  MOVLB  4
....................          } 
....................       if (SD_cmd(SD_CMD_WRITE_MULTIBLOCK, SectorNumber) == 0)  
059F4:  MOVLW  59
059F6:  MOVLB  A
059F8:  MOVWF  x2B
059FA:  MOVFF  A25,A2F
059FE:  MOVFF  A24,A2E
05A02:  MOVFF  A23,A2D
05A06:  MOVFF  A22,A2C
05A0A:  MOVLB  0
05A0C:  CALL   3534
05A10:  MOVF   01,F
05A12:  BNZ   5A58
....................          { 
....................          do  
....................             { 
....................             if (!SD_write_data(Buffer, 0xFC))  
05A14:  MOVFF  A21,A28
05A18:  MOVFF  A20,A27
05A1C:  MOVLW  FC
05A1E:  MOVLB  A
05A20:  MOVWF  x29
05A22:  MOVLB  0
05A24:  RCALL  587E
05A26:  MOVF   01,F
05A28:  BNZ   5A2C
....................                break; 
05A2A:  BRA    5A3E
....................             Buffer += 512; 
05A2C:  MOVLW  02
05A2E:  MOVLB  A
05A30:  ADDWF  x21,F
....................             } while (--SectorCount); 
05A32:  DECF   x26,F
05A34:  BTFSC  FD8.2
05A36:  BRA    5A3C
05A38:  MOVLB  0
05A3A:  BRA    5A14
05A3C:  MOVLB  0
....................  
....................          if (!SD_write_data(0, 0xFD))   // STOP_TRAN token  
05A3E:  MOVLB  A
05A40:  CLRF   x28
05A42:  CLRF   x27
05A44:  MOVLW  FD
05A46:  MOVWF  x29
05A48:  MOVLB  0
05A4A:  RCALL  587E
05A4C:  MOVF   01,F
05A4E:  BNZ   5A58
....................             SectorCount = 1; 
05A50:  MOVLW  01
05A52:  MOVLB  A
05A54:  MOVWF  x26
05A56:  MOVLB  0
....................          } 
....................       } 
....................  
....................    DeselectSD; 
05A58:  BSF    F91.1
....................    SD_spi_read(0xFF); 
05A5A:  MOVF   FC9,W
05A5C:  SETF   FC9
05A5E:  RRCF   FC7,W
05A60:  BNC   5A5E
....................    return SectorCount ? RES_ERROR : RES_OK; 
05A62:  MOVLB  A
05A64:  MOVF   x26,F
05A66:  BZ    5A6C
05A68:  MOVLW  01
05A6A:  BRA    5A6E
05A6C:  MOVLW  00
05A6E:  MOVWF  01
05A70:  MOVLB  4
05A72:  MOVLB  0
05A74:  RETURN 0
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #separate 
.................... DRESULT disk_read (BYTE* Buffer, DWORD SectorNumber, BYTE SectorCount) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reads SectorCount Sectors from the SD Card starting at the address 
.................... //   SectorNumber 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... // Entry 
.................... //  Buffer             Pointer to the read buffer 
.................... //  SectorNumber      Sector number to read from 
.................... //  SectorCount        Number of sectors to read (SHOULD BE 1) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (Media_Status & STA_NOINIT)  
*
044C0:  MOVLB  4
044C2:  BTFSS  xED.0
044C4:  BRA    44CC
....................       return (RES_NOTRDY); 
044C6:  MOVLW  03
044C8:  MOVWF  01
044CA:  BRA    45FC
....................  
....................    // check sector count is valid 
....................    if ((SectorCount > MaxSectorCount) || !SectorCount) 
044CC:  MOVLB  A
044CE:  MOVF   x26,W
044D0:  SUBLW  01
044D2:  BNC   44D8
044D4:  MOVF   x26,F
044D6:  BNZ   44E2
....................       return(RES_PARERR); 
044D8:  MOVLW  04
044DA:  MOVWF  01
044DC:  MOVLB  4
044DE:  BRA    45FC
044E0:  MOVLB  A
....................  
....................    SelectSD; 
044E2:  BCF    F91.1
....................  
....................    // set the block size 
....................    if (!SD_set_BLOCKLEN(512)) 
044E4:  CLRF   x2A
044E6:  CLRF   x29
044E8:  MOVLW  02
044EA:  MOVWF  x28
044EC:  CLRF   x27
044EE:  MOVLB  0
044F0:  BRA    43C8
044F2:  MOVF   01,F
044F4:  BNZ   4502
....................       { 
....................       // Cannot set block length; 
....................       DeselectSD; 
044F6:  BSF    F91.1
....................       return(RES_ERROR); 
044F8:  MOVLW  01
044FA:  MOVWF  01
044FC:  MOVLB  4
044FE:  BRA    45FC
04500:  MOVLB  0
....................       } 
....................  
....................    if (Card != SDHC) 
04502:  MOVLB  4
04504:  MOVF   xE7,W
04506:  SUBLW  05
04508:  BZ    4524
....................       SectorNumber *= 512; 
0450A:  BCF    FD8.0
0450C:  MOVFF  A24,A25
04510:  MOVFF  A23,A24
04514:  MOVFF  A22,A23
04518:  MOVLB  A
0451A:  CLRF   x22
0451C:  RLCF   x23,F
0451E:  RLCF   x24,F
04520:  RLCF   x25,F
04522:  MOVLB  4
....................  
....................    if (SectorCount == 1) 
04524:  MOVLB  A
04526:  DECFSZ x26,W
04528:  BRA    4580
....................       { 
....................       // read block command 
....................       if(SD_cmd(SD_CMD_READ_BLOCK, SectorNumber)) 
0452A:  MOVLW  51
0452C:  MOVWF  x2B
0452E:  MOVFF  A25,A2F
04532:  MOVFF  A24,A2E
04536:  MOVFF  A23,A2D
0453A:  MOVFF  A22,A2C
0453E:  MOVLB  0
04540:  CALL   3534
04544:  MOVF   01,F
04546:  BZ    4554
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
04548:  BSF    F91.1
....................          return(RES_PARERR); 
0454A:  MOVLW  04
0454C:  MOVWF  01
0454E:  MOVLB  4
04550:  BRA    45FC
04552:  MOVLB  0
....................          } 
....................  
....................       if (SD_receive_data(Buffer, (DWORD) 512)) 
04554:  MOVFF  A21,A28
04558:  MOVFF  A20,A27
0455C:  MOVLB  A
0455E:  CLRF   x2C
04560:  CLRF   x2B
04562:  MOVLW  02
04564:  MOVWF  x2A
04566:  CLRF   x29
04568:  MOVLB  0
0456A:  RCALL  4412
0456C:  MOVF   01,F
0456E:  BZ    457C
....................          { 
....................          DeselectSD; 
04570:  BSF    F91.1
....................          return(RES_ERROR); 
04572:  MOVLW  01
04574:  MOVWF  01
04576:  MOVLB  4
04578:  BRA    45FC
0457A:  MOVLB  0
....................          } 
....................       } 
0457C:  BRA    45F4
0457E:  MOVLB  A
....................    else 
....................       { 
....................       // here to transfer multiple blocks 
....................       // send multi block read command 
....................       if(SD_cmd(SD_CMD_READ_MULTIBLOCK, SectorNumber)) 
04580:  MOVLW  52
04582:  MOVWF  x2B
04584:  MOVFF  A25,A2F
04588:  MOVFF  A24,A2E
0458C:  MOVFF  A23,A2D
04590:  MOVFF  A22,A2C
04594:  MOVLB  0
04596:  CALL   3534
0459A:  MOVF   01,F
0459C:  BZ    45AA
....................          { 
....................          // Read_Block Error: couldn't set the read address 
....................          DeselectSD; 
0459E:  BSF    F91.1
....................          return(RES_PARERR); 
045A0:  MOVLW  04
045A2:  MOVWF  01
045A4:  MOVLB  4
045A6:  BRA    45FC
045A8:  MOVLB  0
....................          } 
....................  
....................       do 
....................          {       
....................          if (SD_receive_data(Buffer, (DWORD) 512)) 
045AA:  MOVFF  A21,A28
045AE:  MOVFF  A20,A27
045B2:  MOVLB  A
045B4:  CLRF   x2C
045B6:  CLRF   x2B
045B8:  MOVLW  02
045BA:  MOVWF  x2A
045BC:  CLRF   x29
045BE:  MOVLB  0
045C0:  RCALL  4412
045C2:  MOVF   01,F
045C4:  BZ    45D2
....................             { 
....................             DeselectSD; 
045C6:  BSF    F91.1
....................             return(RES_ERROR); 
045C8:  MOVLW  01
045CA:  MOVWF  01
045CC:  MOVLB  4
045CE:  BRA    45FC
045D0:  MOVLB  0
....................             } 
....................  
....................          // Update the buffer pointer 
....................          Buffer += 512; 
045D2:  MOVLW  02
045D4:  MOVLB  A
045D6:  ADDWF  x21,F
....................          } while (--SectorCount); 
045D8:  DECF   x26,F
045DA:  BTFSC  FD8.2
045DC:  BRA    45E2
045DE:  MOVLB  0
045E0:  BRA    45AA
....................       SD_cmd(SD_CMD_STOP_TX,0);      // stop transmission 
045E2:  MOVLW  4C
045E4:  MOVWF  x2B
045E6:  CLRF   x2F
045E8:  CLRF   x2E
045EA:  CLRF   x2D
045EC:  CLRF   x2C
045EE:  MOVLB  0
045F0:  CALL   3534
....................       } 
....................  
....................    // finished sucessfully 
....................    DeselectSD; 
045F4:  BSF    F91.1
....................    return(RES_OK); 
045F6:  MOVLW  00
045F8:  MOVWF  01
045FA:  MOVLB  4
045FC:  MOVLB  0
045FE:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_shutdown(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Deselects the drive and sets the Media_Status to STA_NOINIT 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DeselectSD; 
....................    Media_Status = STA_NOINIT; 
....................    return(Media_Status); 
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_status(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Tests and returns the status of the Media 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // test for presence of the card 
....................    #ifdef SD_CD 
....................       if (bit_test(SD_CD)) 
....................          { 
....................          // no card, go clean up 
....................          Media_Status = disk_shutdown() | STA_NODISK; 
....................          return(Media_Status); 
....................          } 
....................       else 
....................    #endif 
....................       // card found 
....................       Media_Status &= ~STA_NODISK; 
*
05592:  MOVLB  4
05594:  BCF    xED.1
....................  
....................    // check write protect status 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          Media_Status |= STA_PROTECT; 
....................       else 
....................    #endif 
....................  
....................       Media_Status &= ~STA_PROTECT; 
05596:  BCF    xED.2
....................  
....................    return(Media_Status); 
05598:  MOVFF  4ED,01
0559C:  MOVLB  0
0559E:  RETURN 0
....................    } 
....................  
....................  
.................... #separate 
.................... DSTATUS disk_initialize(void) 
*
0366A:  MOVLB  9
0366C:  CLRF   xEB
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the SPI bus and Memory card internal logic 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE i, response, ocr[4]; 
....................    WORD Timer; 
....................    DSTATUS SDCardStatus = 0; 
....................  
....................    // initialise the card type 
....................    Card = None; 
0366E:  MOVLB  4
03670:  CLRF   xE7
....................  
....................    DeselectSD; 
03672:  BSF    F91.1
....................  
....................    // test if the card is present 
....................    #ifdef SD_CD 
....................       if (nv_report_mode == 4) printf("@FS:Testing card\r\n"); 
....................       if (bit_test(SD_CD)) 
....................          return(STA_NODISK | STA_NOINIT); 
....................    #endif 
....................  
....................    delay_ms(10); 
03674:  MOVLW  0A
03676:  MOVLB  9
03678:  MOVWF  xEC
0367A:  MOVLB  0
0367C:  CALL   2904
....................  
....................    // prepare to flush the SPI bus for the MMC and SD Memory Cards.  
....................    // sets the SPI bus speed low and initiates 80 SPI clock pulses 
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_64 | SPI_XMIT_L_TO_H); 
03680:  BCF    FC6.5
03682:  MOVLW  22
03684:  MOVWF  FC6
03686:  MOVLW  40
03688:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
0368A:  BCF    F9E.3
....................  
....................    // flush the SPI bus 
....................    for(i=0; i<10; i++)     // generate 80 clocks to get SD/MMC card ready 
0368C:  MOVLB  9
0368E:  CLRF   xE3
03690:  MOVF   xE3,W
03692:  SUBLW  09
03694:  BNC   36A2
....................       SD_spi_read(0xFF); 
03696:  MOVF   FC9,W
03698:  SETF   FC9
0369A:  RRCF   FC7,W
0369C:  BNC   369A
0369E:  INCF   xE3,F
036A0:  BRA    3690
....................  
....................    //printf("Testing write protect status of the card\r\n"); 
....................    // get the write protect status of the card 
....................    // active low indicates the card is write protected 
....................    #ifdef SD_WP 
....................       if (bit_test(SD_WP)) 
....................          SDCardStatus = STA_PROTECT; 
....................    #endif 
....................  
....................    // put the card into the idle state 
....................    SelectSD; 
036A2:  BCF    F91.1
....................    if (nv_report_mode == 4) printf("@FS:Discovery\r\n"); 
036A4:  MOVF   1F,W
036A6:  SUBLW  04
036A8:  BNZ   36CE
036AA:  MOVF   20,F
036AC:  BNZ   36CE
036AE:  MOVLW  76
036B0:  MOVWF  FF6
036B2:  MOVLW  06
036B4:  MOVWF  FF7
036B6:  MOVLW  00
036B8:  MOVWF  FF8
036BA:  CLRF   1B
036BC:  BTFSC  FF2.7
036BE:  BSF    1B.7
036C0:  BCF    FF2.7
036C2:  MOVLB  0
036C4:  CALL   0E42
036C8:  BTFSC  1B.7
036CA:  BSF    FF2.7
036CC:  MOVLB  9
....................    response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);       // CMD0 
036CE:  MOVLW  40
036D0:  MOVLB  A
036D2:  MOVWF  x2B
036D4:  CLRF   x2F
036D6:  CLRF   x2E
036D8:  CLRF   x2D
036DA:  CLRF   x2C
036DC:  MOVLB  0
036DE:  RCALL  3534
036E0:  MOVFF  01,9E4
....................    if (response > 1 ) 
036E4:  MOVLB  9
036E6:  MOVF   xE4,W
036E8:  SUBLW  01
036EA:  BC    3740
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Unable to put card in idle state, response = %02x\r\n", response); 
036EC:  MOVF   1F,W
036EE:  SUBLW  04
036F0:  BNZ   373A
036F2:  MOVF   20,F
036F4:  BNZ   373A
036F6:  MOVLW  86
036F8:  MOVWF  FF6
036FA:  MOVLW  06
036FC:  MOVWF  FF7
036FE:  MOVLW  00
03700:  MOVWF  FF8
03702:  CLRF   1B
03704:  BTFSC  FF2.7
03706:  BSF    1B.7
03708:  BCF    FF2.7
0370A:  MOVLW  31
0370C:  MOVLB  A
0370E:  MOVWF  x40
03710:  MOVLB  0
03712:  CALL   1018
03716:  BTFSC  1B.7
03718:  BSF    FF2.7
0371A:  MOVFF  9E4,9EC
0371E:  MOVLW  57
03720:  MOVLB  9
03722:  MOVWF  xED
03724:  MOVLB  0
03726:  RCALL  3604
03728:  MOVLW  0D
0372A:  BTFSS  F9E.4
0372C:  BRA    372A
0372E:  MOVWF  FAD
03730:  MOVLW  0A
03732:  BTFSS  F9E.4
03734:  BRA    3732
03736:  MOVWF  FAD
03738:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
0373A:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
0373C:  GOTO   43BE
....................    } 
....................  
....................    // Here the card is in idle state 
....................    if (nv_report_mode == 4) printf("@FS:Card idle, response = %02x\r\n",response);    
03740:  MOVF   1F,W
03742:  SUBLW  04
03744:  BNZ   378E
03746:  MOVF   20,F
03748:  BNZ   378E
0374A:  MOVLW  BE
0374C:  MOVWF  FF6
0374E:  MOVLW  06
03750:  MOVWF  FF7
03752:  MOVLW  00
03754:  MOVWF  FF8
03756:  CLRF   1B
03758:  BTFSC  FF2.7
0375A:  BSF    1B.7
0375C:  BCF    FF2.7
0375E:  MOVLW  1A
03760:  MOVLB  A
03762:  MOVWF  x40
03764:  MOVLB  0
03766:  CALL   1018
0376A:  BTFSC  1B.7
0376C:  BSF    FF2.7
0376E:  MOVFF  9E4,9EC
03772:  MOVLW  57
03774:  MOVLB  9
03776:  MOVWF  xED
03778:  MOVLB  0
0377A:  RCALL  3604
0377C:  MOVLW  0D
0377E:  BTFSS  F9E.4
03780:  BRA    377E
03782:  MOVWF  FAD
03784:  MOVLW  0A
03786:  BTFSS  F9E.4
03788:  BRA    3786
0378A:  MOVWF  FAD
0378C:  MOVLB  9
....................  
....................    //    checking for SD ver 2 - sending CMD8 
....................    response = SD_cmd(SD_CMD_SEND_IF_COND, 0x1AA); 
0378E:  MOVLW  48
03790:  MOVLB  A
03792:  MOVWF  x2B
03794:  CLRF   x2F
03796:  CLRF   x2E
03798:  MOVLW  01
0379A:  MOVWF  x2D
0379C:  MOVLW  AA
0379E:  MOVWF  x2C
037A0:  MOVLB  0
037A2:  RCALL  3534
037A4:  MOVFF  01,9E4
....................    if (nv_report_mode == 4) printf("@FS:Response to SD ver 2 test CMD8 = %x\r\n",response); 
037A8:  MOVF   1F,W
037AA:  SUBLW  04
037AC:  BNZ   37F4
037AE:  MOVF   20,F
037B0:  BNZ   37F4
037B2:  MOVLW  E0
037B4:  MOVWF  FF6
037B6:  MOVLW  06
037B8:  MOVWF  FF7
037BA:  MOVLW  00
037BC:  MOVWF  FF8
037BE:  CLRF   1B
037C0:  BTFSC  FF2.7
037C2:  BSF    1B.7
037C4:  BCF    FF2.7
037C6:  MOVLW  25
037C8:  MOVLB  A
037CA:  MOVWF  x40
037CC:  MOVLB  0
037CE:  CALL   1018
037D2:  BTFSC  1B.7
037D4:  BSF    FF2.7
037D6:  MOVFF  9E4,9EC
037DA:  MOVLW  57
037DC:  MOVLB  9
037DE:  MOVWF  xED
037E0:  MOVLB  0
037E2:  RCALL  3604
037E4:  MOVLW  0D
037E6:  BTFSS  F9E.4
037E8:  BRA    37E6
037EA:  MOVWF  FAD
037EC:  MOVLW  0A
037EE:  BTFSS  F9E.4
037F0:  BRA    37EE
037F2:  MOVWF  FAD
....................    if (response == 1)  
037F4:  MOVLB  9
037F6:  DECFSZ xE4,W
037F8:  BRA    3BCA
....................    {  
....................       if (nv_report_mode == 4) printf("@FS:Possible SDv2 card detected\r\n"); 
037FA:  MOVF   1F,W
037FC:  SUBLW  04
037FE:  BNZ   3824
03800:  MOVF   20,F
03802:  BNZ   3824
03804:  MOVLW  0A
03806:  MOVWF  FF6
03808:  MOVLW  07
0380A:  MOVWF  FF7
0380C:  MOVLW  00
0380E:  MOVWF  FF8
03810:  CLRF   1B
03812:  BTFSC  FF2.7
03814:  BSF    1B.7
03816:  BCF    FF2.7
03818:  MOVLB  0
0381A:  CALL   0E42
0381E:  BTFSC  1B.7
03820:  BSF    FF2.7
03822:  MOVLB  9
....................       // Response to CMD8 - indicates possible SD ver 2 card 
....................       for (i = 0; i < 4; i++)  
03824:  CLRF   xE3
03826:  MOVF   xE3,W
03828:  SUBLW  03
0382A:  BNC   384A
....................          ocr[i] = SD_spi_read(0xFF);      // Get trailing return value of R7 resp 
0382C:  CLRF   03
0382E:  MOVF   xE3,W
03830:  ADDLW  E5
03832:  MOVWF  FE9
03834:  MOVLW  09
03836:  ADDWFC 03,W
03838:  MOVWF  FEA
0383A:  MOVF   FC9,W
0383C:  SETF   FC9
0383E:  RRCF   FC7,W
03840:  BNC   383E
03842:  MOVFF  FC9,FEF
03846:  INCF   xE3,F
03848:  BRA    3826
....................  
....................       // check the voltage range of the card andcheck the pattern 
....................       if (nv_report_mode == 4) printf("@FS:Voltage range check, ocr = %02x%02x%02x%02x\r\n", ocr[0],ocr[1],ocr[2],ocr[3]); 
0384A:  MOVF   1F,W
0384C:  SUBLW  04
0384E:  BNZ   38C2
03850:  MOVF   20,F
03852:  BNZ   38C2
03854:  MOVLW  2C
03856:  MOVWF  FF6
03858:  MOVLW  07
0385A:  MOVWF  FF7
0385C:  MOVLW  00
0385E:  MOVWF  FF8
03860:  CLRF   1B
03862:  BTFSC  FF2.7
03864:  BSF    1B.7
03866:  BCF    FF2.7
03868:  MOVLW  1F
0386A:  MOVLB  A
0386C:  MOVWF  x40
0386E:  MOVLB  0
03870:  CALL   1018
03874:  BTFSC  1B.7
03876:  BSF    FF2.7
03878:  MOVFF  9E5,9EC
0387C:  MOVLW  57
0387E:  MOVLB  9
03880:  MOVWF  xED
03882:  MOVLB  0
03884:  RCALL  3604
03886:  MOVFF  9E6,9EC
0388A:  MOVLW  57
0388C:  MOVLB  9
0388E:  MOVWF  xED
03890:  MOVLB  0
03892:  RCALL  3604
03894:  MOVFF  9E7,9EC
03898:  MOVLW  57
0389A:  MOVLB  9
0389C:  MOVWF  xED
0389E:  MOVLB  0
038A0:  RCALL  3604
038A2:  MOVFF  9E8,9EC
038A6:  MOVLW  57
038A8:  MOVLB  9
038AA:  MOVWF  xED
038AC:  MOVLB  0
038AE:  RCALL  3604
038B0:  MOVLW  0D
038B2:  BTFSS  F9E.4
038B4:  BRA    38B2
038B6:  MOVWF  FAD
038B8:  MOVLW  0A
038BA:  BTFSS  F9E.4
038BC:  BRA    38BA
038BE:  MOVWF  FAD
038C0:  MOVLB  9
....................       if (ocr[2] == 0x01 && ocr[3] == 0xAA)  
038C2:  DECFSZ xE7,W
038C4:  BRA    3BA0
038C6:  MOVF   xE8,W
038C8:  SUBLW  AA
038CA:  BTFSS  FD8.2
038CC:  BRA    3BA0
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card Vdd range = 2.7-3.6 volts\r\n"); 
038CE:  MOVF   1F,W
038D0:  SUBLW  04
038D2:  BNZ   38F8
038D4:  MOVF   20,F
038D6:  BNZ   38F8
038D8:  MOVLW  5E
038DA:  MOVWF  FF6
038DC:  MOVLW  07
038DE:  MOVWF  FF7
038E0:  MOVLW  00
038E2:  MOVWF  FF8
038E4:  CLRF   1B
038E6:  BTFSC  FF2.7
038E8:  BSF    1B.7
038EA:  BCF    FF2.7
038EC:  MOVLB  0
038EE:  CALL   0E42
038F2:  BTFSC  1B.7
038F4:  BSF    FF2.7
038F6:  MOVLB  9
....................          // The card can work at vdd range of 2.7-3.6V 
....................          if (nv_report_mode == 4) printf("@FS:Sending ACMD41 command to SD ver 2 card\r\n"); 
038F8:  MOVF   1F,W
038FA:  SUBLW  04
038FC:  BNZ   3922
038FE:  MOVF   20,F
03900:  BNZ   3922
03902:  MOVLW  84
03904:  MOVWF  FF6
03906:  MOVLW  07
03908:  MOVWF  FF7
0390A:  MOVLW  00
0390C:  MOVWF  FF8
0390E:  CLRF   1B
03910:  BTFSC  FF2.7
03912:  BSF    1B.7
03914:  BCF    FF2.7
03916:  MOVLB  0
03918:  CALL   0E42
0391C:  BTFSC  1B.7
0391E:  BSF    FF2.7
03920:  MOVLB  9
....................          // send Application Specific Command identifier (CMD55) 
....................          // followed by ACMD41 
....................          Timer = 0; 
03922:  CLRF   xEA
03924:  CLRF   xE9
....................          response = SD_cmd(SD_CMD_APPL_CMD,0); 
03926:  MOVLW  77
03928:  MOVLB  A
0392A:  MOVWF  x2B
0392C:  CLRF   x2F
0392E:  CLRF   x2E
03930:  CLRF   x2D
03932:  CLRF   x2C
03934:  MOVLB  0
03936:  RCALL  3534
03938:  MOVFF  01,9E4
....................          response = SD_cmd(SD_ACMD41, 1UL << 30); 
0393C:  MOVLW  69
0393E:  MOVLB  A
03940:  MOVWF  x2B
03942:  MOVLW  40
03944:  MOVWF  x2F
03946:  CLRF   x2E
03948:  CLRF   x2D
0394A:  CLRF   x2C
0394C:  MOVLB  0
0394E:  RCALL  3534
03950:  MOVFF  01,9E4
....................          while (response && (Timer < 50000)) 
03954:  MOVLB  9
03956:  MOVF   xE4,F
03958:  BZ    39AA
0395A:  MOVF   xEA,W
0395C:  SUBLW  C3
0395E:  BNC   39AA
03960:  BNZ   3968
03962:  MOVF   xE9,W
03964:  SUBLW  4F
03966:  BNC   39AA
....................          { 
....................             delay_us(20); 
03968:  MOVLW  6A
0396A:  MOVWF  00
0396C:  DECFSZ 00,F
0396E:  BRA    396C
03970:  NOP   
....................             Timer++; 
03972:  INCF   xE9,F
03974:  BTFSC  FD8.2
03976:  INCF   xEA,F
....................             response = SD_cmd(SD_CMD_APPL_CMD,0); 
03978:  MOVLW  77
0397A:  MOVLB  A
0397C:  MOVWF  x2B
0397E:  CLRF   x2F
03980:  CLRF   x2E
03982:  CLRF   x2D
03984:  CLRF   x2C
03986:  MOVLB  0
03988:  RCALL  3534
0398A:  MOVFF  01,9E4
....................             response = SD_cmd(SD_ACMD41, 1UL << 30); 
0398E:  MOVLW  69
03990:  MOVLB  A
03992:  MOVWF  x2B
03994:  MOVLW  40
03996:  MOVWF  x2F
03998:  CLRF   x2E
0399A:  CLRF   x2D
0399C:  CLRF   x2C
0399E:  MOVLB  0
039A0:  RCALL  3534
039A2:  MOVFF  01,9E4
039A6:  BRA    3954
039A8:  MOVLB  9
....................          }  
....................  
....................          if (nv_report_mode == 4) printf("@FS:Response from sending ACMD41 = %02x, Timer = %lu\r\n",response,Timer); 
039AA:  MOVF   1F,W
039AC:  SUBLW  04
039AE:  BNZ   3A38
039B0:  MOVF   20,F
039B2:  BNZ   3A38
039B4:  MOVLW  B2
039B6:  MOVWF  FF6
039B8:  MOVLW  07
039BA:  MOVWF  FF7
039BC:  MOVLW  00
039BE:  MOVWF  FF8
039C0:  CLRF   1B
039C2:  BTFSC  FF2.7
039C4:  BSF    1B.7
039C6:  BCF    FF2.7
039C8:  MOVLW  23
039CA:  MOVLB  A
039CC:  MOVWF  x40
039CE:  MOVLB  0
039D0:  CALL   1018
039D4:  BTFSC  1B.7
039D6:  BSF    FF2.7
039D8:  MOVFF  9E4,9EC
039DC:  MOVLW  57
039DE:  MOVLB  9
039E0:  MOVWF  xED
039E2:  MOVLB  0
039E4:  RCALL  3604
039E6:  MOVLW  D9
039E8:  MOVWF  FF6
039EA:  MOVLW  07
039EC:  MOVWF  FF7
039EE:  MOVLW  00
039F0:  MOVWF  FF8
039F2:  CLRF   1B
039F4:  BTFSC  FF2.7
039F6:  BSF    1B.7
039F8:  BCF    FF2.7
039FA:  MOVLW  0A
039FC:  MOVLB  A
039FE:  MOVWF  x40
03A00:  MOVLB  0
03A02:  CALL   1018
03A06:  BTFSC  1B.7
03A08:  BSF    FF2.7
03A0A:  MOVLW  10
03A0C:  MOVWF  FE9
03A0E:  CLRF   1B
03A10:  BTFSC  FF2.7
03A12:  BSF    1B.7
03A14:  BCF    FF2.7
03A16:  MOVFF  9EA,A41
03A1A:  MOVFF  9E9,A40
03A1E:  CALL   119A
03A22:  BTFSC  1B.7
03A24:  BSF    FF2.7
03A26:  MOVLW  0D
03A28:  BTFSS  F9E.4
03A2A:  BRA    3A28
03A2C:  MOVWF  FAD
03A2E:  MOVLW  0A
03A30:  BTFSS  F9E.4
03A32:  BRA    3A30
03A34:  MOVWF  FAD
03A36:  MOVLB  9
....................          if (!response) 
03A38:  MOVF   xE4,F
03A3A:  BTFSS  FD8.2
03A3C:  BRA    3B9E
....................          { 
....................             // send CMD58 Get CCS 
....................             response = (SD_cmd(SD_CMD_SEND_OCR, 0x40000000)); 
03A3E:  MOVLW  7A
03A40:  MOVLB  A
03A42:  MOVWF  x2B
03A44:  MOVLW  40
03A46:  MOVWF  x2F
03A48:  CLRF   x2E
03A4A:  CLRF   x2D
03A4C:  CLRF   x2C
03A4E:  MOVLB  0
03A50:  RCALL  3534
03A52:  MOVFF  01,9E4
....................             if (nv_report_mode == 4) printf("@FS:Response to CMD58 = %x\r\n",response); 
03A56:  MOVF   1F,W
03A58:  SUBLW  04
03A5A:  BNZ   3AA2
03A5C:  MOVF   20,F
03A5E:  BNZ   3AA2
03A60:  MOVLW  EA
03A62:  MOVWF  FF6
03A64:  MOVLW  07
03A66:  MOVWF  FF7
03A68:  MOVLW  00
03A6A:  MOVWF  FF8
03A6C:  CLRF   1B
03A6E:  BTFSC  FF2.7
03A70:  BSF    1B.7
03A72:  BCF    FF2.7
03A74:  MOVLW  18
03A76:  MOVLB  A
03A78:  MOVWF  x40
03A7A:  MOVLB  0
03A7C:  CALL   1018
03A80:  BTFSC  1B.7
03A82:  BSF    FF2.7
03A84:  MOVFF  9E4,9EC
03A88:  MOVLW  57
03A8A:  MOVLB  9
03A8C:  MOVWF  xED
03A8E:  MOVLB  0
03A90:  RCALL  3604
03A92:  MOVLW  0D
03A94:  BTFSS  F9E.4
03A96:  BRA    3A94
03A98:  MOVWF  FAD
03A9A:  MOVLW  0A
03A9C:  BTFSS  F9E.4
03A9E:  BRA    3A9C
03AA0:  MOVWF  FAD
....................             if (response == 0)   // CMD58  
03AA2:  MOVLB  9
03AA4:  MOVF   xE4,F
03AA6:  BTFSS  FD8.2
03AA8:  BRA    3B9E
....................             { 
....................                // Check CCS bit in the OCR 
....................                for (i = 0; i < 4; i++)  
03AAA:  CLRF   xE3
03AAC:  MOVF   xE3,W
03AAE:  SUBLW  03
03AB0:  BNC   3AD0
....................                   ocr[i] = SD_spi_read(0xFF); 
03AB2:  CLRF   03
03AB4:  MOVF   xE3,W
03AB6:  ADDLW  E5
03AB8:  MOVWF  FE9
03ABA:  MOVLW  09
03ABC:  ADDWFC 03,W
03ABE:  MOVWF  FEA
03AC0:  MOVF   FC9,W
03AC2:  SETF   FC9
03AC4:  RRCF   FC7,W
03AC6:  BNC   3AC4
03AC8:  MOVFF  FC9,FEF
03ACC:  INCF   xE3,F
03ACE:  BRA    3AAC
....................                if (ocr[0] & 0x40) 
03AD0:  BTFSS  xE5.6
03AD2:  BRA    3ADE
....................                   Card = SDHC; 
03AD4:  MOVLW  05
03AD6:  MOVLB  4
03AD8:  MOVWF  xE7
03ADA:  BRA    3AE4
03ADC:  MOVLB  9
....................                else 
....................                   Card = SDSC; 
03ADE:  MOVLW  04
03AE0:  MOVLB  4
03AE2:  MOVWF  xE7
....................  
....................                if (nv_report_mode == 4)printf("@FS:Sent CMD 58, Timer value = %lu, ocr = %02x%02x%02x%02x\r\n", Timer, ocr[0],ocr[1],ocr[2],ocr[3]); 
03AE4:  MOVF   1F,W
03AE6:  SUBLW  04
03AE8:  BNZ   3B9C
03AEA:  MOVF   20,F
03AEC:  BNZ   3B9C
03AEE:  MOVLW  08
03AF0:  MOVWF  FF6
03AF2:  MOVLW  08
03AF4:  MOVWF  FF7
03AF6:  MOVLW  00
03AF8:  MOVWF  FF8
03AFA:  CLRF   1B
03AFC:  BTFSC  FF2.7
03AFE:  BSF    1B.7
03B00:  BCF    FF2.7
03B02:  MOVLW  1F
03B04:  MOVLB  A
03B06:  MOVWF  x40
03B08:  MOVLB  0
03B0A:  CALL   1018
03B0E:  BTFSC  1B.7
03B10:  BSF    FF2.7
03B12:  MOVLW  10
03B14:  MOVWF  FE9
03B16:  CLRF   1B
03B18:  BTFSC  FF2.7
03B1A:  BSF    1B.7
03B1C:  BCF    FF2.7
03B1E:  MOVFF  9EA,A41
03B22:  MOVFF  9E9,A40
03B26:  CALL   119A
03B2A:  BTFSC  1B.7
03B2C:  BSF    FF2.7
03B2E:  MOVLW  2A
03B30:  MOVWF  FF6
03B32:  MOVLW  08
03B34:  MOVWF  FF7
03B36:  MOVLW  00
03B38:  MOVWF  FF8
03B3A:  CLRF   1B
03B3C:  BTFSC  FF2.7
03B3E:  BSF    1B.7
03B40:  BCF    FF2.7
03B42:  MOVLW  08
03B44:  MOVLB  A
03B46:  MOVWF  x40
03B48:  MOVLB  0
03B4A:  CALL   1018
03B4E:  BTFSC  1B.7
03B50:  BSF    FF2.7
03B52:  MOVFF  9E5,9EC
03B56:  MOVLW  57
03B58:  MOVLB  9
03B5A:  MOVWF  xED
03B5C:  MOVLB  0
03B5E:  RCALL  3604
03B60:  MOVFF  9E6,9EC
03B64:  MOVLW  57
03B66:  MOVLB  9
03B68:  MOVWF  xED
03B6A:  MOVLB  0
03B6C:  RCALL  3604
03B6E:  MOVFF  9E7,9EC
03B72:  MOVLW  57
03B74:  MOVLB  9
03B76:  MOVWF  xED
03B78:  MOVLB  0
03B7A:  RCALL  3604
03B7C:  MOVFF  9E8,9EC
03B80:  MOVLW  57
03B82:  MOVLB  9
03B84:  MOVWF  xED
03B86:  MOVLB  0
03B88:  RCALL  3604
03B8A:  MOVLW  0D
03B8C:  BTFSS  F9E.4
03B8E:  BRA    3B8C
03B90:  MOVWF  FAD
03B92:  MOVLW  0A
03B94:  BTFSS  F9E.4
03B96:  BRA    3B94
03B98:  MOVWF  FAD
03B9A:  MOVLB  4
03B9C:  MOVLB  9
....................             } 
....................          } 
....................       } 
03B9E:  BRA    3BCA
....................       else 
....................       { 
....................          if (nv_report_mode == 4) printf("@FS:Card CANNOT work Vdd range of 2.7-3.6 volts\r\n"); 
03BA0:  MOVF   1F,W
03BA2:  SUBLW  04
03BA4:  BNZ   3BCA
03BA6:  MOVF   20,F
03BA8:  BNZ   3BCA
03BAA:  MOVLW  46
03BAC:  MOVWF  FF6
03BAE:  MOVLW  08
03BB0:  MOVWF  FF7
03BB2:  MOVLW  00
03BB4:  MOVWF  FF8
03BB6:  CLRF   1B
03BB8:  BTFSC  FF2.7
03BBA:  BSF    1B.7
03BBC:  BCF    FF2.7
03BBE:  MOVLB  0
03BC0:  CALL   0E42
03BC4:  BTFSC  1B.7
03BC6:  BSF    FF2.7
03BC8:  MOVLB  9
....................       } 
....................    }  
....................     
....................    // test to see if we now have a valid card 
....................    // if not perform legacy SD and MMC card detection 
....................    if (Card == None) 
03BCA:  MOVLB  4
03BCC:  MOVF   xE7,F
03BCE:  BTFSS  FD8.2
03BD0:  BRA    40A0
....................    { 
....................       // Invalid response to Command 8, SD Version 1 or MMC  
....................       if (nv_report_mode == 4) printf("@FS:Not an SDSC or SDHC card, Testing for SD Ver1 or MMC Card\r\n"); 
03BD2:  MOVF   1F,W
03BD4:  SUBLW  04
03BD6:  BNZ   3BFC
03BD8:  MOVF   20,F
03BDA:  BNZ   3BFC
03BDC:  MOVLW  78
03BDE:  MOVWF  FF6
03BE0:  MOVLW  08
03BE2:  MOVWF  FF7
03BE4:  MOVLW  00
03BE6:  MOVWF  FF8
03BE8:  CLRF   1B
03BEA:  BTFSC  FF2.7
03BEC:  BSF    1B.7
03BEE:  BCF    FF2.7
03BF0:  MOVLB  0
03BF2:  CALL   0E42
03BF6:  BTFSC  1B.7
03BF8:  BSF    FF2.7
03BFA:  MOVLB  4
....................  
....................       // reinitialise the card 
....................       response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03BFC:  MOVLW  40
03BFE:  MOVLB  A
03C00:  MOVWF  x2B
03C02:  CLRF   x2F
03C04:  CLRF   x2E
03C06:  CLRF   x2D
03C08:  CLRF   x2C
03C0A:  MOVLB  0
03C0C:  RCALL  3534
03C0E:  MOVFF  01,9E4
....................       if (nv_report_mode == 4) printf("@FS:Response from GO_IDLE = %02x\r\n",response); 
03C12:  MOVF   1F,W
03C14:  SUBLW  04
03C16:  BNZ   3C5E
03C18:  MOVF   20,F
03C1A:  BNZ   3C5E
03C1C:  MOVLW  B8
03C1E:  MOVWF  FF6
03C20:  MOVLW  08
03C22:  MOVWF  FF7
03C24:  MOVLW  00
03C26:  MOVWF  FF8
03C28:  CLRF   1B
03C2A:  BTFSC  FF2.7
03C2C:  BSF    1B.7
03C2E:  BCF    FF2.7
03C30:  MOVLW  1C
03C32:  MOVLB  A
03C34:  MOVWF  x40
03C36:  MOVLB  0
03C38:  CALL   1018
03C3C:  BTFSC  1B.7
03C3E:  BSF    FF2.7
03C40:  MOVFF  9E4,9EC
03C44:  MOVLW  57
03C46:  MOVLB  9
03C48:  MOVWF  xED
03C4A:  MOVLB  0
03C4C:  RCALL  3604
03C4E:  MOVLW  0D
03C50:  BTFSS  F9E.4
03C52:  BRA    3C50
03C54:  MOVWF  FAD
03C56:  MOVLW  0A
03C58:  BTFSS  F9E.4
03C5A:  BRA    3C58
03C5C:  MOVWF  FAD
....................  
....................       if ((response != 0x01) && (response != 0)) 
03C5E:  MOVLB  9
03C60:  DECFSZ xE4,W
03C62:  BRA    3C66
03C64:  BRA    3C70
03C66:  MOVF   xE4,F
03C68:  BZ    3C70
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03C6A:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
03C6C:  GOTO   43BE
....................          } 
....................  
....................       // Wait for the card to become ready 
....................       // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................       Timer = 0; 
03C70:  CLRF   xEA
03C72:  CLRF   xE9
....................       do 
....................          { 
....................          response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03C74:  MOVLW  41
03C76:  MOVLB  A
03C78:  MOVWF  x2B
03C7A:  CLRF   x2F
03C7C:  CLRF   x2E
03C7E:  CLRF   x2D
03C80:  CLRF   x2C
03C82:  MOVLB  0
03C84:  RCALL  3534
03C86:  MOVFF  01,9E4
....................          if (response != 0x00 ) 
03C8A:  MOVLB  9
03C8C:  MOVF   xE4,F
03C8E:  BZ    3C98
....................             delay_us(10); 
03C90:  MOVLW  35
03C92:  MOVWF  00
03C94:  DECFSZ 00,F
03C96:  BRA    3C94
....................          Timer++; 
03C98:  INCF   xE9,F
03C9A:  BTFSC  FD8.2
03C9C:  INCF   xEA,F
....................          } 
....................       while ((!(response==0x00)) && (Timer < 50000));  
03C9E:  MOVF   xE4,F
03CA0:  BZ    3CB0
03CA2:  MOVF   xEA,W
03CA4:  SUBLW  C3
03CA6:  BNC   3CB0
03CA8:  BNZ   3C74
03CAA:  MOVF   xE9,W
03CAC:  SUBLW  4F
03CAE:  BC    3C74
....................  
....................       if (nv_report_mode == 4) printf("@FS:Response from SD_CMD_SEND_OP_COND = %02x, Timer = %lu\r\n",response, Timer); 
03CB0:  MOVF   1F,W
03CB2:  SUBLW  04
03CB4:  BNZ   3D3E
03CB6:  MOVF   20,F
03CB8:  BNZ   3D3E
03CBA:  MOVLW  DC
03CBC:  MOVWF  FF6
03CBE:  MOVLW  08
03CC0:  MOVWF  FF7
03CC2:  MOVLW  00
03CC4:  MOVWF  FF8
03CC6:  CLRF   1B
03CC8:  BTFSC  FF2.7
03CCA:  BSF    1B.7
03CCC:  BCF    FF2.7
03CCE:  MOVLW  28
03CD0:  MOVLB  A
03CD2:  MOVWF  x40
03CD4:  MOVLB  0
03CD6:  CALL   1018
03CDA:  BTFSC  1B.7
03CDC:  BSF    FF2.7
03CDE:  MOVFF  9E4,9EC
03CE2:  MOVLW  57
03CE4:  MOVLB  9
03CE6:  MOVWF  xED
03CE8:  MOVLB  0
03CEA:  RCALL  3604
03CEC:  MOVLW  08
03CEE:  MOVWF  FF6
03CF0:  MOVLW  09
03CF2:  MOVWF  FF7
03CF4:  MOVLW  00
03CF6:  MOVWF  FF8
03CF8:  CLRF   1B
03CFA:  BTFSC  FF2.7
03CFC:  BSF    1B.7
03CFE:  BCF    FF2.7
03D00:  MOVLW  0A
03D02:  MOVLB  A
03D04:  MOVWF  x40
03D06:  MOVLB  0
03D08:  CALL   1018
03D0C:  BTFSC  1B.7
03D0E:  BSF    FF2.7
03D10:  MOVLW  10
03D12:  MOVWF  FE9
03D14:  CLRF   1B
03D16:  BTFSC  FF2.7
03D18:  BSF    1B.7
03D1A:  BCF    FF2.7
03D1C:  MOVFF  9EA,A41
03D20:  MOVFF  9E9,A40
03D24:  CALL   119A
03D28:  BTFSC  1B.7
03D2A:  BSF    FF2.7
03D2C:  MOVLW  0D
03D2E:  BTFSS  F9E.4
03D30:  BRA    3D2E
03D32:  MOVWF  FAD
03D34:  MOVLW  0A
03D36:  BTFSS  F9E.4
03D38:  BRA    3D36
03D3A:  MOVWF  FAD
03D3C:  MOVLB  9
....................       if(response) 
03D3E:  MOVF   xE4,F
03D40:  BZ    3D46
....................          { 
....................          SDCardStatus |= STA_NOINIT; 
03D42:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
03D44:  BRA    43BE
....................          } 
....................  
....................       // test for SD card 
....................       // send an SD specific command 
....................       response = SD_cmd(SD_CMD_APPL_CMD,0); 
03D46:  MOVLW  77
03D48:  MOVLB  A
03D4A:  MOVWF  x2B
03D4C:  CLRF   x2F
03D4E:  CLRF   x2E
03D50:  CLRF   x2D
03D52:  CLRF   x2C
03D54:  MOVLB  0
03D56:  CALL   3534
03D5A:  MOVFF  01,9E4
....................       if (nv_report_mode == 4) printf("@FS:Attempting SDv1 versus MMC ID, Response from SD_CMD_APPL_CMD = %02x\r\n",response); 
03D5E:  MOVF   1F,W
03D60:  SUBLW  04
03D62:  BNZ   3DAA
03D64:  MOVF   20,F
03D66:  BNZ   3DAA
03D68:  MOVLW  18
03D6A:  MOVWF  FF6
03D6C:  MOVLW  09
03D6E:  MOVWF  FF7
03D70:  MOVLW  00
03D72:  MOVWF  FF8
03D74:  CLRF   1B
03D76:  BTFSC  FF2.7
03D78:  BSF    1B.7
03D7A:  BCF    FF2.7
03D7C:  MOVLW  43
03D7E:  MOVLB  A
03D80:  MOVWF  x40
03D82:  MOVLB  0
03D84:  CALL   1018
03D88:  BTFSC  1B.7
03D8A:  BSF    FF2.7
03D8C:  MOVFF  9E4,9EC
03D90:  MOVLW  57
03D92:  MOVLB  9
03D94:  MOVWF  xED
03D96:  MOVLB  0
03D98:  RCALL  3604
03D9A:  MOVLW  0D
03D9C:  BTFSS  F9E.4
03D9E:  BRA    3D9C
03DA0:  MOVWF  FAD
03DA2:  MOVLW  0A
03DA4:  BTFSS  F9E.4
03DA6:  BRA    3DA4
03DA8:  MOVWF  FAD
....................       if (response) 
03DAA:  MOVLB  9
03DAC:  MOVF   xE4,F
03DAE:  BZ    3DBA
....................          { 
....................          // if any response then the card cannot support application commands 
....................          // and therefore cannot be an SD card 
....................          Card = MMC; 
03DB0:  MOVLW  02
03DB2:  MOVLB  4
03DB4:  MOVWF  xE7
....................          } 
03DB6:  BRA    3FB4
03DB8:  MOVLB  9
....................       else 
....................          { 
....................          // send SD_SEND_OP_COND 
....................          response = SD_cmd(SD_ACMD41,0); 
03DBA:  MOVLW  69
03DBC:  MOVLB  A
03DBE:  MOVWF  x2B
03DC0:  CLRF   x2F
03DC2:  CLRF   x2E
03DC4:  CLRF   x2D
03DC6:  CLRF   x2C
03DC8:  MOVLB  0
03DCA:  CALL   3534
03DCE:  MOVFF  01,9E4
....................          if (response <= 1 ) 
03DD2:  MOVLB  9
03DD4:  MOVF   xE4,W
03DD6:  SUBLW  01
03DD8:  BNC   3DE4
....................             Card = SDv1; 
03DDA:  MOVLW  03
03DDC:  MOVLB  4
03DDE:  MOVWF  xE7
03DE0:  BRA    3FB4
03DE2:  MOVLB  9
....................          else 
....................             { 
....................             if (nv_report_mode == 4) printf("@FS:Invalid response to SD_ACMD41, response = %02X, reinitializing as MMC\r\n",response); 
03DE4:  MOVF   1F,W
03DE6:  SUBLW  04
03DE8:  BNZ   3E48
03DEA:  MOVF   20,F
03DEC:  BNZ   3E48
03DEE:  MOVLW  62
03DF0:  MOVWF  FF6
03DF2:  MOVLW  09
03DF4:  MOVWF  FF7
03DF6:  MOVLW  00
03DF8:  MOVWF  FF8
03DFA:  CLRF   1B
03DFC:  BTFSC  FF2.7
03DFE:  BSF    1B.7
03E00:  BCF    FF2.7
03E02:  MOVLW  2E
03E04:  MOVLB  A
03E06:  MOVWF  x40
03E08:  MOVLB  0
03E0A:  CALL   1018
03E0E:  BTFSC  1B.7
03E10:  BSF    FF2.7
03E12:  MOVFF  9E4,9EC
03E16:  MOVLW  37
03E18:  MOVLB  9
03E1A:  MOVWF  xED
03E1C:  MOVLB  0
03E1E:  CALL   3604
03E22:  MOVLW  94
03E24:  MOVWF  FF6
03E26:  MOVLW  09
03E28:  MOVWF  FF7
03E2A:  MOVLW  00
03E2C:  MOVWF  FF8
03E2E:  CLRF   1B
03E30:  BTFSC  FF2.7
03E32:  BSF    1B.7
03E34:  BCF    FF2.7
03E36:  MOVLW  19
03E38:  MOVLB  A
03E3A:  MOVWF  x40
03E3C:  MOVLB  0
03E3E:  CALL   1018
03E42:  BTFSC  1B.7
03E44:  BSF    FF2.7
03E46:  MOVLB  9
....................             // Invalid response to SD Application command - trying MMC init sequence 
....................             // reinitialise as MMC card 
....................             response = SD_cmd(SD_CMD_GO_IDLE_STATE,0);  
03E48:  MOVLW  40
03E4A:  MOVLB  A
03E4C:  MOVWF  x2B
03E4E:  CLRF   x2F
03E50:  CLRF   x2E
03E52:  CLRF   x2D
03E54:  CLRF   x2C
03E56:  MOVLB  0
03E58:  CALL   3534
03E5C:  MOVFF  01,9E4
....................             if ((response !=0x01) && (response != 0)) 
03E60:  MOVLB  9
03E62:  DECFSZ xE4,W
03E64:  BRA    3E68
03E66:  BRA    3ED4
03E68:  MOVF   xE4,F
03E6A:  BZ    3ED4
....................                { 
....................                // Card reset failure - aborting SD card initialization; 
....................                if (nv_report_mode == 4) printf("@FS:Failed to initialize as MMC, response = %02X, exiting\r\n",response); 
03E6C:  MOVF   1F,W
03E6E:  SUBLW  04
03E70:  BNZ   3ED0
03E72:  MOVF   20,F
03E74:  BNZ   3ED0
03E76:  MOVLW  AE
03E78:  MOVWF  FF6
03E7A:  MOVLW  09
03E7C:  MOVWF  FF7
03E7E:  MOVLW  00
03E80:  MOVWF  FF8
03E82:  CLRF   1B
03E84:  BTFSC  FF2.7
03E86:  BSF    1B.7
03E88:  BCF    FF2.7
03E8A:  MOVLW  2C
03E8C:  MOVLB  A
03E8E:  MOVWF  x40
03E90:  MOVLB  0
03E92:  CALL   1018
03E96:  BTFSC  1B.7
03E98:  BSF    FF2.7
03E9A:  MOVFF  9E4,9EC
03E9E:  MOVLW  37
03EA0:  MOVLB  9
03EA2:  MOVWF  xED
03EA4:  MOVLB  0
03EA6:  CALL   3604
03EAA:  MOVLW  DE
03EAC:  MOVWF  FF6
03EAE:  MOVLW  09
03EB0:  MOVWF  FF7
03EB2:  MOVLW  00
03EB4:  MOVWF  FF8
03EB6:  CLRF   1B
03EB8:  BTFSC  FF2.7
03EBA:  BSF    1B.7
03EBC:  BCF    FF2.7
03EBE:  MOVLW  0B
03EC0:  MOVLB  A
03EC2:  MOVWF  x40
03EC4:  MOVLB  0
03EC6:  CALL   1018
03ECA:  BTFSC  1B.7
03ECC:  BSF    FF2.7
03ECE:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03ED0:  BSF    xEB.0
....................                goto Exit_disk_initialize; 
03ED2:  BRA    43BE
....................                } 
....................  
....................             // Wait for the card to become ready 
....................             // Maximum 500ms CMD1 (SD_CMD_SEND_OP_COND) to Ready 
....................             Timer = 0; 
03ED4:  CLRF   xEA
03ED6:  CLRF   xE9
....................             do 
....................                { 
....................                response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
03ED8:  MOVLW  41
03EDA:  MOVLB  A
03EDC:  MOVWF  x2B
03EDE:  CLRF   x2F
03EE0:  CLRF   x2E
03EE2:  CLRF   x2D
03EE4:  CLRF   x2C
03EE6:  MOVLB  0
03EE8:  CALL   3534
03EEC:  MOVFF  01,9E4
....................                if (response != 0x00 ) 
03EF0:  MOVLB  9
03EF2:  MOVF   xE4,F
03EF4:  BZ    3EFE
....................                   delay_us(10); 
03EF6:  MOVLW  35
03EF8:  MOVWF  00
03EFA:  DECFSZ 00,F
03EFC:  BRA    3EFA
....................                Timer++; 
03EFE:  INCF   xE9,F
03F00:  BTFSC  FD8.2
03F02:  INCF   xEA,F
....................                } 
....................             while ((!(response==0x00)) && (Timer < 50000));  
03F04:  MOVF   xE4,F
03F06:  BZ    3F16
03F08:  MOVF   xEA,W
03F0A:  SUBLW  C3
03F0C:  BNC   3F16
03F0E:  BNZ   3ED8
03F10:  MOVF   xE9,W
03F12:  SUBLW  4F
03F14:  BC    3ED8
....................     
....................             if(response) 
03F16:  MOVF   xE4,F
03F18:  BZ    3FAE
....................                { 
....................                if (nv_report_mode == 4) printf("@FS:Card failed to respond correcly after SD_CMD_SEND_OP_COND, response = %02X, Timer = %lu\r\n",response, Timer); 
03F1A:  MOVF   1F,W
03F1C:  SUBLW  04
03F1E:  BNZ   3FAA
03F20:  MOVF   20,F
03F22:  BNZ   3FAA
03F24:  MOVLW  EA
03F26:  MOVWF  FF6
03F28:  MOVLW  09
03F2A:  MOVWF  FF7
03F2C:  MOVLW  00
03F2E:  MOVWF  FF8
03F30:  CLRF   1B
03F32:  BTFSC  FF2.7
03F34:  BSF    1B.7
03F36:  BCF    FF2.7
03F38:  MOVLW  4A
03F3A:  MOVLB  A
03F3C:  MOVWF  x40
03F3E:  MOVLB  0
03F40:  CALL   1018
03F44:  BTFSC  1B.7
03F46:  BSF    FF2.7
03F48:  MOVFF  9E4,9EC
03F4C:  MOVLW  37
03F4E:  MOVLB  9
03F50:  MOVWF  xED
03F52:  MOVLB  0
03F54:  CALL   3604
03F58:  MOVLW  38
03F5A:  MOVWF  FF6
03F5C:  MOVLW  0A
03F5E:  MOVWF  FF7
03F60:  MOVLW  00
03F62:  MOVWF  FF8
03F64:  CLRF   1B
03F66:  BTFSC  FF2.7
03F68:  BSF    1B.7
03F6A:  BCF    FF2.7
03F6C:  MOVLW  0A
03F6E:  MOVLB  A
03F70:  MOVWF  x40
03F72:  MOVLB  0
03F74:  CALL   1018
03F78:  BTFSC  1B.7
03F7A:  BSF    FF2.7
03F7C:  MOVLW  10
03F7E:  MOVWF  FE9
03F80:  CLRF   1B
03F82:  BTFSC  FF2.7
03F84:  BSF    1B.7
03F86:  BCF    FF2.7
03F88:  MOVFF  9EA,A41
03F8C:  MOVFF  9E9,A40
03F90:  CALL   119A
03F94:  BTFSC  1B.7
03F96:  BSF    FF2.7
03F98:  MOVLW  0D
03F9A:  BTFSS  F9E.4
03F9C:  BRA    3F9A
03F9E:  MOVWF  FAD
03FA0:  MOVLW  0A
03FA2:  BTFSS  F9E.4
03FA4:  BRA    3FA2
03FA6:  MOVWF  FAD
03FA8:  MOVLB  9
....................                SDCardStatus |= STA_NOINIT; 
03FAA:  BSF    xEB.0
....................                goto Exit_disk_initialize; 
03FAC:  BRA    43BE
....................                } 
....................  
....................             Card = MMC; 
03FAE:  MOVLW  02
03FB0:  MOVLB  4
03FB2:  MOVWF  xE7
....................             } 
....................          } 
....................  
....................       if (nv_report_mode == 4) printf("@FS:Setting block length\r\n"); 
03FB4:  MOVF   1F,W
03FB6:  SUBLW  04
03FB8:  BNZ   3FDE
03FBA:  MOVF   20,F
03FBC:  BNZ   3FDE
03FBE:  MOVLW  48
03FC0:  MOVWF  FF6
03FC2:  MOVLW  0A
03FC4:  MOVWF  FF7
03FC6:  MOVLW  00
03FC8:  MOVWF  FF8
03FCA:  CLRF   1B
03FCC:  BTFSC  FF2.7
03FCE:  BSF    1B.7
03FD0:  BCF    FF2.7
03FD2:  MOVLB  0
03FD4:  CALL   0E42
03FD8:  BTFSC  1B.7
03FDA:  BSF    FF2.7
03FDC:  MOVLB  4
....................       // CMD16 Set R/W block length to 512 
....................       response = SD_cmd(SD_CMD_SET_BLOCKLEN,512); 
03FDE:  MOVLW  50
03FE0:  MOVLB  A
03FE2:  MOVWF  x2B
03FE4:  CLRF   x2F
03FE6:  CLRF   x2E
03FE8:  MOVLW  02
03FEA:  MOVWF  x2D
03FEC:  CLRF   x2C
03FEE:  MOVLB  0
03FF0:  CALL   3534
03FF4:  MOVFF  01,9E4
....................       if ((Timer == 50000) || (response > 1))    
03FF8:  MOVLB  9
03FFA:  MOVF   xE9,W
03FFC:  SUBLW  50
03FFE:  BNZ   4006
04000:  MOVF   xEA,W
04002:  SUBLW  C3
04004:  BZ    400C
04006:  MOVF   xE4,W
04008:  SUBLW  01
0400A:  BC    40A2
....................       { 
....................          Card = None; 
0400C:  MOVLB  4
0400E:  CLRF   xE7
....................          if (nv_report_mode == 4) printf("@FS:Error setting block length, response = %02x, timer = %lu\r\n",response, Timer); 
04010:  MOVF   1F,W
04012:  SUBLW  04
04014:  BNZ   40A0
04016:  MOVF   20,F
04018:  BNZ   40A0
0401A:  MOVLW  64
0401C:  MOVWF  FF6
0401E:  MOVLW  0A
04020:  MOVWF  FF7
04022:  MOVLW  00
04024:  MOVWF  FF8
04026:  CLRF   1B
04028:  BTFSC  FF2.7
0402A:  BSF    1B.7
0402C:  BCF    FF2.7
0402E:  MOVLW  2B
04030:  MOVLB  A
04032:  MOVWF  x40
04034:  MOVLB  0
04036:  CALL   1018
0403A:  BTFSC  1B.7
0403C:  BSF    FF2.7
0403E:  MOVFF  9E4,9EC
04042:  MOVLW  57
04044:  MOVLB  9
04046:  MOVWF  xED
04048:  MOVLB  0
0404A:  CALL   3604
0404E:  MOVLW  93
04050:  MOVWF  FF6
04052:  MOVLW  0A
04054:  MOVWF  FF7
04056:  MOVLW  00
04058:  MOVWF  FF8
0405A:  CLRF   1B
0405C:  BTFSC  FF2.7
0405E:  BSF    1B.7
04060:  BCF    FF2.7
04062:  MOVLW  0A
04064:  MOVLB  A
04066:  MOVWF  x40
04068:  MOVLB  0
0406A:  CALL   1018
0406E:  BTFSC  1B.7
04070:  BSF    FF2.7
04072:  MOVLW  10
04074:  MOVWF  FE9
04076:  CLRF   1B
04078:  BTFSC  FF2.7
0407A:  BSF    1B.7
0407C:  BCF    FF2.7
0407E:  MOVFF  9EA,A41
04082:  MOVFF  9E9,A40
04086:  CALL   119A
0408A:  BTFSC  1B.7
0408C:  BSF    FF2.7
0408E:  MOVLW  0D
04090:  BTFSS  F9E.4
04092:  BRA    4090
04094:  MOVWF  FAD
04096:  MOVLW  0A
04098:  BTFSS  F9E.4
0409A:  BRA    4098
0409C:  MOVWF  FAD
0409E:  MOVLB  4
040A0:  MOVLB  9
....................       } 
....................    } 
....................     
....................    if (Card == None) 
040A2:  MOVLB  4
040A4:  MOVF   xE7,F
040A6:  BNZ   40DA
....................    { 
....................       if (nv_report_mode == 4) 
040A8:  MOVF   1F,W
040AA:  SUBLW  04
040AC:  BNZ   40D2
040AE:  MOVF   20,F
040B0:  BNZ   40D2
....................          printf("@FS:Card Type Discovery Error\r\n"); 
040B2:  MOVLW  A4
040B4:  MOVWF  FF6
040B6:  MOVLW  0A
040B8:  MOVWF  FF7
040BA:  MOVLW  00
040BC:  MOVWF  FF8
040BE:  CLRF   1B
040C0:  BTFSC  FF2.7
040C2:  BSF    1B.7
040C4:  BCF    FF2.7
040C6:  MOVLB  0
040C8:  CALL   0E42
040CC:  BTFSC  1B.7
040CE:  BSF    FF2.7
040D0:  MOVLB  4
....................  
....................       SDCardStatus |= STA_NOINIT; 
040D2:  MOVLB  9
040D4:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
040D6:  BRA    43BE
040D8:  MOVLB  4
....................    } 
....................  
....................  
....................    // Completed card identification 
....................    switch (Card) 
040DA:  MOVF   xE7,W
040DC:  XORLW  02
040DE:  MOVLB  0
040E0:  BZ    40F0
040E2:  XORLW  01
040E4:  BZ    4118
040E6:  XORLW  07
040E8:  BZ    4140
040EA:  XORLW  01
040EC:  BZ    4168
040EE:  BRA    4190
....................    { 
....................       case MMC : 
....................          if (nv_report_mode == 4) printf("@FS:MMC Card found\r\n"); 
040F0:  MOVF   1F,W
040F2:  SUBLW  04
040F4:  BNZ   4116
040F6:  MOVF   20,F
040F8:  BNZ   4116
040FA:  MOVLW  C4
040FC:  MOVWF  FF6
040FE:  MOVLW  0A
04100:  MOVWF  FF7
04102:  MOVLW  00
04104:  MOVWF  FF8
04106:  CLRF   1B
04108:  BTFSC  FF2.7
0410A:  BSF    1B.7
0410C:  BCF    FF2.7
0410E:  CALL   0E42
04112:  BTFSC  1B.7
04114:  BSF    FF2.7
....................          break; 
04116:  BRA    41E6
....................  
....................       case SDv1 : 
....................          if (nv_report_mode == 4) printf("@FS:SDv1 Card found\r\n"); 
04118:  MOVF   1F,W
0411A:  SUBLW  04
0411C:  BNZ   413E
0411E:  MOVF   20,F
04120:  BNZ   413E
04122:  MOVLW  DA
04124:  MOVWF  FF6
04126:  MOVLW  0A
04128:  MOVWF  FF7
0412A:  MOVLW  00
0412C:  MOVWF  FF8
0412E:  CLRF   1B
04130:  BTFSC  FF2.7
04132:  BSF    1B.7
04134:  BCF    FF2.7
04136:  CALL   0E42
0413A:  BTFSC  1B.7
0413C:  BSF    FF2.7
....................          break; 
0413E:  BRA    41E6
....................  
....................       case SDSC : 
....................          if (nv_report_mode == 4) printf("@FS:SDSC Card found\r\n"); 
04140:  MOVF   1F,W
04142:  SUBLW  04
04144:  BNZ   4166
04146:  MOVF   20,F
04148:  BNZ   4166
0414A:  MOVLW  F0
0414C:  MOVWF  FF6
0414E:  MOVLW  0A
04150:  MOVWF  FF7
04152:  MOVLW  00
04154:  MOVWF  FF8
04156:  CLRF   1B
04158:  BTFSC  FF2.7
0415A:  BSF    1B.7
0415C:  BCF    FF2.7
0415E:  CALL   0E42
04162:  BTFSC  1B.7
04164:  BSF    FF2.7
....................          break; 
04166:  BRA    41E6
....................  
....................       case SDHC : 
....................          if (nv_report_mode == 4) printf("@FS:SDHC Card found\r\n"); 
04168:  MOVF   1F,W
0416A:  SUBLW  04
0416C:  BNZ   418E
0416E:  MOVF   20,F
04170:  BNZ   418E
04172:  MOVLW  06
04174:  MOVWF  FF6
04176:  MOVLW  0B
04178:  MOVWF  FF7
0417A:  MOVLW  00
0417C:  MOVWF  FF8
0417E:  CLRF   1B
04180:  BTFSC  FF2.7
04182:  BSF    1B.7
04184:  BCF    FF2.7
04186:  CALL   0E42
0418A:  BTFSC  1B.7
0418C:  BSF    FF2.7
....................          break; 
0418E:  BRA    41E6
....................  
....................       default : 
....................          if (nv_report_mode == 4) printf("@FS:Card Type Discovery Error, Card = %02X\r\n",Card); 
04190:  MOVF   1F,W
04192:  SUBLW  04
04194:  BNZ   41DE
04196:  MOVF   20,F
04198:  BNZ   41DE
0419A:  MOVLW  1C
0419C:  MOVWF  FF6
0419E:  MOVLW  0B
041A0:  MOVWF  FF7
041A2:  MOVLW  00
041A4:  MOVWF  FF8
041A6:  CLRF   1B
041A8:  BTFSC  FF2.7
041AA:  BSF    1B.7
041AC:  BCF    FF2.7
041AE:  MOVLW  26
041B0:  MOVLB  A
041B2:  MOVWF  x40
041B4:  MOVLB  0
041B6:  CALL   1018
041BA:  BTFSC  1B.7
041BC:  BSF    FF2.7
041BE:  MOVFF  4E7,9EC
041C2:  MOVLW  37
041C4:  MOVLB  9
041C6:  MOVWF  xED
041C8:  MOVLB  0
041CA:  CALL   3604
041CE:  MOVLW  0D
041D0:  BTFSS  F9E.4
041D2:  BRA    41D0
041D4:  MOVWF  FAD
041D6:  MOVLW  0A
041D8:  BTFSS  F9E.4
041DA:  BRA    41D8
041DC:  MOVWF  FAD
....................          SDCardStatus |= STA_NOINIT; 
041DE:  MOVLB  9
041E0:  BSF    xEB.0
....................          goto Exit_disk_initialize; 
041E2:  BRA    43BE
041E4:  MOVLB  0
....................    } 
....................  
....................    SDCardStatus &= ~STA_NOINIT; 
041E6:  MOVLB  9
041E8:  BCF    xEB.0
....................  
....................    if (nv_report_mode == 4) printf("@FS:Card reset success - Cmd to Ready count = %lu\r\n", Timer); 
041EA:  MOVF   1F,W
041EC:  SUBLW  04
041EE:  BNZ   4246
041F0:  MOVF   20,F
041F2:  BNZ   4246
041F4:  MOVLW  4A
041F6:  MOVWF  FF6
041F8:  MOVLW  0B
041FA:  MOVWF  FF7
041FC:  MOVLW  00
041FE:  MOVWF  FF8
04200:  CLRF   1B
04202:  BTFSC  FF2.7
04204:  BSF    1B.7
04206:  BCF    FF2.7
04208:  MOVLW  2E
0420A:  MOVLB  A
0420C:  MOVWF  x40
0420E:  MOVLB  0
04210:  CALL   1018
04214:  BTFSC  1B.7
04216:  BSF    FF2.7
04218:  MOVLW  10
0421A:  MOVWF  FE9
0421C:  CLRF   1B
0421E:  BTFSC  FF2.7
04220:  BSF    1B.7
04222:  BCF    FF2.7
04224:  MOVFF  9EA,A41
04228:  MOVFF  9E9,A40
0422C:  CALL   119A
04230:  BTFSC  1B.7
04232:  BSF    FF2.7
04234:  MOVLW  0D
04236:  BTFSS  F9E.4
04238:  BRA    4236
0423A:  MOVWF  FAD
0423C:  MOVLW  0A
0423E:  BTFSS  F9E.4
04240:  BRA    423E
04242:  MOVWF  FAD
04244:  MOVLB  9
....................  
....................    // set the SPI bus speed to high 
....................  
....................    DeselectSD; 
04246:  BSF    F91.1
....................  
....................    // SPI Mode 0 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_CLK_DIV_4 | SPI_XMIT_L_TO_H); 
04248:  BCF    FC6.5
0424A:  MOVLW  20
0424C:  MOVWF  FC6
0424E:  MOVLW  40
04250:  MOVWF  FC7
....................    clear_interrupt(INT_SSP); 
04252:  BCF    F9E.3
....................    SelectSD; 
04254:  BCF    F91.1
....................  
....................    if (nv_report_mode == 4) printf("@FS:SPI bus speed set to high\r\n"); 
04256:  MOVF   1F,W
04258:  SUBLW  04
0425A:  BNZ   4280
0425C:  MOVF   20,F
0425E:  BNZ   4280
04260:  MOVLW  7E
04262:  MOVWF  FF6
04264:  MOVLW  0B
04266:  MOVWF  FF7
04268:  MOVLW  00
0426A:  MOVWF  FF8
0426C:  CLRF   1B
0426E:  BTFSC  FF2.7
04270:  BSF    1B.7
04272:  BCF    FF2.7
04274:  MOVLB  0
04276:  CALL   0E42
0427A:  BTFSC  1B.7
0427C:  BSF    FF2.7
0427E:  MOVLB  9
....................  
....................    // Wait for the card to become ready  
....................    Timer = 0; 
04280:  CLRF   xEA
04282:  CLRF   xE9
....................    do 
....................    { 
....................       response = SD_cmd(SD_CMD_SEND_OP_COND,0);    
04284:  MOVLW  41
04286:  MOVLB  A
04288:  MOVWF  x2B
0428A:  CLRF   x2F
0428C:  CLRF   x2E
0428E:  CLRF   x2D
04290:  CLRF   x2C
04292:  MOVLB  0
04294:  CALL   3534
04298:  MOVFF  01,9E4
....................       if (response != 0x00 ) 
0429C:  MOVLB  9
0429E:  MOVF   xE4,F
042A0:  BZ    42AA
....................          delay_us(10); 
042A2:  MOVLW  35
042A4:  MOVWF  00
042A6:  DECFSZ 00,F
042A8:  BRA    42A6
....................  
....................       Timer++; 
042AA:  INCF   xE9,F
042AC:  BTFSC  FD8.2
042AE:  INCF   xEA,F
....................    } while ((!(response==0x00)) && (Timer < 50000)); 
042B0:  MOVF   xE4,F
042B2:  BZ    42C2
042B4:  MOVF   xEA,W
042B6:  SUBLW  C3
042B8:  BNC   42C2
042BA:  BNZ   4284
042BC:  MOVF   xE9,W
042BE:  SUBLW  4F
042C0:  BC    4284
....................  
....................    if (response != 0x00) 
042C2:  MOVF   xE4,F
042C4:  BZ    435A
....................    { 
....................       if (nv_report_mode == 4) printf("@FS:Card activate failure, response = %02X, Timer = %lu\r\n", response, Timer); 
042C6:  MOVF   1F,W
042C8:  SUBLW  04
042CA:  BNZ   4356
042CC:  MOVF   20,F
042CE:  BNZ   4356
042D0:  MOVLW  9E
042D2:  MOVWF  FF6
042D4:  MOVLW  0B
042D6:  MOVWF  FF7
042D8:  MOVLW  00
042DA:  MOVWF  FF8
042DC:  CLRF   1B
042DE:  BTFSC  FF2.7
042E0:  BSF    1B.7
042E2:  BCF    FF2.7
042E4:  MOVLW  26
042E6:  MOVLB  A
042E8:  MOVWF  x40
042EA:  MOVLB  0
042EC:  CALL   1018
042F0:  BTFSC  1B.7
042F2:  BSF    FF2.7
042F4:  MOVFF  9E4,9EC
042F8:  MOVLW  37
042FA:  MOVLB  9
042FC:  MOVWF  xED
042FE:  MOVLB  0
04300:  CALL   3604
04304:  MOVLW  C8
04306:  MOVWF  FF6
04308:  MOVLW  0B
0430A:  MOVWF  FF7
0430C:  MOVLW  00
0430E:  MOVWF  FF8
04310:  CLRF   1B
04312:  BTFSC  FF2.7
04314:  BSF    1B.7
04316:  BCF    FF2.7
04318:  MOVLW  0A
0431A:  MOVLB  A
0431C:  MOVWF  x40
0431E:  MOVLB  0
04320:  CALL   1018
04324:  BTFSC  1B.7
04326:  BSF    FF2.7
04328:  MOVLW  10
0432A:  MOVWF  FE9
0432C:  CLRF   1B
0432E:  BTFSC  FF2.7
04330:  BSF    1B.7
04332:  BCF    FF2.7
04334:  MOVFF  9EA,A41
04338:  MOVFF  9E9,A40
0433C:  CALL   119A
04340:  BTFSC  1B.7
04342:  BSF    FF2.7
04344:  MOVLW  0D
04346:  BTFSS  F9E.4
04348:  BRA    4346
0434A:  MOVWF  FAD
0434C:  MOVLW  0A
0434E:  BTFSS  F9E.4
04350:  BRA    434E
04352:  MOVWF  FAD
04354:  MOVLB  9
....................       SDCardStatus |= STA_NOINIT; 
04356:  BSF    xEB.0
....................       goto Exit_disk_initialize; 
04358:  BRA    43BE
....................    } 
....................  
....................    if (nv_report_mode == 4) 
0435A:  MOVF   1F,W
0435C:  SUBLW  04
0435E:  BNZ   43B6
04360:  MOVF   20,F
04362:  BNZ   43B6
....................       printf("@FS:Card activate success on attempt %lu\r\n",Timer); 
04364:  MOVLW  D8
04366:  MOVWF  FF6
04368:  MOVLW  0B
0436A:  MOVWF  FF7
0436C:  MOVLW  00
0436E:  MOVWF  FF8
04370:  CLRF   1B
04372:  BTFSC  FF2.7
04374:  BSF    1B.7
04376:  BCF    FF2.7
04378:  MOVLW  25
0437A:  MOVLB  A
0437C:  MOVWF  x40
0437E:  MOVLB  0
04380:  CALL   1018
04384:  BTFSC  1B.7
04386:  BSF    FF2.7
04388:  MOVLW  10
0438A:  MOVWF  FE9
0438C:  CLRF   1B
0438E:  BTFSC  FF2.7
04390:  BSF    1B.7
04392:  BCF    FF2.7
04394:  MOVFF  9EA,A41
04398:  MOVFF  9E9,A40
0439C:  CALL   119A
043A0:  BTFSC  1B.7
043A2:  BSF    FF2.7
043A4:  MOVLW  0D
043A6:  BTFSS  F9E.4
043A8:  BRA    43A6
043AA:  MOVWF  FAD
043AC:  MOVLW  0A
043AE:  BTFSS  F9E.4
043B0:  BRA    43AE
043B2:  MOVWF  FAD
043B4:  MOVLB  9
....................  
....................    msg_card_ok(); 
043B6:  MOVLB  0
043B8:  GOTO   364A
043BC:  MOVLB  9
....................  
....................  
.................... Exit_disk_initialize: 
....................    DeselectSD; 
043BE:  BSF    F91.1
....................    return(SDCardStatus); 
043C0:  MOVFF  9EB,01
043C4:  MOVLB  0
043C6:  RETURN 0
.................... } 
....................  
.................... #separate 
.................... DRESULT disk_ioctl (BYTE ctrl, void *buff) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Low Level SD function 
.................... // 
.................... //   Revision History 
.................... //      20/01/09   SDHC support added 
.................... // 
.................... //   Entry 
.................... //      ctrl      control code 
.................... //      buff      pointer to send / receive block 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DRESULT Response; 
....................    BYTE n, csd[16], *ptr; 
....................    WORD csize; 
....................  
....................    ptr = buff; 
....................    if (Media_Status & STA_NOINIT)  
....................       return (RES_NOTRDY); 
....................  
....................    SelectSD; 
....................  
....................    Response = RES_ERROR; 
....................    switch (ctrl) 
....................    { 
....................       case CTRL_SYNC :      // Flush dirty buffer if present 
....................          if (wait_ready() == 0xFF) 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_COUNT :   // Get number of sectors on the disk (unsigned long)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                { 
....................                // Calculate disk size  
....................                if ((csd[0] >> 6) == 1)  
....................                   {  
....................                   // SDC ver 2.00 
....................                   csize = csd[9] + ((WORD)csd[8] << 8) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << 10; 
....................                   }  
....................                else  
....................                   {  
....................                   // MMC or SDC ver 1.XX 
....................                   n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; 
....................                   csize = (csd[8] >> 6) + ((WORD)csd[7] << 2) + ((WORD)(csd[6] & 3) << 10) + 1; 
....................                   *(DWORD*)buff = (DWORD)csize << (n - 9); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................          break; 
....................  
....................  
....................       case GET_SECTOR_SIZE :   // Get sectors on the disk (WORD) 
....................             *(WORD*)buff = 512; 
....................             Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case GET_BLOCK_SIZE :   // Get erase block size in unit of sectors (DWORD) 
....................          if (Card & (SDv1 || SDSC || SDHC))  
....................             {  
....................             // SDC ver 2.00 
....................             SD_cmd(SD_CMD_APPL_CMD,0); 
....................             if (SD_cmd(SD_ACMD13, 0) == 0)  
....................                {  
....................                // read SD status 
....................                SD_spi_read(0xFF); 
....................                if (SD_receive_data(csd, (DWORD) 16))  
....................                   { 
....................                   // Read partial block 
....................                   for (n = 64 - 16; n; n--)  
....................                      SD_spi_read(0xFF);      // Purge trailing data 
....................                   *(DWORD*)buff = 16UL << (csd[10] >> 4); 
....................                   Response = RES_OK; 
....................                   } 
....................                } 
....................             }  
....................          else  
....................             {  
....................             // SDC ver 1.XX or MMC 
....................             if ((SD_cmd(SD_CMD_SEND_CSD, 0) == 0) && SD_receive_data(csd, (DWORD) 16))  
....................                { 
....................                // read CSD 
....................                if (Card & SDv1)  
....................                   { 
....................                   // SDC ver 1.XX 
....................                   *(DWORD*)buff = (((csd[10] & 63) << 1) + ((WORD)(csd[11] & 128) >> 7) + 1) << ((csd[13] >> 6) - 1); 
....................                   }  
....................                else  
....................                   {             
....................                   // MMC  
....................                   *(DWORD*)buff = ((WORD)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1); 
....................                   } 
....................                Response = RES_OK; 
....................                } 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_TYPE :      // Get card type (1 byte) 
....................          *ptr = Card; 
....................          Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CSD :   // Receive CSD as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CSD,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_CID :   // Receive CID as a data block (16 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_CID,0x00000000) == 0) 
....................             if (SD_receive_data(ptr, (DWORD) 16) == 0) 
....................                Response = RES_OK; 
....................          break; 
....................  
....................  
....................       case SD_GET_OCR :   // Receive OCR as an R3 resp (4 bytes)  
....................          if (SD_cmd(SD_CMD_SEND_OCR, 0) == 0)  
....................             {   // READ_OCR  
....................             for (n = 0; n < 4; n++) 
....................                *ptr++ = SD_spi_read(0xFF); 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       case SD_GET_SDSTAT :   // Receive SD statsu as a data block (64 bytes) 
....................          SD_cmd(SD_CMD_APPL_CMD,0); 
....................          if (SD_cmd(SD_ACMD13, 0) == 0)  
....................             {    
....................             // SD status 
....................             SD_spi_read(0xFF); 
....................             if (SD_receive_data(buff, (DWORD) 64)) 
....................             Response = RES_OK; 
....................             } 
....................          break; 
....................  
....................  
....................       default: 
....................          Response = RES_PARERR; 
....................    } 
....................    DeselectSD;    
....................    SD_spi_read(0xFF);         // Idle (Release DO)  
....................    return (Response); 
.................... } 
.................... #define _DISKIF 
.................... #endif 
....................  
....................  
.................... // Result type for fatfs application interface  
.................... typedef unsigned char   FRESULT; 
.................... typedef char* pchar; 
.................... typedef BYTE* pBYTE; 
....................  
.................... // File system object structure  
.................... typedef struct _FATFS  
....................    { 
....................    BYTE   fs_type;      // FAT type  
....................    BYTE   files;         // Number of files currently opened  
....................    BYTE   sects_clust;   // Sectors per cluster  
....................    BYTE   n_fats;         // Number of FAT copies  
....................    WORD   n_rootdir;      // Number of root directory entry  
....................    BYTE   winflag;      // win[] dirty flag (1:must be written back)  
....................    BYTE   pad1; 
....................    DWORD   sects_fat;      // Sectors per fat  
....................    DWORD   max_clust;      // Maximum cluster# + 1  
....................    DWORD   fatbase;      // FAT start sector  
....................    DWORD   dirbase;      // Root directory start sector (cluster# for FAT32)  
....................    DWORD   database;      // Data start sector  
....................    DWORD   last_clust;      // last allocated cluster 
....................    DWORD   winsect;      // Current sector appearing in the win[]  
....................    BYTE   win[512];      // Disk access window for Directory/FAT area  
....................    } FATFS; 
....................  
....................  
.................... // Directory object structure  
.................... typedef struct _DIR  
....................    { 
....................    DWORD   sclust;      // Start cluster  
....................    DWORD   clust;      // Current cluster  
....................    DWORD   sect;      // Current sector  
....................    WORD   index;      // Current index  
....................    } DIR; 
....................  
....................  
.................... // File object structure  
.................... typedef struct _FIL  
....................    { 
....................    DWORD   fptr;         // File R/W pointer  
....................    DWORD   fsize;         // File size  
....................    DWORD   org_clust;      // File start cluster  
....................    DWORD   curr_clust;      // Current cluster  
....................    DWORD   curr_sect;      // Current sector  
....................  
....................    #ifndef _FS_READONLY 
....................       DWORD   dir_sect;   // Sector containing the directory entry  
....................       BYTE*   dir_ptr;   // Pointer to the directory entry in the window  
....................    #endif 
....................  
....................    BYTE   flag;         // File status flags  
....................    BYTE   sect_clust;      // Left sectors in cluster  
....................  
....................    #ifndef USE_FAT_LITE 
....................       BYTE   buffer[512];   // File R/W buffer  
....................    #endif 
....................    } FIL; 
....................  
....................  
.................... // File status structure  
.................... typedef struct _FILINFO  
....................    { 
....................    DWORD fsize;         // Size  
....................    WORD fdate;            // Date  
....................    WORD ftime;            // Time  
....................    BYTE fattrib;         // Attribute  
....................    char fname[8+1+3+1];   // Name (8.3 format)  
....................    } FILINFO; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // FatFs module application interface                   
....................  
.................... //void f_init(void);                                // Initialise the file system data structure  
.................... #define f_init()    memset(fs, 0, sizeof(FATFS))         // Initialise the file system data structure 
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode);         // Open or create a file  
.................... FRESULT f_read (FIL *fp, void *buff, WORD btr, WORD *br);   // Read from a file  
.................... FRESULT f_close (FIL *fp);                           // Close a file  
.................... FRESULT f_lseek (FIL *fp, DWORD ofs);                  // Seek file pointer  
.................... FRESULT f_opendir (DIR *scan, char *path);               // Initialize to read a directory  
.................... FRESULT f_readdir (DIR *scan, FILINFO *finfo);            // Read a directory item  
.................... FRESULT f_stat (char *path, FILINFO *finfo);            // Get file status  
.................... FRESULT f_getfree (DWORD *nclust);                     // Get number of free clusters  
.................... FRESULT f_mountdrv (void);                           // Force initialized the file system  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination);      // Convert the FRESULT return code to a string 
....................  
.................... #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw);   // Write file  
....................    FRESULT f_sync (FIL *fp);                           // Flush cached information of a writing file     
....................    FRESULT f_unlink (char *path);                        // Delete a file or directory  
....................    FRESULT f_mkdir (char *path);                        // Create a directory  
....................    FRESULT f_chmod (char *path, BYTE value, BYTE mask);      // Change file attriburte  
....................    FRESULT f_rename ( char *path_old,   char *path_new);      // Rename a file / directory 
.................... #endif 
....................  
....................  
.................... // User defined function to give a current time to fatfs module  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD get_fattime(void);   // 31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31)  
....................                      // 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2)  
.................... #endif 
....................  
....................  
....................    // File function return code  
.................... #define   FR_OK                  0 
.................... #define   FR_NOT_READY            1 
.................... #define   FR_NO_FILE               2 
.................... #define   FR_NO_PATH               3 
.................... #define   FR_INVALID_NAME            4 
.................... #define   FR_DENIED               5 
.................... #define   FR_DISK_FULL            6 
.................... #define   FR_RW_ERROR               7 
.................... #define   FR_INCORRECT_DISK_CHANGE   9 
.................... #define   FR_WRITE_PROTECTED         10 
.................... #define   FR_NOT_ENABLED            11 
.................... #define   FR_NO_FILESYSTEM         12 
....................  
....................  
....................    // File access control and file status flags  
.................... #define   FA_READ            0x01 
.................... #define   FA_OPEN_EXISTING   0x00 
.................... #ifndef _FS_READONLY 
.................... #define   FA_WRITE         0x02 
.................... #define   FA_CREATE_ALWAYS   0x08 
.................... #define   FA_OPEN_ALWAYS      0x10 
.................... #define FA__WRITTEN         0x20 
.................... #define FA__DIRTY         0x40 
.................... #endif 
.................... #define FA__ERROR         0x80 
....................  
....................  
....................    // FAT type signature (fs_type)  
.................... #define FS_FAT12   1 
.................... #define FS_FAT16   2 
.................... #define FS_FAT32   3 
....................  
....................  
....................    // File attribute mask for directory entry  
.................... #define   AM_RDO      0x01   // Read Only  
.................... #define   AM_HID      0x02   // Hidden  
.................... #define   AM_SYS      0x04   // System  
.................... #define   AM_VOL      0x08   // Volume Label  
.................... #define AM_DIR      0x10   // Directory  
.................... #define AM_ARC      0x20   // Archive  
....................  
....................  
....................  
....................    // Multi-byte word access macros  
.................... #ifdef _BYTE_ACC 
.................... #define   LD_WORD(ptr)      (((WORD)*(BYTE*)(ptr+1)<<8)|*(ptr)) 
.................... #define   LD_DWORD(ptr)      (((DWORD)*(BYTE*)(ptr+3)<<24)|((DWORD)*(BYTE*)(ptr+2)<<16)|((WORD)*(BYTE*)(ptr+1)<<8)|*(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8 
.................... #define   ST_DWORD(ptr,val)   *(BYTE*)(ptr)=val; *(BYTE*)(ptr+1)=val>>8; *(BYTE*)(ptr+2)=val>>16; *(BYTE*)(ptr+3)=val>>24 
.................... #else 
.................... #define   LD_WORD(ptr)      (*(WORD*)(BYTE*)(ptr)) 
.................... #define   LD_DWORD(ptr)      (*(DWORD*)(BYTE*)(ptr)) 
.................... #define   ST_WORD(ptr,val)   *(WORD*)(BYTE*)(ptr)=(val) 
.................... #define   ST_DWORD(ptr,val)   *(DWORD*)(BYTE*)(ptr)=(val) 
.................... #endif 
....................  
....................  
.................... //#include <string.h> 
....................  
....................     // Give a work area for FAT File System (activate module) 
.................... FATFS   FileSystem;     // Fat File System work area 
.................... FATFS   *fs = &FileSystem; 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //                    Module Private Functions 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................        
.................... BOOLEAN move_window (DWORD sector) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Loads the specified sector into the FATFS window. If the existing sector 
.................... //   in the window is "dirty" the existing sector is written to the media 
.................... //   before the new sector is loaded to the window. If the target sector is 
.................... //   the same as the current sector in the window no chage is made. If the 
.................... //   target sector number == 0, then the existing sector, if dirty, is written 
.................... //   to the media 
.................... // 
.................... //   Entry: 
.................... //      Sector         Sector number to make apperance in the FATFS->win 
.................... //                  Move to zero writes back (flushes) the dirty window 
.................... //      FATFS->winset   Sector number of current sector in the window 
.................... //      FATFS->winflag   Dirty flag. If winflag == 1 the existing sector 
.................... //                  is written the the media 
.................... // 
.................... //   Exit: 
.................... //      Returns true on success, false otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD wsect; 
....................    FRESULT response; 
.................... //   char mesg[32]; 
....................  
....................    wsect = fs->winsect; 
*
05A76:  MOVLW  20
05A78:  MOVLB  7
05A7A:  ADDWF  x12,W
05A7C:  MOVWF  FE9
05A7E:  MOVLW  00
05A80:  ADDWFC x13,W
05A82:  MOVWF  FEA
05A84:  MOVFF  FEF,A18
05A88:  MOVFF  FEC,A19
05A8C:  MOVFF  FEC,A1A
05A90:  MOVFF  FEC,A1B
....................  
....................    // test if the current window if the target window 
....................    if (wsect != sector)  
05A94:  MOVLB  A
05A96:  MOVF   x14,W
05A98:  SUBWF  x18,W
05A9A:  BNZ   5AB0
05A9C:  MOVF   x15,W
05A9E:  SUBWF  x19,W
05AA0:  BNZ   5AB0
05AA2:  MOVF   x16,W
05AA4:  SUBWF  x1A,W
05AA6:  BNZ   5AB0
05AA8:  MOVF   x17,W
05AAA:  SUBWF  x1B,W
05AAC:  BTFSC  FD8.2
05AAE:  BRA    5C84
....................       { 
....................       // Need to load (move) the new sector into the window 
....................  
....................       #ifndef _FS_READONLY 
....................          BYTE n; 
....................          // Determine if the existing sector in the window is "dirty" 
....................          // If dirty the old entry must be written to the disk 
....................          if (fs->winflag)  
05AB0:  MOVLW  06
05AB2:  MOVLB  7
05AB4:  ADDWF  x12,W
05AB6:  MOVWF  FE9
05AB8:  MOVLW  00
05ABA:  ADDWFC x13,W
05ABC:  MOVWF  FEA
05ABE:  MOVF   FEF,F
05AC0:  BTFSC  FD8.2
05AC2:  BRA    5C0E
....................             { 
....................             // The existing sector must be written back to the disk 
....................             response = disk_write(fs->win, wsect, 1); 
05AC4:  MOVLW  24
05AC6:  ADDWF  x12,W
05AC8:  MOVWF  01
05ACA:  MOVLW  00
05ACC:  ADDWFC x13,W
05ACE:  MOVWF  03
05AD0:  MOVFF  01,A1E
05AD4:  MOVLB  A
05AD6:  MOVWF  x1F
05AD8:  MOVWF  x21
05ADA:  MOVFF  01,A20
05ADE:  MOVFF  A1B,A25
05AE2:  MOVFF  A1A,A24
05AE6:  MOVFF  A19,A23
05AEA:  MOVFF  A18,A22
05AEE:  MOVLW  01
05AF0:  MOVWF  x26
05AF2:  MOVLB  0
05AF4:  RCALL  5932
05AF6:  MOVFF  01,A1C
....................             if (response != RES_OK) 
05AFA:  MOVLB  A
05AFC:  MOVF   x1C,F
05AFE:  BZ    5B06
....................                { 
.................... //               f_get_error_mesg(response, mesg); 
.................... //               printf("move_window FS ERROR - %s\r\n", mesg); 
....................                return (FALSE); 
05B00:  MOVLW  00
05B02:  MOVWF  01
05B04:  BRA    5C88
....................                } 
....................  
....................             // clear the dirty flag and update the file system data structure 
....................             // for the new sector to be loaded 
....................             fs->winflag = 0; 
05B06:  MOVLW  06
05B08:  MOVLB  7
05B0A:  ADDWF  x12,W
05B0C:  MOVWF  FE9
05B0E:  MOVLW  00
05B10:  ADDWFC x13,W
05B12:  MOVWF  FEA
05B14:  CLRF   FEF
....................             if (wsect < (fs->fatbase + fs->sects_fat)) 
05B16:  MOVLW  10
05B18:  ADDWF  x12,W
05B1A:  MOVWF  FE9
05B1C:  MOVLW  00
05B1E:  ADDWFC x13,W
05B20:  MOVWF  FEA
05B22:  MOVFF  FEF,A1E
05B26:  MOVFF  FEC,A1F
05B2A:  MOVFF  FEC,A20
05B2E:  MOVFF  FEC,A21
05B32:  MOVLW  08
05B34:  ADDWF  x12,W
05B36:  MOVWF  FE9
05B38:  MOVLW  00
05B3A:  ADDWFC x13,W
05B3C:  MOVWF  FEA
05B3E:  MOVFF  FEF,00
05B42:  MOVFF  FEC,01
05B46:  MOVFF  FEC,02
05B4A:  MOVFF  FEC,03
05B4E:  MOVLB  A
05B50:  MOVF   x1E,W
05B52:  ADDWF  00,F
05B54:  MOVF   x1F,W
05B56:  ADDWFC 01,F
05B58:  MOVF   x20,W
05B5A:  ADDWFC 02,F
05B5C:  MOVF   x21,W
05B5E:  ADDWFC 03,F
05B60:  MOVF   x1B,W
05B62:  SUBWF  03,W
05B64:  BNC   5C0C
05B66:  BNZ   5B7E
05B68:  MOVF   x1A,W
05B6A:  SUBWF  02,W
05B6C:  BNC   5C0C
05B6E:  BNZ   5B7E
05B70:  MOVF   x19,W
05B72:  SUBWF  01,W
05B74:  BNC   5C0C
05B76:  BNZ   5B7E
05B78:  MOVF   00,W
05B7A:  SUBWF  x18,W
05B7C:  BC    5C0C
....................                { 
....................                // The target sector is inside the FAT area 
....................                // Refresh other FAT copies 
....................                for (n = fs->n_fats; n >= 2; n--)  
05B7E:  MOVLW  03
05B80:  MOVLB  7
05B82:  ADDWF  x12,W
05B84:  MOVWF  FE9
05B86:  MOVLW  00
05B88:  ADDWFC x13,W
05B8A:  MOVWF  FEA
05B8C:  MOVFF  FEF,A1D
05B90:  MOVLB  A
05B92:  MOVF   x1D,W
05B94:  SUBLW  01
05B96:  BC    5C0C
....................                   { 
....................                   // Reflect the change to all FAT copies 
....................                   wsect += fs->sects_fat; 
05B98:  MOVLW  08
05B9A:  MOVLB  7
05B9C:  ADDWF  x12,W
05B9E:  MOVWF  FE9
05BA0:  MOVLW  00
05BA2:  ADDWFC x13,W
05BA4:  MOVWF  FEA
05BA6:  MOVFF  FEF,00
05BAA:  MOVFF  FEC,01
05BAE:  MOVFF  FEC,02
05BB2:  MOVFF  FEC,03
05BB6:  MOVF   00,W
05BB8:  MOVLB  A
05BBA:  ADDWF  x18,F
05BBC:  MOVF   01,W
05BBE:  ADDWFC x19,F
05BC0:  MOVF   02,W
05BC2:  ADDWFC x1A,F
05BC4:  MOVF   03,W
05BC6:  ADDWFC x1B,F
....................                   if (disk_write(fs->win, wsect, 1) != RES_OK) 
05BC8:  MOVLW  24
05BCA:  MOVLB  7
05BCC:  ADDWF  x12,W
05BCE:  MOVWF  01
05BD0:  MOVLW  00
05BD2:  ADDWFC x13,W
05BD4:  MOVWF  03
05BD6:  MOVFF  01,A1E
05BDA:  MOVLB  A
05BDC:  MOVWF  x1F
05BDE:  MOVWF  x21
05BE0:  MOVFF  01,A20
05BE4:  MOVFF  A1B,A25
05BE8:  MOVFF  A1A,A24
05BEC:  MOVFF  A19,A23
05BF0:  MOVFF  A18,A22
05BF4:  MOVLW  01
05BF6:  MOVWF  x26
05BF8:  MOVLB  0
05BFA:  RCALL  5932
05BFC:  MOVF   01,F
05BFE:  BZ    5C06
....................                      break; 
05C00:  MOVLB  A
05C02:  BRA    5C0C
05C04:  MOVLB  0
05C06:  MOVLB  A
05C08:  DECF   x1D,F
05C0A:  BRA    5B92
05C0C:  MOVLB  7
....................                   } 
....................                } 
....................             } 
....................       #endif 
....................       // new sector to load? 
....................       if (sector)  
05C0E:  MOVLB  A
05C10:  MOVF   x14,F
05C12:  BNZ   5C20
05C14:  MOVF   x15,F
05C16:  BNZ   5C20
05C18:  MOVF   x16,F
05C1A:  BNZ   5C20
05C1C:  MOVF   x17,F
05C1E:  BZ    5C84
....................          { 
....................          // load the target sector and update the winset pointer to  
....................          // identify this sector as the one in the window 
....................          if (disk_read(fs->win, sector, 1) != RES_OK)  
05C20:  MOVLW  24
05C22:  MOVLB  7
05C24:  ADDWF  x12,W
05C26:  MOVWF  01
05C28:  MOVLW  00
05C2A:  ADDWFC x13,W
05C2C:  MOVWF  03
05C2E:  MOVFF  01,A1E
05C32:  MOVLB  A
05C34:  MOVWF  x1F
05C36:  MOVWF  x21
05C38:  MOVFF  01,A20
05C3C:  MOVFF  A17,A25
05C40:  MOVFF  A16,A24
05C44:  MOVFF  A15,A23
05C48:  MOVFF  A14,A22
05C4C:  MOVLW  01
05C4E:  MOVWF  x26
05C50:  MOVLB  0
05C52:  CALL   44C0
05C56:  MOVF   01,F
05C58:  BZ    5C64
....................             return FALSE; 
05C5A:  MOVLW  00
05C5C:  MOVWF  01
05C5E:  MOVLB  A
05C60:  BRA    5C88
05C62:  MOVLB  0
....................          fs->winsect = sector; 
05C64:  MOVLW  20
05C66:  MOVLB  7
05C68:  ADDWF  x12,W
05C6A:  MOVWF  FE9
05C6C:  MOVLW  00
05C6E:  ADDWFC x13,W
05C70:  MOVWF  FEA
05C72:  MOVFF  A14,FEF
05C76:  MOVFF  A15,FEC
05C7A:  MOVFF  A16,FEC
05C7E:  MOVFF  A17,FEC
05C82:  MOVLB  A
....................          } 
....................       } 
....................    return (TRUE); 
05C84:  MOVLW  01
05C86:  MOVWF  01
05C88:  MOVLB  0
05C8A:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... DWORD get_cluster (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the next cluster link information from the directory for the 
.................... //   target cluster 
.................... // 
.................... //   Entry: 
.................... //      FATFS      Must have been initialized 
.................... //      clust      Target cluster number 
.................... // 
.................... //   Exit 
.................... //      Return      Next cluster in chain or 1 on error       
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD wc, bc; 
....................    DWORD fatsect; 
....................  
....................    // check if the cluster number is valid for the file system 
....................    if ((clust >= 2) && (clust < fs->max_clust)) 
*
05CAE:  MOVLB  9
05CB0:  MOVF   xFF,F
05CB2:  BNZ   5CC4
05CB4:  MOVF   xFE,F
05CB6:  BNZ   5CC4
05CB8:  MOVF   xFD,F
05CBA:  BNZ   5CC4
05CBC:  MOVF   xFC,W
05CBE:  SUBLW  01
05CC0:  BTFSC  FD8.0
05CC2:  BRA    5FEC
05CC4:  MOVLW  0C
05CC6:  MOVLB  7
05CC8:  ADDWF  x12,W
05CCA:  MOVWF  FE9
05CCC:  MOVLW  00
05CCE:  ADDWFC x13,W
05CD0:  MOVWF  FEA
05CD2:  MOVFF  FEF,00
05CD6:  MOVFF  FEC,01
05CDA:  MOVFF  FEC,02
05CDE:  MOVFF  FEC,03
05CE2:  MOVLB  9
05CE4:  MOVF   xFF,W
05CE6:  SUBWF  03,W
05CE8:  BTFSS  FD8.0
05CEA:  BRA    5FEC
05CEC:  BNZ   5D0A
05CEE:  MOVF   xFE,W
05CF0:  SUBWF  02,W
05CF2:  BTFSS  FD8.0
05CF4:  BRA    5FEC
05CF6:  BNZ   5D0A
05CF8:  MOVF   xFD,W
05CFA:  SUBWF  01,W
05CFC:  BTFSS  FD8.0
05CFE:  BRA    5FEC
05D00:  BNZ   5D0A
05D02:  MOVF   00,W
05D04:  SUBWF  xFC,W
05D06:  BTFSC  FD8.0
05D08:  BRA    5FEC
....................       { 
....................       // Here we have a valid data cluster number 
....................       fatsect = fs->fatbase; 
05D0A:  MOVLW  10
05D0C:  MOVLB  7
05D0E:  ADDWF  x12,W
05D10:  MOVWF  FE9
05D12:  MOVLW  00
05D14:  ADDWFC x13,W
05D16:  MOVWF  FEA
05D18:  MOVFF  FEF,A04
05D1C:  MOVFF  FEC,A05
05D20:  MOVFF  FEC,A06
05D24:  MOVFF  FEC,A07
....................       switch (fs->fs_type)  
05D28:  MOVF   x12,W
05D2A:  MOVWF  FE9
05D2C:  MOVF   x13,W
05D2E:  MOVWF  FEA
05D30:  MOVF   FEF,W
05D32:  XORLW  01
05D34:  MOVLB  0
05D36:  BZ    5D46
05D38:  XORLW  03
05D3A:  BTFSC  FD8.2
05D3C:  BRA    5E92
05D3E:  XORLW  01
05D40:  BTFSC  FD8.2
05D42:  BRA    5F1A
05D44:  BRA    5FEA
....................          { 
....................          case FS_FAT12 : 
....................             bc = (WORD)clust * 3 / 2; 
05D46:  MOVFF  9FD,A11
05D4A:  MOVFF  9FC,A10
05D4E:  MOVLB  A
05D50:  CLRF   x13
05D52:  MOVLW  03
05D54:  MOVWF  x12
05D56:  MOVLB  0
05D58:  RCALL  5C8C
05D5A:  BCF    FD8.0
05D5C:  MOVLB  A
05D5E:  RRCF   02,W
05D60:  MOVWF  x03
05D62:  RRCF   01,W
05D64:  MOVWF  x02
....................             if (!move_window(fatsect + bc / 512))  
05D66:  BCF    FD8.0
05D68:  CLRF   03
05D6A:  RRCF   x03,W
05D6C:  MOVWF  02
05D6E:  ADDWF  x04,W
05D70:  MOVWF  x08
05D72:  MOVF   03,W
05D74:  ADDWFC x05,W
05D76:  MOVWF  x09
05D78:  MOVLW  00
05D7A:  ADDWFC x06,W
05D7C:  MOVWF  x0A
05D7E:  MOVLW  00
05D80:  ADDWFC x07,W
05D82:  MOVWF  x0B
05D84:  MOVWF  x17
05D86:  MOVFF  A0A,A16
05D8A:  MOVFF  A09,A15
05D8E:  MOVFF  A08,A14
05D92:  MOVLB  0
05D94:  RCALL  5A76
05D96:  MOVF   01,F
05D98:  BNZ   5D9C
....................                break; 
05D9A:  BRA    5FEA
....................             wc = fs->win[bc % 512]; 
05D9C:  MOVLB  A
05D9E:  MOVF   x03,W
05DA0:  ANDLW  01
05DA2:  MOVWF  x09
05DA4:  MOVLW  24
05DA6:  ADDWF  x02,W
05DA8:  MOVWF  01
05DAA:  MOVLW  00
05DAC:  ADDWFC x09,W
05DAE:  MOVWF  03
05DB0:  MOVF   01,W
05DB2:  MOVLB  7
05DB4:  ADDWF  x12,W
05DB6:  MOVWF  FE9
05DB8:  MOVF   x13,W
05DBA:  ADDWFC 03,W
05DBC:  MOVWF  FEA
05DBE:  MOVLB  A
05DC0:  CLRF   x01
05DC2:  MOVFF  FEF,A00
....................             bc++; 
05DC6:  INCF   x02,F
05DC8:  BTFSC  FD8.2
05DCA:  INCF   x03,F
....................             if (!move_window(fatsect + bc / 512))  
05DCC:  BCF    FD8.0
05DCE:  CLRF   03
05DD0:  RRCF   x03,W
05DD2:  MOVWF  02
05DD4:  ADDWF  x04,W
05DD6:  MOVWF  x08
05DD8:  MOVF   03,W
05DDA:  ADDWFC x05,W
05DDC:  MOVWF  x09
05DDE:  MOVLW  00
05DE0:  ADDWFC x06,W
05DE2:  MOVWF  x0A
05DE4:  MOVLW  00
05DE6:  ADDWFC x07,W
05DE8:  MOVWF  x0B
05DEA:  MOVWF  x17
05DEC:  MOVFF  A0A,A16
05DF0:  MOVFF  A09,A15
05DF4:  MOVFF  A08,A14
05DF8:  MOVLB  0
05DFA:  RCALL  5A76
05DFC:  MOVF   01,F
05DFE:  BNZ   5E02
....................                break; 
05E00:  BRA    5FEA
....................             wc |= (WORD)fs->win[bc % 512] << 8; 
05E02:  MOVLB  A
05E04:  MOVF   x03,W
05E06:  ANDLW  01
05E08:  MOVWF  x09
05E0A:  MOVLW  24
05E0C:  ADDWF  x02,W
05E0E:  MOVWF  01
05E10:  MOVLW  00
05E12:  ADDWFC x09,W
05E14:  MOVWF  03
05E16:  MOVF   01,W
05E18:  MOVLB  7
05E1A:  ADDWF  x12,W
05E1C:  MOVWF  FE9
05E1E:  MOVF   x13,W
05E20:  ADDWFC 03,W
05E22:  MOVWF  FEA
05E24:  MOVF   FEF,W
05E26:  MOVLB  A
05E28:  MOVWF  x0A
05E2A:  MOVLW  00
05E2C:  IORWF  x00,F
05E2E:  MOVF   x0A,W
05E30:  IORWF  x01,F
....................             return ((clust & 1) ? (wc >> 4) : (wc & 0xFFF)); 
05E32:  MOVLB  9
05E34:  MOVF   xFC,W
05E36:  ANDLW  01
05E38:  MOVWF  00
05E3A:  CLRF   01
05E3C:  CLRF   02
05E3E:  CLRF   03
05E40:  MOVF   00,F
05E42:  BNZ   5E50
05E44:  MOVF   01,F
05E46:  BNZ   5E50
05E48:  MOVF   02,F
05E4A:  BNZ   5E50
05E4C:  MOVF   03,F
05E4E:  BZ    5E78
05E50:  MOVLB  A
05E52:  RRCF   x01,W
05E54:  MOVWF  03
05E56:  RRCF   x00,W
05E58:  MOVWF  02
05E5A:  RRCF   03,F
05E5C:  RRCF   02,F
05E5E:  RRCF   03,F
05E60:  RRCF   02,F
05E62:  RRCF   03,F
05E64:  RRCF   02,F
05E66:  MOVLW  0F
05E68:  ANDWF  03,F
05E6A:  MOVFF  02,00
05E6E:  MOVFF  03,01
05E72:  CLRF   02
05E74:  CLRF   03
05E76:  BRA    5E8E
05E78:  MOVLB  A
05E7A:  MOVFF  A00,00
05E7E:  MOVF   x01,W
05E80:  ANDLW  0F
05E82:  MOVWF  03
05E84:  MOVF   x00,W
05E86:  MOVFF  03,01
05E8A:  CLRF   02
05E8C:  CLRF   03
05E8E:  BRA    5FF8
05E90:  MOVLB  0
....................  
....................          case FS_FAT16 : 
....................             if (!move_window(fatsect + clust / 256)) 
05E92:  MOVFF  9FD,00
05E96:  MOVFF  9FE,01
05E9A:  MOVFF  9FF,02
05E9E:  CLRF   03
05EA0:  MOVF   00,W
05EA2:  MOVLB  A
05EA4:  ADDWF  x04,W
05EA6:  MOVWF  x08
05EA8:  MOVF   01,W
05EAA:  ADDWFC x05,W
05EAC:  MOVWF  x09
05EAE:  MOVF   02,W
05EB0:  ADDWFC x06,W
05EB2:  MOVWF  x0A
05EB4:  MOVF   03,W
05EB6:  ADDWFC x07,W
05EB8:  MOVWF  x0B
05EBA:  MOVWF  x17
05EBC:  MOVFF  A0A,A16
05EC0:  MOVFF  A09,A15
05EC4:  MOVFF  A08,A14
05EC8:  MOVLB  0
05ECA:  RCALL  5A76
05ECC:  MOVF   01,F
05ECE:  BNZ   5ED2
....................                break; 
05ED0:  BRA    5FEA
....................             return (LD_WORD(&(fs->win[((WORD)clust * 2) % 512]))); 
05ED2:  BCF    FD8.0
05ED4:  MOVLB  9
05ED6:  RLCF   xFC,W
05ED8:  MOVLB  A
05EDA:  MOVWF  x08
05EDC:  MOVLB  9
05EDE:  RLCF   xFD,W
05EE0:  MOVLB  A
05EE2:  MOVWF  x09
05EE4:  MOVLW  01
05EE6:  ANDWF  x09,F
05EE8:  MOVLW  24
05EEA:  ADDWF  x08,W
05EEC:  MOVWF  01
05EEE:  MOVLW  00
05EF0:  ADDWFC x09,W
05EF2:  MOVWF  03
05EF4:  MOVF   01,W
05EF6:  MOVLB  7
05EF8:  ADDWF  x12,W
05EFA:  MOVWF  01
05EFC:  MOVF   x13,W
05EFE:  ADDWFC 03,F
05F00:  MOVFF  01,FE9
05F04:  MOVFF  03,FEA
05F08:  MOVFF  FEF,00
05F0C:  MOVFF  FEC,01
05F10:  CLRF   02
05F12:  CLRF   03
05F14:  MOVLB  A
05F16:  BRA    5FF8
05F18:  MOVLB  0
....................  
....................          case FS_FAT32 : 
....................             if (!move_window(fatsect + clust / 128)) 
05F1A:  MOVLB  9
05F1C:  RRCF   xFF,W
05F1E:  MOVWF  03
05F20:  RRCF   xFE,W
05F22:  MOVWF  02
05F24:  RRCF   xFD,W
05F26:  MOVWF  01
05F28:  RRCF   xFC,W
05F2A:  MOVWF  00
05F2C:  RRCF   03,F
05F2E:  RRCF   02,F
05F30:  RRCF   01,F
05F32:  RRCF   00,F
05F34:  RRCF   03,F
05F36:  RRCF   02,F
05F38:  RRCF   01,F
05F3A:  RRCF   00,F
05F3C:  RRCF   03,F
05F3E:  RRCF   02,F
05F40:  RRCF   01,F
05F42:  RRCF   00,F
05F44:  RRCF   03,F
05F46:  RRCF   02,F
05F48:  RRCF   01,F
05F4A:  RRCF   00,F
05F4C:  RRCF   03,F
05F4E:  RRCF   02,F
05F50:  RRCF   01,F
05F52:  RRCF   00,F
05F54:  RRCF   03,F
05F56:  RRCF   02,F
05F58:  RRCF   01,F
05F5A:  RRCF   00,F
05F5C:  MOVLW  01
05F5E:  ANDWF  03,F
05F60:  MOVF   00,W
05F62:  MOVLB  A
05F64:  ADDWF  x04,W
05F66:  MOVWF  x08
05F68:  MOVF   01,W
05F6A:  ADDWFC x05,W
05F6C:  MOVWF  x09
05F6E:  MOVF   02,W
05F70:  ADDWFC x06,W
05F72:  MOVWF  x0A
05F74:  MOVF   03,W
05F76:  ADDWFC x07,W
05F78:  MOVWF  x0B
05F7A:  MOVWF  x17
05F7C:  MOVFF  A0A,A16
05F80:  MOVFF  A09,A15
05F84:  MOVFF  A08,A14
05F88:  MOVLB  0
05F8A:  RCALL  5A76
05F8C:  MOVF   01,F
05F8E:  BNZ   5F92
....................                break; 
05F90:  BRA    5FEA
....................             return (LD_DWORD(&(fs->win[((WORD)clust * 4) % 512])) &0x0FFFFFFF); 
05F92:  MOVLB  9
05F94:  RLCF   xFC,W
05F96:  MOVLB  A
05F98:  MOVWF  x08
05F9A:  MOVLB  9
05F9C:  RLCF   xFD,W
05F9E:  MOVLB  A
05FA0:  MOVWF  x09
05FA2:  RLCF   x08,F
05FA4:  RLCF   x09,F
05FA6:  MOVLW  FC
05FA8:  ANDWF  x08,F
05FAA:  MOVLW  01
05FAC:  ANDWF  x09,F
05FAE:  MOVLW  24
05FB0:  ADDWF  x08,W
05FB2:  MOVWF  01
05FB4:  MOVLW  00
05FB6:  ADDWFC x09,W
05FB8:  MOVWF  03
05FBA:  MOVF   01,W
05FBC:  MOVLB  7
05FBE:  ADDWF  x12,W
05FC0:  MOVWF  01
05FC2:  MOVF   x13,W
05FC4:  ADDWFC 03,F
05FC6:  MOVFF  01,FE9
05FCA:  MOVFF  03,FEA
05FCE:  MOVFF  FEF,00
05FD2:  MOVFF  FEC,01
05FD6:  MOVFF  FEC,02
05FDA:  MOVFF  FEC,A0D
05FDE:  MOVLB  A
05FE0:  MOVF   x0D,W
05FE2:  ANDLW  0F
05FE4:  MOVWF  03
05FE6:  BRA    5FF8
05FE8:  MOVLB  0
05FEA:  MOVLB  9
....................          } 
....................       } 
....................    return (1);   // Return with 1 means function failed  
05FEC:  MOVLW  01
05FEE:  MOVWF  00
05FF0:  CLRF   01
05FF2:  CLRF   02
05FF4:  CLRF   03
05FF6:  MOVLB  A
05FF8:  MOVLB  0
05FFA:  RETURN 0
....................    } 
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN put_cluster (DWORD clust, DWORD val) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Change the status of a Cluster 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... //      val         New value to mark the cluster 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    WORD bc; 
....................    BYTE *p; 
....................    DWORD fatsect; 
....................  
....................    fatsect = fs->fatbase; 
*
065BE:  MOVLW  10
065C0:  MOVLB  7
065C2:  ADDWF  x12,W
065C4:  MOVWF  FE9
065C6:  MOVLW  00
065C8:  ADDWFC x13,W
065CA:  MOVWF  FEA
065CC:  MOVFF  FEF,A08
065D0:  MOVFF  FEC,A09
065D4:  MOVFF  FEC,A0A
065D8:  MOVFF  FEC,A0B
....................    switch (fs->fs_type)  
065DC:  MOVF   x12,W
065DE:  MOVWF  FE9
065E0:  MOVF   x13,W
065E2:  MOVWF  FEA
065E4:  MOVF   FEF,W
065E6:  XORLW  01
065E8:  MOVLB  0
065EA:  BZ    65FA
065EC:  XORLW  03
065EE:  BTFSC  FD8.2
065F0:  BRA    67DE
065F2:  XORLW  01
065F4:  BTFSC  FD8.2
065F6:  BRA    6868
065F8:  BRA    6938
....................       { 
....................       case FS_FAT12 : 
....................          bc = (WORD)clust * 3 / 2; 
065FA:  MOVFF  9FD,A11
065FE:  MOVFF  9FC,A10
06602:  MOVLB  A
06604:  CLRF   x13
06606:  MOVLW  03
06608:  MOVWF  x12
0660A:  MOVLB  0
0660C:  CALL   5C8C
06610:  BCF    FD8.0
06612:  MOVLB  A
06614:  RRCF   02,W
06616:  MOVWF  x05
06618:  RRCF   01,W
0661A:  MOVWF  x04
....................          if (!move_window(fatsect + bc / 512)) 
0661C:  BCF    FD8.0
0661E:  CLRF   03
06620:  RRCF   x05,W
06622:  MOVWF  02
06624:  ADDWF  x08,W
06626:  MOVWF  x0C
06628:  MOVF   03,W
0662A:  ADDWFC x09,W
0662C:  MOVWF  x0D
0662E:  MOVLW  00
06630:  ADDWFC x0A,W
06632:  MOVWF  x0E
06634:  MOVLW  00
06636:  ADDWFC x0B,W
06638:  MOVWF  x0F
0663A:  MOVWF  x17
0663C:  MOVFF  A0E,A16
06640:  MOVFF  A0D,A15
06644:  MOVFF  A0C,A14
06648:  MOVLB  0
0664A:  CALL   5A76
0664E:  MOVF   01,F
06650:  BNZ   6658
....................             return (FALSE); 
06652:  MOVLW  00
06654:  MOVWF  01
06656:  BRA    6956
....................          p = &fs->win[bc % 512]; 
06658:  MOVLB  A
0665A:  MOVF   x05,W
0665C:  ANDLW  01
0665E:  MOVWF  x0D
06660:  MOVLW  24
06662:  ADDWF  x04,W
06664:  MOVWF  01
06666:  MOVLW  00
06668:  ADDWFC x0D,W
0666A:  MOVWF  03
0666C:  MOVF   01,W
0666E:  MOVLB  7
06670:  ADDWF  x12,W
06672:  MOVWF  01
06674:  MOVF   x13,W
06676:  ADDWFC 03,F
06678:  MOVFF  01,A06
0667C:  MOVLB  A
0667E:  MOVFF  03,A07
....................          *p = (clust & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val; 
06682:  MOVFF  A06,A0C
06686:  MOVFF  A07,A0D
0668A:  MOVLB  9
0668C:  MOVF   xFC,W
0668E:  ANDLW  01
06690:  MOVWF  00
06692:  CLRF   01
06694:  CLRF   02
06696:  CLRF   03
06698:  MOVF   00,F
0669A:  BNZ   66A8
0669C:  MOVF   01,F
0669E:  BNZ   66A8
066A0:  MOVF   02,F
066A2:  BNZ   66A8
066A4:  MOVF   03,F
066A6:  BZ    66CA
066A8:  MOVFF  A07,03
066AC:  MOVLB  A
066AE:  MOVFF  A06,FE9
066B2:  MOVFF  A07,FEA
066B6:  MOVF   FEF,W
066B8:  ANDLW  0F
066BA:  MOVWF  x0E
066BC:  SWAPF  x00,W
066BE:  MOVWF  00
066C0:  MOVLW  F0
066C2:  ANDWF  00,F
066C4:  MOVF   00,W
066C6:  IORWF  x0E,W
066C8:  BRA    66CE
066CA:  MOVLB  A
066CC:  MOVF   x00,W
066CE:  MOVFF  A0D,FEA
066D2:  MOVFF  A0C,FE9
066D6:  MOVWF  FEF
....................          fs->winflag = 1; 
066D8:  MOVLW  06
066DA:  MOVLB  7
066DC:  ADDWF  x12,W
066DE:  MOVWF  FE9
066E0:  MOVLW  00
066E2:  ADDWFC x13,W
066E4:  MOVWF  FEA
066E6:  MOVLW  01
066E8:  MOVWF  FEF
....................          bc++; 
066EA:  MOVLB  A
066EC:  INCF   x04,F
066EE:  BTFSC  FD8.2
066F0:  INCF   x05,F
....................          if (!move_window(fatsect + bc / 512)) 
066F2:  BCF    FD8.0
066F4:  CLRF   03
066F6:  RRCF   x05,W
066F8:  MOVWF  02
066FA:  ADDWF  x08,W
066FC:  MOVWF  x0C
066FE:  MOVF   03,W
06700:  ADDWFC x09,W
06702:  MOVWF  x0D
06704:  MOVLW  00
06706:  ADDWFC x0A,W
06708:  MOVWF  x0E
0670A:  MOVLW  00
0670C:  ADDWFC x0B,W
0670E:  MOVWF  x0F
06710:  MOVWF  x17
06712:  MOVFF  A0E,A16
06716:  MOVFF  A0D,A15
0671A:  MOVFF  A0C,A14
0671E:  MOVLB  0
06720:  CALL   5A76
06724:  MOVF   01,F
06726:  BNZ   672E
....................             return (FALSE); 
06728:  MOVLW  00
0672A:  MOVWF  01
0672C:  BRA    6956
....................          p = &fs->win[bc % 512]; 
0672E:  MOVLB  A
06730:  MOVF   x05,W
06732:  ANDLW  01
06734:  MOVWF  x0D
06736:  MOVLW  24
06738:  ADDWF  x04,W
0673A:  MOVWF  01
0673C:  MOVLW  00
0673E:  ADDWFC x0D,W
06740:  MOVWF  03
06742:  MOVF   01,W
06744:  MOVLB  7
06746:  ADDWF  x12,W
06748:  MOVWF  01
0674A:  MOVF   x13,W
0674C:  ADDWFC 03,F
0674E:  MOVFF  01,A06
06752:  MOVLB  A
06754:  MOVFF  03,A07
....................          *p = (clust & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F)); 
06758:  MOVFF  A06,A0C
0675C:  MOVFF  A07,A0D
06760:  MOVLB  9
06762:  MOVF   xFC,W
06764:  ANDLW  01
06766:  MOVWF  00
06768:  CLRF   01
0676A:  CLRF   02
0676C:  CLRF   03
0676E:  MOVF   00,F
06770:  BNZ   677E
06772:  MOVF   01,F
06774:  BNZ   677E
06776:  MOVF   02,F
06778:  BNZ   677E
0677A:  MOVF   03,F
0677C:  BZ    67B0
0677E:  MOVLB  A
06780:  RRCF   x03,W
06782:  MOVWF  03
06784:  RRCF   x02,W
06786:  MOVWF  02
06788:  RRCF   x01,W
0678A:  MOVWF  01
0678C:  RRCF   x00,W
0678E:  MOVWF  00
06790:  RRCF   03,F
06792:  RRCF   02,F
06794:  RRCF   01,F
06796:  RRCF   00,F
06798:  RRCF   03,F
0679A:  RRCF   02,F
0679C:  RRCF   01,F
0679E:  RRCF   00,F
067A0:  RRCF   03,F
067A2:  RRCF   02,F
067A4:  RRCF   01,F
067A6:  RRCF   00,F
067A8:  MOVLW  0F
067AA:  ANDWF  03,F
067AC:  MOVF   00,W
067AE:  BRA    67D2
067B0:  MOVLB  A
067B2:  MOVFF  A06,FE9
067B6:  MOVFF  A07,FEA
067BA:  MOVF   FEF,W
067BC:  ANDLW  F0
067BE:  MOVWF  x0F
067C0:  MOVFF  A01,00
067C4:  MOVFF  A02,01
067C8:  MOVFF  A03,02
067CC:  MOVF   x01,W
067CE:  ANDLW  0F
067D0:  IORWF  x0F,W
067D2:  MOVFF  A0D,FEA
067D6:  MOVFF  A0C,FE9
067DA:  MOVWF  FEF
....................          break; 
067DC:  BRA    6940
....................  
....................       case FS_FAT16 : 
....................          if (!move_window(fatsect + clust / 256))  
067DE:  MOVFF  9FD,00
067E2:  MOVFF  9FE,01
067E6:  MOVFF  9FF,02
067EA:  CLRF   03
067EC:  MOVF   00,W
067EE:  MOVLB  A
067F0:  ADDWF  x08,W
067F2:  MOVWF  x0C
067F4:  MOVF   01,W
067F6:  ADDWFC x09,W
067F8:  MOVWF  x0D
067FA:  MOVF   02,W
067FC:  ADDWFC x0A,W
067FE:  MOVWF  x0E
06800:  MOVF   03,W
06802:  ADDWFC x0B,W
06804:  MOVWF  x0F
06806:  MOVWF  x17
06808:  MOVFF  A0E,A16
0680C:  MOVFF  A0D,A15
06810:  MOVFF  A0C,A14
06814:  MOVLB  0
06816:  CALL   5A76
0681A:  MOVF   01,F
0681C:  BNZ   6824
....................             return (FALSE); 
0681E:  MOVLW  00
06820:  MOVWF  01
06822:  BRA    6956
....................          ST_WORD(&(fs->win[((WORD)clust * 2) % 512]), (WORD)val); 
06824:  BCF    FD8.0
06826:  MOVLB  9
06828:  RLCF   xFC,W
0682A:  MOVLB  A
0682C:  MOVWF  x0C
0682E:  MOVLB  9
06830:  RLCF   xFD,W
06832:  MOVLB  A
06834:  MOVWF  x0D
06836:  MOVLW  01
06838:  ANDWF  x0D,F
0683A:  MOVLW  24
0683C:  ADDWF  x0C,W
0683E:  MOVWF  01
06840:  MOVLW  00
06842:  ADDWFC x0D,W
06844:  MOVWF  03
06846:  MOVF   01,W
06848:  MOVLB  7
0684A:  ADDWF  x12,W
0684C:  MOVWF  01
0684E:  MOVF   x13,W
06850:  ADDWFC 03,F
06852:  MOVFF  01,FE9
06856:  MOVFF  03,FEA
0685A:  MOVFF  A01,FEC
0685E:  MOVF   FED,F
06860:  MOVFF  A00,FEF
....................          break; 
06864:  MOVLB  A
06866:  BRA    6940
....................  
....................       case FS_FAT32 : 
....................          if (!move_window(fatsect + clust / 128))  
06868:  MOVLB  9
0686A:  RRCF   xFF,W
0686C:  MOVWF  03
0686E:  RRCF   xFE,W
06870:  MOVWF  02
06872:  RRCF   xFD,W
06874:  MOVWF  01
06876:  RRCF   xFC,W
06878:  MOVWF  00
0687A:  RRCF   03,F
0687C:  RRCF   02,F
0687E:  RRCF   01,F
06880:  RRCF   00,F
06882:  RRCF   03,F
06884:  RRCF   02,F
06886:  RRCF   01,F
06888:  RRCF   00,F
0688A:  RRCF   03,F
0688C:  RRCF   02,F
0688E:  RRCF   01,F
06890:  RRCF   00,F
06892:  RRCF   03,F
06894:  RRCF   02,F
06896:  RRCF   01,F
06898:  RRCF   00,F
0689A:  RRCF   03,F
0689C:  RRCF   02,F
0689E:  RRCF   01,F
068A0:  RRCF   00,F
068A2:  RRCF   03,F
068A4:  RRCF   02,F
068A6:  RRCF   01,F
068A8:  RRCF   00,F
068AA:  MOVLW  01
068AC:  ANDWF  03,F
068AE:  MOVF   00,W
068B0:  MOVLB  A
068B2:  ADDWF  x08,W
068B4:  MOVWF  x0C
068B6:  MOVF   01,W
068B8:  ADDWFC x09,W
068BA:  MOVWF  x0D
068BC:  MOVF   02,W
068BE:  ADDWFC x0A,W
068C0:  MOVWF  x0E
068C2:  MOVF   03,W
068C4:  ADDWFC x0B,W
068C6:  MOVWF  x0F
068C8:  MOVWF  x17
068CA:  MOVFF  A0E,A16
068CE:  MOVFF  A0D,A15
068D2:  MOVFF  A0C,A14
068D6:  MOVLB  0
068D8:  CALL   5A76
068DC:  MOVF   01,F
068DE:  BNZ   68E6
....................             return (FALSE); 
068E0:  MOVLW  00
068E2:  MOVWF  01
068E4:  BRA    6956
....................          ST_DWORD(&(fs->win[((WORD)clust * 4) % 512]), val); 
068E6:  MOVLB  9
068E8:  RLCF   xFC,W
068EA:  MOVLB  A
068EC:  MOVWF  x0C
068EE:  MOVLB  9
068F0:  RLCF   xFD,W
068F2:  MOVLB  A
068F4:  MOVWF  x0D
068F6:  RLCF   x0C,F
068F8:  RLCF   x0D,F
068FA:  MOVLW  FC
068FC:  ANDWF  x0C,F
068FE:  MOVLW  01
06900:  ANDWF  x0D,F
06902:  MOVLW  24
06904:  ADDWF  x0C,W
06906:  MOVWF  01
06908:  MOVLW  00
0690A:  ADDWFC x0D,W
0690C:  MOVWF  03
0690E:  MOVF   01,W
06910:  MOVLB  7
06912:  ADDWF  x12,W
06914:  MOVWF  01
06916:  MOVF   x13,W
06918:  ADDWFC 03,F
0691A:  MOVFF  01,FE9
0691E:  MOVFF  03,FEA
06922:  MOVFF  A00,FEF
06926:  MOVFF  A01,FEC
0692A:  MOVFF  A02,FEC
0692E:  MOVFF  A03,FEC
....................          break; 
06932:  MOVLB  A
06934:  BRA    6940
06936:  MOVLB  0
....................  
....................       default : 
....................          return (FALSE); 
06938:  MOVLW  00
0693A:  MOVWF  01
0693C:  BRA    6956
0693E:  MOVLB  A
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    fs->winflag = 1; 
06940:  MOVLW  06
06942:  MOVLB  7
06944:  ADDWF  x12,W
06946:  MOVWF  FE9
06948:  MOVLW  00
0694A:  ADDWFC x13,W
0694C:  MOVWF  FEA
0694E:  MOVLW  01
06950:  MOVWF  FEF
....................    return (TRUE); 
06952:  MOVWF  01
06954:  MOVLB  0
06956:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... BOOLEAN remove_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Remove a cluster from the cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD nxt; 
....................  
....................    for (nxt = get_cluster(clust); nxt >= 2; nxt = get_cluster(clust)) 
*
06F3A:  MOVFF  9DE,9FF
06F3E:  MOVFF  9DD,9FE
06F42:  MOVFF  9DC,9FD
06F46:  MOVFF  9DB,9FC
06F4A:  CALL   5CAE
06F4E:  MOVFF  03,9E2
06F52:  MOVFF  02,9E1
06F56:  MOVFF  01,9E0
06F5A:  MOVFF  00,9DF
06F5E:  MOVLB  9
06F60:  MOVF   xE2,F
06F62:  BNZ   6F72
06F64:  MOVF   xE1,F
06F66:  BNZ   6F72
06F68:  MOVF   xE0,F
06F6A:  BNZ   6F72
06F6C:  MOVF   xDF,W
06F6E:  SUBLW  01
06F70:  BC    6FD4
....................       { 
....................       if (!put_cluster(clust, 0)) 
06F72:  MOVFF  9DE,9FF
06F76:  MOVFF  9DD,9FE
06F7A:  MOVFF  9DC,9FD
06F7E:  MOVFF  9DB,9FC
06F82:  MOVLB  A
06F84:  CLRF   x03
06F86:  CLRF   x02
06F88:  CLRF   x01
06F8A:  CLRF   x00
06F8C:  MOVLB  0
06F8E:  CALL   65BE
06F92:  MOVF   01,F
06F94:  BNZ   6F9C
....................          return FALSE; 
06F96:  MOVLW  00
06F98:  MOVWF  01
06F9A:  BRA    6FDA
....................       clust = nxt; 
06F9C:  MOVFF  9E2,9DE
06FA0:  MOVFF  9E1,9DD
06FA4:  MOVFF  9E0,9DC
06FA8:  MOVFF  9DF,9DB
06FAC:  MOVFF  9DE,9FF
06FB0:  MOVFF  9DD,9FE
06FB4:  MOVFF  9DC,9FD
06FB8:  MOVFF  9DB,9FC
06FBC:  CALL   5CAE
06FC0:  MOVFF  03,9E2
06FC4:  MOVFF  02,9E1
06FC8:  MOVFF  01,9E0
06FCC:  MOVFF  00,9DF
06FD0:  BRA    6F5E
06FD2:  MOVLB  9
....................       } 
....................    return TRUE; 
06FD4:  MOVLW  01
06FD6:  MOVWF  01
06FD8:  MOVLB  0
06FDA:  RETURN 0
....................    } 
.................... #endif 
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... DWORD create_chain (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create or lengthen a cluster chain 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to stretch. 0 creates a new chain 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD cstat, ncl, scl, mcl; 
....................  
....................    mcl = fs->max_clust; 
*
06958:  MOVLW  0C
0695A:  MOVLB  7
0695C:  ADDWF  x12,W
0695E:  MOVWF  FE9
06960:  MOVLW  00
06962:  ADDWFC x13,W
06964:  MOVWF  FEA
06966:  MOVFF  FEF,9F8
0696A:  MOVFF  FEC,9F9
0696E:  MOVFF  FEC,9FA
06972:  MOVFF  FEC,9FB
....................    if (clust == 0)  
06976:  MOVLB  9
06978:  MOVF   xE8,F
0697A:  BNZ   69E4
0697C:  MOVF   xE9,F
0697E:  BNZ   69E4
06980:  MOVF   xEA,F
06982:  BNZ   69E4
06984:  MOVF   xEB,F
06986:  BNZ   69E4
....................       {                        // Create new chain 
....................       scl = fs->last_clust;         // Get last allocated cluster 
06988:  MOVLW  1C
0698A:  MOVLB  7
0698C:  ADDWF  x12,W
0698E:  MOVWF  FE9
06990:  MOVLW  00
06992:  ADDWFC x13,W
06994:  MOVWF  FEA
06996:  MOVFF  FEF,9F4
0699A:  MOVFF  FEC,9F5
0699E:  MOVFF  FEC,9F6
069A2:  MOVFF  FEC,9F7
....................       if (scl < 2 || scl >= mcl) scl = 1; 
069A6:  MOVLB  9
069A8:  MOVF   xF7,F
069AA:  BNZ   69BA
069AC:  MOVF   xF6,F
069AE:  BNZ   69BA
069B0:  MOVF   xF5,F
069B2:  BNZ   69BA
069B4:  MOVF   xF4,W
069B6:  SUBLW  01
069B8:  BC    69D8
069BA:  MOVF   xFB,W
069BC:  SUBWF  xF7,W
069BE:  BNC   69E2
069C0:  BNZ   69D8
069C2:  MOVF   xFA,W
069C4:  SUBWF  xF6,W
069C6:  BNC   69E2
069C8:  BNZ   69D8
069CA:  MOVF   xF9,W
069CC:  SUBWF  xF5,W
069CE:  BNC   69E2
069D0:  BNZ   69D8
069D2:  MOVF   xF8,W
069D4:  SUBWF  xF4,W
069D6:  BNC   69E2
069D8:  CLRF   xF7
069DA:  CLRF   xF6
069DC:  CLRF   xF5
069DE:  MOVLW  01
069E0:  MOVWF  xF4
....................       } 
069E2:  BRA    6A68
....................    else  
....................       {      // Stretch existing chain 
....................       cstat = get_cluster(clust);      // Check the cluster status 
069E4:  MOVFF  9EB,9FF
069E8:  MOVFF  9EA,9FE
069EC:  MOVFF  9E9,9FD
069F0:  MOVFF  9E8,9FC
069F4:  MOVLB  0
069F6:  CALL   5CAE
069FA:  MOVFF  03,9EF
069FE:  MOVFF  02,9EE
06A02:  MOVFF  01,9ED
06A06:  MOVFF  00,9EC
....................       if (cstat < 2) return 0;      // It is an invalid cluster 
06A0A:  MOVLB  9
06A0C:  MOVF   xEF,F
06A0E:  BNZ   6A28
06A10:  MOVF   xEE,F
06A12:  BNZ   6A28
06A14:  MOVF   xED,F
06A16:  BNZ   6A28
06A18:  MOVF   xEC,W
06A1A:  SUBLW  01
06A1C:  BNC   6A28
06A1E:  CLRF   00
06A20:  CLRF   01
06A22:  CLRF   02
06A24:  CLRF   03
06A26:  BRA    6BEC
....................       if (cstat < mcl) return cstat;   // It is already followed by next cluster 
06A28:  MOVF   xEF,W
06A2A:  SUBWF  xFB,W
06A2C:  BNC   6A58
06A2E:  BNZ   6A46
06A30:  MOVF   xEE,W
06A32:  SUBWF  xFA,W
06A34:  BNC   6A58
06A36:  BNZ   6A46
06A38:  MOVF   xED,W
06A3A:  SUBWF  xF9,W
06A3C:  BNC   6A58
06A3E:  BNZ   6A46
06A40:  MOVF   xF8,W
06A42:  SUBWF  xEC,W
06A44:  BC    6A58
06A46:  MOVFF  9EC,00
06A4A:  MOVFF  9ED,01
06A4E:  MOVFF  9EE,02
06A52:  MOVFF  9EF,03
06A56:  BRA    6BEC
....................       scl = clust; 
06A58:  MOVFF  9EB,9F7
06A5C:  MOVFF  9EA,9F6
06A60:  MOVFF  9E9,9F5
06A64:  MOVFF  9E8,9F4
....................       } 
....................       ncl = scl;                  // Scan start cluster 
06A68:  MOVFF  9F7,9F3
06A6C:  MOVFF  9F6,9F2
06A70:  MOVFF  9F5,9F1
06A74:  MOVFF  9F4,9F0
....................    do  
....................       { 
....................       ncl++;                     // Next cluster 
06A78:  MOVLW  01
06A7A:  ADDWF  xF0,F
06A7C:  BTFSC  FD8.0
06A7E:  INCF   xF1,F
06A80:  BTFSC  FD8.2
06A82:  INCF   xF2,F
06A84:  BTFSC  FD8.2
06A86:  INCF   xF3,F
....................       if (ncl >= mcl)  
06A88:  MOVF   xFB,W
06A8A:  SUBWF  xF3,W
06A8C:  BNC   6ACA
06A8E:  BNZ   6AA6
06A90:  MOVF   xFA,W
06A92:  SUBWF  xF2,W
06A94:  BNC   6ACA
06A96:  BNZ   6AA6
06A98:  MOVF   xF9,W
06A9A:  SUBWF  xF1,W
06A9C:  BNC   6ACA
06A9E:  BNZ   6AA6
06AA0:  MOVF   xF8,W
06AA2:  SUBWF  xF0,W
06AA4:  BNC   6ACA
....................          {         // Wrap around 
....................          ncl = 2; 
06AA6:  CLRF   xF3
06AA8:  CLRF   xF2
06AAA:  CLRF   xF1
06AAC:  MOVLW  02
06AAE:  MOVWF  xF0
....................          if (scl == 1) return 0;      // No free custer was found 
06AB0:  DECFSZ xF4,W
06AB2:  BRA    6ACA
06AB4:  MOVF   xF5,F
06AB6:  BNZ   6ACA
06AB8:  MOVF   xF6,F
06ABA:  BNZ   6ACA
06ABC:  MOVF   xF7,F
06ABE:  BNZ   6ACA
06AC0:  CLRF   00
06AC2:  CLRF   01
06AC4:  CLRF   02
06AC6:  CLRF   03
06AC8:  BRA    6BEC
....................          } 
....................       if (ncl == scl) return 0;      // No free custer was found 
06ACA:  MOVF   xF4,W
06ACC:  SUBWF  xF0,W
06ACE:  BNZ   6AEC
06AD0:  MOVF   xF5,W
06AD2:  SUBWF  xF1,W
06AD4:  BNZ   6AEC
06AD6:  MOVF   xF6,W
06AD8:  SUBWF  xF2,W
06ADA:  BNZ   6AEC
06ADC:  MOVF   xF7,W
06ADE:  SUBWF  xF3,W
06AE0:  BNZ   6AEC
06AE2:  CLRF   00
06AE4:  CLRF   01
06AE6:  CLRF   02
06AE8:  CLRF   03
06AEA:  BRA    6BEC
....................       cstat = get_cluster(ncl);      // Get the cluster status 
06AEC:  MOVFF  9F3,9FF
06AF0:  MOVFF  9F2,9FE
06AF4:  MOVFF  9F1,9FD
06AF8:  MOVFF  9F0,9FC
06AFC:  MOVLB  0
06AFE:  CALL   5CAE
06B02:  MOVFF  03,9EF
06B06:  MOVFF  02,9EE
06B0A:  MOVFF  01,9ED
06B0E:  MOVFF  00,9EC
....................       if (cstat == 1) return 0;      // Any error occured 
06B12:  MOVLB  9
06B14:  DECFSZ xEC,W
06B16:  BRA    6B2E
06B18:  MOVF   xED,F
06B1A:  BNZ   6B2E
06B1C:  MOVF   xEE,F
06B1E:  BNZ   6B2E
06B20:  MOVF   xEF,F
06B22:  BNZ   6B2E
06B24:  CLRF   00
06B26:  CLRF   01
06B28:  CLRF   02
06B2A:  CLRF   03
06B2C:  BRA    6BEC
....................       } while (cstat);            // Repeat until find a free cluster 
06B2E:  MOVF   xEC,F
06B30:  BNZ   6A78
06B32:  MOVF   xED,F
06B34:  BNZ   6A78
06B36:  MOVF   xEE,F
06B38:  BNZ   6A78
06B3A:  MOVF   xEF,F
06B3C:  BNZ   6A78
....................  
....................    if (!put_cluster(ncl, 0x0FFFFFFF)) return 0;      // Mark the new cluster "in use" 
06B3E:  MOVFF  9F3,9FF
06B42:  MOVFF  9F2,9FE
06B46:  MOVFF  9F1,9FD
06B4A:  MOVFF  9F0,9FC
06B4E:  MOVLW  0F
06B50:  MOVLB  A
06B52:  MOVWF  x03
06B54:  SETF   x02
06B56:  SETF   x01
06B58:  SETF   x00
06B5A:  MOVLB  0
06B5C:  RCALL  65BE
06B5E:  MOVF   01,F
06B60:  BNZ   6B70
06B62:  CLRF   00
06B64:  CLRF   01
06B66:  CLRF   02
06B68:  CLRF   03
06B6A:  MOVLB  9
06B6C:  BRA    6BEC
06B6E:  MOVLB  0
....................    if (clust && !put_cluster(clust, ncl)) return 0;   // Link it to previous one if needed 
06B70:  MOVLB  9
06B72:  MOVF   xE8,F
06B74:  BNZ   6B82
06B76:  MOVF   xE9,F
06B78:  BNZ   6B82
06B7A:  MOVF   xEA,F
06B7C:  BNZ   6B82
06B7E:  MOVF   xEB,F
06B80:  BZ    6BBC
06B82:  MOVFF  9EB,9FF
06B86:  MOVFF  9EA,9FE
06B8A:  MOVFF  9E9,9FD
06B8E:  MOVFF  9E8,9FC
06B92:  MOVFF  9F3,A03
06B96:  MOVFF  9F2,A02
06B9A:  MOVFF  9F1,A01
06B9E:  MOVFF  9F0,A00
06BA2:  MOVLB  0
06BA4:  RCALL  65BE
06BA6:  MOVF   01,F
06BA8:  BTFSC  FD8.2
06BAA:  BRA    6BB0
06BAC:  MOVLB  9
06BAE:  BRA    6BBC
06BB0:  CLRF   00
06BB2:  CLRF   01
06BB4:  CLRF   02
06BB6:  CLRF   03
06BB8:  MOVLB  9
06BBA:  BRA    6BEC
....................    fs->last_clust = ncl; 
06BBC:  MOVLW  1C
06BBE:  MOVLB  7
06BC0:  ADDWF  x12,W
06BC2:  MOVWF  FE9
06BC4:  MOVLW  00
06BC6:  ADDWFC x13,W
06BC8:  MOVWF  FEA
06BCA:  MOVFF  9F0,FEF
06BCE:  MOVFF  9F1,FEC
06BD2:  MOVFF  9F2,FEC
06BD6:  MOVFF  9F3,FEC
....................  
....................    return ncl;      // Return new cluster number 
06BDA:  MOVFF  9F0,00
06BDE:  MOVFF  9F1,01
06BE2:  MOVFF  9F2,02
06BE6:  MOVFF  9F3,03
06BEA:  MOVLB  9
06BEC:  MOVLB  0
06BEE:  RETURN 0
.................... } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... DWORD clust2sect (DWORD clust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determines the sector number from the cluster number 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    clust -= 2;      // First cluster in data area is cluster 2 
*
05602:  MOVLW  02
05604:  MOVLB  9
05606:  SUBWF  xEF,F
05608:  MOVLW  00
0560A:  SUBWFB xF0,F
0560C:  SUBWFB xF1,F
0560E:  SUBWFB xF2,F
....................    if (clust >= fs->max_clust)  
05610:  MOVLW  0C
05612:  MOVLB  7
05614:  ADDWF  x12,W
05616:  MOVWF  FE9
05618:  MOVLW  00
0561A:  ADDWFC x13,W
0561C:  MOVWF  FEA
0561E:  MOVFF  FEF,00
05622:  MOVFF  FEC,01
05626:  MOVFF  FEC,02
0562A:  MOVFF  FEC,03
0562E:  MOVF   03,W
05630:  MOVLB  9
05632:  SUBWF  xF2,W
05634:  BNC   5658
05636:  BNZ   564E
05638:  MOVF   02,W
0563A:  SUBWF  xF1,W
0563C:  BNC   5658
0563E:  BNZ   564E
05640:  MOVF   01,W
05642:  SUBWF  xF0,W
05644:  BNC   5658
05646:  BNZ   564E
05648:  MOVF   00,W
0564A:  SUBWF  xEF,W
0564C:  BNC   5658
....................       return 0;      // Invalid cluster#  
0564E:  CLRF   00
05650:  CLRF   01
05652:  CLRF   02
05654:  CLRF   03
05656:  BRA    56D8
....................    return (clust * fs->sects_clust + fs->database); 
05658:  MOVLW  02
0565A:  MOVLB  7
0565C:  ADDWF  x12,W
0565E:  MOVWF  FE9
05660:  MOVLW  00
05662:  ADDWFC x13,W
05664:  MOVWF  FEA
05666:  MOVFF  FEF,9FA
0566A:  MOVLB  9
0566C:  MOVFF  FEA,9F5
05670:  MOVFF  FE9,9F4
05674:  MOVFF  9F2,9F9
05678:  MOVFF  9F1,9F8
0567C:  MOVFF  9F0,9F7
05680:  MOVFF  9EF,9F6
05684:  CLRF   xFD
05686:  CLRF   xFC
05688:  CLRF   xFB
0568A:  MOVLB  0
0568C:  CALL   47E4
05690:  MOVFF  9F5,FEA
05694:  MOVFF  9F4,FE9
05698:  MOVFF  03,9F6
0569C:  MOVFF  02,9F5
056A0:  MOVFF  01,9F4
056A4:  MOVFF  00,9F3
056A8:  MOVLW  18
056AA:  MOVLB  7
056AC:  ADDWF  x12,W
056AE:  MOVWF  FE9
056B0:  MOVLW  00
056B2:  ADDWFC x13,W
056B4:  MOVWF  FEA
056B6:  MOVFF  FEF,00
056BA:  MOVFF  FEC,01
056BE:  MOVFF  FEC,02
056C2:  MOVFF  FEC,03
056C6:  MOVLB  9
056C8:  MOVF   xF3,W
056CA:  ADDWF  00,F
056CC:  MOVF   xF4,W
056CE:  ADDWFC 01,F
056D0:  MOVF   xF5,W
056D2:  ADDWFC 02,F
056D4:  MOVF   xF6,W
056D6:  ADDWFC 03,F
056D8:  MOVLB  0
056DA:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BYTE check_fs (DWORD sect) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Determine the FAT type 
.................... // 
.................... //   Entry: 
.................... //      clust      Target cluster number to determine if a FAT boot record 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    //static const char fatsign[] = "FAT12FAT16FAT32"; 
....................    static char fatsign[] = "FAT12FAT16FAT32"; 
....................  
....................    // clear the file system buffer 
....................    memset(fs->win, 0, 512); 
*
04684:  MOVLW  24
04686:  MOVLB  7
04688:  ADDWF  x12,W
0468A:  MOVWF  01
0468C:  MOVLW  00
0468E:  ADDWFC x13,W
04690:  MOVWF  03
04692:  MOVFF  01,9E7
04696:  MOVLB  9
04698:  MOVWF  xE8
0469A:  MOVWF  FEA
0469C:  MOVFF  01,FE9
046A0:  CLRF   00
046A2:  MOVLW  02
046A4:  MOVWF  02
046A6:  CLRF   01
046A8:  MOVLB  0
046AA:  CALL   351A
....................    if (disk_read(fs->win, sect, 1) == RES_OK)  
046AE:  MOVLW  24
046B0:  MOVLB  7
046B2:  ADDWF  x12,W
046B4:  MOVWF  01
046B6:  MOVLW  00
046B8:  ADDWFC x13,W
046BA:  MOVWF  03
046BC:  MOVFF  01,9E7
046C0:  MOVLB  9
046C2:  MOVWF  xE8
046C4:  MOVFF  FE8,A21
046C8:  MOVFF  01,A20
046CC:  MOVFF  9E6,A25
046D0:  MOVFF  9E5,A24
046D4:  MOVFF  9E4,A23
046D8:  MOVFF  9E3,A22
046DC:  MOVLW  01
046DE:  MOVLB  A
046E0:  MOVWF  x26
046E2:  MOVLB  0
046E4:  RCALL  44C0
046E6:  MOVF   01,F
046E8:  BTFSS  FD8.2
046EA:  BRA    47DA
....................       {   // Load boot record  
....................       if (LD_WORD(&(fs->win[510])) == 0xAA55)  
046EC:  MOVLW  22
046EE:  MOVLB  7
046F0:  ADDWF  x12,W
046F2:  MOVWF  01
046F4:  MOVLW  02
046F6:  ADDWFC x13,W
046F8:  MOVWF  03
046FA:  MOVFF  01,FE9
046FE:  MOVWF  FEA
04700:  MOVFF  FEC,9E8
04704:  MOVF   FED,F
04706:  MOVFF  FEF,9E7
0470A:  MOVLB  9
0470C:  MOVF   xE7,W
0470E:  SUBLW  55
04710:  BNZ   47DC
04712:  MOVF   xE8,W
04714:  SUBLW  AA
04716:  BNZ   47DC
....................          {      // Is it valid?  
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[0], 5)) 
04718:  MOVLW  5A
0471A:  MOVLB  7
0471C:  ADDWF  x12,W
0471E:  MOVWF  01
04720:  MOVLW  00
04722:  ADDWFC x13,W
04724:  MOVWF  03
04726:  MOVFF  01,9E7
0472A:  MOVLB  9
0472C:  MOVWF  xE8
0472E:  MOVWF  xEA
04730:  MOVFF  01,9E9
04734:  MOVLW  07
04736:  MOVWF  xEC
04738:  MOVLW  14
0473A:  MOVWF  xEB
0473C:  CLRF   xEE
0473E:  MOVLW  05
04740:  MOVWF  xED
04742:  MOVLB  0
04744:  RCALL  4600
04746:  MOVF   01,F
04748:  BNZ   4750
....................             return (FS_FAT12); 
0474A:  MOVLW  01
0474C:  MOVWF  01
0474E:  BRA    47E2
....................          if (!memcmp(&(fs->win[0x36]), &fatsign[5], 5)) 
04750:  MOVLW  5A
04752:  MOVLB  7
04754:  ADDWF  x12,W
04756:  MOVWF  01
04758:  MOVLW  00
0475A:  ADDWFC x13,W
0475C:  MOVWF  03
0475E:  MOVFF  01,9E7
04762:  MOVLB  9
04764:  MOVWF  xE8
04766:  MOVWF  xEA
04768:  MOVFF  01,9E9
0476C:  MOVLW  07
0476E:  MOVWF  xEC
04770:  MOVLW  19
04772:  MOVWF  xEB
04774:  CLRF   xEE
04776:  MOVLW  05
04778:  MOVWF  xED
0477A:  MOVLB  0
0477C:  RCALL  4600
0477E:  MOVF   01,F
04780:  BNZ   4788
....................             return (FS_FAT16); 
04782:  MOVLW  02
04784:  MOVWF  01
04786:  BRA    47E2
....................          if (!memcmp(&(fs->win[0x52]), &fatsign[10], 5) && (fs->win[0x28] == 0)) 
04788:  MOVLW  76
0478A:  MOVLB  7
0478C:  ADDWF  x12,W
0478E:  MOVWF  01
04790:  MOVLW  00
04792:  ADDWFC x13,W
04794:  MOVWF  03
04796:  MOVFF  01,9E7
0479A:  MOVLB  9
0479C:  MOVWF  xE8
0479E:  MOVWF  xEA
047A0:  MOVFF  01,9E9
047A4:  MOVLW  07
047A6:  MOVWF  xEC
047A8:  MOVLW  1E
047AA:  MOVWF  xEB
047AC:  CLRF   xEE
047AE:  MOVLW  05
047B0:  MOVWF  xED
047B2:  MOVLB  0
047B4:  RCALL  4600
047B6:  MOVF   01,F
047B8:  BNZ   47DA
047BA:  MOVLW  4C
047BC:  MOVLB  7
047BE:  ADDWF  x12,W
047C0:  MOVWF  FE9
047C2:  MOVLW  00
047C4:  ADDWFC x13,W
047C6:  MOVWF  FEA
047C8:  MOVF   FEF,F
047CA:  BTFSC  FD8.2
047CC:  BRA    47D2
047CE:  MOVLB  0
047D0:  BRA    47DA
....................             return (FS_FAT32); 
047D2:  MOVLW  03
047D4:  MOVWF  01
047D6:  MOVLB  0
047D8:  BRA    47E2
047DA:  MOVLB  9
....................          } 
....................       } 
....................    return 0; 
047DC:  MOVLW  00
047DE:  MOVWF  01
047E0:  MOVLB  0
047E2:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... BOOLEAN next_dir_ptr (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Move Directory Pointer to Next 
.................... // 
.................... //   Entry: 
.................... //      scan      Pointer to a directory object 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    WORD idx; 
....................  
....................    idx = scan->index + 1; 
*
05FFC:  MOVLW  0C
05FFE:  MOVLB  9
06000:  ADDWF  xE5,W
06002:  MOVWF  FE9
06004:  MOVLW  00
06006:  ADDWFC xE6,W
06008:  MOVWF  FEA
0600A:  MOVFF  FEC,9EE
0600E:  MOVF   FED,F
06010:  MOVFF  FEF,9ED
06014:  MOVLW  01
06016:  ADDWF  xED,W
06018:  MOVWF  xEB
0601A:  MOVLW  00
0601C:  ADDWFC xEE,W
0601E:  MOVWF  xEC
....................    if ((idx & 15) == 0)  
06020:  MOVF   xEB,W
06022:  ANDLW  0F
06024:  MOVWF  xED
06026:  CLRF   xEE
06028:  MOVF   xED,F
0602A:  BTFSS  FD8.2
0602C:  BRA    61B8
0602E:  MOVF   xEE,F
06030:  BTFSS  FD8.2
06032:  BRA    61B8
....................       {      // Table sector changed?  
....................       scan->sect++;         // Next sector  
06034:  MOVLW  08
06036:  ADDWF  xE5,W
06038:  MOVWF  FE9
0603A:  MOVLW  00
0603C:  ADDWFC xE6,W
0603E:  MOVWF  FEA
06040:  MOVLW  01
06042:  ADDWF  FEE,F
06044:  MOVLW  00
06046:  ADDWFC FEE,F
06048:  ADDWFC FEE,F
0604A:  ADDWFC FED,F
....................       if (!scan->clust)  
0604C:  MOVLW  04
0604E:  ADDWF  xE5,W
06050:  MOVWF  FE9
06052:  MOVLW  00
06054:  ADDWFC xE6,W
06056:  MOVWF  FEA
06058:  MOVF   FEF,F
0605A:  BNZ   6098
0605C:  MOVF   FEC,F
0605E:  BNZ   6098
06060:  MOVF   FEC,F
06062:  BNZ   6098
06064:  MOVF   FEC,F
06066:  BNZ   6098
....................          {      // In static table  
....................          if (idx >= fs->n_rootdir)  
06068:  MOVLW  04
0606A:  MOVLB  7
0606C:  ADDWF  x12,W
0606E:  MOVWF  FE9
06070:  MOVLW  00
06072:  ADDWFC x13,W
06074:  MOVWF  FEA
06076:  MOVFF  FEC,03
0607A:  MOVF   FED,F
0607C:  MOVFF  FEF,01
06080:  MOVF   03,W
06082:  MOVLB  9
06084:  SUBWF  xEC,W
06086:  BNC   6096
06088:  BNZ   6090
0608A:  MOVF   01,W
0608C:  SUBWF  xEB,W
0608E:  BNC   6096
....................             return (FALSE);   // Reached to end of table  
06090:  MOVLW  00
06092:  MOVWF  01
06094:  BRA    61D2
....................          }  
06096:  BRA    61B8
....................       else  
....................          {   // In dynamic table  
....................          if (((idx / 16) & (fs->sects_clust - 1)) == 0)  
06098:  RRCF   xEC,W
0609A:  MOVWF  xEE
0609C:  RRCF   xEB,W
0609E:  MOVWF  xED
060A0:  RRCF   xEE,F
060A2:  RRCF   xED,F
060A4:  RRCF   xEE,F
060A6:  RRCF   xED,F
060A8:  RRCF   xEE,F
060AA:  RRCF   xED,F
060AC:  MOVLW  0F
060AE:  ANDWF  xEE,F
060B0:  MOVLW  02
060B2:  MOVLB  7
060B4:  ADDWF  x12,W
060B6:  MOVWF  FE9
060B8:  MOVLW  00
060BA:  ADDWFC x13,W
060BC:  MOVWF  FEA
060BE:  MOVLW  01
060C0:  SUBWF  FEF,W
060C2:  MOVLB  9
060C4:  ANDWF  xED,F
060C6:  CLRF   xEE
060C8:  MOVF   xED,F
060CA:  BTFSS  FD8.2
060CC:  BRA    61B8
060CE:  MOVF   xEE,F
060D0:  BTFSS  FD8.2
060D2:  BRA    61B8
....................             {   // Cluster changed?  
....................  
....................             // Get next cluster  
....................             clust = get_cluster(scan->clust);          
060D4:  MOVLW  04
060D6:  ADDWF  xE5,W
060D8:  MOVWF  FE9
060DA:  MOVLW  00
060DC:  ADDWFC xE6,W
060DE:  MOVWF  FEA
060E0:  MOVFF  FEF,9FC
060E4:  MOVFF  FEC,9FD
060E8:  MOVFF  FEC,9FE
060EC:  MOVFF  FEC,9FF
060F0:  MOVLB  0
060F2:  RCALL  5CAE
060F4:  MOVFF  03,9EA
060F8:  MOVFF  02,9E9
060FC:  MOVFF  01,9E8
06100:  MOVFF  00,9E7
....................  
....................             // Reached the end of table?  
....................             if ((clust >= fs->max_clust) || (clust < 2)) 
06104:  MOVLW  0C
06106:  MOVLB  7
06108:  ADDWF  x12,W
0610A:  MOVWF  FE9
0610C:  MOVLW  00
0610E:  ADDWFC x13,W
06110:  MOVWF  FEA
06112:  MOVFF  FEF,00
06116:  MOVFF  FEC,01
0611A:  MOVFF  FEC,02
0611E:  MOVFF  FEC,03
06122:  MOVF   03,W
06124:  MOVLB  9
06126:  SUBWF  xEA,W
06128:  BNC   6142
0612A:  BNZ   6154
0612C:  MOVF   02,W
0612E:  SUBWF  xE9,W
06130:  BNC   6142
06132:  BNZ   6154
06134:  MOVF   01,W
06136:  SUBWF  xE8,W
06138:  BNC   6142
0613A:  BNZ   6154
0613C:  MOVF   00,W
0613E:  SUBWF  xE7,W
06140:  BC    6154
06142:  MOVF   xEA,F
06144:  BNZ   615A
06146:  MOVF   xE9,F
06148:  BNZ   615A
0614A:  MOVF   xE8,F
0614C:  BNZ   615A
0614E:  MOVF   xE7,W
06150:  SUBLW  01
06152:  BNC   615A
....................                return (FALSE); 
06154:  MOVLW  00
06156:  MOVWF  01
06158:  BRA    61D2
....................  
....................             // Initialize for new cluster  
....................             scan->clust = clust; 
0615A:  MOVLW  04
0615C:  ADDWF  xE5,W
0615E:  MOVWF  FE9
06160:  MOVLW  00
06162:  ADDWFC xE6,W
06164:  MOVWF  FEA
06166:  MOVFF  9E7,FEF
0616A:  MOVFF  9E8,FEC
0616E:  MOVFF  9E9,FEC
06172:  MOVFF  9EA,FEC
....................             scan->sect = clust2sect(clust); 
06176:  MOVLW  08
06178:  ADDWF  xE5,W
0617A:  MOVWF  01
0617C:  MOVLW  00
0617E:  ADDWFC xE6,W
06180:  MOVWF  03
06182:  MOVFF  01,9ED
06186:  MOVWF  xEE
06188:  MOVFF  9EA,9F2
0618C:  MOVFF  9E9,9F1
06190:  MOVFF  9E8,9F0
06194:  MOVFF  9E7,9EF
06198:  MOVLB  0
0619A:  CALL   5602
0619E:  MOVFF  9EE,FEA
061A2:  MOVFF  9ED,FE9
061A6:  MOVFF  00,FEF
061AA:  MOVFF  01,FEC
061AE:  MOVFF  02,FEC
061B2:  MOVFF  03,FEC
061B6:  MOVLB  9
....................             } 
....................          } 
....................       } 
....................    scan->index = idx;   // Lower 4 bit of scan->index indicates offset in scan->sect  
061B8:  MOVLW  0C
061BA:  ADDWF  xE5,W
061BC:  MOVWF  FE9
061BE:  MOVLW  00
061C0:  ADDWFC xE6,W
061C2:  MOVWF  FEA
061C4:  MOVFF  9EC,FEC
061C8:  MOVF   FED,F
061CA:  MOVFF  9EB,FEF
....................    return (TRUE); 
061CE:  MOVLW  01
061D0:  MOVWF  01
061D2:  MOVLB  0
061D4:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... #ifndef _FS_MINIMUM 
.................... void get_fileinfo (FILINFO *finfo, BYTE *dir_ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Fetches the file status from the Directory Entry 
.................... // 
.................... //   Entry: 
.................... //      finfo      Pointer to Store the File Information 
.................... //      dir         Pointer to the Directory Entry  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, c, a; 
....................    char *p; 
....................  
....................    p = &(finfo->fname[0]); 
....................    a = *(dir_ptr+12);            // NT flag  
....................    for (n = 0; n < 8; n++)  
....................       {   // Convert file name (body)  
....................       c = *(dir_ptr+n); 
....................       if (c == ' ')  
....................          break; 
....................  
....................       if (c == 0x05) 
....................          c = 0xE5; 
....................  
....................       if ((a & 0x08) && (c >= 'A') && (c <= 'Z')) 
....................          c += 0x20; 
....................  
....................       *p++ = c; 
....................       } 
....................    if (*(dir_ptr+8) != ' ')  
....................       {   // Convert file name (extension)  
....................       *p++ = '.'; 
....................       for (n = 8; n < 11; n++)  
....................          { 
....................          c = *(dir_ptr+n); 
....................          if (c == ' ')  
....................             break; 
....................          if ((a & 0x10) && (c >= 'A') && (c <= 'Z')) 
....................             c += 0x20; 
....................          *p++ = c; 
....................          } 
....................       } 
....................    *p = '\0'; 
....................  
....................    finfo->fattrib = *(dir_ptr+11);         // Attribute  
....................    finfo->fsize = LD_DWORD(dir_ptr+28);   // Size  
....................    finfo->fdate = LD_WORD(dir_ptr+24);      // Date  
....................    finfo->ftime = LD_WORD(dir_ptr+22);      // Time  
....................    } 
.................... #endif // _FS_MINIMUM  
....................  
....................  
.................... char make_dirfile (pchar *path, char *dirname) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Extract and construct a standard format directory name 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file path pointer 
.................... //      dirname      Pointer to the Directory name buffer {Name(8), Ext(3), NT flag(1)} 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE n, t, c, a, b; 
....................    char *ptr; 
....................  
....................    // initialise the directory name buffer (work area) 
....................    memset(dirname, ' ', 8+3);      // Fill buffer with spaces 
*
056DC:  MOVFF  9E8,FEA
056E0:  MOVFF  9E7,FE9
056E4:  MOVLW  20
056E6:  MOVWF  00
056E8:  CLRF   02
056EA:  MOVLW  0B
056EC:  MOVWF  01
056EE:  CALL   351A
....................    a = 0; b = 0x18;            // NT flag 
056F2:  MOVLB  9
056F4:  CLRF   xEC
056F6:  MOVLW  18
056F8:  MOVWF  xED
....................    n = 0; t = 8; 
056FA:  CLRF   xE9
056FC:  MOVLW  08
056FE:  MOVWF  xEA
....................    for (;;)  
....................       { 
.................... //      c = *(*path)++; 
....................       ptr = *path; 
05700:  MOVFF  9E5,FE9
05704:  MOVFF  9E6,FEA
05708:  MOVFF  FEC,9EF
0570C:  MOVF   FED,F
0570E:  MOVFF  FEF,9EE
....................       c = *ptr; 
05712:  MOVFF  9EE,FE9
05716:  MOVFF  9EF,FEA
0571A:  MOVFF  FEF,9EB
....................       (*path)++; 
0571E:  MOVFF  9E6,03
05722:  MOVFF  9E5,FE9
05726:  MOVFF  9E6,FEA
0572A:  MOVLW  01
0572C:  ADDWF  FEE,F
0572E:  BNC   5732
05730:  INCF   FEF,F
....................  
....................       if (c <= ' ')  
05732:  MOVF   xEB,W
05734:  SUBLW  20
05736:  BNC   573A
....................          c = 0; 
05738:  CLRF   xEB
....................  
....................       if ((c == 0) || (c == '/') || (c == '\\')) 
0573A:  MOVF   xEB,F
0573C:  BZ    574A
0573E:  MOVF   xEB,W
05740:  SUBLW  2F
05742:  BZ    574A
05744:  MOVF   xEB,W
05746:  SUBLW  5C
05748:  BNZ   5768
....................          {   // Reached to end of str or directory separator  
....................          if (n == 0)  
0574A:  MOVF   xE9,F
0574C:  BNZ   5750
....................             break; 
0574E:  BRA    5830
....................          dirname[11] = a & b;  
05750:  MOVLW  0B
05752:  ADDWF  xE7,W
05754:  MOVWF  FE9
05756:  MOVLW  00
05758:  ADDWFC xE8,W
0575A:  MOVWF  FEA
0575C:  MOVF   xEC,W
0575E:  ANDWF  xED,W
05760:  MOVWF  FEF
....................             return (c); 
05762:  MOVFF  9EB,01
05766:  BRA    5834
....................          } 
....................       if (c <= ' ' || c == 0x7F) 
05768:  MOVF   xEB,W
0576A:  SUBLW  20
0576C:  BC    5774
0576E:  MOVF   xEB,W
05770:  SUBLW  7F
05772:  BNZ   5776
....................          break;   // reject invisible characters 
05774:  BRA    5830
....................       if (c == '.')  
05776:  MOVF   xEB,W
05778:  SUBLW  2E
0577A:  BNZ   5798
....................          { 
....................          if(!(a & 1) && (n >= 1) && (n <= 8)) 
0577C:  BTFSC  xEC.0
0577E:  BRA    5796
05780:  MOVF   xE9,W
05782:  SUBLW  00
05784:  BC    5796
05786:  MOVF   xE9,W
05788:  SUBLW  08
0578A:  BNC   5796
....................             {   // Enter extension part  
....................             n = 8; t = 11;  
0578C:  MOVLW  08
0578E:  MOVWF  xE9
05790:  MOVLW  0B
05792:  MOVWF  xEA
....................             continue; 
05794:  BRA    582E
....................             } 
....................          break; 
05796:  BRA    5830
....................          } 
....................  
.................... #ifdef _USE_SJIS 
....................       if (((c >= 0x81) && (c <= 0x9F)) ||      // Accept S-JIS code  
....................           ((c >= 0xE0) && (c <= 0xFC)))  
....................          { 
....................          if ((n == 0) && (c == 0xE5))      // Change heading \xE5 to \x05  
....................             c = 0x05; 
....................          a ^= 0x01;  
....................          goto md_l2; 
....................          } 
.................... #endif 
....................       if (c == '"') 
05798:  MOVF   xEB,W
0579A:  SUBLW  22
0579C:  BNZ   57A0
....................          break;               // Reject "  
0579E:  BRA    5830
....................  
....................       if (c <= ')')  
057A0:  MOVF   xEB,W
057A2:  SUBLW  29
057A4:  BNC   57A8
....................          goto md_l1;            // Accept ! # $ % & ' ( )  
057A6:  BRA    5812
....................  
....................       if (c <= ',') 
057A8:  MOVF   xEB,W
057AA:  SUBLW  2C
057AC:  BNC   57B0
....................          break;               // Reject * + ,  
057AE:  BRA    5830
....................  
....................       if (c <= '9')  
057B0:  MOVF   xEB,W
057B2:  SUBLW  39
057B4:  BNC   57B8
....................          goto md_l1;            // Accept - 0-9  
057B6:  BRA    5812
....................  
....................       if (c <= '?')  
057B8:  MOVF   xEB,W
057BA:  SUBLW  3F
057BC:  BNC   57C0
....................          break;               // Reject : ; < = > ?  
057BE:  BRA    5830
....................  
....................       if (!(a & 1))  
057C0:  BTFSC  xEC.0
057C2:  BRA    5812
....................          {   // These checks are not applied to S-JIS 2nd byte  
....................          if (c == '|')  
057C4:  MOVF   xEB,W
057C6:  SUBLW  7C
057C8:  BNZ   57CC
....................             break;            // Reject |  
057CA:  BRA    5830
....................  
....................          if ((c >= '[') && (c <= ']')) 
057CC:  MOVF   xEB,W
057CE:  SUBLW  5A
057D0:  BC    57DA
057D2:  MOVF   xEB,W
057D4:  SUBLW  5D
057D6:  BNC   57DA
....................             break;// Reject [ \ ]  
057D8:  BRA    5830
....................  
....................          if ((c >= 'A') && (c <= 'Z')) 
057DA:  MOVF   xEB,W
057DC:  SUBLW  40
057DE:  BC    57F4
057E0:  MOVF   xEB,W
057E2:  SUBLW  5A
057E4:  BNC   57F4
....................             (t == 8) ? (b &= 0xF7) : (b &= 0xEF); 
057E6:  MOVF   xEA,W
057E8:  SUBLW  08
057EA:  BNZ   57F2
057EC:  BCF    xED.3
057EE:  MOVF   xED,W
057F0:  BRA    57F4
057F2:  BCF    xED.4
....................  
....................          if ((c >= 'a') && (c <= 'z'))  
057F4:  MOVF   xEB,W
057F6:  SUBLW  60
057F8:  BC    5812
057FA:  MOVF   xEB,W
057FC:  SUBLW  7A
057FE:  BNC   5812
....................             {      // Convert to upper case  
....................             c -= 0x20; 
05800:  MOVLW  20
05802:  SUBWF  xEB,F
....................             (t == 8) ? (a |= 0x08) : (a |= 0x10); 
05804:  MOVF   xEA,W
05806:  SUBLW  08
05808:  BNZ   5810
0580A:  BSF    xEC.3
0580C:  MOVF   xEC,W
0580E:  BRA    5812
05810:  BSF    xEC.4
....................             } 
....................          } 
....................    md_l1: 
....................       a &= 0xFE; 
05812:  BCF    xEC.0
....................    md_l2: 
....................       if (n >= t)  
05814:  MOVF   xEA,W
05816:  SUBWF  xE9,W
05818:  BNC   581C
....................          break; 
0581A:  BRA    5830
....................       dirname[n++] = c; 
0581C:  MOVF   xE9,W
0581E:  INCF   xE9,F
05820:  ADDWF  xE7,W
05822:  MOVWF  FE9
05824:  MOVLW  00
05826:  ADDWFC xE8,W
05828:  MOVWF  FEA
0582A:  MOVFF  9EB,FEF
0582E:  BRA    5700
....................       } 
....................    return 1; 
05830:  MOVLW  01
05832:  MOVWF  01
05834:  MOVLB  0
05836:  GOTO   6378 (RETURN)
....................    } 
....................  
....................  
....................  
.................... FRESULT trace_path (DIR *scan, char *fn, char *path, pBYTE *win_dir) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Trace the file path for the specified object 
.................... // 
.................... //   Entry: 
.................... //      *scan,         Pointer to directory object to return last directory 
.................... //      *fn,         Pointer to last segment name to return 
.................... //      *path,         Full-path string to trace a file or directory 
.................... //      *win_dir      Directory pointer in Win[] to return 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust; 
....................    char ds; 
....................    BYTE *dptr; 
....................  
....................    dptr = NULL; 
*
061D6:  MOVLB  9
061D8:  CLRF   xE4
061DA:  CLRF   xE3
....................  
....................    // Initialize directory object 
....................    // Point to the start of the directory area on the media 
....................    clust = fs->dirbase; 
061DC:  MOVLW  14
061DE:  MOVLB  7
061E0:  ADDWF  x12,W
061E2:  MOVWF  FE9
061E4:  MOVLW  00
061E6:  ADDWFC x13,W
061E8:  MOVWF  FEA
061EA:  MOVFF  FEF,9DE
061EE:  MOVFF  FEC,9DF
061F2:  MOVFF  FEC,9E0
061F6:  MOVFF  FEC,9E1
....................    if (fs->fs_type == FS_FAT32)  
061FA:  MOVFF  712,FE9
061FE:  MOVFF  713,FEA
06202:  MOVF   FEF,W
06204:  SUBLW  03
06206:  BNZ   628A
....................       { 
....................       scan->clust = scan->sclust = clust; 
06208:  MOVLW  04
0620A:  MOVLB  9
0620C:  ADDWF  xD6,W
0620E:  MOVWF  01
06210:  MOVLW  00
06212:  ADDWFC xD7,W
06214:  MOVFF  01,9E5
06218:  MOVFF  9D6,FE9
0621C:  MOVFF  9D7,FEA
06220:  MOVFF  9DE,FEF
06224:  MOVFF  9DF,FEC
06228:  MOVFF  9E0,FEC
0622C:  MOVFF  9E1,FEC
06230:  MOVWF  FEA
06232:  MOVFF  9E5,FE9
06236:  MOVFF  9DE,FEF
0623A:  MOVFF  9DF,FEC
0623E:  MOVFF  9E0,FEC
06242:  MOVFF  9E1,FEC
....................       scan->sect = clust2sect(clust); 
06246:  MOVLW  08
06248:  ADDWF  xD6,W
0624A:  MOVWF  01
0624C:  MOVLW  00
0624E:  ADDWFC xD7,W
06250:  MOVWF  03
06252:  MOVFF  01,9E5
06256:  MOVWF  xE6
06258:  MOVFF  9E1,9F2
0625C:  MOVFF  9E0,9F1
06260:  MOVFF  9DF,9F0
06264:  MOVFF  9DE,9EF
06268:  MOVLB  0
0626A:  CALL   5602
0626E:  MOVFF  9E6,FEA
06272:  MOVFF  9E5,FE9
06276:  MOVFF  00,FEF
0627A:  MOVFF  01,FEC
0627E:  MOVFF  02,FEC
06282:  MOVFF  03,FEC
....................       } 
06286:  BRA    62EA
06288:  MOVLB  7
....................    else  
....................       { 
....................       scan->clust = scan->sclust = 0; 
0628A:  MOVLW  04
0628C:  MOVLB  9
0628E:  ADDWF  xD6,W
06290:  MOVWF  01
06292:  MOVLW  00
06294:  ADDWFC xD7,W
06296:  MOVWF  03
06298:  MOVFF  9D6,FE9
0629C:  MOVFF  9D7,FEA
062A0:  MOVF   FEE,F
062A2:  MOVF   FEE,F
062A4:  CLRF   FEC
062A6:  MOVF   FED,F
062A8:  CLRF   FEF
062AA:  MOVF   FED,F
062AC:  CLRF   FEF
062AE:  MOVF   FED,F
062B0:  CLRF   FEF
062B2:  MOVLW  00
062B4:  MOVFF  03,FEA
062B8:  MOVFF  01,FE9
062BC:  MOVFF  00,FEF
062C0:  MOVFF  01,FEC
062C4:  MOVFF  02,FEC
062C8:  MOVFF  03,FEC
....................       scan->sect = clust; 
062CC:  MOVLW  08
062CE:  ADDWF  xD6,W
062D0:  MOVWF  FE9
062D2:  MOVLW  00
062D4:  ADDWFC xD7,W
062D6:  MOVWF  FEA
062D8:  MOVFF  9DE,FEF
062DC:  MOVFF  9DF,FEC
062E0:  MOVFF  9E0,FEC
062E4:  MOVFF  9E1,FEC
062E8:  MOVLB  0
....................       } 
....................    scan->index = 0; 
062EA:  MOVLW  0C
062EC:  MOVLB  9
062EE:  ADDWF  xD6,W
062F0:  MOVWF  FE9
062F2:  MOVLW  00
062F4:  ADDWFC xD7,W
062F6:  MOVWF  FEA
062F8:  CLRF   FEC
062FA:  MOVF   FED,F
062FC:  CLRF   FEF
....................  
....................    // Skip leading spaces 
....................    while ((*path == ' ') || (*path == '/') || (*path == '\\')) 
062FE:  MOVFF  9DB,03
06302:  MOVFF  9DA,FE9
06306:  MOVFF  9DB,FEA
0630A:  MOVF   FEF,W
0630C:  SUBLW  20
0630E:  BZ    6334
06310:  MOVFF  9DB,03
06314:  MOVFF  9DA,FE9
06318:  MOVFF  9DB,FEA
0631C:  MOVF   FEF,W
0631E:  SUBLW  2F
06320:  BZ    6334
06322:  MOVFF  9DB,03
06326:  MOVFF  9DA,FE9
0632A:  MOVFF  9DB,FEA
0632E:  MOVF   FEF,W
06330:  SUBLW  5C
06332:  BNZ   633C
....................        path++; 
06334:  INCF   xDA,F
06336:  BTFSC  FD8.2
06338:  INCF   xDB,F
0633A:  BRA    62FE
....................  
....................    if ((BYTE)*path < ' ')  
0633C:  MOVFF  9DB,03
06340:  MOVFF  9DA,FE9
06344:  MOVFF  9DB,FEA
06348:  MOVF   FEF,W
0634A:  SUBLW  1F
0634C:  BNC   6362
....................       {   // Null path means the root directory  
....................       *win_dir = NULL;  
0634E:  MOVFF  9DC,FE9
06352:  MOVFF  9DD,FEA
06356:  CLRF   FEC
06358:  MOVF   FED,F
0635A:  CLRF   FEF
....................       return (FR_OK); 
0635C:  MOVLW  00
0635E:  MOVWF  01
06360:  BRA    65BA
....................       } 
....................  
....................    for (;;)  
....................       { 
....................       // extract the next short file name from the path parameter 
....................       ds = make_dirfile(&path, fn); 
06362:  MOVLW  09
06364:  MOVWF  xE6
06366:  MOVLW  DA
06368:  MOVWF  xE5
0636A:  MOVFF  9D9,9E8
0636E:  MOVFF  9D8,9E7
06372:  MOVLB  0
06374:  GOTO   56DC
06378:  MOVFF  01,9E2
....................       if (ds == 1)  
0637C:  MOVLB  9
0637E:  DECFSZ xE2,W
06380:  BRA    6388
....................          return (FR_INVALID_NAME); 
06382:  MOVLW  04
06384:  MOVWF  01
06386:  BRA    65BA
....................  
....................       // load the FATFS window with the first sector of the current object 
....................       for (;;)  
....................          { 
....................          if (!move_window(scan->sect))  
06388:  MOVLW  08
0638A:  ADDWF  xD6,W
0638C:  MOVWF  FE9
0638E:  MOVLW  00
06390:  ADDWFC xD7,W
06392:  MOVWF  FEA
06394:  MOVFF  FEF,A14
06398:  MOVFF  FEC,A15
0639C:  MOVFF  FEC,A16
063A0:  MOVFF  FEC,A17
063A4:  MOVLB  0
063A6:  CALL   5A76
063AA:  MOVF   01,F
063AC:  BNZ   63B8
....................             return (FR_RW_ERROR); 
063AE:  MOVLW  07
063B0:  MOVWF  01
063B2:  MOVLB  9
063B4:  BRA    65BA
063B6:  MOVLB  0
....................  
....................          dptr = &(fs->win[(scan->index & 15) * 32]);   // Pointer to the directory entry 
063B8:  MOVLW  0C
063BA:  MOVLB  9
063BC:  ADDWF  xD6,W
063BE:  MOVWF  FE9
063C0:  MOVLW  00
063C2:  ADDWFC xD7,W
063C4:  MOVWF  FEA
063C6:  MOVFF  FEC,9E6
063CA:  MOVF   FED,F
063CC:  MOVFF  FEF,9E5
063D0:  MOVLW  0F
063D2:  ANDWF  xE5,F
063D4:  CLRF   xE6
063D6:  RLCF   xE5,F
063D8:  RLCF   xE6,F
063DA:  RLCF   xE5,F
063DC:  RLCF   xE6,F
063DE:  RLCF   xE5,F
063E0:  RLCF   xE6,F
063E2:  RLCF   xE5,F
063E4:  RLCF   xE6,F
063E6:  RLCF   xE5,F
063E8:  RLCF   xE6,F
063EA:  MOVLW  E0
063EC:  ANDWF  xE5,F
063EE:  MOVLW  24
063F0:  ADDWF  xE5,W
063F2:  MOVWF  01
063F4:  MOVLW  00
063F6:  ADDWFC xE6,W
063F8:  MOVWF  03
063FA:  MOVF   01,W
063FC:  MOVLB  7
063FE:  ADDWF  x12,W
06400:  MOVWF  01
06402:  MOVF   x13,W
06404:  ADDWFC 03,F
06406:  MOVFF  01,9E3
0640A:  MOVLB  9
0640C:  MOVFF  03,9E4
....................          if (*dptr == 0)                        // Has it reached to end of dir? 
06410:  MOVFF  9E4,03
06414:  MOVFF  9E3,FE9
06418:  MOVFF  9E4,FEA
0641C:  MOVF   FEF,F
0641E:  BNZ   642E
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06420:  MOVF   xE2,F
06422:  BNZ   6428
06424:  MOVLW  02
06426:  BRA    642A
06428:  MOVLW  03
0642A:  MOVWF  01
0642C:  BRA    65BA
....................          if (    (*dptr != 0xE5)                  // Matched? 
....................             && !(*(dptr+11) & AM_VOL) 
....................             && !memcmp(dptr, fn, 8+3) ) 
0642E:  MOVFF  9E4,03
06432:  MOVFF  9E3,FE9
06436:  MOVFF  9E4,FEA
0643A:  MOVF   FEF,W
0643C:  SUBLW  E5
0643E:  BZ    6480
06440:  MOVLW  0B
06442:  ADDWF  xE3,W
06444:  MOVWF  01
06446:  MOVLW  00
06448:  ADDWFC xE4,W
0644A:  MOVWF  03
0644C:  MOVFF  01,FE9
06450:  MOVWF  FEA
06452:  BTFSC  FEF.3
06454:  BRA    6480
06456:  MOVFF  9E4,9EA
0645A:  MOVFF  9E3,9E9
0645E:  MOVFF  9D9,9EC
06462:  MOVFF  9D8,9EB
06466:  CLRF   xEE
06468:  MOVLW  0B
0646A:  MOVWF  xED
0646C:  MOVLB  0
0646E:  CALL   4600
06472:  MOVF   01,F
06474:  BTFSC  FD8.2
06476:  BRA    647C
06478:  MOVLB  9
0647A:  BRA    6480
....................              break; 
0647C:  BRA    64A8
0647E:  MOVLB  9
....................          if (!next_dir_ptr(scan))               // Next directory pointer 
06480:  MOVFF  9D7,9E6
06484:  MOVFF  9D6,9E5
06488:  MOVLB  0
0648A:  RCALL  5FFC
0648C:  MOVF   01,F
0648E:  BNZ   64A2
....................             return (!ds ? FR_NO_FILE : FR_NO_PATH); 
06490:  MOVLB  9
06492:  MOVF   xE2,F
06494:  BNZ   649A
06496:  MOVLW  02
06498:  BRA    649C
0649A:  MOVLW  03
0649C:  MOVWF  01
0649E:  BRA    65BA
064A0:  MOVLB  0
064A2:  MOVLB  9
064A4:  BRA    6388
064A6:  MOVLB  0
....................          } 
....................       if (!ds)  
064A8:  MOVLB  9
064AA:  MOVF   xE2,F
064AC:  BNZ   64C6
....................          {  
....................          *win_dir = dptr;  
064AE:  MOVFF  9DC,FE9
064B2:  MOVFF  9DD,FEA
064B6:  MOVFF  9E4,FEC
064BA:  MOVF   FED,F
064BC:  MOVFF  9E3,FEF
....................          return (FR_OK); 
064C0:  MOVLW  00
064C2:  MOVWF  01
064C4:  BRA    65BA
....................           }   // Matched with end of path  
....................  
....................       if (!(*(dptr+11) & AM_DIR))  
064C6:  MOVLW  0B
064C8:  ADDWF  xE3,W
064CA:  MOVWF  01
064CC:  MOVLW  00
064CE:  ADDWFC xE4,W
064D0:  MOVWF  03
064D2:  MOVFF  01,FE9
064D6:  MOVWF  FEA
064D8:  BTFSC  FEF.4
064DA:  BRA    64E2
....................          return FR_NO_PATH;                     // Cannot trace because it is a file 
064DC:  MOVLW  03
064DE:  MOVWF  01
064E0:  BRA    65BA
....................  
....................       clust = ((DWORD)LD_WORD(dptr+20) << 16) | LD_WORD(dptr+26); // Get cluster# of the directory 
064E2:  MOVLW  14
064E4:  ADDWF  xE3,W
064E6:  MOVWF  01
064E8:  MOVLW  00
064EA:  ADDWFC xE4,W
064EC:  MOVWF  03
064EE:  MOVFF  01,FE9
064F2:  MOVWF  FEA
064F4:  MOVFF  FEC,9E1
064F8:  MOVF   FED,F
064FA:  MOVFF  FEF,9E5
064FE:  MOVFF  9E5,9E0
06502:  CLRF   xE5
06504:  CLRF   xE6
06506:  MOVLW  1A
06508:  ADDWF  xE3,W
0650A:  MOVWF  01
0650C:  MOVLW  00
0650E:  ADDWFC xE4,W
06510:  MOVFF  01,FE9
06514:  MOVWF  FEA
06516:  MOVFF  FEC,03
0651A:  MOVF   FED,F
0651C:  MOVF   FEF,W
0651E:  IORWF  xE5,W
06520:  MOVWF  xDE
06522:  MOVF   03,W
06524:  IORWF  xE6,W
06526:  MOVWF  xDF
....................       scan->clust = scan->sclust = clust;            // Restart scan with the new directory 
06528:  MOVLW  04
0652A:  ADDWF  xD6,W
0652C:  MOVWF  01
0652E:  MOVLW  00
06530:  ADDWFC xD7,W
06532:  MOVFF  01,9E5
06536:  MOVFF  9D6,FE9
0653A:  MOVFF  9D7,FEA
0653E:  MOVFF  9DE,FEF
06542:  MOVFF  9DF,FEC
06546:  MOVFF  9E0,FEC
0654A:  MOVFF  9E1,FEC
0654E:  MOVWF  FEA
06550:  MOVFF  9E5,FE9
06554:  MOVFF  9DE,FEF
06558:  MOVFF  9DF,FEC
0655C:  MOVFF  9E0,FEC
06560:  MOVFF  9E1,FEC
....................       scan->sect = clust2sect(clust); 
06564:  MOVLW  08
06566:  ADDWF  xD6,W
06568:  MOVWF  01
0656A:  MOVLW  00
0656C:  ADDWFC xD7,W
0656E:  MOVWF  03
06570:  MOVFF  01,9E5
06574:  MOVWF  xE6
06576:  MOVFF  9E1,9F2
0657A:  MOVFF  9E0,9F1
0657E:  MOVFF  9DF,9F0
06582:  MOVFF  9DE,9EF
06586:  MOVLB  0
06588:  CALL   5602
0658C:  MOVFF  9E6,FEA
06590:  MOVFF  9E5,FE9
06594:  MOVFF  00,FEF
06598:  MOVFF  01,FEC
0659C:  MOVFF  02,FEC
065A0:  MOVFF  03,FEC
....................       scan->index = 0; 
065A4:  MOVLW  0C
065A6:  MOVLB  9
065A8:  ADDWF  xD6,W
065AA:  MOVWF  FE9
065AC:  MOVLW  00
065AE:  ADDWFC xD7,W
065B0:  MOVWF  FEA
065B2:  CLRF   FEC
065B4:  MOVF   FED,F
065B6:  CLRF   FEF
065B8:  BRA    6362
....................       } 
065BA:  MOVLB  0
065BC:  RETURN 0
....................    } 
....................  
....................  
....................  
....................  
.................... #ifndef _FS_READONLY 
.................... static 
.................... BYTE* reserve_direntry (DIR *scan) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Reserve a Directory Entry  
.................... // 
.................... //   Entry: 
.................... //      DIR *scan         Target directory to create new entry 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD clust, sector; 
....................    BYTE c, n, *dptr; 
....................  
....................    // Re-initialize directory object  
....................    clust = scan->sclust; 
*
06BF0:  MOVLB  9
06BF2:  MOVFF  9D6,FE9
06BF6:  MOVFF  9D7,FEA
06BFA:  MOVFF  FEF,9D8
06BFE:  MOVFF  FEC,9D9
06C02:  MOVFF  FEC,9DA
06C06:  MOVFF  FEC,9DB
....................    if (clust) {   // Dyanmic directory table  
06C0A:  MOVF   xD8,F
06C0C:  BNZ   6C1A
06C0E:  MOVF   xD9,F
06C10:  BNZ   6C1A
06C12:  MOVF   xDA,F
06C14:  BNZ   6C1A
06C16:  MOVF   xDB,F
06C18:  BZ    6C7A
....................       scan->clust = clust; 
06C1A:  MOVLW  04
06C1C:  ADDWF  xD6,W
06C1E:  MOVWF  FE9
06C20:  MOVLW  00
06C22:  ADDWFC xD7,W
06C24:  MOVWF  FEA
06C26:  MOVFF  9D8,FEF
06C2A:  MOVFF  9D9,FEC
06C2E:  MOVFF  9DA,FEC
06C32:  MOVFF  9DB,FEC
....................       scan->sect = clust2sect(clust); 
06C36:  MOVLW  08
06C38:  ADDWF  xD6,W
06C3A:  MOVWF  01
06C3C:  MOVLW  00
06C3E:  ADDWFC xD7,W
06C40:  MOVWF  03
06C42:  MOVFF  01,9E4
06C46:  MOVWF  xE5
06C48:  MOVFF  9DB,9F2
06C4C:  MOVFF  9DA,9F1
06C50:  MOVFF  9D9,9F0
06C54:  MOVFF  9D8,9EF
06C58:  MOVLB  0
06C5A:  CALL   5602
06C5E:  MOVFF  9E5,FEA
06C62:  MOVFF  9E4,FE9
06C66:  MOVFF  00,FEF
06C6A:  MOVFF  01,FEC
06C6E:  MOVFF  02,FEC
06C72:  MOVFF  03,FEC
....................    } else {      // Static directory table  
06C76:  BRA    6CC4
06C78:  MOVLB  9
....................       scan->sect = fs->dirbase; 
06C7A:  MOVLW  08
06C7C:  ADDWF  xD6,W
06C7E:  MOVWF  01
06C80:  MOVLW  00
06C82:  ADDWFC xD7,W
06C84:  MOVWF  03
06C86:  MOVFF  01,9E4
06C8A:  MOVWF  xE5
06C8C:  MOVLW  14
06C8E:  MOVLB  7
06C90:  ADDWF  x12,W
06C92:  MOVWF  FE9
06C94:  MOVLW  00
06C96:  ADDWFC x13,W
06C98:  MOVWF  FEA
06C9A:  MOVFF  FEF,00
06C9E:  MOVFF  FEC,01
06CA2:  MOVFF  FEC,02
06CA6:  MOVFF  FEC,03
06CAA:  MOVFF  9E5,FEA
06CAE:  MOVFF  9E4,FE9
06CB2:  MOVFF  00,FEF
06CB6:  MOVFF  01,FEC
06CBA:  MOVFF  02,FEC
06CBE:  MOVFF  03,FEC
06CC2:  MOVLB  0
....................    } 
....................    scan->index = 0; 
06CC4:  MOVLW  0C
06CC6:  MOVLB  9
06CC8:  ADDWF  xD6,W
06CCA:  MOVWF  FE9
06CCC:  MOVLW  00
06CCE:  ADDWFC xD7,W
06CD0:  MOVWF  FEA
06CD2:  CLRF   FEC
06CD4:  MOVF   FED,F
06CD6:  CLRF   FEF
....................  
....................    do  
....................       { 
....................       if (!move_window(scan->sect))  
06CD8:  MOVLW  08
06CDA:  ADDWF  xD6,W
06CDC:  MOVWF  FE9
06CDE:  MOVLW  00
06CE0:  ADDWFC xD7,W
06CE2:  MOVWF  FEA
06CE4:  MOVFF  FEF,A14
06CE8:  MOVFF  FEC,A15
06CEC:  MOVFF  FEC,A16
06CF0:  MOVFF  FEC,A17
06CF4:  MOVLB  0
06CF6:  CALL   5A76
06CFA:  MOVF   01,F
06CFC:  BNZ   6D06
....................          return (NULL); 
06CFE:  MOVLW  00
06D00:  MOVWF  01
06D02:  MOVWF  02
06D04:  BRA    6F34
....................       dptr = &(fs->win[(scan->index & 15) * 32]);      // Pointer to the directory entry  
06D06:  MOVLW  0C
06D08:  MOVLB  9
06D0A:  ADDWF  xD6,W
06D0C:  MOVWF  FE9
06D0E:  MOVLW  00
06D10:  ADDWFC xD7,W
06D12:  MOVWF  FEA
06D14:  MOVFF  FEC,9E5
06D18:  MOVF   FED,F
06D1A:  MOVFF  FEF,9E4
06D1E:  MOVLW  0F
06D20:  ANDWF  xE4,F
06D22:  CLRF   xE5
06D24:  RLCF   xE4,F
06D26:  RLCF   xE5,F
06D28:  RLCF   xE4,F
06D2A:  RLCF   xE5,F
06D2C:  RLCF   xE4,F
06D2E:  RLCF   xE5,F
06D30:  RLCF   xE4,F
06D32:  RLCF   xE5,F
06D34:  RLCF   xE4,F
06D36:  RLCF   xE5,F
06D38:  MOVLW  E0
06D3A:  ANDWF  xE4,F
06D3C:  MOVLW  24
06D3E:  ADDWF  xE4,W
06D40:  MOVWF  01
06D42:  MOVLW  00
06D44:  ADDWFC xE5,W
06D46:  MOVWF  03
06D48:  MOVF   01,W
06D4A:  MOVLB  7
06D4C:  ADDWF  x12,W
06D4E:  MOVWF  01
06D50:  MOVF   x13,W
06D52:  ADDWFC 03,F
06D54:  MOVFF  01,9E2
06D58:  MOVLB  9
06D5A:  MOVFF  03,9E3
....................       c = *dptr; 
06D5E:  MOVFF  9E2,FE9
06D62:  MOVFF  9E3,FEA
06D66:  MOVFF  FEF,9E0
....................       if ((c == 0) || (c == 0xE5))  
06D6A:  MOVF   xE0,F
06D6C:  BZ    6D74
06D6E:  MOVF   xE0,W
06D70:  SUBLW  E5
06D72:  BNZ   6D82
....................          return (dptr);      // Found an empty entry!  
06D74:  MOVFF  9E2,01
06D78:  MOVFF  9E3,02
06D7C:  MOVLB  0
06D7E:  BRA    6F34
06D80:  MOVLB  9
....................    } while (next_dir_ptr(scan));                  // Next directory pointer  
06D82:  MOVFF  9D7,9E6
06D86:  MOVFF  9D6,9E5
06D8A:  MOVLB  0
06D8C:  CALL   5FFC
06D90:  MOVF   01,F
06D92:  BTFSC  FD8.2
06D94:  BRA    6D9A
06D96:  MOVLB  9
06D98:  BRA    6CD8
....................    // Reached to end of the directory table  
....................  
....................    // Abort when static table or could not stretch dynamic table  
....................    if (!clust)  
06D9A:  MOVLB  9
06D9C:  MOVF   xD8,F
06D9E:  BNZ   6DB8
06DA0:  MOVF   xD9,F
06DA2:  BNZ   6DB8
06DA4:  MOVF   xDA,F
06DA6:  BNZ   6DB8
06DA8:  MOVF   xDB,F
06DAA:  BNZ   6DB8
....................        return (NULL); 
06DAC:  MOVLW  00
06DAE:  MOVWF  01
06DB0:  MOVWF  02
06DB2:  MOVLB  0
06DB4:  BRA    6F34
06DB6:  MOVLB  9
....................  
....................    clust = create_chain(scan->clust); 
06DB8:  MOVLW  04
06DBA:  ADDWF  xD6,W
06DBC:  MOVWF  FE9
06DBE:  MOVLW  00
06DC0:  ADDWFC xD7,W
06DC2:  MOVWF  FEA
06DC4:  MOVFF  FEF,9E8
06DC8:  MOVFF  FEC,9E9
06DCC:  MOVFF  FEC,9EA
06DD0:  MOVFF  FEC,9EB
06DD4:  MOVLB  0
06DD6:  RCALL  6958
06DD8:  MOVFF  03,9DB
06DDC:  MOVFF  02,9DA
06DE0:  MOVFF  01,9D9
06DE4:  MOVFF  00,9D8
....................    if (!(clust))  
06DE8:  MOVLB  9
06DEA:  MOVF   xD8,F
06DEC:  BNZ   6E06
06DEE:  MOVF   xD9,F
06DF0:  BNZ   6E06
06DF2:  MOVF   xDA,F
06DF4:  BNZ   6E06
06DF6:  MOVF   xDB,F
06DF8:  BNZ   6E06
....................       return (NULL); 
06DFA:  MOVLW  00
06DFC:  MOVWF  01
06DFE:  MOVWF  02
06E00:  MOVLB  0
06E02:  BRA    6F34
06E04:  MOVLB  9
....................  
....................    // flush the contents of the current FATFS Window 
....................    if (!move_window(0))  
06E06:  MOVLB  A
06E08:  CLRF   x17
06E0A:  CLRF   x16
06E0C:  CLRF   x15
06E0E:  CLRF   x14
06E10:  MOVLB  0
06E12:  CALL   5A76
06E16:  MOVF   01,F
06E18:  BNZ   6E22
....................       return (0); 
06E1A:  MOVLW  00
06E1C:  MOVWF  01
06E1E:  MOVWF  02
06E20:  BRA    6F34
....................  
....................    // point to the first sector of the target cluster 
....................    fs->winsect = sector = clust2sect(clust);         // Cleanup the expanded table  
06E22:  MOVLW  20
06E24:  MOVLB  7
06E26:  ADDWF  x12,W
06E28:  MOVWF  01
06E2A:  MOVLW  00
06E2C:  ADDWFC x13,W
06E2E:  MOVWF  03
06E30:  MOVFF  01,9E4
06E34:  MOVLB  9
06E36:  MOVWF  xE5
06E38:  MOVFF  9DB,9F2
06E3C:  MOVFF  9DA,9F1
06E40:  MOVFF  9D9,9F0
06E44:  MOVFF  9D8,9EF
06E48:  MOVLB  0
06E4A:  CALL   5602
06E4E:  MOVFF  03,9DF
06E52:  MOVFF  02,9DE
06E56:  MOVFF  01,9DD
06E5A:  MOVFF  00,9DC
06E5E:  MOVFF  9E5,FEA
06E62:  MOVFF  9E4,FE9
06E66:  MOVFF  9DC,FEF
06E6A:  MOVFF  9DD,FEC
06E6E:  MOVFF  9DE,FEC
06E72:  MOVFF  9DF,FEC
....................  
....................    // flush the contents of the FATFS window 
....................    memset(fs->win, 0, 512); 
06E76:  MOVLW  24
06E78:  MOVLB  7
06E7A:  ADDWF  x12,W
06E7C:  MOVWF  01
06E7E:  MOVLW  00
06E80:  ADDWFC x13,W
06E82:  MOVWF  03
06E84:  MOVFF  01,9E4
06E88:  MOVLB  9
06E8A:  MOVWF  xE5
06E8C:  MOVWF  FEA
06E8E:  MOVFF  01,FE9
06E92:  CLRF   00
06E94:  MOVLW  02
06E96:  MOVWF  02
06E98:  CLRF   01
06E9A:  MOVLB  0
06E9C:  CALL   351A
....................  
....................    // flush the contents of all sectors in the cluster 
....................    for (n = fs->sects_clust; n; n--)  
06EA0:  MOVLW  02
06EA2:  MOVLB  7
06EA4:  ADDWF  x12,W
06EA6:  MOVWF  FE9
06EA8:  MOVLW  00
06EAA:  ADDWFC x13,W
06EAC:  MOVWF  FEA
06EAE:  MOVFF  FEF,9E1
06EB2:  MOVLB  9
06EB4:  MOVF   xE1,F
06EB6:  BZ    6F14
....................       { 
....................       if (disk_write(fs->win, sector, 1) != RES_OK)  
06EB8:  MOVLW  24
06EBA:  MOVLB  7
06EBC:  ADDWF  x12,W
06EBE:  MOVWF  01
06EC0:  MOVLW  00
06EC2:  ADDWFC x13,W
06EC4:  MOVWF  03
06EC6:  MOVFF  01,9E4
06ECA:  MOVLB  9
06ECC:  MOVWF  xE5
06ECE:  MOVFF  FE8,A21
06ED2:  MOVFF  01,A20
06ED6:  MOVFF  9DF,A25
06EDA:  MOVFF  9DE,A24
06EDE:  MOVFF  9DD,A23
06EE2:  MOVFF  9DC,A22
06EE6:  MOVLW  01
06EE8:  MOVLB  A
06EEA:  MOVWF  x26
06EEC:  MOVLB  0
06EEE:  CALL   5932
06EF2:  MOVF   01,F
06EF4:  BZ    6EFE
....................          return (NULL); 
06EF6:  MOVLW  00
06EF8:  MOVWF  01
06EFA:  MOVWF  02
06EFC:  BRA    6F34
....................       sector++; 
06EFE:  MOVLW  01
06F00:  MOVLB  9
06F02:  ADDWF  xDC,F
06F04:  BTFSC  FD8.0
06F06:  INCF   xDD,F
06F08:  BTFSC  FD8.2
06F0A:  INCF   xDE,F
06F0C:  BTFSC  FD8.2
06F0E:  INCF   xDF,F
06F10:  DECF   xE1,F
06F12:  BRA    6EB4
....................       } 
....................  
....................    // flag the FATFS window as dirty 
....................    // probably should flush it instead 
....................    fs->winflag = 1; 
06F14:  MOVLW  06
06F16:  MOVLB  7
06F18:  ADDWF  x12,W
06F1A:  MOVWF  FE9
06F1C:  MOVLW  00
06F1E:  ADDWFC x13,W
06F20:  MOVWF  FEA
06F22:  MOVLW  01
06F24:  MOVWF  FEF
....................    return (fs->win); 
06F26:  MOVLW  24
06F28:  ADDWF  x12,W
06F2A:  MOVWF  01
06F2C:  MOVLW  00
06F2E:  ADDWFC x13,W
06F30:  MOVWF  03
06F32:  MOVWF  02
06F34:  MOVLB  0
06F36:  GOTO   71CE (RETURN)
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
....................  
.................... FRESULT check_mounted (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Checks to ensure that the file system is mounted. The disk status is 
.................... //   tested to determine if it is in the initialised state. If the disk is 
.................... //   not in the initialised state the file system is checked to ensure 
.................... //   there are no open files. Open files with a drive state of 
.................... //   uninitialised is a fatal error indicating possible media change. 
.................... // 
.................... //   If the drive is not mounted and there are no apparent open files the 
.................... //   drive will be mounted (initialized). 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    if (!fs)  
*
055A0:  MOVLB  7
055A2:  MOVF   x12,W
055A4:  IORWF  x13,W
055A6:  BNZ   55AE
....................       return (FR_NOT_ENABLED);      // Has the FileSystem been enabled?  
055A8:  MOVLW  0B
055AA:  MOVWF  01
055AC:  BRA    55FE
....................  
....................    if (disk_status() & STA_NOINIT)  
055AE:  MOVLB  0
055B0:  RCALL  5592
055B2:  BTFSS  01.0
055B4:  BRA    55E0
....................       {   // The drive has not been initialized  
....................       if (fs->files)               // Drive was uninitialized with any file left opend  
055B6:  MOVLW  01
055B8:  MOVLB  7
055BA:  ADDWF  x12,W
055BC:  MOVWF  FE9
055BE:  MOVLW  00
055C0:  ADDWFC x13,W
055C2:  MOVWF  FEA
055C4:  MOVF   FEF,F
055C6:  BZ    55D0
....................          return (FR_INCORRECT_DISK_CHANGE); 
055C8:  MOVLW  09
055CA:  MOVWF  01
055CC:  BRA    55FE
055CE:  BRA    55DC
....................       else 
....................          return (f_mountdrv());      // Initialize file system and return result   
055D0:  MOVLB  0
055D2:  CALL   484A
055D6:  MOVF   01,W
055D8:  MOVLB  7
055DA:  BRA    55FE
....................       }  
055DC:  BRA    55FA
055DE:  MOVLB  0
....................    else  
....................       {                        // The drive has been initialized  
....................       if (!fs->fs_type)            // But the file system has not been initialized  
055E0:  MOVLB  7
055E2:  MOVFF  712,FE9
055E6:  MOVFF  713,FEA
055EA:  MOVF   FEF,F
055EC:  BNZ   55FA
....................          return (f_mountdrv());      // Initialize file system and return resulut  
055EE:  MOVLB  0
055F0:  CALL   484A
055F4:  MOVF   01,W
055F6:  MOVLB  7
055F8:  BRA    55FE
....................       } 
....................    return FR_OK;                  // File system is valid  
055FA:  MOVLW  00
055FC:  MOVWF  01
055FE:  MOVLB  0
05600:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //         ********   Module Public Functions    ******** 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
.................... void f_init(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialize the File System FAT Data Structure  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    // initialize the File System Data Structure 
.................... //   fs = &FileSystem; 
....................     memset(fs, 0, sizeof(FATFS)); 
....................    } 
.................... */ 
....................  
.................... void f_get_error_mesg(FRESULT Mesg, char *destination) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns string representation of File function return code  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    switch (Mesg) 
*
0B96A:  MOVLB  8
0B96C:  MOVF   xCC,W
0B96E:  XORLW  00
0B970:  MOVLB  0
0B972:  BZ    B9AC
0B974:  XORLW  04
0B976:  BZ    B9C8
0B978:  XORLW  05
0B97A:  BZ    B9E4
0B97C:  XORLW  03
0B97E:  BZ    BA00
0B980:  XORLW  01
0B982:  BZ    BA1C
0B984:  XORLW  06
0B986:  BZ    BA38
0B988:  XORLW  03
0B98A:  BZ    BA54
0B98C:  XORLW  01
0B98E:  BTFSC  FD8.2
0B990:  BRA    BA70
0B992:  XORLW  0E
0B994:  BTFSC  FD8.2
0B996:  BRA    BA8C
0B998:  XORLW  03
0B99A:  BTFSC  FD8.2
0B99C:  BRA    BAA8
0B99E:  XORLW  01
0B9A0:  BTFSC  FD8.2
0B9A2:  BRA    BAC4
0B9A4:  XORLW  07
0B9A6:  BTFSC  FD8.2
0B9A8:  BRA    BAE0
0B9AA:  BRA    BAFC
....................       { 
....................       case FR_OK : 
....................          strcpy(destination, "No Error"); 
0B9AC:  MOVFF  8CE,FEA
0B9B0:  MOVFF  8CD,FE9
0B9B4:  MOVLW  00
0B9B6:  CALL   0106
0B9BA:  TBLRD*-
0B9BC:  TBLRD*+
0B9BE:  MOVF   FF5,W
0B9C0:  MOVWF  FEE
0B9C2:  IORLW  00
0B9C4:  BNZ   B9BC
....................          break; 
0B9C6:  BRA    BB16
....................  
....................       case FR_INVALID_NAME : 
....................          strcpy(destination, "ILLEGAL FILE NAME"); 
0B9C8:  MOVFF  8CE,FEA
0B9CC:  MOVFF  8CD,FE9
0B9D0:  MOVLW  00
0B9D2:  CALL   0124
0B9D6:  TBLRD*-
0B9D8:  TBLRD*+
0B9DA:  MOVF   FF5,W
0B9DC:  MOVWF  FEE
0B9DE:  IORLW  00
0B9E0:  BNZ   B9D8
....................          break; 
0B9E2:  BRA    BB16
....................  
....................       case FR_NOT_READY : 
....................          strcpy(destination, "MEDIA NOT READY"); 
0B9E4:  MOVFF  8CE,FEA
0B9E8:  MOVFF  8CD,FE9
0B9EC:  MOVLW  00
0B9EE:  CALL   014A
0B9F2:  TBLRD*-
0B9F4:  TBLRD*+
0B9F6:  MOVF   FF5,W
0B9F8:  MOVWF  FEE
0B9FA:  IORLW  00
0B9FC:  BNZ   B9F4
....................          break; 
0B9FE:  BRA    BB16
....................  
....................       case FR_NO_FILE : 
....................          strcpy(destination, "FILE NOT FOUND"); 
0BA00:  MOVFF  8CE,FEA
0BA04:  MOVFF  8CD,FE9
0BA08:  MOVLW  00
0BA0A:  CALL   016E
0BA0E:  TBLRD*-
0BA10:  TBLRD*+
0BA12:  MOVF   FF5,W
0BA14:  MOVWF  FEE
0BA16:  IORLW  00
0BA18:  BNZ   BA10
....................          break; 
0BA1A:  BRA    BB16
....................  
....................       case FR_NO_PATH : 
....................          strcpy(destination, "PATH NOT FOUND"); 
0BA1C:  MOVFF  8CE,FEA
0BA20:  MOVFF  8CD,FE9
0BA24:  MOVLW  00
0BA26:  CALL   0192
0BA2A:  TBLRD*-
0BA2C:  TBLRD*+
0BA2E:  MOVF   FF5,W
0BA30:  MOVWF  FEE
0BA32:  IORLW  00
0BA34:  BNZ   BA2C
....................          break; 
0BA36:  BRA    BB16
....................  
....................       case FR_DENIED : 
....................          strcpy(destination, "ACCESS DENIED"); 
0BA38:  MOVFF  8CE,FEA
0BA3C:  MOVFF  8CD,FE9
0BA40:  MOVLW  00
0BA42:  CALL   01B6
0BA46:  TBLRD*-
0BA48:  TBLRD*+
0BA4A:  MOVF   FF5,W
0BA4C:  MOVWF  FEE
0BA4E:  IORLW  00
0BA50:  BNZ   BA48
....................          break; 
0BA52:  BRA    BB16
....................  
....................       case FR_DISK_FULL :  
....................          strcpy(destination, "MEDIA FULL"); 
0BA54:  MOVFF  8CE,FEA
0BA58:  MOVFF  8CD,FE9
0BA5C:  MOVLW  00
0BA5E:  CALL   01D8
0BA62:  TBLRD*-
0BA64:  TBLRD*+
0BA66:  MOVF   FF5,W
0BA68:  MOVWF  FEE
0BA6A:  IORLW  00
0BA6C:  BNZ   BA64
....................          break; 
0BA6E:  BRA    BB16
....................  
....................       case FR_RW_ERROR : 
....................          strcpy(destination, "R/W ERROR"); 
0BA70:  MOVFF  8CE,FEA
0BA74:  MOVFF  8CD,FE9
0BA78:  MOVLW  00
0BA7A:  CALL   01F8
0BA7E:  TBLRD*-
0BA80:  TBLRD*+
0BA82:  MOVF   FF5,W
0BA84:  MOVWF  FEE
0BA86:  IORLW  00
0BA88:  BNZ   BA80
....................          break; 
0BA8A:  BRA    BB16
....................  
....................       case FR_INCORRECT_DISK_CHANGE : 
....................          strcpy(destination, "INCORRECT MEDIA CHANGE"); 
0BA8C:  MOVFF  8CE,FEA
0BA90:  MOVFF  8CD,FE9
0BA94:  MOVLW  00
0BA96:  CALL   0216
0BA9A:  TBLRD*-
0BA9C:  TBLRD*+
0BA9E:  MOVF   FF5,W
0BAA0:  MOVWF  FEE
0BAA2:  IORLW  00
0BAA4:  BNZ   BA9C
....................          break; 
0BAA6:  BRA    BB16
....................  
....................       case FR_WRITE_PROTECTED :  
....................          strcpy(destination, "WRITE PROTECTED"); 
0BAA8:  MOVFF  8CE,FEA
0BAAC:  MOVFF  8CD,FE9
0BAB0:  MOVLW  00
0BAB2:  CALL   0242
0BAB6:  TBLRD*-
0BAB8:  TBLRD*+
0BABA:  MOVF   FF5,W
0BABC:  MOVWF  FEE
0BABE:  IORLW  00
0BAC0:  BNZ   BAB8
....................          break; 
0BAC2:  BRA    BB16
....................  
....................       case FR_NOT_ENABLED : 
....................          strcpy(destination, "FS NOT ENABLED"); 
0BAC4:  MOVFF  8CE,FEA
0BAC8:  MOVFF  8CD,FE9
0BACC:  MOVLW  00
0BACE:  CALL   0266
0BAD2:  TBLRD*-
0BAD4:  TBLRD*+
0BAD6:  MOVF   FF5,W
0BAD8:  MOVWF  FEE
0BADA:  IORLW  00
0BADC:  BNZ   BAD4
....................          break; 
0BADE:  BRA    BB16
....................  
....................       case FR_NO_FILESYSTEM : 
....................          strcpy(destination, "NO FILESYSTEM"); 
0BAE0:  MOVFF  8CE,FEA
0BAE4:  MOVFF  8CD,FE9
0BAE8:  MOVLW  00
0BAEA:  CALL   028A
0BAEE:  TBLRD*-
0BAF0:  TBLRD*+
0BAF2:  MOVF   FF5,W
0BAF4:  MOVWF  FEE
0BAF6:  IORLW  00
0BAF8:  BNZ   BAF0
....................          break; 
0BAFA:  BRA    BB16
....................  
....................       default :  
....................          strcpy(destination, "UNKNOWN ERROR"); 
0BAFC:  MOVFF  8CE,FEA
0BB00:  MOVFF  8CD,FE9
0BB04:  MOVLW  00
0BB06:  CALL   02AC
0BB0A:  TBLRD*-
0BB0C:  TBLRD*+
0BB0E:  MOVF   FF5,W
0BB10:  MOVWF  FEE
0BB12:  IORLW  00
0BB14:  BNZ   BB0C
....................       } 
0BB16:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_mountdrv(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Initialise the SPI bus to the SD/MMC card 
.................... //   Initialise the SD/MMC card 
.................... //   Initialize file system data structure 
.................... //   Load File System Information 
.................... // 
.................... //   Entry 
.................... //      Card_CS      don't care      SD Card Chip Select condition 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... ///////////////////////////////////////////////////////////////////////////  
....................  
....................    { 
....................    BYTE fat; 
....................    DWORD sect, fatend, maxsect; 
....................  
....................    if (!fs)  
*
0484A:  MOVLB  7
0484C:  MOVF   x12,W
0484E:  IORWF  x13,W
04850:  BNZ   4858
....................       return (FR_NOT_ENABLED); 
04852:  MOVLW  0B
04854:  MOVWF  01
04856:  BRA    4DE4
....................  
....................    // Initialize file system object (data structure)  
....................    f_init(); 
04858:  MOVFF  713,FEA
0485C:  MOVFF  712,FE9
04860:  CLRF   00
04862:  MOVLW  02
04864:  MOVWF  02
04866:  MOVLW  24
04868:  MOVWF  01
0486A:  MOVLB  0
0486C:  CALL   351A
....................  
....................    // Initialize disk drive  
....................    Media_Status = disk_initialize(); 
04870:  CALL   366A
04874:  MOVFF  01,4ED
....................    if (Media_Status & STA_NOINIT) {             // work-around to re-initialize  
04878:  MOVLB  4
0487A:  BTFSS  xED.0
0487C:  BRA    488A
....................       Media_Status = disk_initialize();         // if 1st attepmt fails 
0487E:  MOVLB  0
04880:  CALL   366A
04884:  MOVFF  01,4ED
04888:  MOVLB  4
....................    } 
....................    if (Media_Status & STA_NOINIT) return (FR_NOT_READY); 
0488A:  BTFSS  xED.0
0488C:  BRA    4898
0488E:  MOVLW  01
04890:  MOVWF  01
04892:  MOVLB  7
04894:  BRA    4DE4
04896:  MOVLB  4
....................  
....................    // Search FAT partition  
....................    // Get Master Boot Record 
....................    fat = check_fs(sect = 0);      // Check sector 0 as an SFD format  
04898:  MOVLB  9
0489A:  CLRF   xDA
0489C:  CLRF   xD9
0489E:  CLRF   xD8
048A0:  CLRF   xD7
048A2:  MOVFF  9DA,9E6
048A6:  MOVFF  9D9,9E5
048AA:  MOVFF  9D8,9E4
048AE:  MOVFF  9D7,9E3
048B2:  MOVLB  0
048B4:  RCALL  4684
048B6:  MOVFF  01,9D6
....................    if (!fat)  
048BA:  MOVLB  9
048BC:  MOVF   xD6,F
048BE:  BNZ   492E
....................       {   
....................       // Not a FAT boot record, it will be an FDISK format 
....................       // Check a partition listed in top of the partition table 
....................       if (fs->win[0x1C2])  
048C0:  MOVLW  E6
048C2:  MOVLB  7
048C4:  ADDWF  x12,W
048C6:  MOVWF  FE9
048C8:  MOVLW  01
048CA:  ADDWFC x13,W
048CC:  MOVWF  FEA
048CE:  MOVF   FEF,F
048D0:  BZ    490E
....................          { 
....................          // Is the partition existing? 
....................          sect = LD_DWORD(&(fs->win[0x1C6]));   // Partition offset in LBA  
048D2:  MOVLW  EA
048D4:  ADDWF  x12,W
048D6:  MOVWF  01
048D8:  MOVLW  01
048DA:  ADDWFC x13,W
048DC:  MOVFF  01,FE9
048E0:  MOVWF  FEA
048E2:  MOVFF  FEF,9D7
048E6:  MOVFF  FEC,9D8
048EA:  MOVFF  FEC,9D9
048EE:  MOVFF  FEC,9DA
....................          fat = check_fs(sect);            // Check the partition  
048F2:  MOVFF  9DA,9E6
048F6:  MOVFF  9D9,9E5
048FA:  MOVFF  9D8,9E4
048FE:  MOVFF  9D7,9E3
04902:  MOVLB  0
04904:  RCALL  4684
04906:  MOVFF  01,9D6
....................          } 
0490A:  BRA    492C
0490C:  MOVLB  7
....................       else 
....................          printf("FAT at sector 0\r\n"); 
0490E:  MOVLW  04
04910:  MOVWF  FF6
04912:  MOVLW  0C
04914:  MOVWF  FF7
04916:  MOVLW  00
04918:  MOVWF  FF8
0491A:  CLRF   1B
0491C:  BTFSC  FF2.7
0491E:  BSF    1B.7
04920:  BCF    FF2.7
04922:  MOVLB  0
04924:  CALL   0E42
04928:  BTFSC  1B.7
0492A:  BSF    FF2.7
0492C:  MOVLB  9
....................       } 
....................    if (!fat)  
0492E:  MOVF   xD6,F
04930:  BNZ   493C
....................       return (FR_NO_FILESYSTEM);   // No FAT patition  
04932:  MOVLW  0C
04934:  MOVWF  01
04936:  MOVLB  7
04938:  BRA    4DE4
0493A:  MOVLB  9
....................  
....................    // Initialize file system object  
....................    fs->fs_type = fat;                        // FAT type  
0493C:  MOVLB  7
0493E:  MOVFF  712,FE9
04942:  MOVFF  713,FEA
04946:  MOVFF  9D6,FEF
....................  
....................    // get the number of sectors per FAT 
....................    if (fat == FS_FAT32) 
0494A:  MOVLB  9
0494C:  MOVF   xD6,W
0494E:  SUBLW  03
04950:  BNZ   49B6
....................       fs->sects_fat = LD_DWORD(&(fs->win[0x24])); 
04952:  MOVLW  08
04954:  MOVLB  7
04956:  ADDWF  x12,W
04958:  MOVWF  01
0495A:  MOVLW  00
0495C:  ADDWFC x13,W
0495E:  MOVWF  03
04960:  MOVFF  01,9E3
04964:  MOVLB  9
04966:  MOVWF  xE4
04968:  MOVLW  48
0496A:  MOVLB  7
0496C:  ADDWF  x12,W
0496E:  MOVWF  01
04970:  MOVLW  00
04972:  ADDWFC x13,W
04974:  MOVFF  01,FE9
04978:  MOVWF  FEA
0497A:  MOVFF  FEF,00
0497E:  MOVFF  FEC,01
04982:  MOVFF  FEC,02
04986:  MOVFF  FEC,03
0498A:  MOVFF  03,9E8
0498E:  MOVFF  02,9E7
04992:  MOVFF  01,9E6
04996:  MOVFF  00,9E5
0499A:  MOVFF  9E4,FEA
0499E:  MOVFF  9E3,FE9
049A2:  MOVFF  00,FEF
049A6:  MOVFF  01,FEC
049AA:  MOVFF  02,FEC
049AE:  MOVFF  03,FEC
049B2:  BRA    4A0E
049B4:  MOVLB  9
....................    else 
....................       fs->sects_fat = LD_WORD(&(fs->win[0x16])); 
049B6:  MOVLW  08
049B8:  MOVLB  7
049BA:  ADDWF  x12,W
049BC:  MOVWF  01
049BE:  MOVLW  00
049C0:  ADDWFC x13,W
049C2:  MOVWF  03
049C4:  MOVFF  01,9E3
049C8:  MOVLB  9
049CA:  MOVWF  xE4
049CC:  MOVLW  3A
049CE:  MOVLB  7
049D0:  ADDWF  x12,W
049D2:  MOVWF  01
049D4:  MOVLW  00
049D6:  ADDWFC x13,W
049D8:  MOVFF  01,FE9
049DC:  MOVWF  FEA
049DE:  MOVFF  FEC,03
049E2:  MOVF   FED,F
049E4:  MOVFF  FEF,9E5
049E8:  MOVLB  9
049EA:  MOVFF  03,9E6
049EE:  MOVFF  9E4,FEA
049F2:  MOVFF  9E3,FE9
049F6:  MOVF   FEE,F
049F8:  MOVF   FEE,F
049FA:  CLRF   FEC
049FC:  MOVF   FED,F
049FE:  CLRF   FEF
04A00:  MOVF   FED,F
04A02:  MOVFF  03,FEF
04A06:  MOVF   FED,F
04A08:  MOVFF  9E5,FEF
04A0C:  MOVLB  7
....................  
....................    fs->sects_clust = fs->win[0x0D];            // Sectors per cluster  
04A0E:  MOVLW  02
04A10:  ADDWF  x12,W
04A12:  MOVWF  01
04A14:  MOVLW  00
04A16:  ADDWFC x13,W
04A18:  MOVWF  03
04A1A:  MOVLW  31
04A1C:  MOVLB  7
04A1E:  ADDWF  x12,W
04A20:  MOVWF  FE9
04A22:  MOVLW  00
04A24:  ADDWFC x13,W
04A26:  MOVWF  FEA
04A28:  MOVFF  FEF,9E5
04A2C:  MOVLB  9
04A2E:  MOVFF  03,FEA
04A32:  MOVFF  01,FE9
04A36:  MOVFF  9E5,FEF
....................    fs->n_fats = fs->win[0x10];                  // Number of FAT copies  
04A3A:  MOVLW  03
04A3C:  MOVLB  7
04A3E:  ADDWF  x12,W
04A40:  MOVWF  01
04A42:  MOVLW  00
04A44:  ADDWFC x13,W
04A46:  MOVWF  03
04A48:  MOVLW  34
04A4A:  MOVLB  7
04A4C:  ADDWF  x12,W
04A4E:  MOVWF  FE9
04A50:  MOVLW  00
04A52:  ADDWFC x13,W
04A54:  MOVWF  FEA
04A56:  MOVFF  FEF,9E5
04A5A:  MOVLB  9
04A5C:  MOVFF  03,FEA
04A60:  MOVFF  01,FE9
04A64:  MOVFF  9E5,FEF
....................    fs->fatbase = sect + LD_WORD(&(fs->win[0x0E]));   // FAT start sector (physical)  
04A68:  MOVLW  10
04A6A:  MOVLB  7
04A6C:  ADDWF  x12,W
04A6E:  MOVWF  01
04A70:  MOVLW  00
04A72:  ADDWFC x13,W
04A74:  MOVWF  03
04A76:  MOVFF  01,9E3
04A7A:  MOVLB  9
04A7C:  MOVWF  xE4
04A7E:  MOVLW  32
04A80:  MOVLB  7
04A82:  ADDWF  x12,W
04A84:  MOVWF  01
04A86:  MOVLW  00
04A88:  ADDWFC x13,W
04A8A:  MOVFF  01,FE9
04A8E:  MOVWF  FEA
04A90:  MOVFF  FEC,03
04A94:  MOVF   FED,F
04A96:  MOVF   FEF,W
04A98:  MOVLB  9
04A9A:  ADDWF  xD7,W
04A9C:  MOVWF  00
04A9E:  MOVF   03,W
04AA0:  ADDWFC xD8,W
04AA2:  MOVWF  01
04AA4:  MOVLW  00
04AA6:  ADDWFC xD9,W
04AA8:  MOVWF  02
04AAA:  MOVLW  00
04AAC:  ADDWFC xDA,W
04AAE:  MOVFF  9E4,FEA
04AB2:  MOVFF  9E3,FE9
04AB6:  MOVFF  00,FEF
04ABA:  MOVFF  01,FEC
04ABE:  MOVFF  02,FEC
04AC2:  MOVWF  FEC
....................    fs->n_rootdir = LD_WORD(&(fs->win[0x11]));      // Number of root directory entries  
04AC4:  MOVLW  04
04AC6:  MOVLB  7
04AC8:  ADDWF  x12,W
04ACA:  MOVWF  01
04ACC:  MOVLW  00
04ACE:  ADDWFC x13,W
04AD0:  MOVWF  03
04AD2:  MOVFF  01,9E3
04AD6:  MOVLB  9
04AD8:  MOVWF  xE4
04ADA:  MOVLW  35
04ADC:  MOVLB  7
04ADE:  ADDWF  x12,W
04AE0:  MOVWF  01
04AE2:  MOVLW  00
04AE4:  ADDWFC x13,W
04AE6:  MOVFF  01,FE9
04AEA:  MOVWF  FEA
04AEC:  MOVFF  FEC,03
04AF0:  MOVF   FED,F
04AF2:  MOVFF  FEF,9E5
04AF6:  MOVLB  9
04AF8:  MOVFF  9E4,FEA
04AFC:  MOVFF  9E3,FE9
04B00:  MOVFF  03,FEC
04B04:  MOVF   FED,F
04B06:  MOVFF  9E5,FEF
....................  
....................    fatend = fs->sects_fat * fs->n_fats + fs->fatbase; 
04B0A:  MOVLW  08
04B0C:  MOVLB  7
04B0E:  ADDWF  x12,W
04B10:  MOVWF  FE9
04B12:  MOVLW  00
04B14:  ADDWFC x13,W
04B16:  MOVWF  FEA
04B18:  MOVFF  FEF,9F6
04B1C:  MOVFF  FEC,9F7
04B20:  MOVFF  FEC,9F8
04B24:  MOVFF  FEC,9F9
04B28:  MOVLW  03
04B2A:  ADDWF  x12,W
04B2C:  MOVWF  FE9
04B2E:  MOVLW  00
04B30:  ADDWFC x13,W
04B32:  MOVWF  FEA
04B34:  MOVFF  FEF,9FA
04B38:  MOVLB  9
04B3A:  MOVFF  FEA,9E9
04B3E:  MOVFF  FE9,9E8
04B42:  CLRF   xFD
04B44:  CLRF   xFC
04B46:  CLRF   xFB
04B48:  MOVLB  0
04B4A:  RCALL  47E4
04B4C:  MOVFF  9E9,FEA
04B50:  MOVFF  9E8,FE9
04B54:  MOVFF  03,9E6
04B58:  MOVFF  02,9E5
04B5C:  MOVFF  01,9E4
04B60:  MOVFF  00,9E3
04B64:  MOVLW  10
04B66:  MOVLB  7
04B68:  ADDWF  x12,W
04B6A:  MOVWF  FE9
04B6C:  MOVLW  00
04B6E:  ADDWFC x13,W
04B70:  MOVWF  FEA
04B72:  MOVFF  FEF,00
04B76:  MOVFF  FEC,01
04B7A:  MOVFF  FEC,02
04B7E:  MOVFF  FEC,03
04B82:  MOVF   00,W
04B84:  MOVLB  9
04B86:  ADDWF  xE3,W
04B88:  MOVWF  xDB
04B8A:  MOVF   01,W
04B8C:  ADDWFC xE4,W
04B8E:  MOVWF  xDC
04B90:  MOVF   02,W
04B92:  ADDWFC xE5,W
04B94:  MOVWF  xDD
04B96:  MOVF   03,W
04B98:  ADDWFC xE6,W
04B9A:  MOVWF  xDE
....................  
....................    // find the directory starting cluster 
....................    if (fat == FS_FAT32)  
04B9C:  MOVF   xD6,W
04B9E:  SUBLW  03
04BA0:  BNZ   4C12
....................       { 
....................       fs->dirbase = LD_DWORD(&(fs->win[0x2C]));   // FAT32: Directory start cluster  
04BA2:  MOVLW  14
04BA4:  MOVLB  7
04BA6:  ADDWF  x12,W
04BA8:  MOVWF  01
04BAA:  MOVLW  00
04BAC:  ADDWFC x13,W
04BAE:  MOVWF  03
04BB0:  MOVFF  01,9E3
04BB4:  MOVLB  9
04BB6:  MOVWF  xE4
04BB8:  MOVLW  50
04BBA:  MOVLB  7
04BBC:  ADDWF  x12,W
04BBE:  MOVWF  01
04BC0:  MOVLW  00
04BC2:  ADDWFC x13,W
04BC4:  MOVFF  01,FE9
04BC8:  MOVWF  FEA
04BCA:  MOVFF  FEF,00
04BCE:  MOVFF  FEC,01
04BD2:  MOVFF  FEC,02
04BD6:  MOVFF  FEC,03
04BDA:  MOVFF  9E4,FEA
04BDE:  MOVFF  9E3,FE9
04BE2:  MOVFF  00,FEF
04BE6:  MOVFF  01,FEC
04BEA:  MOVFF  02,FEC
04BEE:  MOVFF  03,FEC
....................       fs->database = fatend;                   // FAT32: Data start sector (physical)  
04BF2:  MOVLW  18
04BF4:  ADDWF  x12,W
04BF6:  MOVWF  FE9
04BF8:  MOVLW  00
04BFA:  ADDWFC x13,W
04BFC:  MOVWF  FEA
04BFE:  MOVFF  9DB,FEF
04C02:  MOVFF  9DC,FEC
04C06:  MOVFF  9DD,FEC
04C0A:  MOVFF  9DE,FEC
....................       }  
04C0E:  BRA    4C9E
04C10:  MOVLB  9
....................    else  
....................       { 
....................       fs->dirbase = fatend;                  // Directory start sector (physical)  
04C12:  MOVLW  14
04C14:  MOVLB  7
04C16:  ADDWF  x12,W
04C18:  MOVWF  FE9
04C1A:  MOVLW  00
04C1C:  ADDWFC x13,W
04C1E:  MOVWF  FEA
04C20:  MOVFF  9DB,FEF
04C24:  MOVFF  9DC,FEC
04C28:  MOVFF  9DD,FEC
04C2C:  MOVFF  9DE,FEC
....................       fs->database = fs->n_rootdir / 16 + fatend;   // Data start sector (physical)  
04C30:  MOVLW  18
04C32:  ADDWF  x12,W
04C34:  MOVWF  01
04C36:  MOVLW  00
04C38:  ADDWFC x13,W
04C3A:  MOVFF  01,9E3
04C3E:  MOVLB  9
04C40:  MOVWF  xE4
04C42:  MOVLW  04
04C44:  MOVLB  7
04C46:  ADDWF  x12,W
04C48:  MOVWF  FE9
04C4A:  MOVLW  00
04C4C:  ADDWFC x13,W
04C4E:  MOVWF  FEA
04C50:  MOVFF  FEC,9E6
04C54:  MOVF   FED,F
04C56:  MOVFF  FEF,9E5
04C5A:  MOVLB  9
04C5C:  RRCF   xE6,F
04C5E:  RRCF   xE5,F
04C60:  RRCF   xE6,F
04C62:  RRCF   xE5,F
04C64:  RRCF   xE6,F
04C66:  RRCF   xE5,F
04C68:  RRCF   xE6,F
04C6A:  RRCF   xE5,F
04C6C:  MOVLW  0F
04C6E:  ANDWF  xE6,F
04C70:  MOVF   xE5,W
04C72:  ADDWF  xDB,W
04C74:  MOVWF  00
04C76:  MOVF   xE6,W
04C78:  ADDWFC xDC,W
04C7A:  MOVWF  01
04C7C:  MOVLW  00
04C7E:  ADDWFC xDD,W
04C80:  MOVWF  02
04C82:  MOVLW  00
04C84:  ADDWFC xDE,W
04C86:  MOVFF  9E4,FEA
04C8A:  MOVFF  9E3,FE9
04C8E:  MOVFF  00,FEF
04C92:  MOVFF  01,FEC
04C96:  MOVFF  02,FEC
04C9A:  MOVWF  FEC
04C9C:  MOVLB  7
....................       } 
....................    maxsect = LD_DWORD(&(fs->win[0x20]));         // Calculate maximum cluster number  
04C9E:  MOVLW  44
04CA0:  ADDWF  x12,W
04CA2:  MOVWF  01
04CA4:  MOVLW  00
04CA6:  ADDWFC x13,W
04CA8:  MOVFF  01,FE9
04CAC:  MOVWF  FEA
04CAE:  MOVFF  FEF,9DF
04CB2:  MOVFF  FEC,9E0
04CB6:  MOVFF  FEC,9E1
04CBA:  MOVFF  FEC,9E2
....................    if (!maxsect)  
04CBE:  MOVLB  9
04CC0:  MOVF   xDF,F
04CC2:  BNZ   4CF2
04CC4:  MOVF   xE0,F
04CC6:  BNZ   4CF2
04CC8:  MOVF   xE1,F
04CCA:  BNZ   4CF2
04CCC:  MOVF   xE2,F
04CCE:  BNZ   4CF2
....................       maxsect = LD_WORD(&(fs->win[0x13])); 
04CD0:  MOVLW  37
04CD2:  MOVLB  7
04CD4:  ADDWF  x12,W
04CD6:  MOVWF  01
04CD8:  MOVLW  00
04CDA:  ADDWFC x13,W
04CDC:  MOVFF  01,FE9
04CE0:  MOVWF  FEA
04CE2:  MOVLB  9
04CE4:  CLRF   xE2
04CE6:  CLRF   xE1
04CE8:  MOVFF  FEC,9E0
04CEC:  MOVF   FED,F
04CEE:  MOVFF  FEF,9DF
....................    fs->max_clust = (maxsect - fs->database + sect) / fs->sects_clust + 2; 
04CF2:  MOVLW  0C
04CF4:  MOVLB  7
04CF6:  ADDWF  x12,W
04CF8:  MOVWF  01
04CFA:  MOVLW  00
04CFC:  ADDWFC x13,W
04CFE:  MOVWF  03
04D00:  MOVFF  01,9E3
04D04:  MOVLB  9
04D06:  MOVWF  xE4
04D08:  MOVLW  18
04D0A:  MOVLB  7
04D0C:  ADDWF  x12,W
04D0E:  MOVWF  FE9
04D10:  MOVLW  00
04D12:  ADDWFC x13,W
04D14:  MOVWF  FEA
04D16:  MOVFF  FEF,00
04D1A:  MOVFF  FEC,01
04D1E:  MOVFF  FEC,02
04D22:  MOVFF  FEC,03
04D26:  MOVF   00,W
04D28:  MOVLB  9
04D2A:  SUBWF  xDF,W
04D2C:  MOVWF  xE5
04D2E:  MOVF   01,W
04D30:  SUBWFB xE0,W
04D32:  MOVWF  xE6
04D34:  MOVF   02,W
04D36:  SUBWFB xE1,W
04D38:  MOVWF  xE7
04D3A:  MOVF   03,W
04D3C:  SUBWFB xE2,W
04D3E:  MOVWF  xE8
04D40:  MOVF   xD7,W
04D42:  ADDWF  xE5,F
04D44:  MOVF   xD8,W
04D46:  ADDWFC xE6,F
04D48:  MOVF   xD9,W
04D4A:  ADDWFC xE7,F
04D4C:  MOVF   xDA,W
04D4E:  ADDWFC xE8,F
04D50:  MOVLW  02
04D52:  MOVLB  7
04D54:  ADDWF  x12,W
04D56:  MOVWF  FE9
04D58:  MOVLW  00
04D5A:  ADDWFC x13,W
04D5C:  MOVWF  FEA
04D5E:  MOVFF  FEF,A50
04D62:  MOVLB  9
04D64:  MOVFF  FEA,9EB
04D68:  MOVFF  FE9,9EA
04D6C:  BCF    FD8.1
04D6E:  CLRF   1B
04D70:  BTFSC  FF2.7
04D72:  BSF    1B.7
04D74:  BCF    FF2.7
04D76:  MOVFF  9E8,A4F
04D7A:  MOVFF  9E7,A4E
04D7E:  MOVFF  9E6,A4D
04D82:  MOVFF  9E5,A4C
04D86:  MOVLB  A
04D88:  CLRF   x53
04D8A:  CLRF   x52
04D8C:  CLRF   x51
04D8E:  MOVLB  0
04D90:  CALL   104A
04D94:  BTFSC  1B.7
04D96:  BSF    FF2.7
04D98:  MOVFF  9EB,FEA
04D9C:  MOVFF  9EA,FE9
04DA0:  MOVFF  03,9E8
04DA4:  MOVFF  02,9E7
04DA8:  MOVFF  01,9E6
04DAC:  MOVFF  00,9E5
04DB0:  MOVLW  02
04DB2:  MOVLB  9
04DB4:  ADDWF  00,W
04DB6:  MOVWF  00
04DB8:  MOVLW  00
04DBA:  ADDWFC 01,W
04DBC:  MOVWF  01
04DBE:  MOVLW  00
04DC0:  ADDWFC 02,W
04DC2:  MOVWF  02
04DC4:  MOVLW  00
04DC6:  ADDWFC 03,W
04DC8:  MOVFF  9E4,FEA
04DCC:  MOVFF  9E3,FE9
04DD0:  MOVFF  00,FEF
04DD4:  MOVFF  01,FEC
04DD8:  MOVFF  02,FEC
04DDC:  MOVWF  FEC
....................  
....................    return (FR_OK); 
04DDE:  MOVLW  00
04DE0:  MOVWF  01
04DE2:  MOVLB  7
04DE4:  MOVLB  0
04DE6:  RETURN 0
....................    } 
....................  
....................  
....................  
.................... FRESULT f_getfree (DWORD *nclust) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Returns the number of free clusters 
.................... // 
.................... //   Entry 
.................... //      *nclust   Pointer to the double word to return number of free clusters  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. *nclust contains the number of free clusters 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD n, clust, sect; 
....................    BYTE fat, f, *p; 
....................    FRESULT result; 
....................  
....................    // check and mount the media if required 
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    // Count number of free clusters  
....................    fat = fs->fs_type; 
....................    n = 0; 
....................    if (fat == FS_FAT12)  
....................       { 
....................       clust = 2; 
....................       do  
....................          { 
....................          if ((WORD)get_cluster(clust) == 0)  
....................             n++; 
....................          } while (++clust < fs->max_clust); 
....................       } 
....................    else  
....................       { 
....................       clust = fs->max_clust; 
....................       sect = fs->fatbase; 
....................       f = 0; p = 0; 
....................       do  
....................          { 
....................          if (!f)  
....................             { 
....................             if (!move_window(sect++))  
....................                return (FR_RW_ERROR); 
....................             p = fs->win; 
....................             } 
....................          if (fat == FS_FAT16)  
....................             { 
....................             if (LD_WORD(p) == 0)  
....................                n++; 
....................             p += 2; 
....................             f += 1; 
....................             }  
....................          else  
....................             { 
....................             if (LD_DWORD(p) == 0) 
....................                n++; 
....................             p += 4; 
....................             f += 2; 
....................             } 
....................          } while (--clust); 
....................       } 
....................  
....................    *nclust = n; 
....................    return (FR_OK); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_open (FIL *fp, char *path, BYTE mode) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open or Create a File 
.................... // 
.................... //   Entry 
.................... //      *fp,      Pointer to the buffer of new file object to create 
.................... //      *path      Pointer to the filename 
.................... //      mode      Access mode and file open mode flags 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   mode flags: 
.................... //    FA_READ 
.................... //      Specifies read access to the object. Data can be read from the file. 
.................... //      Combine with FA_WRITE for read-write access. 
.................... // 
.................... //   FA_WRITE    
.................... //      Specifies write access to the object. Data can be written to the file. 
.................... //      Combine with FA_READ for read-write access 
.................... // 
.................... //   FA_OPEN_EXISTING 
.................... //      Opens the file. The function fails if the file does not exist 
.................... // 
.................... //   FA_CREATE_ALWAYS 
.................... //      Creates a new file. If the file exists, it is truncated and overwritten 
.................... // 
.................... //   FA_OPEN_ALWAYS    
.................... //      Opens the file, if it exists, creates it otherwise 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. This error is generated under the following conditions: 
.................... //         write mode open of a file that has a read-only attribute,  
.................... //         file creation when a file of the same name already exists in the directory 
.................... //         attemp to create or write to a read-only file, 
.................... //         directory or disk full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    DIR dirscan; 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // mount the media and initialize the file system if necessary 
....................    result = check_mounted(); 
*
0714C:  CALL   55A0
07150:  MOVFF  01,9C3
....................    if (result != FR_OK)  
07154:  MOVLB  9
07156:  MOVF   xC3,F
07158:  BZ    7160
....................       return (result); 
0715A:  MOVFF  9C3,01
0715E:  BRA    7590
....................  
....................    #ifndef _FS_READONLY 
....................       // if opened in write mode, check the media is not write protected 
....................       if ((mode & (FA_WRITE|FA_CREATE_ALWAYS)) && (disk_status() & STA_PROTECT)) 
07160:  MOVF   xB4,W
07162:  ANDLW  0A
07164:  BZ    717C
07166:  MOVLB  0
07168:  CALL   5592
0716C:  BTFSC  01.2
0716E:  BRA    7174
07170:  MOVLB  9
07172:  BRA    717C
....................          return (FR_WRITE_PROTECTED); 
07174:  MOVLW  0A
07176:  MOVWF  01
07178:  MOVLB  9
0717A:  BRA    7590
....................    #endif 
....................  
....................    // test if the file exists 
....................    result = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0717C:  MOVLW  09
0717E:  MOVWF  xD7
07180:  MOVLW  B5
07182:  MOVWF  xD6
07184:  MOVLW  09
07186:  MOVWF  xD9
07188:  MOVLW  C6
0718A:  MOVWF  xD8
0718C:  MOVFF  9B3,9DB
07190:  MOVFF  9B2,9DA
07194:  MOVLW  09
07196:  MOVWF  xDD
07198:  MOVLW  C4
0719A:  MOVWF  xDC
0719C:  MOVLB  0
0719E:  CALL   61D6
071A2:  MOVFF  01,9C3
....................  
....................    #ifndef _FS_READONLY 
....................       // Create or Open a File  
....................    if (mode & (FA_CREATE_ALWAYS|FA_OPEN_ALWAYS))  
071A6:  MOVLB  9
071A8:  MOVF   xB4,W
071AA:  ANDLW  18
071AC:  BTFSC  FD8.2
071AE:  BRA    73D2
....................    { 
....................       DWORD dw; 
....................       // check to see if the file exists 
....................       if (result != FR_OK)  
071B0:  MOVF   xC3,F
071B2:  BZ    723A
....................       { 
....................          // file does not exist 
....................          mode |= FA_CREATE_ALWAYS; 
071B4:  BSF    xB4.3
....................          if (result != FR_NO_FILE) 
071B6:  MOVF   xC3,W
071B8:  SUBLW  02
071BA:  BZ    71C2
....................             return (result); 
071BC:  MOVFF  9C3,01
071C0:  BRA    7590
....................  
....................          // reserve an entry in the directory for this file 
....................          dir_ptr = reserve_direntry(&dirscan); 
071C2:  MOVLW  09
071C4:  MOVWF  xD7
071C6:  MOVLW  B5
071C8:  MOVWF  xD6
071CA:  MOVLB  0
071CC:  BRA    6BF0
071CE:  MOVFF  02,9C5
071D2:  MOVFF  01,9C4
....................          if (dir_ptr == NULL) 
071D6:  MOVLB  9
071D8:  MOVF   xC4,F
071DA:  BNZ   71E6
071DC:  MOVF   xC5,F
071DE:  BNZ   71E6
....................             return (FR_DENIED); 
071E0:  MOVLW  05
071E2:  MOVWF  01
071E4:  BRA    7590
....................  
....................          // initialise the new directory entry 
....................          memcpy(dir_ptr, fn, 8+3); 
071E6:  MOVFF  9C5,FEA
071EA:  MOVFF  9C4,FE9
071EE:  MOVLW  09
071F0:  MOVWF  FE2
071F2:  MOVLW  C6
071F4:  MOVWF  FE1
071F6:  MOVLW  0B
071F8:  MOVWF  01
071FA:  MOVFF  FE6,FEE
071FE:  DECFSZ 01,F
07200:  BRA    71FA
....................          *(dir_ptr+12) = fn[11]; 
07202:  MOVLW  0C
07204:  ADDWF  xC4,W
07206:  MOVWF  01
07208:  MOVLW  00
0720A:  ADDWFC xC5,W
0720C:  MOVFF  01,FE9
07210:  MOVWF  FEA
07212:  MOVFF  9D1,FEF
....................          memset(dir_ptr+13, 0, 32-13); 
07216:  MOVLW  0D
07218:  ADDWF  xC4,W
0721A:  MOVWF  xD6
0721C:  MOVLW  00
0721E:  ADDWFC xC5,W
07220:  MOVWF  xD7
07222:  MOVWF  FEA
07224:  MOVFF  9D6,FE9
07228:  CLRF   00
0722A:  CLRF   02
0722C:  MOVLW  13
0722E:  MOVWF  01
07230:  MOVLB  0
07232:  CALL   351A
....................       }  
07236:  BRA    734C
07238:  MOVLB  9
....................       else  
....................       { 
....................          // the file already exists - chaeck file access rights 
....................          if ((dir_ptr == NULL) || (*(dir_ptr+11) & (AM_RDO|AM_DIR)))   // Could not overwrite (R/O or DIR)  
0723A:  MOVF   xC4,F
0723C:  BNZ   7242
0723E:  MOVF   xC5,F
07240:  BZ    725A
07242:  MOVLW  0B
07244:  ADDWF  xC4,W
07246:  MOVWF  01
07248:  MOVLW  00
0724A:  ADDWFC xC5,W
0724C:  MOVWF  03
0724E:  MOVFF  01,FE9
07252:  MOVWF  FEA
07254:  MOVF   FEF,W
07256:  ANDLW  11
07258:  BZ    7260
....................             return (FR_DENIED); 
0725A:  MOVLW  05
0725C:  MOVWF  01
0725E:  BRA    7590
....................  
....................          // if mode is alway create then reset the file to zero length 
....................          // and remove the cluster chain 
....................          if (mode & FA_CREATE_ALWAYS)  
07260:  BTFSS  xB4.3
07262:  BRA    734A
....................          { 
....................             // remove the cluster chain 
....................             // get the current sector in the FATFS window 
....................             // this will point to the first cluster of the file 
....................             // as a result of the trace_path() 
....................             dw = fs->winsect; 
07264:  MOVLW  20
07266:  MOVLB  7
07268:  ADDWF  x12,W
0726A:  MOVWF  FE9
0726C:  MOVLW  00
0726E:  ADDWFC x13,W
07270:  MOVWF  FEA
07272:  MOVFF  FEF,9D2
07276:  MOVFF  FEC,9D3
0727A:  MOVFF  FEC,9D4
0727E:  MOVFF  FEC,9D5
....................  
....................             if (!remove_chain(((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26)) || !move_window(dw) ) 
07282:  MOVLW  14
07284:  MOVLB  9
07286:  ADDWF  xC4,W
07288:  MOVWF  01
0728A:  MOVLW  00
0728C:  ADDWFC xC5,W
0728E:  MOVWF  03
07290:  MOVFF  01,FE9
07294:  MOVWF  FEA
07296:  MOVFF  FEC,9DE
0729A:  MOVF   FED,F
0729C:  MOVFF  FEF,9D6
072A0:  CLRF   xD8
072A2:  MOVFF  9D6,9DD
072A6:  CLRF   xD6
072A8:  CLRF   xD7
072AA:  MOVLW  1A
072AC:  ADDWF  xC4,W
072AE:  MOVWF  01
072B0:  MOVLW  00
072B2:  ADDWFC xC5,W
072B4:  MOVFF  01,FE9
072B8:  MOVWF  FEA
072BA:  MOVFF  FEC,03
072BE:  MOVF   FED,F
072C0:  MOVF   FEF,W
072C2:  IORWF  xD6,F
072C4:  MOVF   03,W
072C6:  IORWF  xD7,F
072C8:  MOVFF  9D7,9DC
072CC:  MOVFF  9D6,9DB
072D0:  MOVLB  0
072D2:  RCALL  6F3A
072D4:  MOVF   01,F
072D6:  BZ    72F0
072D8:  MOVFF  9D5,A17
072DC:  MOVFF  9D4,A16
072E0:  MOVFF  9D3,A15
072E4:  MOVFF  9D2,A14
072E8:  CALL   5A76
072EC:  MOVF   01,F
072EE:  BNZ   72FA
....................                return (FR_RW_ERROR); 
072F0:  MOVLW  07
072F2:  MOVWF  01
072F4:  MOVLB  9
072F6:  BRA    7590
072F8:  MOVLB  0
....................  
....................             ST_WORD(dir_ptr+20, 0);  
072FA:  MOVLW  14
072FC:  MOVLB  9
072FE:  ADDWF  xC4,W
07300:  MOVWF  01
07302:  MOVLW  00
07304:  ADDWFC xC5,W
07306:  MOVFF  01,FE9
0730A:  MOVWF  FEA
0730C:  CLRF   FEC
0730E:  MOVF   FED,F
07310:  CLRF   FEF
....................             ST_WORD(dir_ptr+26, 0);   // cluster = 0  
07312:  MOVLW  1A
07314:  ADDWF  xC4,W
07316:  MOVWF  01
07318:  MOVLW  00
0731A:  ADDWFC xC5,W
0731C:  MOVFF  01,FE9
07320:  MOVWF  FEA
07322:  CLRF   FEC
07324:  MOVF   FED,F
07326:  CLRF   FEF
....................             ST_DWORD(dir_ptr+28, 0);               // size = 0  
07328:  MOVLW  1C
0732A:  ADDWF  xC4,W
0732C:  MOVWF  01
0732E:  MOVLW  00
07330:  ADDWFC xC5,W
07332:  MOVFF  01,FE9
07336:  MOVWF  FEA
07338:  MOVF   FEE,F
0733A:  MOVF   FEE,F
0733C:  CLRF   FEC
0733E:  MOVF   FED,F
07340:  CLRF   FEF
07342:  MOVF   FED,F
07344:  CLRF   FEF
07346:  MOVF   FED,F
07348:  CLRF   FEF
0734A:  MOVLB  0
....................          } 
....................       } 
....................  
....................       if (mode & FA_CREATE_ALWAYS)  
0734C:  MOVLB  9
0734E:  BTFSS  xB4.3
07350:  BRA    73D0
....................       { 
....................          *(dir_ptr+11) = AM_ARC; 
07352:  MOVLW  0B
07354:  ADDWF  xC4,W
07356:  MOVWF  01
07358:  MOVLW  00
0735A:  ADDWFC xC5,W
0735C:  MOVFF  01,FE9
07360:  MOVWF  FEA
07362:  MOVLW  20
07364:  MOVWF  FEF
....................          dw = get_fattime(); 
07366:  MOVLB  0
07368:  RCALL  6FDC
0736A:  MOVFF  03,9D5
0736E:  MOVFF  02,9D4
07372:  MOVFF  01,9D3
07376:  MOVFF  00,9D2
....................          ST_DWORD(dir_ptr+14, dw);   // Created time  
0737A:  MOVLW  0E
0737C:  MOVLB  9
0737E:  ADDWF  xC4,W
07380:  MOVWF  01
07382:  MOVLW  00
07384:  ADDWFC xC5,W
07386:  MOVFF  01,FE9
0738A:  MOVWF  FEA
0738C:  MOVFF  9D2,FEF
07390:  MOVFF  9D3,FEC
07394:  MOVFF  9D4,FEC
07398:  MOVFF  9D5,FEC
....................          ST_DWORD(dir_ptr+22, dw);   // Updated time  
0739C:  MOVLW  16
0739E:  ADDWF  xC4,W
073A0:  MOVWF  01
073A2:  MOVLW  00
073A4:  ADDWFC xC5,W
073A6:  MOVFF  01,FE9
073AA:  MOVWF  FEA
073AC:  MOVFF  9D2,FEF
073B0:  MOVFF  9D3,FEC
073B4:  MOVFF  9D4,FEC
073B8:  MOVFF  9D5,FEC
....................          fs->winflag = 1; 
073BC:  MOVLW  06
073BE:  MOVLB  7
073C0:  ADDWF  x12,W
073C2:  MOVWF  FE9
073C4:  MOVLW  00
073C6:  ADDWFC x13,W
073C8:  MOVWF  FEA
073CA:  MOVLW  01
073CC:  MOVWF  FEF
073CE:  MOVLB  9
....................       } 
....................    } 
073D0:  BRA    7420
....................    // Open a File  
....................    else  
....................    { 
....................    #endif // _FS_READONLY  
....................  
....................       if (result != FR_OK)  
073D2:  MOVF   xC3,F
073D4:  BZ    73DC
....................          return (result);      // Trace failed  
073D6:  MOVFF  9C3,01
073DA:  BRA    7590
....................  
....................       if ((dir_ptr == NULL) || (*(dir_ptr+11) & AM_DIR))   // It is a directory  
073DC:  MOVF   xC4,F
073DE:  BNZ   73E4
073E0:  MOVF   xC5,F
073E2:  BZ    73FA
073E4:  MOVLW  0B
073E6:  ADDWF  xC4,W
073E8:  MOVWF  01
073EA:  MOVLW  00
073EC:  ADDWFC xC5,W
073EE:  MOVWF  03
073F0:  MOVFF  01,FE9
073F4:  MOVWF  FEA
073F6:  BTFSS  FEF.4
073F8:  BRA    7400
....................          return (FR_NO_FILE); 
073FA:  MOVLW  02
073FC:  MOVWF  01
073FE:  BRA    7590
....................  
....................    #ifndef _FS_READONLY 
....................       if ((mode & FA_WRITE) && (*(dir_ptr+11) & AM_RDO)) // R/O violation  
07400:  BTFSS  xB4.1
07402:  BRA    7420
07404:  MOVLW  0B
07406:  ADDWF  xC4,W
07408:  MOVWF  01
0740A:  MOVLW  00
0740C:  ADDWFC xC5,W
0740E:  MOVWF  03
07410:  MOVFF  01,FE9
07414:  MOVWF  FEA
07416:  BTFSS  FEF.0
07418:  BRA    7420
....................          return (FR_DENIED); 
0741A:  MOVLW  05
0741C:  MOVWF  01
0741E:  BRA    7590
....................    } 
....................    #endif 
....................  
....................    #ifdef _FS_READONLY 
....................       fp->flag = mode & FA_READ; 
....................    #else 
....................       fp->flag = mode & (FA_WRITE|FA_READ); 
07420:  MOVLW  1A
07422:  ADDWF  xB0,W
07424:  MOVWF  FE9
07426:  MOVLW  00
07428:  ADDWFC xB1,W
0742A:  MOVWF  FEA
0742C:  MOVF   xB4,W
0742E:  ANDLW  03
07430:  MOVWF  FEF
....................       fp->dir_sect = fs->winsect;            // Pointer to the current directory sector in the FATFS window  
07432:  MOVLW  14
07434:  ADDWF  xB0,W
07436:  MOVWF  01
07438:  MOVLW  00
0743A:  ADDWFC xB1,W
0743C:  MOVWF  03
0743E:  MOVFF  01,9D6
07442:  MOVWF  xD7
07444:  MOVLW  20
07446:  MOVLB  7
07448:  ADDWF  x12,W
0744A:  MOVWF  FE9
0744C:  MOVLW  00
0744E:  ADDWFC x13,W
07450:  MOVWF  FEA
07452:  MOVFF  FEF,00
07456:  MOVFF  FEC,01
0745A:  MOVFF  FEC,02
0745E:  MOVFF  FEC,03
07462:  MOVFF  9D7,FEA
07466:  MOVFF  9D6,FE9
0746A:  MOVFF  00,FEF
0746E:  MOVFF  01,FEC
07472:  MOVFF  02,FEC
07476:  MOVFF  03,FEC
....................       fp->dir_ptr = dir_ptr;               // pointer to directory offset in the window 
0747A:  MOVLW  18
0747C:  MOVLB  9
0747E:  ADDWF  xB0,W
07480:  MOVWF  FE9
07482:  MOVLW  00
07484:  ADDWFC xB1,W
07486:  MOVWF  FEA
07488:  MOVFF  9C5,FEC
0748C:  MOVF   FED,F
0748E:  MOVFF  9C4,FEF
....................    #endif 
....................    fp->org_clust =   ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26);   // File start cluster  
07492:  MOVLW  08
07494:  ADDWF  xB0,W
07496:  MOVWF  01
07498:  MOVLW  00
0749A:  ADDWFC xB1,W
0749C:  MOVWF  03
0749E:  MOVFF  01,9D6
074A2:  MOVWF  xD7
074A4:  MOVLW  14
074A6:  ADDWF  xC4,W
074A8:  MOVWF  01
074AA:  MOVLW  00
074AC:  ADDWFC xC5,W
074AE:  MOVWF  03
074B0:  MOVFF  01,FE9
074B4:  MOVWF  FEA
074B6:  MOVFF  FEC,9DB
074BA:  MOVF   FED,F
074BC:  MOVFF  FEF,9D8
074C0:  CLRF   xDA
074C2:  MOVFF  9D8,9DA
074C6:  CLRF   xD8
074C8:  CLRF   xD9
074CA:  MOVLW  1A
074CC:  ADDWF  xC4,W
074CE:  MOVWF  01
074D0:  MOVLW  00
074D2:  ADDWFC xC5,W
074D4:  MOVFF  01,FE9
074D8:  MOVWF  FEA
074DA:  MOVFF  FEC,03
074DE:  MOVF   FED,F
074E0:  MOVF   FEF,W
074E2:  IORWF  xD8,W
074E4:  MOVWF  00
074E6:  MOVF   03,W
074E8:  IORWF  xD9,W
074EA:  MOVFF  9DA,02
074EE:  MOVFF  9DB,03
074F2:  MOVFF  9D7,FEA
074F6:  MOVFF  9D6,FE9
074FA:  MOVFF  00,FEF
074FE:  MOVWF  FEC
07500:  MOVFF  9DA,FEC
07504:  MOVFF  9DB,FEC
....................    fp->fsize = LD_DWORD(dir_ptr+28);      // File size 
07508:  MOVLW  04
0750A:  ADDWF  xB0,W
0750C:  MOVWF  01
0750E:  MOVLW  00
07510:  ADDWFC xB1,W
07512:  MOVWF  03
07514:  MOVFF  01,9D6
07518:  MOVWF  xD7
0751A:  MOVLW  1C
0751C:  ADDWF  xC4,W
0751E:  MOVWF  01
07520:  MOVLW  00
07522:  ADDWFC xC5,W
07524:  MOVFF  01,FE9
07528:  MOVWF  FEA
0752A:  MOVFF  FEF,00
0752E:  MOVFF  FEC,01
07532:  MOVFF  FEC,02
07536:  MOVFF  FEC,03
0753A:  MOVFF  9D7,FEA
0753E:  MOVFF  9D6,FE9
07542:  MOVFF  00,FEF
07546:  MOVFF  01,FEC
0754A:  MOVFF  02,FEC
0754E:  MOVFF  03,FEC
....................    fp->fptr = 0;                     // File ptr  - point to the start of the file 
07552:  MOVFF  9B0,FE9
07556:  MOVFF  9B1,FEA
0755A:  MOVF   FEE,F
0755C:  MOVF   FEE,F
0755E:  CLRF   FEC
07560:  MOVF   FED,F
07562:  CLRF   FEF
07564:  MOVF   FED,F
07566:  CLRF   FEF
07568:  MOVF   FED,F
0756A:  CLRF   FEF
....................    fp->sect_clust = 1;                  // Remaining sectors in cluster (forces new cluster) 
0756C:  MOVLW  1B
0756E:  ADDWF  xB0,W
07570:  MOVWF  FE9
07572:  MOVLW  00
07574:  ADDWFC xB1,W
07576:  MOVWF  FEA
07578:  MOVLW  01
0757A:  MOVWF  FEF
....................    fs->files++;                     // update the number of files open count 
0757C:  MOVLB  7
0757E:  ADDWF  x12,W
07580:  MOVWF  FE9
07582:  MOVLW  00
07584:  ADDWFC x13,W
07586:  MOVWF  FEA
07588:  INCF   FEF,F
....................    return (FR_OK); 
0758A:  MOVLW  00
0758C:  MOVWF  01
0758E:  MOVLB  9
07590:  MOVLB  0
07592:  RETURN 0
.................... } 
....................  
.................... // File System Lite Mode = USE_FAT_LITE defined 
.................... FRESULT f_read(FIL *fp, void *buff, WORD btr, WORD *br) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Read a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data buffer 
....................    //      btw         Number of bytes to read 
....................    //      bw         Pointer to number of bytes to read 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded. The FileObject structure is used for subsequent  
....................    //      calls to refer to the file. Use function f_close() to close 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. File already open in write access mode 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................     
....................       { 
....................       DWORD clust, sect, ln; 
....................       WORD rcnt; 
....................       BYTE cc, *rbuff; 
....................     
....................       rbuff = buff; 
*
0B45C:  MOVFF  8CF,8E4
0B460:  MOVFF  8CE,8E3
....................       *br = 0; 
0B464:  MOVLB  8
0B466:  MOVFF  8D2,FE9
0B46A:  MOVFF  8D3,FEA
0B46E:  CLRF   FEC
0B470:  MOVF   FED,F
0B472:  CLRF   FEF
....................       if (!fs)  
0B474:  MOVLB  7
0B476:  MOVF   x12,W
0B478:  IORWF  x13,W
0B47A:  BNZ   B482
....................          return (FR_NOT_ENABLED); 
0B47C:  MOVLW  0B
0B47E:  MOVWF  01
0B480:  BRA    B964
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
0B482:  MOVLB  0
0B484:  CALL   5592
0B488:  BTFSC  01.0
0B48A:  BRA    B49C
0B48C:  MOVLB  7
0B48E:  MOVFF  712,FE9
0B492:  MOVFF  713,FEA
0B496:  MOVF   FEF,F
0B498:  BNZ   B4A4
0B49A:  MOVLB  0
....................          return (FR_NOT_READY);   // Check disk ready  
0B49C:  MOVLW  01
0B49E:  MOVWF  01
0B4A0:  MOVLB  7
0B4A2:  BRA    B964
....................     
....................       if (fp->flag & FA__ERROR) 
0B4A4:  MOVLW  1A
0B4A6:  MOVLB  8
0B4A8:  ADDWF  xCC,W
0B4AA:  MOVWF  FE9
0B4AC:  MOVLW  00
0B4AE:  ADDWFC xCD,W
0B4B0:  MOVWF  FEA
0B4B2:  BTFSS  FEF.7
0B4B4:  BRA    B4C0
....................          return (FR_RW_ERROR);   // Check error flag  
0B4B6:  MOVLW  07
0B4B8:  MOVWF  01
0B4BA:  MOVLB  7
0B4BC:  BRA    B964
0B4BE:  MOVLB  8
....................     
....................       if (!(fp->flag & FA_READ)) 
0B4C0:  MOVLW  1A
0B4C2:  ADDWF  xCC,W
0B4C4:  MOVWF  FE9
0B4C6:  MOVLW  00
0B4C8:  ADDWFC xCD,W
0B4CA:  MOVWF  FEA
0B4CC:  BTFSC  FEF.0
0B4CE:  BRA    B4DA
....................          return (FR_DENIED);      // Check access mode  
0B4D0:  MOVLW  05
0B4D2:  MOVWF  01
0B4D4:  MOVLB  7
0B4D6:  BRA    B964
0B4D8:  MOVLB  8
....................     
....................       ln = fp->fsize - fp->fptr; 
0B4DA:  MOVLW  04
0B4DC:  ADDWF  xCC,W
0B4DE:  MOVWF  FE9
0B4E0:  MOVLW  00
0B4E2:  ADDWFC xCD,W
0B4E4:  MOVWF  FEA
0B4E6:  MOVFF  FEF,8E5
0B4EA:  MOVFF  FEC,8E6
0B4EE:  MOVFF  FEC,8E7
0B4F2:  MOVFF  FEC,8E8
0B4F6:  MOVFF  8CC,FE9
0B4FA:  MOVFF  8CD,FEA
0B4FE:  MOVFF  FEF,00
0B502:  MOVFF  FEC,01
0B506:  MOVFF  FEC,02
0B50A:  MOVFF  FEC,03
0B50E:  MOVF   00,W
0B510:  SUBWF  xE5,W
0B512:  MOVWF  xDC
0B514:  MOVF   01,W
0B516:  SUBWFB xE6,W
0B518:  MOVWF  xDD
0B51A:  MOVF   02,W
0B51C:  SUBWFB xE7,W
0B51E:  MOVWF  xDE
0B520:  MOVF   03,W
0B522:  SUBWFB xE8,W
0B524:  MOVWF  xDF
....................       if (btr > ln) 
0B526:  MOVF   xDF,F
0B528:  BNZ   B544
0B52A:  MOVF   xDE,F
0B52C:  BNZ   B544
0B52E:  MOVF   xDD,W
0B530:  SUBWF  xD1,W
0B532:  BNC   B544
0B534:  BNZ   B53C
0B536:  MOVF   xD0,W
0B538:  SUBWF  xDC,W
0B53A:  BC    B544
....................          btr = ln;            // Truncate read count by number of bytes left  
0B53C:  MOVFF  8DD,8D1
0B540:  MOVFF  8DC,8D0
....................     
....................       for ( ;  btr;               // Repeat until all data transferred  
0B544:  MOVF   xD0,W
0B546:  IORWF  xD1,W
0B548:  BTFSC  FD8.2
0B54A:  BRA    B942
....................          rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt)  
....................          { 
....................          if ((fp->fptr % 512) == 0)  
0B54C:  MOVFF  8CC,FE9
0B550:  MOVFF  8CD,FEA
0B554:  MOVFF  FEF,8E5
0B558:  MOVFF  FEC,8E6
0B55C:  MOVFF  FEC,8E7
0B560:  MOVFF  FEC,8E8
0B564:  MOVLW  01
0B566:  ANDWF  xE6,F
0B568:  CLRF   xE7
0B56A:  CLRF   xE8
0B56C:  MOVF   xE5,F
0B56E:  BTFSS  FD8.2
0B570:  BRA    B7EA
0B572:  MOVF   xE6,F
0B574:  BTFSS  FD8.2
0B576:  BRA    B7EA
0B578:  MOVF   xE7,F
0B57A:  BTFSS  FD8.2
0B57C:  BRA    B7EA
0B57E:  MOVF   xE8,F
0B580:  BTFSS  FD8.2
0B582:  BRA    B7EA
....................             {   // On the sector boundary  
....................             if (--(fp->sect_clust))  
0B584:  MOVLW  1B
0B586:  ADDWF  xCC,W
0B588:  MOVWF  FE9
0B58A:  MOVLW  00
0B58C:  ADDWFC xCD,W
0B58E:  MOVWF  FEA
0B590:  DECF   FEF,F
0B592:  BZ    B5CA
....................                {   // Decrement sector counter  
....................                sect = fp->curr_sect + 1;         // Next sector  
0B594:  MOVLW  10
0B596:  ADDWF  xCC,W
0B598:  MOVWF  FE9
0B59A:  MOVLW  00
0B59C:  ADDWFC xCD,W
0B59E:  MOVWF  FEA
0B5A0:  MOVFF  FEF,8E5
0B5A4:  MOVFF  FEC,8E6
0B5A8:  MOVFF  FEC,8E7
0B5AC:  MOVFF  FEC,8E8
0B5B0:  MOVLW  01
0B5B2:  ADDWF  xE5,W
0B5B4:  MOVWF  xD8
0B5B6:  MOVLW  00
0B5B8:  ADDWFC xE6,W
0B5BA:  MOVWF  xD9
0B5BC:  MOVLW  00
0B5BE:  ADDWFC xE7,W
0B5C0:  MOVWF  xDA
0B5C2:  MOVLW  00
0B5C4:  ADDWFC xE8,W
0B5C6:  MOVWF  xDB
....................                }  
0B5C8:  BRA    B706
....................             else  
....................                {   // Next cluster  
....................                clust = (fp->fptr == 0) ? fp->org_clust : get_cluster(fp->curr_clust); 
0B5CA:  MOVFF  8CC,FE9
0B5CE:  MOVFF  8CD,FEA
0B5D2:  MOVFF  FEF,8E5
0B5D6:  MOVFF  FEC,8E6
0B5DA:  MOVFF  FEC,8E7
0B5DE:  MOVFF  FEC,8E8
0B5E2:  MOVF   xE5,F
0B5E4:  BNZ   B610
0B5E6:  MOVF   xE6,F
0B5E8:  BNZ   B610
0B5EA:  MOVF   xE7,F
0B5EC:  BNZ   B610
0B5EE:  MOVF   xE8,F
0B5F0:  BNZ   B610
0B5F2:  MOVLW  08
0B5F4:  ADDWF  xCC,W
0B5F6:  MOVWF  FE9
0B5F8:  MOVLW  00
0B5FA:  ADDWFC xCD,W
0B5FC:  MOVWF  FEA
0B5FE:  MOVFF  FEF,00
0B602:  MOVFF  FEC,01
0B606:  MOVFF  FEC,02
0B60A:  MOVFF  FEC,03
0B60E:  BRA    B634
0B610:  MOVLW  0C
0B612:  ADDWF  xCC,W
0B614:  MOVWF  FE9
0B616:  MOVLW  00
0B618:  ADDWFC xCD,W
0B61A:  MOVWF  FEA
0B61C:  MOVFF  FEF,9FC
0B620:  MOVFF  FEC,9FD
0B624:  MOVFF  FEC,9FE
0B628:  MOVFF  FEC,9FF
0B62C:  MOVLB  0
0B62E:  CALL   5CAE
0B632:  MOVLB  8
0B634:  MOVFF  03,8D7
0B638:  MOVFF  02,8D6
0B63C:  MOVFF  01,8D5
0B640:  MOVFF  00,8D4
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
0B644:  MOVF   xD7,F
0B646:  BNZ   B656
0B648:  MOVF   xD6,F
0B64A:  BNZ   B656
0B64C:  MOVF   xD5,F
0B64E:  BNZ   B656
0B650:  MOVF   xD4,W
0B652:  SUBLW  01
0B654:  BC    B694
0B656:  MOVLW  0C
0B658:  MOVLB  7
0B65A:  ADDWF  x12,W
0B65C:  MOVWF  FE9
0B65E:  MOVLW  00
0B660:  ADDWFC x13,W
0B662:  MOVWF  FEA
0B664:  MOVFF  FEF,00
0B668:  MOVFF  FEC,01
0B66C:  MOVFF  FEC,02
0B670:  MOVFF  FEC,03
0B674:  MOVF   03,W
0B676:  MOVLB  8
0B678:  SUBWF  xD7,W
0B67A:  BNC   B696
0B67C:  BNZ   B694
0B67E:  MOVF   02,W
0B680:  SUBWF  xD6,W
0B682:  BNC   B696
0B684:  BNZ   B694
0B686:  MOVF   01,W
0B688:  SUBWF  xD5,W
0B68A:  BNC   B696
0B68C:  BNZ   B694
0B68E:  MOVF   00,W
0B690:  SUBWF  xD4,W
0B692:  BNC   B696
....................                   goto fr_error; 
0B694:  BRA    B94C
....................                fp->curr_clust = clust;            // Current cluster  
0B696:  MOVLW  0C
0B698:  ADDWF  xCC,W
0B69A:  MOVWF  FE9
0B69C:  MOVLW  00
0B69E:  ADDWFC xCD,W
0B6A0:  MOVWF  FEA
0B6A2:  MOVFF  8D4,FEF
0B6A6:  MOVFF  8D5,FEC
0B6AA:  MOVFF  8D6,FEC
0B6AE:  MOVFF  8D7,FEC
....................                sect = clust2sect(clust);         // Current sector  
0B6B2:  MOVFF  8D7,9F2
0B6B6:  MOVFF  8D6,9F1
0B6BA:  MOVFF  8D5,9F0
0B6BE:  MOVFF  8D4,9EF
0B6C2:  MOVLB  0
0B6C4:  CALL   5602
0B6C8:  MOVFF  03,8DB
0B6CC:  MOVFF  02,8DA
0B6D0:  MOVFF  01,8D9
0B6D4:  MOVFF  00,8D8
....................                fp->sect_clust = fs->sects_clust;   // Re-initialize the sector counter  
0B6D8:  MOVLW  1B
0B6DA:  MOVLB  8
0B6DC:  ADDWF  xCC,W
0B6DE:  MOVWF  01
0B6E0:  MOVLW  00
0B6E2:  ADDWFC xCD,W
0B6E4:  MOVWF  03
0B6E6:  MOVLW  02
0B6E8:  MOVLB  7
0B6EA:  ADDWF  x12,W
0B6EC:  MOVWF  FE9
0B6EE:  MOVLW  00
0B6F0:  ADDWFC x13,W
0B6F2:  MOVWF  FEA
0B6F4:  MOVFF  FEF,8E7
0B6F8:  MOVLB  8
0B6FA:  MOVFF  03,FEA
0B6FE:  MOVFF  01,FE9
0B702:  MOVFF  8E7,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
0B706:  MOVLW  10
0B708:  ADDWF  xCC,W
0B70A:  MOVWF  FE9
0B70C:  MOVLW  00
0B70E:  ADDWFC xCD,W
0B710:  MOVWF  FEA
0B712:  MOVFF  8D8,FEF
0B716:  MOVFF  8D9,FEC
0B71A:  MOVFF  8DA,FEC
0B71E:  MOVFF  8DB,FEC
....................             cc = btr / 512;                     // When left bytes >= 512  
0B722:  BCF    FD8.0
0B724:  RRCF   xD1,W
0B726:  MOVWF  xE2
....................             if (cc)  
0B728:  MOVF   xE2,F
0B72A:  BZ    B7EA
....................                {   // Read maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
0B72C:  MOVLW  1B
0B72E:  ADDWF  xCC,W
0B730:  MOVWF  FE9
0B732:  MOVLW  00
0B734:  ADDWFC xCD,W
0B736:  MOVWF  FEA
0B738:  MOVF   FEF,W
0B73A:  SUBWF  xE2,W
0B73C:  BZ    B750
0B73E:  BNC   B750
....................                   cc = fp->sect_clust; 
0B740:  MOVLW  1B
0B742:  ADDWF  xCC,W
0B744:  MOVWF  FE9
0B746:  MOVLW  00
0B748:  ADDWFC xCD,W
0B74A:  MOVWF  FEA
0B74C:  MOVFF  FEF,8E2
....................                if (disk_read(rbuff, sect, cc) != RES_OK)  
0B750:  MOVFF  8E4,A21
0B754:  MOVFF  8E3,A20
0B758:  MOVFF  8DB,A25
0B75C:  MOVFF  8DA,A24
0B760:  MOVFF  8D9,A23
0B764:  MOVFF  8D8,A22
0B768:  MOVFF  8E2,A26
0B76C:  MOVLB  0
0B76E:  CALL   44C0
0B772:  MOVF   01,F
0B774:  BZ    B77C
....................                   goto fr_error; 
0B776:  MOVLB  8
0B778:  BRA    B94C
0B77A:  MOVLB  0
....................                fp->sect_clust -= cc - 1; 
0B77C:  MOVLW  1B
0B77E:  MOVLB  8
0B780:  ADDWF  xCC,W
0B782:  MOVWF  FE9
0B784:  MOVLW  00
0B786:  ADDWFC xCD,W
0B788:  MOVWF  FEA
0B78A:  MOVLW  01
0B78C:  SUBWF  xE2,W
0B78E:  SUBWF  FEF,W
0B790:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
0B792:  MOVLW  10
0B794:  ADDWF  xCC,W
0B796:  MOVWF  FE9
0B798:  MOVLW  00
0B79A:  ADDWFC xCD,W
0B79C:  MOVWF  FEA
0B79E:  MOVLW  01
0B7A0:  SUBWF  xE2,W
0B7A2:  ADDWF  FEF,W
0B7A4:  MOVWF  00
0B7A6:  MOVLW  00
0B7A8:  ADDWFC FEC,W
0B7AA:  MOVWF  01
0B7AC:  MOVLW  00
0B7AE:  ADDWFC FEC,W
0B7B0:  MOVWF  02
0B7B2:  MOVLW  00
0B7B4:  ADDWFC FEC,W
0B7B6:  MOVF   FED,F
0B7B8:  MOVF   FED,F
0B7BA:  MOVF   FED,F
0B7BC:  MOVFF  00,FEF
0B7C0:  MOVFF  01,FEC
0B7C4:  MOVFF  02,FEC
0B7C8:  MOVWF  FEC
....................                rcnt = cc * 512;  
0B7CA:  MOVLB  A
0B7CC:  CLRF   x11
0B7CE:  MOVFF  8E2,A10
0B7D2:  MOVLW  02
0B7D4:  MOVWF  x13
0B7D6:  CLRF   x12
0B7D8:  MOVLB  0
0B7DA:  CALL   5C8C
0B7DE:  MOVFF  02,8E1
0B7E2:  MOVFF  01,8E0
....................                continue; 
0B7E6:  BRA    B8DE
0B7E8:  MOVLB  8
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))         // Move the sector window  
0B7EA:  MOVLW  10
0B7EC:  ADDWF  xCC,W
0B7EE:  MOVWF  FE9
0B7F0:  MOVLW  00
0B7F2:  ADDWFC xCD,W
0B7F4:  MOVWF  FEA
0B7F6:  MOVFF  FEF,A14
0B7FA:  MOVFF  FEC,A15
0B7FE:  MOVFF  FEC,A16
0B802:  MOVFF  FEC,A17
0B806:  MOVLB  0
0B808:  CALL   5A76
0B80C:  MOVF   01,F
0B80E:  BNZ   B816
....................                goto fr_error; 
0B810:  MOVLB  8
0B812:  BRA    B94C
0B814:  MOVLB  0
....................          rcnt = 512 - (fp->fptr % 512);      // Copy fractional bytes from file I/O buffer  
0B816:  MOVLB  8
0B818:  MOVFF  8CC,FE9
0B81C:  MOVFF  8CD,FEA
0B820:  MOVFF  FEF,8E5
0B824:  MOVFF  FEC,8E6
0B828:  MOVFF  FEC,8E7
0B82C:  MOVFF  FEC,8E8
0B830:  MOVF   xE6,W
0B832:  ANDLW  01
0B834:  MOVWF  01
0B836:  MOVLW  00
0B838:  BSF    FD8.0
0B83A:  SUBFWB xE5,W
0B83C:  MOVWF  xE0
0B83E:  MOVLW  02
0B840:  SUBFWB 01,W
0B842:  MOVWF  xE1
....................          if (rcnt > btr) 
0B844:  MOVF   xD1,W
0B846:  SUBWF  xE1,W
0B848:  BNC   B85A
0B84A:  BNZ   B852
0B84C:  MOVF   xE0,W
0B84E:  SUBWF  xD0,W
0B850:  BC    B85A
....................             rcnt = btr; 
0B852:  MOVFF  8D1,8E1
0B856:  MOVFF  8D0,8E0
....................          memcpy(rbuff, &fs->win[fp->fptr % 512], rcnt); 
0B85A:  MOVFF  8CC,FE9
0B85E:  MOVFF  8CD,FEA
0B862:  MOVFF  FEF,8E5
0B866:  MOVFF  FEC,8E6
0B86A:  MOVFF  FEC,8E7
0B86E:  MOVFF  FEC,8E8
0B872:  MOVLW  01
0B874:  ANDWF  xE6,F
0B876:  CLRF   xE7
0B878:  CLRF   xE8
0B87A:  MOVLW  24
0B87C:  ADDWF  xE5,W
0B87E:  MOVWF  00
0B880:  MOVLW  00
0B882:  ADDWFC xE6,W
0B884:  MOVWF  01
0B886:  MOVLW  00
0B888:  ADDWFC xE7,W
0B88A:  MOVWF  02
0B88C:  MOVLW  00
0B88E:  ADDWFC xE8,W
0B890:  MOVWF  03
0B892:  MOVFF  01,03
0B896:  MOVF   00,W
0B898:  MOVLB  7
0B89A:  ADDWF  x12,W
0B89C:  MOVWF  01
0B89E:  MOVF   x13,W
0B8A0:  ADDWFC 03,F
0B8A2:  MOVFF  01,8E9
0B8A6:  MOVLB  8
0B8A8:  MOVFF  03,8EA
0B8AC:  MOVFF  8E4,FEA
0B8B0:  MOVFF  8E3,FE9
0B8B4:  MOVFF  03,FE2
0B8B8:  MOVFF  01,FE1
0B8BC:  MOVFF  8E1,02
0B8C0:  MOVFF  8E0,01
0B8C4:  MOVF   01,F
0B8C6:  BZ    B8CC
0B8C8:  INCF   02,F
0B8CA:  BRA    B8D0
0B8CC:  MOVF   02,F
0B8CE:  BZ    B8DC
0B8D0:  MOVFF  FE6,FEE
0B8D4:  DECFSZ 01,F
0B8D6:  BRA    B8D0
0B8D8:  DECFSZ 02,F
0B8DA:  BRA    B8D0
0B8DC:  MOVLB  0
0B8DE:  MOVLB  8
0B8E0:  MOVF   xE0,W
0B8E2:  ADDWF  xE3,F
0B8E4:  MOVF   xE1,W
0B8E6:  ADDWFC xE4,F
0B8E8:  MOVFF  8CC,FE9
0B8EC:  MOVFF  8CD,FEA
0B8F0:  MOVF   xE0,W
0B8F2:  ADDWF  FEF,W
0B8F4:  MOVWF  00
0B8F6:  MOVF   xE1,W
0B8F8:  ADDWFC FEC,W
0B8FA:  MOVWF  01
0B8FC:  MOVLW  00
0B8FE:  ADDWFC FEC,W
0B900:  MOVWF  02
0B902:  MOVLW  00
0B904:  ADDWFC FEC,W
0B906:  MOVWF  03
0B908:  MOVF   FED,F
0B90A:  MOVF   FED,F
0B90C:  MOVF   FED,F
0B90E:  MOVFF  00,FEF
0B912:  MOVFF  01,FEC
0B916:  MOVFF  02,FEC
0B91A:  MOVWF  FEC
0B91C:  MOVFF  8D2,FE9
0B920:  MOVFF  8D3,FEA
0B924:  MOVF   xE0,W
0B926:  ADDWF  FEF,W
0B928:  MOVWF  01
0B92A:  MOVF   xE1,W
0B92C:  ADDWFC FEC,W
0B92E:  MOVWF  03
0B930:  MOVF   FED,F
0B932:  MOVFF  01,FEF
0B936:  MOVWF  FEC
0B938:  MOVF   xE0,W
0B93A:  SUBWF  xD0,F
0B93C:  MOVF   xE1,W
0B93E:  SUBWFB xD1,F
0B940:  BRA    B544
....................          } 
....................       return (FR_OK); 
0B942:  MOVLW  00
0B944:  MOVWF  01
0B946:  MOVLB  7
0B948:  BRA    B964
0B94A:  MOVLB  8
....................     
....................    fr_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0B94C:  MOVLW  1A
0B94E:  ADDWF  xCC,W
0B950:  MOVWF  FE9
0B952:  MOVLW  00
0B954:  ADDWFC xCD,W
0B956:  MOVWF  FEA
0B958:  MOVF   FEF,W
0B95A:  IORLW  80
0B95C:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
0B95E:  MOVLW  07
0B960:  MOVWF  01
0B962:  MOVLB  7
0B964:  MOVLB  0
0B966:  GOTO   BB62 (RETURN)
....................       } 
....................     
....................     
....................     
....................    #ifndef _FS_READONLY 
....................    FRESULT f_write (FIL *fp, void *buff, WORD btw, WORD *bw) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Write to a file 
....................    // 
....................    //   Entry: 
....................    //      fp         Pointer to the file object 
....................    //      buff      Pointer to the data to be written 
....................    //      btw         Number of bytes to write 
....................    //      bw         Pointer to number of bytes written 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_DENIED 
....................    //      File Access Denied. Attempt to write to a read-only file 
....................    // 
....................    //   FR_NOT_READY 
....................    //      Media not ready 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust, sect; 
....................       WORD wcnt; 
....................       BYTE cc; 
....................       BYTE *wbuff; 
....................     
....................       wbuff = buff; 
*
079EE:  MOVFF  9B3,9C4
079F2:  MOVFF  9B2,9C3
....................       *bw = 0; 
079F6:  MOVLB  9
079F8:  MOVFF  9B6,FE9
079FC:  MOVFF  9B7,FEA
07A00:  CLRF   FEC
07A02:  MOVF   FED,F
07A04:  CLRF   FEF
....................       wcnt = 0;      // bug fix to original 0.2 code 
07A06:  CLRF   xC1
07A08:  CLRF   xC0
....................     
....................       // check the fs pointer to the FATFS data structure is valid 
....................       if (!fs)  
07A0A:  MOVLB  7
07A0C:  MOVF   x12,W
07A0E:  IORWF  x13,W
07A10:  BNZ   7A18
....................          return (FR_NOT_ENABLED); 
07A12:  MOVLW  0B
07A14:  MOVWF  01
07A16:  BRA    80B8
....................     
....................       // check the card is in the initialized state and the File System is recognized 
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
07A18:  MOVLB  0
07A1A:  CALL   5592
07A1E:  BTFSC  01.0
07A20:  BRA    7A32
07A22:  MOVLB  7
07A24:  MOVFF  712,FE9
07A28:  MOVFF  713,FEA
07A2C:  MOVF   FEF,F
07A2E:  BNZ   7A3A
07A30:  MOVLB  0
....................          return (FR_NOT_READY); 
07A32:  MOVLW  01
07A34:  MOVWF  01
07A36:  MOVLB  7
07A38:  BRA    80B8
....................     
....................       // if an existing error in the file pointer then exit 
....................       if (fp->flag & FA__ERROR) 
07A3A:  MOVLW  1A
07A3C:  MOVLB  9
07A3E:  ADDWF  xB0,W
07A40:  MOVWF  FE9
07A42:  MOVLW  00
07A44:  ADDWFC xB1,W
07A46:  MOVWF  FEA
07A48:  BTFSS  FEF.7
07A4A:  BRA    7A56
....................          return (FR_RW_ERROR);         // Check error flag  
07A4C:  MOVLW  07
07A4E:  MOVWF  01
07A50:  MOVLB  7
07A52:  BRA    80B8
07A54:  MOVLB  9
....................     
....................       // ensure the file is openned for write operations 
....................       if (!(fp->flag & FA_WRITE))  
07A56:  MOVLW  1A
07A58:  ADDWF  xB0,W
07A5A:  MOVWF  FE9
07A5C:  MOVLW  00
07A5E:  ADDWFC xB1,W
07A60:  MOVWF  FEA
07A62:  BTFSC  FEF.1
07A64:  BRA    7A70
....................          return (FR_DENIED);            // Check access mode  
07A66:  MOVLW  05
07A68:  MOVWF  01
07A6A:  MOVLB  7
07A6C:  BRA    80B8
07A6E:  MOVLB  9
....................     
....................       // ensure no pointer rollover will occur 
....................       if (fp->fsize + btw < fp->fsize)  
07A70:  MOVLW  04
07A72:  ADDWF  xB0,W
07A74:  MOVWF  FE9
07A76:  MOVLW  00
07A78:  ADDWFC xB1,W
07A7A:  MOVWF  FEA
07A7C:  MOVFF  FEF,9C5
07A80:  MOVFF  FEC,9C6
07A84:  MOVFF  FEC,9C7
07A88:  MOVFF  FEC,9C8
07A8C:  MOVF   xB4,W
07A8E:  ADDWF  xC5,F
07A90:  MOVF   xB5,W
07A92:  ADDWFC xC6,F
07A94:  MOVLW  00
07A96:  ADDWFC xC7,F
07A98:  ADDWFC xC8,F
07A9A:  MOVLW  04
07A9C:  ADDWF  xB0,W
07A9E:  MOVWF  FE9
07AA0:  MOVLW  00
07AA2:  ADDWFC xB1,W
07AA4:  MOVWF  FEA
07AA6:  MOVFF  FEF,00
07AAA:  MOVFF  FEC,01
07AAE:  MOVFF  FEC,02
07AB2:  MOVFF  FEC,03
07AB6:  MOVF   xC8,W
07AB8:  SUBWF  03,W
07ABA:  BNC   7AD8
07ABC:  BNZ   7AD4
07ABE:  MOVF   xC7,W
07AC0:  SUBWF  02,W
07AC2:  BNC   7AD8
07AC4:  BNZ   7AD4
07AC6:  MOVF   xC6,W
07AC8:  SUBWF  01,W
07ACA:  BNC   7AD8
07ACC:  BNZ   7AD4
07ACE:  MOVF   00,W
07AD0:  SUBWF  xC5,W
07AD2:  BC    7AD8
....................          btw = 0;                  // File size cannot reach 4GB  
07AD4:  CLRF   xB5
07AD6:  CLRF   xB4
....................     
....................       // write to Media loop 
....................       for ( ;  btw; wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt)  
07AD8:  MOVF   xB4,W
07ADA:  IORWF  xB5,W
07ADC:  BTFSC  FD8.2
07ADE:  BRA    7FEC
....................          // Repeat until all data transferred 
....................          { 
....................          if ((fp->fptr % 512) == 0)  
07AE0:  MOVFF  9B0,FE9
07AE4:  MOVFF  9B1,FEA
07AE8:  MOVFF  FEF,9C5
07AEC:  MOVFF  FEC,9C6
07AF0:  MOVFF  FEC,9C7
07AF4:  MOVFF  FEC,9C8
07AF8:  MOVLW  01
07AFA:  ANDWF  xC6,F
07AFC:  CLRF   xC7
07AFE:  CLRF   xC8
07B00:  MOVF   xC5,F
07B02:  BTFSS  FD8.2
07B04:  BRA    7E86
07B06:  MOVF   xC6,F
07B08:  BTFSS  FD8.2
07B0A:  BRA    7E86
07B0C:  MOVF   xC7,F
07B0E:  BTFSS  FD8.2
07B10:  BRA    7E86
07B12:  MOVF   xC8,F
07B14:  BTFSS  FD8.2
07B16:  BRA    7E86
....................             { 
....................             // On the sector boundary, decrement sector counter 
....................             if (--(fp->sect_clust))  
07B18:  MOVLW  1B
07B1A:  ADDWF  xB0,W
07B1C:  MOVWF  FE9
07B1E:  MOVLW  00
07B20:  ADDWFC xB1,W
07B22:  MOVWF  FEA
07B24:  DECF   FEF,F
07B26:  BZ    7B5E
....................                { 
....................                sect = fp->curr_sect + 1;   // point to the next sector 
07B28:  MOVLW  10
07B2A:  ADDWF  xB0,W
07B2C:  MOVWF  FE9
07B2E:  MOVLW  00
07B30:  ADDWFC xB1,W
07B32:  MOVWF  FEA
07B34:  MOVFF  FEF,9C5
07B38:  MOVFF  FEC,9C6
07B3C:  MOVFF  FEC,9C7
07B40:  MOVFF  FEC,9C8
07B44:  MOVLW  01
07B46:  ADDWF  xC5,W
07B48:  MOVWF  xBC
07B4A:  MOVLW  00
07B4C:  ADDWFC xC6,W
07B4E:  MOVWF  xBD
07B50:  MOVLW  00
07B52:  ADDWFC xC7,W
07B54:  MOVWF  xBE
07B56:  MOVLW  00
07B58:  ADDWFC xC8,W
07B5A:  MOVWF  xBF
....................                }  
07B5C:  BRA    7CF4
....................             else  
....................                { 
....................                // finished this cluster, get next cluster 
....................                // at the beginning of the file? 
....................                if (fp->fptr == 0)  
07B5E:  MOVFF  9B0,FE9
07B62:  MOVFF  9B1,FEA
07B66:  MOVFF  FEF,9C5
07B6A:  MOVFF  FEC,9C6
07B6E:  MOVFF  FEC,9C7
07B72:  MOVFF  FEC,9C8
07B76:  MOVF   xC5,F
07B78:  BNZ   7BFE
07B7A:  MOVF   xC6,F
07B7C:  BNZ   7BFE
07B7E:  MOVF   xC7,F
07B80:  BNZ   7BFE
07B82:  MOVF   xC8,F
07B84:  BNZ   7BFE
....................                   { 
....................                   // at start of the file 
....................                   clust = fp->org_clust; 
07B86:  MOVLW  08
07B88:  ADDWF  xB0,W
07B8A:  MOVWF  FE9
07B8C:  MOVLW  00
07B8E:  ADDWFC xB1,W
07B90:  MOVWF  FEA
07B92:  MOVFF  FEF,9B8
07B96:  MOVFF  FEC,9B9
07B9A:  MOVFF  FEC,9BA
07B9E:  MOVFF  FEC,9BB
....................                   if (clust == 0)            // No cluster is created  
07BA2:  MOVF   xB8,F
07BA4:  BNZ   7BFC
07BA6:  MOVF   xB9,F
07BA8:  BNZ   7BFC
07BAA:  MOVF   xBA,F
07BAC:  BNZ   7BFC
07BAE:  MOVF   xBB,F
07BB0:  BNZ   7BFC
....................                      fp->org_clust = clust = create_chain(0);   // Create a new cluster chain 
07BB2:  MOVLW  08
07BB4:  ADDWF  xB0,W
07BB6:  MOVWF  01
07BB8:  MOVLW  00
07BBA:  ADDWFC xB1,W
07BBC:  MOVWF  03
07BBE:  MOVFF  01,9C5
07BC2:  MOVWF  xC6
07BC4:  CLRF   xEB
07BC6:  CLRF   xEA
07BC8:  CLRF   xE9
07BCA:  CLRF   xE8
07BCC:  MOVLB  0
07BCE:  CALL   6958
07BD2:  MOVFF  03,9BB
07BD6:  MOVFF  02,9BA
07BDA:  MOVFF  01,9B9
07BDE:  MOVFF  00,9B8
07BE2:  MOVFF  9C6,FEA
07BE6:  MOVFF  9C5,FE9
07BEA:  MOVFF  9B8,FEF
07BEE:  MOVFF  9B9,FEC
07BF2:  MOVFF  9BA,FEC
07BF6:  MOVFF  9BB,FEC
07BFA:  MOVLB  9
....................                   } 
07BFC:  BRA    7C32
....................                else  
....................                   {   // Middle or end of file  
....................                   clust = create_chain(fp->curr_clust);   // Trace or stretch cluster chain  
07BFE:  MOVLW  0C
07C00:  ADDWF  xB0,W
07C02:  MOVWF  FE9
07C04:  MOVLW  00
07C06:  ADDWFC xB1,W
07C08:  MOVWF  FEA
07C0A:  MOVFF  FEF,9E8
07C0E:  MOVFF  FEC,9E9
07C12:  MOVFF  FEC,9EA
07C16:  MOVFF  FEC,9EB
07C1A:  MOVLB  0
07C1C:  CALL   6958
07C20:  MOVFF  03,9BB
07C24:  MOVFF  02,9BA
07C28:  MOVFF  01,9B9
07C2C:  MOVFF  00,9B8
07C30:  MOVLB  9
....................                   } 
....................                if ((clust < 2) || (clust >= fs->max_clust)) 
07C32:  MOVF   xBB,F
07C34:  BNZ   7C44
07C36:  MOVF   xBA,F
07C38:  BNZ   7C44
07C3A:  MOVF   xB9,F
07C3C:  BNZ   7C44
07C3E:  MOVF   xB8,W
07C40:  SUBLW  01
07C42:  BC    7C82
07C44:  MOVLW  0C
07C46:  MOVLB  7
07C48:  ADDWF  x12,W
07C4A:  MOVWF  FE9
07C4C:  MOVLW  00
07C4E:  ADDWFC x13,W
07C50:  MOVWF  FEA
07C52:  MOVFF  FEF,00
07C56:  MOVFF  FEC,01
07C5A:  MOVFF  FEC,02
07C5E:  MOVFF  FEC,03
07C62:  MOVF   03,W
07C64:  MOVLB  9
07C66:  SUBWF  xBB,W
07C68:  BNC   7C84
07C6A:  BNZ   7C82
07C6C:  MOVF   02,W
07C6E:  SUBWF  xBA,W
07C70:  BNC   7C84
07C72:  BNZ   7C82
07C74:  MOVF   01,W
07C76:  SUBWF  xB9,W
07C78:  BNC   7C84
07C7A:  BNZ   7C82
07C7C:  MOVF   00,W
07C7E:  SUBWF  xB8,W
07C80:  BNC   7C84
....................                   break; 
07C82:  BRA    7FEC
....................                fp->curr_clust = clust;            // Current cluster  
07C84:  MOVLW  0C
07C86:  ADDWF  xB0,W
07C88:  MOVWF  FE9
07C8A:  MOVLW  00
07C8C:  ADDWFC xB1,W
07C8E:  MOVWF  FEA
07C90:  MOVFF  9B8,FEF
07C94:  MOVFF  9B9,FEC
07C98:  MOVFF  9BA,FEC
07C9C:  MOVFF  9BB,FEC
....................                sect = clust2sect(clust);         // Current sector  
07CA0:  MOVFF  9BB,9F2
07CA4:  MOVFF  9BA,9F1
07CA8:  MOVFF  9B9,9F0
07CAC:  MOVFF  9B8,9EF
07CB0:  MOVLB  0
07CB2:  CALL   5602
07CB6:  MOVFF  03,9BF
07CBA:  MOVFF  02,9BE
07CBE:  MOVFF  01,9BD
07CC2:  MOVFF  00,9BC
....................                fp->sect_clust = fs->sects_clust;      // Re-initialize the sector counter  
07CC6:  MOVLW  1B
07CC8:  MOVLB  9
07CCA:  ADDWF  xB0,W
07CCC:  MOVWF  01
07CCE:  MOVLW  00
07CD0:  ADDWFC xB1,W
07CD2:  MOVWF  03
07CD4:  MOVLW  02
07CD6:  MOVLB  7
07CD8:  ADDWF  x12,W
07CDA:  MOVWF  FE9
07CDC:  MOVLW  00
07CDE:  ADDWFC x13,W
07CE0:  MOVWF  FEA
07CE2:  MOVFF  FEF,9C7
07CE6:  MOVLB  9
07CE8:  MOVFF  03,FEA
07CEC:  MOVFF  01,FE9
07CF0:  MOVFF  9C7,FEF
....................                } 
....................     
....................             fp->curr_sect = sect;               // Update current sector  
07CF4:  MOVLW  10
07CF6:  ADDWF  xB0,W
07CF8:  MOVWF  FE9
07CFA:  MOVLW  00
07CFC:  ADDWFC xB1,W
07CFE:  MOVWF  FEA
07D00:  MOVFF  9BC,FEF
07D04:  MOVFF  9BD,FEC
07D08:  MOVFF  9BE,FEC
07D0C:  MOVFF  9BF,FEC
....................             cc = btw / 512;                  // When left bytes >= 512  
07D10:  BCF    FD8.0
07D12:  RRCF   xB5,W
07D14:  MOVWF  xC2
....................             if (cc)  
07D16:  MOVF   xC2,F
07D18:  BZ    7DD4
....................                {   // Write maximum contiguous sectors  
....................                if (cc > fp->sect_clust)  
07D1A:  MOVLW  1B
07D1C:  ADDWF  xB0,W
07D1E:  MOVWF  FE9
07D20:  MOVLW  00
07D22:  ADDWFC xB1,W
07D24:  MOVWF  FEA
07D26:  MOVF   FEF,W
07D28:  SUBWF  xC2,W
07D2A:  BZ    7D3E
07D2C:  BNC   7D3E
....................                   cc = fp->sect_clust; 
07D2E:  MOVLW  1B
07D30:  ADDWF  xB0,W
07D32:  MOVWF  FE9
07D34:  MOVLW  00
07D36:  ADDWFC xB1,W
07D38:  MOVWF  FEA
07D3A:  MOVFF  FEF,9C2
....................                if (disk_write(wbuff, sect, cc) != RES_OK)  
07D3E:  MOVFF  9C4,A21
07D42:  MOVFF  9C3,A20
07D46:  MOVFF  9BF,A25
07D4A:  MOVFF  9BE,A24
07D4E:  MOVFF  9BD,A23
07D52:  MOVFF  9BC,A22
07D56:  MOVFF  9C2,A26
07D5A:  MOVLB  0
07D5C:  CALL   5932
07D60:  MOVF   01,F
07D62:  BZ    7D66
....................                   goto fw_error; 
07D64:  BRA    809E
....................                fp->sect_clust -= cc - 1; 
07D66:  MOVLW  1B
07D68:  MOVLB  9
07D6A:  ADDWF  xB0,W
07D6C:  MOVWF  FE9
07D6E:  MOVLW  00
07D70:  ADDWFC xB1,W
07D72:  MOVWF  FEA
07D74:  MOVLW  01
07D76:  SUBWF  xC2,W
07D78:  SUBWF  FEF,W
07D7A:  MOVWF  FEF
....................                fp->curr_sect += cc - 1; 
07D7C:  MOVLW  10
07D7E:  ADDWF  xB0,W
07D80:  MOVWF  FE9
07D82:  MOVLW  00
07D84:  ADDWFC xB1,W
07D86:  MOVWF  FEA
07D88:  MOVLW  01
07D8A:  SUBWF  xC2,W
07D8C:  ADDWF  FEF,W
07D8E:  MOVWF  00
07D90:  MOVLW  00
07D92:  ADDWFC FEC,W
07D94:  MOVWF  01
07D96:  MOVLW  00
07D98:  ADDWFC FEC,W
07D9A:  MOVWF  02
07D9C:  MOVLW  00
07D9E:  ADDWFC FEC,W
07DA0:  MOVF   FED,F
07DA2:  MOVF   FED,F
07DA4:  MOVF   FED,F
07DA6:  MOVFF  00,FEF
07DAA:  MOVFF  01,FEC
07DAE:  MOVFF  02,FEC
07DB2:  MOVWF  FEC
....................                wcnt = cc * 512; 
07DB4:  MOVLB  A
07DB6:  CLRF   x11
07DB8:  MOVFF  9C2,A10
07DBC:  MOVLW  02
07DBE:  MOVWF  x13
07DC0:  CLRF   x12
07DC2:  MOVLB  0
07DC4:  CALL   5C8C
07DC8:  MOVFF  02,9C1
07DCC:  MOVFF  01,9C0
....................                continue; 
07DD0:  BRA    7F88
07DD2:  MOVLB  9
....................                } 
....................     
....................             if (fp->fptr >= fp->fsize)  
07DD4:  MOVFF  9B0,FE9
07DD8:  MOVFF  9B1,FEA
07DDC:  MOVFF  FEF,9C5
07DE0:  MOVFF  FEC,9C6
07DE4:  MOVFF  FEC,9C7
07DE8:  MOVFF  FEC,9C8
07DEC:  MOVLW  04
07DEE:  ADDWF  xB0,W
07DF0:  MOVWF  FE9
07DF2:  MOVLW  00
07DF4:  ADDWFC xB1,W
07DF6:  MOVWF  FEA
07DF8:  MOVFF  FEF,00
07DFC:  MOVFF  FEC,01
07E00:  MOVFF  FEC,02
07E04:  MOVFF  FEC,03
07E08:  MOVF   03,W
07E0A:  SUBWF  xC8,W
07E0C:  BNC   7E86
07E0E:  BNZ   7E26
07E10:  MOVF   02,W
07E12:  SUBWF  xC7,W
07E14:  BNC   7E86
07E16:  BNZ   7E26
07E18:  MOVF   01,W
07E1A:  SUBWF  xC6,W
07E1C:  BNC   7E86
07E1E:  BNZ   7E26
07E20:  MOVF   00,W
07E22:  SUBWF  xC5,W
07E24:  BNC   7E86
....................                { 
....................                if (!move_window(0))        // Flush R/W window if needed 
07E26:  MOVLB  A
07E28:  CLRF   x17
07E2A:  CLRF   x16
07E2C:  CLRF   x15
07E2E:  CLRF   x14
07E30:  MOVLB  0
07E32:  CALL   5A76
07E36:  MOVF   01,F
07E38:  BNZ   7E3C
....................                   goto fw_error; 
07E3A:  BRA    809E
....................                fs->winsect = fp->curr_sect; 
07E3C:  MOVLW  20
07E3E:  MOVLB  7
07E40:  ADDWF  x12,W
07E42:  MOVWF  01
07E44:  MOVLW  00
07E46:  ADDWFC x13,W
07E48:  MOVWF  03
07E4A:  MOVFF  01,9C5
07E4E:  MOVLB  9
07E50:  MOVWF  xC6
07E52:  MOVLW  10
07E54:  ADDWF  xB0,W
07E56:  MOVWF  FE9
07E58:  MOVLW  00
07E5A:  ADDWFC xB1,W
07E5C:  MOVWF  FEA
07E5E:  MOVFF  FEF,00
07E62:  MOVFF  FEC,01
07E66:  MOVFF  FEC,02
07E6A:  MOVFF  FEC,03
07E6E:  MOVFF  9C6,FEA
07E72:  MOVFF  9C5,FE9
07E76:  MOVFF  00,FEF
07E7A:  MOVFF  01,FEC
07E7E:  MOVFF  02,FEC
07E82:  MOVFF  03,FEC
....................                } 
....................             } 
....................     
....................          if (!move_window(fp->curr_sect))  
07E86:  MOVLW  10
07E88:  ADDWF  xB0,W
07E8A:  MOVWF  FE9
07E8C:  MOVLW  00
07E8E:  ADDWFC xB1,W
07E90:  MOVWF  FEA
07E92:  MOVFF  FEF,A14
07E96:  MOVFF  FEC,A15
07E9A:  MOVFF  FEC,A16
07E9E:  MOVFF  FEC,A17
07EA2:  MOVLB  0
07EA4:  CALL   5A76
07EA8:  MOVF   01,F
07EAA:  BNZ   7EAE
....................             goto fw_error;               // Move sector window 
07EAC:  BRA    809E
....................     
....................          wcnt = 512 - (fp->fptr % 512);         // Copy fractional bytes to file I/O buffer  
07EAE:  MOVLB  9
07EB0:  MOVFF  9B0,FE9
07EB4:  MOVFF  9B1,FEA
07EB8:  MOVFF  FEF,9C5
07EBC:  MOVFF  FEC,9C6
07EC0:  MOVFF  FEC,9C7
07EC4:  MOVFF  FEC,9C8
07EC8:  MOVF   xC6,W
07ECA:  ANDLW  01
07ECC:  MOVWF  01
07ECE:  MOVLW  00
07ED0:  BSF    FD8.0
07ED2:  SUBFWB xC5,W
07ED4:  MOVWF  xC0
07ED6:  MOVLW  02
07ED8:  SUBFWB 01,W
07EDA:  MOVWF  xC1
....................          if (wcnt > btw) 
07EDC:  MOVF   xB5,W
07EDE:  SUBWF  xC1,W
07EE0:  BNC   7EF2
07EE2:  BNZ   7EEA
07EE4:  MOVF   xC0,W
07EE6:  SUBWF  xB4,W
07EE8:  BC    7EF2
....................             wcnt = btw; 
07EEA:  MOVFF  9B5,9C1
07EEE:  MOVFF  9B4,9C0
....................          memcpy(&fs->win[fp->fptr % 512], wbuff, wcnt); 
07EF2:  MOVFF  9B0,FE9
07EF6:  MOVFF  9B1,FEA
07EFA:  MOVFF  FEF,9C5
07EFE:  MOVFF  FEC,9C6
07F02:  MOVFF  FEC,9C7
07F06:  MOVFF  FEC,9C8
07F0A:  MOVLW  01
07F0C:  ANDWF  xC6,F
07F0E:  CLRF   xC7
07F10:  CLRF   xC8
07F12:  MOVLW  24
07F14:  ADDWF  xC5,W
07F16:  MOVWF  00
07F18:  MOVLW  00
07F1A:  ADDWFC xC6,W
07F1C:  MOVWF  01
07F1E:  MOVLW  00
07F20:  ADDWFC xC7,W
07F22:  MOVWF  02
07F24:  MOVLW  00
07F26:  ADDWFC xC8,W
07F28:  MOVWF  03
07F2A:  MOVFF  01,03
07F2E:  MOVF   00,W
07F30:  MOVLB  7
07F32:  ADDWF  x12,W
07F34:  MOVWF  01
07F36:  MOVF   x13,W
07F38:  ADDWFC 03,F
07F3A:  MOVFF  01,9C9
07F3E:  MOVLB  9
07F40:  MOVFF  03,9CA
07F44:  MOVFF  03,FEA
07F48:  MOVFF  01,FE9
07F4C:  MOVFF  9C4,FE2
07F50:  MOVFF  9C3,FE1
07F54:  MOVFF  9C1,02
07F58:  MOVFF  9C0,01
07F5C:  MOVF   01,F
07F5E:  BZ    7F64
07F60:  INCF   02,F
07F62:  BRA    7F68
07F64:  MOVF   02,F
07F66:  BZ    7F74
07F68:  MOVFF  FE6,FEE
07F6C:  DECFSZ 01,F
07F6E:  BRA    7F68
07F70:  DECFSZ 02,F
07F72:  BRA    7F68
....................          fs->winflag = 1; 
07F74:  MOVLW  06
07F76:  MOVLB  7
07F78:  ADDWF  x12,W
07F7A:  MOVWF  FE9
07F7C:  MOVLW  00
07F7E:  ADDWFC x13,W
07F80:  MOVWF  FEA
07F82:  MOVLW  01
07F84:  MOVWF  FEF
07F86:  MOVLB  0
07F88:  MOVLB  9
07F8A:  MOVF   xC0,W
07F8C:  ADDWF  xC3,F
07F8E:  MOVF   xC1,W
07F90:  ADDWFC xC4,F
07F92:  MOVFF  9B0,FE9
07F96:  MOVFF  9B1,FEA
07F9A:  MOVF   xC0,W
07F9C:  ADDWF  FEF,W
07F9E:  MOVWF  00
07FA0:  MOVF   xC1,W
07FA2:  ADDWFC FEC,W
07FA4:  MOVWF  01
07FA6:  MOVLW  00
07FA8:  ADDWFC FEC,W
07FAA:  MOVWF  02
07FAC:  MOVLW  00
07FAE:  ADDWFC FEC,W
07FB0:  MOVWF  03
07FB2:  MOVF   FED,F
07FB4:  MOVF   FED,F
07FB6:  MOVF   FED,F
07FB8:  MOVFF  00,FEF
07FBC:  MOVFF  01,FEC
07FC0:  MOVFF  02,FEC
07FC4:  MOVWF  FEC
07FC6:  MOVFF  9B6,FE9
07FCA:  MOVFF  9B7,FEA
07FCE:  MOVF   xC0,W
07FD0:  ADDWF  FEF,W
07FD2:  MOVWF  01
07FD4:  MOVF   xC1,W
07FD6:  ADDWFC FEC,W
07FD8:  MOVWF  03
07FDA:  MOVF   FED,F
07FDC:  MOVFF  01,FEF
07FE0:  MOVWF  FEC
07FE2:  MOVF   xC0,W
07FE4:  SUBWF  xB4,F
07FE6:  MOVF   xC1,W
07FE8:  SUBWFB xB5,F
07FEA:  BRA    7AD8
....................          } 
....................     
....................       if (fp->fptr > fp->fsize)  
07FEC:  MOVFF  9B0,FE9
07FF0:  MOVFF  9B1,FEA
07FF4:  MOVFF  FEF,9C5
07FF8:  MOVFF  FEC,9C6
07FFC:  MOVFF  FEC,9C7
08000:  MOVFF  FEC,9C8
08004:  MOVLW  04
08006:  ADDWF  xB0,W
08008:  MOVWF  FE9
0800A:  MOVLW  00
0800C:  ADDWFC xB1,W
0800E:  MOVWF  FEA
08010:  MOVFF  FEF,00
08014:  MOVFF  FEC,01
08018:  MOVFF  FEC,02
0801C:  MOVFF  FEC,03
08020:  MOVF   03,W
08022:  SUBWF  xC8,W
08024:  BNC   8082
08026:  BNZ   803E
08028:  MOVF   02,W
0802A:  SUBWF  xC7,W
0802C:  BNC   8082
0802E:  BNZ   803E
08030:  MOVF   01,W
08032:  SUBWF  xC6,W
08034:  BNC   8082
08036:  BNZ   803E
08038:  MOVF   xC5,W
0803A:  SUBWF  00,W
0803C:  BC    8082
....................          fp->fsize = fp->fptr;      // Update file size if needed  
0803E:  MOVLW  04
08040:  ADDWF  xB0,W
08042:  MOVWF  01
08044:  MOVLW  00
08046:  ADDWFC xB1,W
08048:  MOVWF  03
0804A:  MOVFF  01,9C5
0804E:  MOVFF  03,9C6
08052:  MOVFF  9B0,FE9
08056:  MOVFF  9B1,FEA
0805A:  MOVFF  FEF,00
0805E:  MOVFF  FEC,01
08062:  MOVFF  FEC,02
08066:  MOVFF  FEC,03
0806A:  MOVFF  9C6,FEA
0806E:  MOVFF  9C5,FE9
08072:  MOVFF  00,FEF
08076:  MOVFF  01,FEC
0807A:  MOVFF  02,FEC
0807E:  MOVFF  03,FEC
....................       fp->flag |= FA__WRITTEN;      // Set file changed flag  
08082:  MOVLW  1A
08084:  ADDWF  xB0,W
08086:  MOVWF  FE9
08088:  MOVLW  00
0808A:  ADDWFC xB1,W
0808C:  MOVWF  FEA
0808E:  MOVF   FEF,W
08090:  IORLW  20
08092:  MOVWF  FEF
....................       return (FR_OK); 
08094:  MOVLW  00
08096:  MOVWF  01
08098:  MOVLB  7
0809A:  BRA    80B8
0809C:  MOVLB  0
....................     
....................    fw_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
0809E:  MOVLW  1A
080A0:  MOVLB  9
080A2:  ADDWF  xB0,W
080A4:  MOVWF  FE9
080A6:  MOVLW  00
080A8:  ADDWFC xB1,W
080AA:  MOVWF  FEA
080AC:  MOVF   FEF,W
080AE:  IORLW  80
080B0:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
080B2:  MOVLW  07
080B4:  MOVWF  01
080B6:  MOVLB  7
080B8:  MOVLB  0
080BA:  GOTO   8462 (RETURN)
....................       } 
....................    #endif // _FS_READONLY  
....................     
....................     
....................     
....................    FRESULT f_lseek (FIL *fp, DWORD ofs) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Seek File Pointer  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    //      ofs      File pointer from top of file 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
....................       { 
....................       DWORD clust; 
....................       BYTE sc; 
....................     
....................       if (!fs) 
*
07594:  MOVLB  7
07596:  MOVF   x12,W
07598:  IORWF  x13,W
0759A:  BNZ   75A2
....................          return (FR_NOT_ENABLED); 
0759C:  MOVLW  0B
0759E:  MOVWF  01
075A0:  BRA    78F6
....................     
....................       if ((disk_status() & STA_NOINIT) || !fs->fs_type)  
075A2:  MOVLB  0
075A4:  CALL   5592
075A8:  BTFSC  01.0
075AA:  BRA    75BC
075AC:  MOVLB  7
075AE:  MOVFF  712,FE9
075B2:  MOVFF  713,FEA
075B6:  MOVF   FEF,F
075B8:  BNZ   75C4
075BA:  MOVLB  0
....................          return (FR_NOT_READY); 
075BC:  MOVLW  01
075BE:  MOVWF  01
075C0:  MOVLB  7
075C2:  BRA    78F6
....................     
....................       if (fp->flag & FA__ERROR) 
075C4:  MOVLW  1A
075C6:  MOVLB  9
075C8:  ADDWF  xB0,W
075CA:  MOVWF  FE9
075CC:  MOVLW  00
075CE:  ADDWFC xB1,W
075D0:  MOVWF  FEA
075D2:  BTFSS  FEF.7
075D4:  BRA    75E0
....................          return (FR_RW_ERROR); 
075D6:  MOVLW  07
075D8:  MOVWF  01
075DA:  MOVLB  7
075DC:  BRA    78F6
075DE:  MOVLB  9
....................     
....................       if (ofs > fp->fsize)  
075E0:  MOVLW  04
075E2:  ADDWF  xB0,W
075E4:  MOVWF  FE9
075E6:  MOVLW  00
075E8:  ADDWFC xB1,W
075EA:  MOVWF  FEA
075EC:  MOVFF  FEF,00
075F0:  MOVFF  FEC,01
075F4:  MOVFF  FEC,02
075F8:  MOVFF  FEC,03
075FC:  MOVF   03,W
075FE:  SUBWF  xB5,W
07600:  BNC   7636
07602:  BNZ   761A
07604:  MOVF   02,W
07606:  SUBWF  xB4,W
07608:  BNC   7636
0760A:  BNZ   761A
0760C:  MOVF   01,W
0760E:  SUBWF  xB3,W
07610:  BNC   7636
07612:  BNZ   761A
07614:  MOVF   xB2,W
07616:  SUBWF  00,W
07618:  BC    7636
....................          ofs = fp->fsize;               // Clip offset by file size  
0761A:  MOVLW  04
0761C:  ADDWF  xB0,W
0761E:  MOVWF  FE9
07620:  MOVLW  00
07622:  ADDWFC xB1,W
07624:  MOVWF  FEA
07626:  MOVFF  FEF,9B2
0762A:  MOVFF  FEC,9B3
0762E:  MOVFF  FEC,9B4
07632:  MOVFF  FEC,9B5
....................       fp->fptr = ofs;  
07636:  MOVFF  9B0,FE9
0763A:  MOVF   xB1,W
0763C:  MOVWF  FEA
0763E:  MOVFF  9B2,FEF
07642:  MOVFF  9B3,FEC
07646:  MOVFF  9B4,FEC
0764A:  MOVFF  9B5,FEC
....................       fp->sect_clust = 1;                // Re-initialize file pointer  
0764E:  MOVLW  1B
07650:  ADDWF  xB0,W
07652:  MOVWF  FE9
07654:  MOVLW  00
07656:  ADDWFC xB1,W
07658:  MOVWF  FEA
0765A:  MOVLW  01
0765C:  MOVWF  FEF
....................     
....................       // Seek file pointer if needed  
....................       if (ofs)  
0765E:  MOVF   xB2,F
07660:  BNZ   7670
07662:  MOVF   xB3,F
07664:  BNZ   7670
07666:  MOVF   xB4,F
07668:  BNZ   7670
0766A:  MOVF   xB5,F
0766C:  BTFSC  FD8.2
0766E:  BRA    78D4
....................          { 
....................          ofs = (ofs - 1) / 512;            // Calcurate current sector  
07670:  MOVLW  01
07672:  SUBWF  xB2,W
07674:  MOVLW  00
07676:  SUBWFB xB3,W
07678:  MOVWF  xBC
0767A:  MOVLW  00
0767C:  SUBWFB xB4,W
0767E:  MOVWF  xBD
07680:  MOVLW  00
07682:  SUBWFB xB5,W
07684:  MOVWF  xBE
07686:  BCF    FD8.0
07688:  CLRF   xB5
0768A:  RRCF   xBE,W
0768C:  MOVWF  xB4
0768E:  RRCF   xBD,W
07690:  MOVWF  xB3
07692:  RRCF   xBC,W
07694:  MOVWF  xB2
....................          sc = fs->sects_clust;            // Number of sectors in a cluster  
07696:  MOVLW  02
07698:  MOVLB  7
0769A:  ADDWF  x12,W
0769C:  MOVWF  FE9
0769E:  MOVLW  00
076A0:  ADDWFC x13,W
076A2:  MOVWF  FEA
076A4:  MOVFF  FEF,9BA
....................          fp->sect_clust = sc - (ofs % sc);      // Calcurate sector counter  
076A8:  MOVLW  1B
076AA:  MOVLB  9
076AC:  ADDWF  xB0,W
076AE:  MOVWF  01
076B0:  MOVLW  00
076B2:  ADDWFC xB1,W
076B4:  MOVWF  03
076B6:  MOVFF  01,9BB
076BA:  MOVWF  xBC
076BC:  MOVFF  FEA,9BE
076C0:  MOVFF  FE9,9BD
076C4:  BSF    FD8.1
076C6:  MOVLW  09
076C8:  MOVWF  FEA
076CA:  MOVLW  BF
076CC:  MOVWF  FE9
076CE:  CLRF   1B
076D0:  BTFSC  FF2.7
076D2:  BSF    1B.7
076D4:  BCF    FF2.7
076D6:  MOVFF  9B5,A4F
076DA:  MOVFF  9B4,A4E
076DE:  MOVFF  9B3,A4D
076E2:  MOVFF  9B2,A4C
076E6:  MOVLB  A
076E8:  CLRF   x53
076EA:  CLRF   x52
076EC:  CLRF   x51
076EE:  MOVFF  9BA,A50
076F2:  MOVLB  0
076F4:  CALL   104A
076F8:  BTFSC  1B.7
076FA:  BSF    FF2.7
076FC:  MOVFF  9BF,00
07700:  MOVFF  9C0,01
07704:  MOVFF  9C1,02
07708:  MOVFF  9C2,03
0770C:  MOVFF  9BE,FEA
07710:  MOVFF  9BD,FE9
07714:  MOVF   00,W
07716:  MOVLB  9
07718:  SUBWF  xBA,W
0771A:  MOVWF  00
0771C:  MOVLW  00
0771E:  SUBFWB 01,F
07720:  SUBFWB 02,F
07722:  SUBFWB 03,F
07724:  MOVFF  9BC,FEA
07728:  MOVFF  9BB,FE9
0772C:  MOVFF  00,FEF
....................          ofs /= sc;                  // Number of clusters to skip  
07730:  BCF    FD8.1
07732:  CLRF   1B
07734:  BTFSC  FF2.7
07736:  BSF    1B.7
07738:  BCF    FF2.7
0773A:  MOVFF  9B5,A4F
0773E:  MOVFF  9B4,A4E
07742:  MOVFF  9B3,A4D
07746:  MOVFF  9B2,A4C
0774A:  MOVLB  A
0774C:  CLRF   x53
0774E:  CLRF   x52
07750:  CLRF   x51
07752:  MOVFF  9BA,A50
07756:  MOVLB  0
07758:  CALL   104A
0775C:  BTFSC  1B.7
0775E:  BSF    FF2.7
07760:  MOVFF  03,9B5
07764:  MOVFF  02,9B4
07768:  MOVFF  01,9B3
0776C:  MOVFF  00,9B2
....................          clust = fp->org_clust;            // Seek to current cluster  
07770:  MOVLW  08
07772:  MOVLB  9
07774:  ADDWF  xB0,W
07776:  MOVWF  FE9
07778:  MOVLW  00
0777A:  ADDWFC xB1,W
0777C:  MOVWF  FEA
0777E:  MOVFF  FEF,9B6
07782:  MOVFF  FEC,9B7
07786:  MOVFF  FEC,9B8
0778A:  MOVFF  FEC,9B9
....................     
....................          while (ofs--) 
0778E:  MOVFF  9B5,03
07792:  MOVFF  9B4,02
07796:  MOVFF  9B3,01
0779A:  MOVFF  9B2,00
0779E:  MOVLW  FF
077A0:  ADDWF  xB2,F
077A2:  BTFSS  FD8.0
077A4:  ADDWF  xB3,F
077A6:  BTFSS  FD8.0
077A8:  ADDWF  xB4,F
077AA:  BTFSS  FD8.0
077AC:  ADDWF  xB5,F
077AE:  MOVF   00,F
077B0:  BNZ   77BE
077B2:  MOVF   01,F
077B4:  BNZ   77BE
077B6:  MOVF   02,F
077B8:  BNZ   77BE
077BA:  MOVF   03,F
077BC:  BZ    77E8
....................             clust = get_cluster(clust); 
077BE:  MOVFF  9B9,9FF
077C2:  MOVFF  9B8,9FE
077C6:  MOVFF  9B7,9FD
077CA:  MOVFF  9B6,9FC
077CE:  MOVLB  0
077D0:  CALL   5CAE
077D4:  MOVFF  03,9B9
077D8:  MOVFF  02,9B8
077DC:  MOVFF  01,9B7
077E0:  MOVFF  00,9B6
077E4:  MOVLB  9
077E6:  BRA    778E
....................     
....................          if ((clust < 2) || (clust >= fs->max_clust))  
077E8:  MOVF   xB9,F
077EA:  BNZ   77FA
077EC:  MOVF   xB8,F
077EE:  BNZ   77FA
077F0:  MOVF   xB7,F
077F2:  BNZ   77FA
077F4:  MOVF   xB6,W
077F6:  SUBLW  01
077F8:  BC    7838
077FA:  MOVLW  0C
077FC:  MOVLB  7
077FE:  ADDWF  x12,W
07800:  MOVWF  FE9
07802:  MOVLW  00
07804:  ADDWFC x13,W
07806:  MOVWF  FEA
07808:  MOVFF  FEF,00
0780C:  MOVFF  FEC,01
07810:  MOVFF  FEC,02
07814:  MOVFF  FEC,03
07818:  MOVF   03,W
0781A:  MOVLB  9
0781C:  SUBWF  xB9,W
0781E:  BNC   783A
07820:  BNZ   7838
07822:  MOVF   02,W
07824:  SUBWF  xB8,W
07826:  BNC   783A
07828:  BNZ   7838
0782A:  MOVF   01,W
0782C:  SUBWF  xB7,W
0782E:  BNC   783A
07830:  BNZ   7838
07832:  MOVF   00,W
07834:  SUBWF  xB6,W
07836:  BNC   783A
....................             goto fk_error; 
07838:  BRA    78DE
....................     
....................          fp->curr_clust = clust; 
0783A:  MOVLW  0C
0783C:  ADDWF  xB0,W
0783E:  MOVWF  FE9
07840:  MOVLW  00
07842:  ADDWFC xB1,W
07844:  MOVWF  FEA
07846:  MOVFF  9B6,FEF
0784A:  MOVFF  9B7,FEC
0784E:  MOVFF  9B8,FEC
07852:  MOVFF  9B9,FEC
....................          fp->curr_sect = clust2sect(clust) + sc - fp->sect_clust;   // Current sector  
07856:  MOVLW  10
07858:  ADDWF  xB0,W
0785A:  MOVWF  01
0785C:  MOVLW  00
0785E:  ADDWFC xB1,W
07860:  MOVWF  03
07862:  MOVFF  01,9BB
07866:  MOVWF  xBC
07868:  MOVFF  9B9,9F2
0786C:  MOVFF  9B8,9F1
07870:  MOVFF  9B7,9F0
07874:  MOVFF  9B6,9EF
07878:  MOVLB  0
0787A:  CALL   5602
0787E:  MOVFF  03,9C0
07882:  MOVFF  02,9BF
07886:  MOVFF  01,9BE
0788A:  MOVFF  00,9BD
0788E:  MOVLB  9
07890:  MOVF   xBA,W
07892:  ADDWF  xBD,F
07894:  MOVLW  00
07896:  ADDWFC xBE,F
07898:  ADDWFC xBF,F
0789A:  ADDWFC xC0,F
0789C:  MOVLW  1B
0789E:  ADDWF  xB0,W
078A0:  MOVWF  FE9
078A2:  MOVLW  00
078A4:  ADDWFC xB1,W
078A6:  MOVWF  FEA
078A8:  MOVF   FEF,W
078AA:  SUBWF  xBD,W
078AC:  MOVWF  00
078AE:  MOVLW  00
078B0:  SUBWFB xBE,W
078B2:  MOVWF  01
078B4:  MOVLW  00
078B6:  SUBWFB xBF,W
078B8:  MOVWF  02
078BA:  MOVLW  00
078BC:  SUBWFB xC0,W
078BE:  MOVFF  9BC,FEA
078C2:  MOVFF  9BB,FE9
078C6:  MOVFF  00,FEF
078CA:  MOVFF  01,FEC
078CE:  MOVFF  02,FEC
078D2:  MOVWF  FEC
....................          } 
....................       return (FR_OK); 
078D4:  MOVLW  00
078D6:  MOVWF  01
078D8:  MOVLB  7
078DA:  BRA    78F6
078DC:  MOVLB  9
....................     
....................    fk_error:   // Abort this file due to an unrecoverable error  
....................       fp->flag |= FA__ERROR; 
078DE:  MOVLW  1A
078E0:  ADDWF  xB0,W
078E2:  MOVWF  FE9
078E4:  MOVLW  00
078E6:  ADDWFC xB1,W
078E8:  MOVWF  FEA
078EA:  MOVF   FEF,W
078EC:  IORLW  80
078EE:  MOVWF  FEF
....................       return (FR_RW_ERROR); 
078F0:  MOVLW  07
078F2:  MOVWF  01
078F4:  MOVLB  7
078F6:  MOVLB  0
078F8:  GOTO   837A (RETURN)
....................       } 
....................     
....................      
.................... #ifndef _FS_READONLY 
.................... FRESULT f_append(char *fname) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    // Opens the data file passed in fname. If the file does not exist then it 
....................    //  is created, if the file exists then the file is appended 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FRESULT result;       // file system result code 
....................    FIL fdata; 
....................      
....................    // open the file - if it does not already exist, then create the file 
....................    result = f_open(&fdata, fname, FA_OPEN_ALWAYS | FA_WRITE); 
....................      
....................    // if the file already exists then append to the end of the file 
....................    if (!result) 
....................    { 
....................       if (fdata.fsize != 0) 
....................          result = f_lseek(&fdata, fdata.fsize); 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... FRESULT f_sync (FIL *fp) 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Synchronize between File and Disk without Close  
....................    // 
....................    //   Entry: 
....................    //      *fp      Pointer to the file object 
....................    /////////////////////////////////////////////////////////////////////////// 
....................    //   Return Values 
....................    //   FR_OK (0) 
....................    //      The function succeeded 
....................    // 
....................    //   FR_RW_ERROR 
....................    //      Low level media access error 
....................    // 
....................    //   FR_INCORRECT_DISK_CHANGE 
....................    //      Incorrect disk removal/change has occured 
....................    // 
....................    //   FR_NOT_ENABLED 
....................    //      FatFs module is not enabled 
....................    /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    BYTE *ptr; 
....................  
....................    if (!fs) 
*
080BE:  MOVLB  7
080C0:  MOVF   x12,W
080C2:  IORWF  x13,W
080C4:  BNZ   80CC
....................       return (FR_NOT_ENABLED); 
080C6:  MOVLW  0B
080C8:  MOVWF  01
080CA:  BRA    829A
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
080CC:  MOVLB  0
080CE:  CALL   5592
080D2:  BTFSC  01.0
080D4:  BRA    80E6
080D6:  MOVLB  7
080D8:  MOVFF  712,FE9
080DC:  MOVFF  713,FEA
080E0:  MOVF   FEF,F
080E2:  BNZ   80EE
080E4:  MOVLB  0
....................       return (FR_INCORRECT_DISK_CHANGE); 
080E6:  MOVLW  09
080E8:  MOVWF  01
080EA:  MOVLB  7
080EC:  BRA    829A
....................  
....................    // Has the file been written?  
....................    if (fp->flag & FA__WRITTEN) 
080EE:  MOVLW  1A
080F0:  MOVLB  9
080F2:  ADDWF  xB3,W
080F4:  MOVWF  FE9
080F6:  MOVLW  00
080F8:  ADDWFC xB4,W
080FA:  MOVWF  FEA
080FC:  BTFSS  FEF.5
080FE:  BRA    8276
....................    { 
....................       // Update the directory entry 
....................       if (!move_window(fp->dir_sect)) 
08100:  MOVLW  14
08102:  ADDWF  xB3,W
08104:  MOVWF  FE9
08106:  MOVLW  00
08108:  ADDWFC xB4,W
0810A:  MOVWF  FEA
0810C:  MOVFF  FEF,A14
08110:  MOVFF  FEC,A15
08114:  MOVFF  FEC,A16
08118:  MOVFF  FEC,A17
0811C:  MOVLB  0
0811E:  CALL   5A76
08122:  MOVF   01,F
08124:  BNZ   8130
....................          return (FR_RW_ERROR); 
08126:  MOVLW  07
08128:  MOVWF  01
0812A:  MOVLB  7
0812C:  BRA    829A
0812E:  MOVLB  0
....................       ptr = fp->dir_ptr; 
08130:  MOVLW  18
08132:  MOVLB  9
08134:  ADDWF  xB3,W
08136:  MOVWF  FE9
08138:  MOVLW  00
0813A:  ADDWFC xB4,W
0813C:  MOVWF  FEA
0813E:  MOVFF  FEC,9B6
08142:  MOVF   FED,F
08144:  MOVFF  FEF,9B5
....................       *(ptr+11) |= AM_ARC;                   // Set archive bit  
08148:  MOVLW  0B
0814A:  ADDWF  xB5,W
0814C:  MOVWF  01
0814E:  MOVLW  00
08150:  ADDWFC xB6,W
08152:  MOVFF  01,FE9
08156:  MOVWF  FEA
08158:  MOVF   FEF,W
0815A:  IORLW  20
0815C:  MOVWF  FEF
....................       ST_DWORD(ptr+28, fp->fsize);           // Update file size  
0815E:  MOVLW  1C
08160:  ADDWF  xB5,W
08162:  MOVWF  01
08164:  MOVLW  00
08166:  ADDWFC xB6,W
08168:  MOVWF  03
0816A:  MOVFF  01,9B7
0816E:  MOVWF  xB8
08170:  MOVLW  04
08172:  ADDWF  xB3,W
08174:  MOVWF  FE9
08176:  MOVLW  00
08178:  ADDWFC xB4,W
0817A:  MOVWF  FEA
0817C:  MOVFF  FEF,00
08180:  MOVFF  FEC,01
08184:  MOVFF  FEC,02
08188:  MOVFF  FEC,03
0818C:  MOVFF  9B8,FEA
08190:  MOVFF  9B7,FE9
08194:  MOVFF  00,FEF
08198:  MOVFF  01,FEC
0819C:  MOVFF  02,FEC
081A0:  MOVFF  03,FEC
....................       ST_WORD(ptr+26, fp->org_clust);        // Update start cluster  
081A4:  MOVLW  1A
081A6:  ADDWF  xB5,W
081A8:  MOVWF  01
081AA:  MOVLW  00
081AC:  ADDWFC xB6,W
081AE:  MOVWF  03
081B0:  MOVFF  01,9B7
081B4:  MOVWF  xB8
081B6:  MOVLW  08
081B8:  ADDWF  xB3,W
081BA:  MOVWF  FE9
081BC:  MOVLW  00
081BE:  ADDWFC xB4,W
081C0:  MOVWF  FEA
081C2:  MOVFF  FEF,00
081C6:  MOVFF  FEC,01
081CA:  MOVFF  FEC,02
081CE:  MOVFF  FEC,03
081D2:  MOVFF  9B8,FEA
081D6:  MOVFF  9B7,FE9
081DA:  MOVFF  00,FEF
081DE:  MOVFF  01,FEC
....................       ST_WORD(ptr+20, fp->org_clust >> 16); 
081E2:  MOVLW  14
081E4:  ADDWF  xB5,W
081E6:  MOVWF  01
081E8:  MOVLW  00
081EA:  ADDWFC xB6,W
081EC:  MOVWF  03
081EE:  MOVFF  01,9B7
081F2:  MOVWF  xB8
081F4:  MOVLW  08
081F6:  ADDWF  xB3,W
081F8:  MOVWF  FE9
081FA:  MOVLW  00
081FC:  ADDWFC xB4,W
081FE:  MOVWF  FEA
08200:  MOVFF  FEF,9B9
08204:  MOVFF  FEC,9BA
08208:  MOVFF  FEC,00
0820C:  MOVFF  FEC,01
08210:  MOVFF  9B8,FEA
08214:  MOVFF  9B7,FE9
08218:  MOVFF  00,FEF
0821C:  MOVFF  01,FEC
....................       ST_DWORD(ptr+22, get_fattime());       // Updated time  
08220:  MOVLW  16
08222:  ADDWF  xB5,W
08224:  MOVWF  01
08226:  MOVLW  00
08228:  ADDWFC xB6,W
0822A:  MOVWF  03
0822C:  MOVFF  01,9B7
08230:  MOVWF  xB8
08232:  MOVLB  0
08234:  CALL   6FDC
08238:  MOVFF  9B8,FEA
0823C:  MOVFF  9B7,FE9
08240:  MOVFF  00,FEF
08244:  MOVFF  01,FEC
08248:  MOVFF  02,FEC
0824C:  MOVFF  03,FEC
....................       fs->winflag = 1; 
08250:  MOVLW  06
08252:  MOVLB  7
08254:  ADDWF  x12,W
08256:  MOVWF  FE9
08258:  MOVLW  00
0825A:  ADDWFC x13,W
0825C:  MOVWF  FEA
0825E:  MOVLW  01
08260:  MOVWF  FEF
....................       fp->flag &= ~FA__WRITTEN; 
08262:  MOVLW  1A
08264:  MOVLB  9
08266:  ADDWF  xB3,W
08268:  MOVWF  FE9
0826A:  MOVLW  00
0826C:  ADDWFC xB4,W
0826E:  MOVWF  FEA
08270:  MOVF   FEF,W
08272:  ANDLW  DF
08274:  MOVWF  FEF
....................    } 
....................  
....................    if (!move_window(0))  
08276:  MOVLB  A
08278:  CLRF   x17
0827A:  CLRF   x16
0827C:  CLRF   x15
0827E:  CLRF   x14
08280:  MOVLB  0
08282:  CALL   5A76
08286:  MOVF   01,F
08288:  BNZ   8294
....................       return (FR_RW_ERROR); 
0828A:  MOVLW  07
0828C:  MOVWF  01
0828E:  MOVLB  7
08290:  BRA    829A
08292:  MOVLB  0
....................  
....................    return (FR_OK); 
08294:  MOVLW  00
08296:  MOVWF  01
08298:  MOVLB  7
0829A:  MOVLB  0
0829C:  GOTO   82AA (RETURN)
.................... } 
....................        
.................... #endif // _FS_READONLY  
....................  
.................... FRESULT f_close (FIL *fp) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Close a file 
.................... // 
.................... //   Entry: 
.................... //      *fp      Pointer to the file object to be closed  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The file has been sucessfully closed 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................  
....................    #ifndef _FS_READONLY 
....................       res = f_sync(fp); 
082A0:  MOVFF  9B1,9B4
082A4:  MOVFF  9B0,9B3
082A8:  BRA    80BE
082AA:  MOVFF  01,9B2
....................    #else 
....................       res = FR_OK; 
....................    #endif 
....................  
....................    if (res == FR_OK)  
082AE:  MOVLB  9
082B0:  MOVF   xB2,F
082B2:  BNZ   82E4
....................       { 
....................       fp->flag = 0; 
082B4:  MOVLW  1A
082B6:  ADDWF  xB0,W
082B8:  MOVWF  FE9
082BA:  MOVLW  00
082BC:  ADDWFC xB1,W
082BE:  MOVWF  FEA
082C0:  CLRF   FEF
....................       if (fs->files) 
082C2:  MOVLW  01
082C4:  MOVLB  7
082C6:  ADDWF  x12,W
082C8:  MOVWF  FE9
082CA:  MOVLW  00
082CC:  ADDWFC x13,W
082CE:  MOVWF  FEA
082D0:  MOVF   FEF,F
082D2:  BZ    82E2
....................          fs->files--; 
082D4:  MOVLW  01
082D6:  ADDWF  x12,W
082D8:  MOVWF  FE9
082DA:  MOVLW  00
082DC:  ADDWFC x13,W
082DE:  MOVWF  FEA
082E0:  DECF   FEF,F
082E2:  MOVLB  9
....................       } 
....................    return (res); 
082E4:  MOVFF  9B2,01
082E8:  MOVLB  0
082EA:  RETURN 0
....................    } 
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_unlink (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Delete a file or directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the file or directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. The file or directory has a read only attribue or the 
.................... //      directory is not empty. 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *sdir; 
....................    DWORD dclust, dsect; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    res = check_mounted(); 
*
0BC92:  CALL   55A0
0BC96:  MOVFF  01,88B
....................    if (res != FR_OK)  
0BC9A:  MOVLB  8
0BC9C:  MOVF   x8B,F
0BC9E:  BZ    BCA6
....................       return (res); 
0BCA0:  MOVFF  88B,01
0BCA4:  BRA    BF36
....................  
....................    if (disk_status() & STA_PROTECT) 
0BCA6:  MOVLB  0
0BCA8:  CALL   5592
0BCAC:  BTFSS  01.2
0BCAE:  BRA    BCBA
....................       return (FR_WRITE_PROTECTED); 
0BCB0:  MOVLW  0A
0BCB2:  MOVWF  01
0BCB4:  MOVLB  8
0BCB6:  BRA    BF36
0BCB8:  MOVLB  0
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
0BCBA:  MOVLW  08
0BCBC:  MOVLB  9
0BCBE:  MOVWF  xD7
0BCC0:  MOVLW  98
0BCC2:  MOVWF  xD6
0BCC4:  MOVLW  08
0BCC6:  MOVWF  xD9
0BCC8:  MOVLW  A6
0BCCA:  MOVWF  xD8
0BCCC:  MOVFF  88A,9DB
0BCD0:  MOVFF  889,9DA
0BCD4:  MOVLW  08
0BCD6:  MOVWF  xDD
0BCD8:  MOVLW  8C
0BCDA:  MOVWF  xDC
0BCDC:  MOVLB  0
0BCDE:  CALL   61D6
0BCE2:  MOVFF  01,88B
....................  
....................    if (res != FR_OK)  
0BCE6:  MOVLB  8
0BCE8:  MOVF   x8B,F
0BCEA:  BZ    BCF2
....................       return (res);            // Trace failed  
0BCEC:  MOVFF  88B,01
0BCF0:  BRA    BF36
....................  
....................    if (dir_ptr == NULL)  
0BCF2:  MOVF   x8C,F
0BCF4:  BNZ   BD00
0BCF6:  MOVF   x8D,F
0BCF8:  BNZ   BD00
....................       return (FR_NO_FILE);      // It is a root directory  
0BCFA:  MOVLW  02
0BCFC:  MOVWF  01
0BCFE:  BRA    BF36
....................  
....................    if (*(dir_ptr+11) & AM_RDO)  
0BD00:  MOVLW  0B
0BD02:  ADDWF  x8C,W
0BD04:  MOVWF  01
0BD06:  MOVLW  00
0BD08:  ADDWFC x8D,W
0BD0A:  MOVWF  03
0BD0C:  MOVFF  01,FE9
0BD10:  MOVWF  FEA
0BD12:  BTFSS  FEF.0
0BD14:  BRA    BD1C
....................       return (FR_DENIED);         // It is a R/O item  
0BD16:  MOVLW  05
0BD18:  MOVWF  01
0BD1A:  BRA    BF36
....................  
....................    dsect = fs->winsect; 
0BD1C:  MOVLW  20
0BD1E:  MOVLB  7
0BD20:  ADDWF  x12,W
0BD22:  MOVWF  FE9
0BD24:  MOVLW  00
0BD26:  ADDWFC x13,W
0BD28:  MOVWF  FEA
0BD2A:  MOVFF  FEF,894
0BD2E:  MOVFF  FEC,895
0BD32:  MOVFF  FEC,896
0BD36:  MOVFF  FEC,897
....................    dclust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
0BD3A:  MOVLW  14
0BD3C:  MOVLB  8
0BD3E:  ADDWF  x8C,W
0BD40:  MOVWF  01
0BD42:  MOVLW  00
0BD44:  ADDWFC x8D,W
0BD46:  MOVWF  03
0BD48:  MOVFF  01,FE9
0BD4C:  MOVWF  FEA
0BD4E:  MOVFF  FEC,893
0BD52:  MOVF   FED,F
0BD54:  MOVFF  FEF,8B2
0BD58:  MOVFF  8B2,892
0BD5C:  CLRF   xB2
0BD5E:  CLRF   xB3
0BD60:  MOVLW  1A
0BD62:  ADDWF  x8C,W
0BD64:  MOVWF  01
0BD66:  MOVLW  00
0BD68:  ADDWFC x8D,W
0BD6A:  MOVFF  01,FE9
0BD6E:  MOVWF  FEA
0BD70:  MOVFF  FEC,03
0BD74:  MOVF   FED,F
0BD76:  MOVF   FEF,W
0BD78:  IORWF  xB2,W
0BD7A:  MOVWF  x90
0BD7C:  MOVF   03,W
0BD7E:  IORWF  xB3,W
0BD80:  MOVWF  x91
....................  
....................    if (*(dir_ptr+11) & AM_DIR)  
0BD82:  MOVLW  0B
0BD84:  ADDWF  x8C,W
0BD86:  MOVWF  01
0BD88:  MOVLW  00
0BD8A:  ADDWFC x8D,W
0BD8C:  MOVWF  03
0BD8E:  MOVFF  01,FE9
0BD92:  MOVWF  FEA
0BD94:  BTFSS  FEF.4
0BD96:  BRA    BEAA
....................       {   // It is a sub-directory  
....................       dirscan.clust = dclust;               // Check if the sub-dir is empty or not  
0BD98:  MOVFF  893,89F
0BD9C:  MOVFF  892,89E
0BDA0:  MOVFF  891,89D
0BDA4:  MOVFF  890,89C
....................       dirscan.sect = clust2sect(dclust); 
0BDA8:  MOVFF  893,9F2
0BDAC:  MOVFF  892,9F1
0BDB0:  MOVFF  891,9F0
0BDB4:  MOVFF  890,9EF
0BDB8:  MOVLB  0
0BDBA:  CALL   5602
0BDBE:  MOVFF  03,8A3
0BDC2:  MOVFF  02,8A2
0BDC6:  MOVFF  01,8A1
0BDCA:  MOVFF  00,8A0
....................       dirscan.index = 0; 
0BDCE:  MOVLB  8
0BDD0:  CLRF   xA5
0BDD2:  CLRF   xA4
....................       do  
....................          { 
....................          if (!move_window(dirscan.sect)) 
0BDD4:  MOVFF  8A3,A17
0BDD8:  MOVFF  8A2,A16
0BDDC:  MOVFF  8A1,A15
0BDE0:  MOVFF  8A0,A14
0BDE4:  MOVLB  0
0BDE6:  CALL   5A76
0BDEA:  MOVF   01,F
0BDEC:  BNZ   BDF8
....................             return (FR_RW_ERROR); 
0BDEE:  MOVLW  07
0BDF0:  MOVWF  01
0BDF2:  MOVLB  8
0BDF4:  BRA    BF36
0BDF6:  MOVLB  0
....................          sdir = &(fs->win[(dirscan.index & 15) * 32]); 
0BDF8:  MOVLB  8
0BDFA:  MOVF   xA4,W
0BDFC:  ANDLW  0F
0BDFE:  MOVWF  xB2
0BE00:  CLRF   xB3
0BE02:  RLCF   xB2,F
0BE04:  RLCF   xB3,F
0BE06:  RLCF   xB2,F
0BE08:  RLCF   xB3,F
0BE0A:  RLCF   xB2,F
0BE0C:  RLCF   xB3,F
0BE0E:  RLCF   xB2,F
0BE10:  RLCF   xB3,F
0BE12:  RLCF   xB2,F
0BE14:  RLCF   xB3,F
0BE16:  MOVLW  E0
0BE18:  ANDWF  xB2,F
0BE1A:  MOVLW  24
0BE1C:  ADDWF  xB2,W
0BE1E:  MOVWF  01
0BE20:  MOVLW  00
0BE22:  ADDWFC xB3,W
0BE24:  MOVWF  03
0BE26:  MOVF   01,W
0BE28:  MOVLB  7
0BE2A:  ADDWF  x12,W
0BE2C:  MOVWF  01
0BE2E:  MOVF   x13,W
0BE30:  ADDWFC 03,F
0BE32:  MOVFF  01,88E
0BE36:  MOVLB  8
0BE38:  MOVFF  03,88F
....................          if (*sdir == 0) 
0BE3C:  MOVFF  88F,03
0BE40:  MOVFF  88E,FE9
0BE44:  MOVFF  88F,FEA
0BE48:  MOVF   FEF,F
0BE4A:  BNZ   BE4E
....................             break; 
0BE4C:  BRA    BEAA
....................  
....................          if (!((*sdir == 0xE5) || (*sdir == '.')) && !(*(sdir+11) & AM_VOL)) 
0BE4E:  MOVFF  88F,03
0BE52:  MOVFF  88E,FE9
0BE56:  MOVFF  88F,FEA
0BE5A:  MOVF   FEF,W
0BE5C:  SUBLW  E5
0BE5E:  BZ    BE8E
0BE60:  MOVFF  88F,03
0BE64:  MOVFF  88E,FE9
0BE68:  MOVFF  88F,FEA
0BE6C:  MOVF   FEF,W
0BE6E:  SUBLW  2E
0BE70:  BZ    BE8E
0BE72:  MOVLW  0B
0BE74:  ADDWF  x8E,W
0BE76:  MOVWF  01
0BE78:  MOVLW  00
0BE7A:  ADDWFC x8F,W
0BE7C:  MOVWF  03
0BE7E:  MOVFF  01,FE9
0BE82:  MOVWF  FEA
0BE84:  BTFSC  FEF.3
0BE86:  BRA    BE8E
....................             return (FR_DENIED);   // The directory is not empty  
0BE88:  MOVLW  05
0BE8A:  MOVWF  01
0BE8C:  BRA    BF36
....................          } while (next_dir_ptr(&dirscan)); 
0BE8E:  MOVLW  08
0BE90:  MOVLB  9
0BE92:  MOVWF  xE6
0BE94:  MOVLW  98
0BE96:  MOVWF  xE5
0BE98:  MOVLB  0
0BE9A:  CALL   5FFC
0BE9E:  MOVF   01,F
0BEA0:  BTFSC  FD8.2
0BEA2:  BRA    BEA8
0BEA4:  MOVLB  8
0BEA6:  BRA    BDD4
0BEA8:  MOVLB  8
....................       } 
....................  
....................    if (!move_window(dsect)) 
0BEAA:  MOVFF  897,A17
0BEAE:  MOVFF  896,A16
0BEB2:  MOVFF  895,A15
0BEB6:  MOVFF  894,A14
0BEBA:  MOVLB  0
0BEBC:  CALL   5A76
0BEC0:  MOVF   01,F
0BEC2:  BNZ   BECE
....................       return (FR_RW_ERROR);   // Mark the directory entry 'deleted'  
0BEC4:  MOVLW  07
0BEC6:  MOVWF  01
0BEC8:  MOVLB  8
0BECA:  BRA    BF36
0BECC:  MOVLB  0
....................  
....................    *dir_ptr = 0xE5;  
0BECE:  MOVLB  8
0BED0:  MOVFF  88C,FE9
0BED4:  MOVFF  88D,FEA
0BED8:  MOVLW  E5
0BEDA:  MOVWF  FEF
....................    fs->winflag = 1; 
0BEDC:  MOVLW  06
0BEDE:  MOVLB  7
0BEE0:  ADDWF  x12,W
0BEE2:  MOVWF  FE9
0BEE4:  MOVLW  00
0BEE6:  ADDWFC x13,W
0BEE8:  MOVWF  FEA
0BEEA:  MOVLW  01
0BEEC:  MOVWF  FEF
....................    if (!remove_chain(dclust))  
0BEEE:  MOVFF  893,9DE
0BEF2:  MOVFF  892,9DD
0BEF6:  MOVFF  891,9DC
0BEFA:  MOVFF  890,9DB
0BEFE:  MOVLB  0
0BF00:  CALL   6F3A
0BF04:  MOVF   01,F
0BF06:  BNZ   BF12
....................       return (FR_RW_ERROR);   // Remove the cluster chain  
0BF08:  MOVLW  07
0BF0A:  MOVWF  01
0BF0C:  MOVLB  8
0BF0E:  BRA    BF36
0BF10:  MOVLB  0
....................  
....................    if (!move_window(0))  
0BF12:  MOVLB  A
0BF14:  CLRF   x17
0BF16:  CLRF   x16
0BF18:  CLRF   x15
0BF1A:  CLRF   x14
0BF1C:  MOVLB  0
0BF1E:  CALL   5A76
0BF22:  MOVF   01,F
0BF24:  BNZ   BF30
....................       return (FR_RW_ERROR); 
0BF26:  MOVLW  07
0BF28:  MOVWF  01
0BF2A:  MOVLB  8
0BF2C:  BRA    BF36
0BF2E:  MOVLB  0
....................  
....................    return (FR_OK); 
0BF30:  MOVLW  00
0BF32:  MOVWF  01
0BF34:  MOVLB  8
0BF36:  MOVLB  0
0BF38:  RETURN 0
....................    } 
.................... #endif // _FS_READONLY  
....................  
.................... #ifndef _FS_READONLY 
.................... FRESULT f_mkdir (char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Create a directory 
.................... // 
.................... //   Entry: 
.................... //      path      Pointer to the directory path  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_DENIED 
.................... //      File Access Denied. File or directoy already exists or the 
.................... //         directory or disk is full 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT res; 
....................    BYTE *dir_ptr, *w, n; 
....................    DWORD sect, dsect, dclust, pclust, tim; 
....................    DIR dirscan; 
....................    char fn[8+3+1]; 
....................  
....................    // check if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    if (disk_status() & STA_PROTECT) 
....................       return (FR_WRITE_PROTECTED); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);   // Trace the file path  
....................  
....................    if (res == FR_OK)  
....................       return (FR_DENIED);      // Any file or directory is already existing  
....................  
....................    if (res != FR_NO_FILE)  
....................       return (res); 
....................  
....................    dir_ptr = reserve_direntry(&dirscan);      // Reserve a directory entry  
....................    if (dir_ptr == NULL)  
....................       return (FR_DENIED); 
....................  
....................    sect = fs->winsect; 
....................    dsect = clust2sect(dclust = create_chain(0));   // Get a new cluster for new directory  
....................  
....................    if (!dsect)  
....................       return (FR_DENIED); 
....................  
....................    if (!move_window(0))  
....................       return (0); 
....................  
....................    w = fs->win; 
....................    memset(w, 0, 512);                  // Initialize the directory table  
....................    for (n = fs->sects_clust - 1; n; n--)  
....................       { 
....................       if (disk_write(w, dsect+n, 1) != RES_OK)  
....................          return (FR_RW_ERROR); 
....................       } 
....................  
....................    fs->winsect = dsect;               // Create dot directories  
....................    memset(w, ' ', 8+3); 
....................    *w = '.'; 
....................    *(w+11) = AM_DIR; 
....................    tim = get_fattime(); 
....................    ST_DWORD(w+22, tim); 
....................  
....................    ST_WORD(w+26, dclust); 
....................    ST_WORD(w+20, dclust >> 16); 
....................    memcpy(w+32, w, 32); *(w+33) = '.'; 
....................    pclust = dirscan.sclust; 
....................    if (fs->fs_type == FS_FAT32 && pclust == fs->dirbase) pclust = 0; 
....................    ST_WORD(w+32+26, pclust); 
....................    ST_WORD(w+32+20, pclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(sect))  
....................       return (FR_RW_ERROR); 
....................  
....................    memcpy(dir_ptr, fn, 8+3);         // Initialize the new entry  
....................    *(dir_ptr+11) = AM_DIR; 
....................    *(dir_ptr+12) = fn[11]; 
....................    memset(dir_ptr+13, 0, 32-13); 
....................    ST_DWORD(dir_ptr+22, tim);         // Crated time  
....................    ST_WORD(dir_ptr+26, dclust);      // Table start cluster  
....................    ST_WORD(dir_ptr+20, dclust >> 16); 
....................    fs->winflag = 1; 
....................  
....................    if (!move_window(0))  
....................       return (FR_RW_ERROR); 
....................  
....................    return (FR_OK); 
....................    } 
.................... #endif // _FS_READONLY  
....................  
....................  
....................  
.................... FRESULT f_opendir (DIR *scan, char *path) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Open directory. Checks and, if necessary mounts the media. 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object to initialize 
.................... //      *path      Pointer to the directory path, null str means the root 
.................... //      SD_CS      don't care  
.................... // 
.................... // Note: The directory separator is '/'. Because the FatFs module does not  
.................... // have a concept of current directory, a full-path name that followed from 
.................... // the root directory must be used. Leading space charactors are skipped if  
.................... // exist and heading '/' can be exist or omitted. The target directory name  
.................... // cannot be followed by a '/'. When open the root directory, specify "" or "/" 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    FRESULT result; 
....................    BYTE *dir_ptr; 
....................    char fn[8+3+1]; 
....................  
....................    result = check_mounted(); 
....................    if (result != FR_OK)  
....................       return (result); 
....................  
....................    result = trace_path(scan, fn, path, &dir_ptr);   // Trace the directory path  
....................    if (result == FR_OK)  
....................       {         // Trace completed  
....................       if (dir_ptr != NULL)  
....................          {      // It is not a root dir  
....................          if (*(dir_ptr+11) & AM_DIR)  
....................             {      // The entry is a directory  
....................             scan->clust = ((DWORD)LD_WORD(dir_ptr+20) << 16) | LD_WORD(dir_ptr+26); 
....................             scan->sect = clust2sect(scan->clust); 
....................             scan->index = 0; 
....................             }  
....................          else  
....................             {   // The entry is a file  
....................             result = FR_NO_PATH; 
....................             } 
....................          } 
....................       } 
....................    return (result); 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_readdir ( DIR *scan, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Read Directory Entry in Sequense 
.................... // 
.................... //   Entry: 
.................... //      *scan      Pointer to the directory object 
.................... //      *finfo      Pointer to file information to return 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded. The FileObject structure is used for subsequent  
.................... //      calls to refer to the file. Use function f_close() to close 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    BYTE *dir_ptr, c; 
....................  
....................    if (!fs)  
....................       return (FR_NOT_ENABLED); 
....................    finfo->fname[0] = 0; 
....................  
....................    if ((disk_status() & STA_NOINIT) || !fs->fs_type) 
....................       return (FR_NOT_READY); 
....................  
....................    while (scan->sect)  
....................       { 
....................       if (!move_window(scan->sect)) 
....................          return (FR_RW_ERROR); 
....................  
....................       dir_ptr = &(fs->win[(scan->index & 15) * 32]);      // pointer to the directory entry  
....................       c = *dir_ptr; 
....................       if (c == 0)    // Has it reached to end of dir?  
....................          break;          
....................  
....................       // test to ensure the entry has not been erased             
....................       if ((c != 0xE5) && (c != '.') && !(*(dir_ptr+11) & AM_VOL))   // Is it a valid entry?  
....................          get_fileinfo(finfo, dir_ptr); 
....................  
....................       if (!next_dir_ptr(scan))  
....................          scan->sect = 0;      // Next entry  
....................  
....................       if (finfo->fname[0]) 
....................          // Found valid entry 
....................           break;             
....................       } 
....................    return FR_OK; 
....................    } 
....................  
....................  
....................  
.................... FRESULT f_stat ( char *path, FILINFO *finfo) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Get the file status 
.................... // 
.................... //   Entry: 
.................... //      *path      Pointer to the file path 
.................... //      *finfo      Pointer to file information to return  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Return Values 
.................... //   FR_OK (0) 
.................... //      The function succeeded 
.................... // 
.................... //   FR_NO_FILE 
.................... //       File not found 
.................... // 
.................... //   FR_NO_PATH 
.................... //      Could not find the path. 
.................... // 
.................... //   FR_INVALID_NAME 
.................... //      Invalid Filename 
.................... // 
.................... //   FR_NOT_READY 
.................... //      Media not ready 
.................... // 
.................... //   FR_WRITE_PROTECTED 
.................... //      Attempt to open a file for write access on write protected media 
.................... // 
.................... //   FR_RW_ERROR 
.................... //      Low level media access error 
.................... // 
.................... //   FR_INCORRECT_DISK_CHANGE 
.................... //      Incorrect disk removal/change has occured 
.................... // 
.................... //   FR_NOT_ENABLED 
.................... //      FatFs module is not enabled 
.................... // 
.................... //   FR_NO_FILESYSTEM 
.................... //      No valid FAT partition on the disk. 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DIR dirscan; 
....................    FRESULT res; 
....................    BYTE *dir_ptr; 
....................  
....................    char fn[8+3+1]; 
....................  
....................    // test if the file system is mounted 
....................    res = check_mounted(); 
....................    if (res != FR_OK)  
....................       return (res); 
....................  
....................    res = trace_path(&dirscan, fn, path, &dir_ptr);      // Trace the file path  
....................    if (res == FR_OK) 
....................       { 
....................       if (dir_ptr)                
....................          get_fileinfo(finfo, dir_ptr);   // Trace completed 
....................       else 
....................          res = FR_INVALID_NAME;      // It is a root directory 
....................       } 
....................    return (res); 
....................    } 
....................  
.................... #define _FAT_FS 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... FRESULT   FS_Status; 
....................  
.................... // prototypes 
.................... char * strupr(char * source); 
.................... // @@@@ DEBUGGING PROTOTYPES @@@@ 
.................... BYTE append_data (char *target); 
....................  
.................... /* strlen modified to test strings > 256 chars long 
....................    standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0)  
.................... */ 
.................... unsigned int16 strlen16(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
079B0:  MOVFF  9B1,9B3
079B4:  MOVFF  9B0,9B2
079B8:  MOVFF  9B3,03
079BC:  MOVLB  9
079BE:  MOVFF  9B2,FE9
079C2:  MOVFF  9B3,FEA
079C6:  MOVF   FEF,F
079C8:  BZ    79D6
079CA:  INCF   xB2,F
079CC:  BTFSC  FD8.2
079CE:  INCF   xB3,F
079D0:  MOVLB  0
079D2:  BRA    79B8
079D4:  MOVLB  9
....................    return(sc - s); 
079D6:  MOVF   xB0,W
079D8:  SUBWF  xB2,W
079DA:  MOVWF  00
079DC:  MOVF   xB1,W
079DE:  SUBWFB xB3,W
079E0:  MOVWF  03
079E2:  MOVFF  00,01
079E6:  MOVWF  02
079E8:  MOVLB  0
079EA:  GOTO   8432 (RETURN)
.................... } 
....................  
.................... void init_rtc (void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // Initialise the Software RTC 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    rtc.DOY=1; 
*
034FC:  MOVLB  4
034FE:  CLRF   xE6
03500:  MOVLW  01
03502:  MOVWF  xE5
....................    rtc.year=10; 
03504:  MOVLW  0A
03506:  MOVWF  xE4
....................    rtc.month=1; 
03508:  MOVLW  01
0350A:  MOVWF  xE3
....................    rtc.day=1; 
0350C:  MOVWF  xE2
....................    rtc.hour=0; 
0350E:  CLRF   xE1
....................    rtc.min=0; 
03510:  CLRF   xE0
....................    rtc.sec=0; 
03512:  CLRF   xDF
....................    rtc.ms100=0; 
03514:  CLRF   xDE
03516:  MOVLB  0
03518:  RETURN 0
....................    } 
....................  
.................... DWORD get_fattime(void) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Platform specific user function to return a FAT time partameter 
.................... //   USed by the FAT file system 
.................... // 
.................... //   31-25: Year(0-127 +1980), 24-21: Month(1-12), 20-16: Day(1-31) 
.................... //   15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) 
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    DWORD work; 
....................  
....................    work =  ((DWORD)rtc.year + 20) << 25; 
*
06FDC:  MOVLB  9
06FDE:  CLRF   xDD
06FE0:  CLRF   xDC
06FE2:  CLRF   xDB
06FE4:  MOVFF  4E4,9DA
06FE8:  MOVLW  14
06FEA:  ADDWF  xDA,F
06FEC:  MOVLW  00
06FEE:  ADDWFC xDB,F
06FF0:  ADDWFC xDC,F
06FF2:  ADDWFC xDD,F
06FF4:  BCF    FD8.0
06FF6:  CLRF   xD6
06FF8:  CLRF   xD7
06FFA:  CLRF   xD8
06FFC:  RLCF   xDA,W
06FFE:  MOVWF  xD9
....................    work |= ((DWORD)rtc.month & 0x0f) << 21; 
07000:  CLRF   xDD
07002:  CLRF   xDC
07004:  CLRF   xDB
07006:  MOVFF  4E3,9DA
0700A:  MOVLW  0F
0700C:  ANDWF  xDA,F
0700E:  CLRF   xDB
07010:  CLRF   xDC
07012:  CLRF   xDD
07014:  CLRF   00
07016:  CLRF   01
07018:  RLCF   xDA,W
0701A:  MOVWF  02
0701C:  RLCF   xDB,W
0701E:  MOVWF  03
07020:  RLCF   02,F
07022:  RLCF   03,F
07024:  RLCF   02,F
07026:  RLCF   03,F
07028:  RLCF   02,F
0702A:  RLCF   03,F
0702C:  RLCF   02,F
0702E:  RLCF   03,F
07030:  MOVLW  E0
07032:  ANDWF  02,F
07034:  MOVF   00,W
07036:  IORWF  xD6,F
07038:  MOVF   01,W
0703A:  IORWF  xD7,F
0703C:  MOVF   02,W
0703E:  IORWF  xD8,F
07040:  MOVF   03,W
07042:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.day & 0x1f) << 16; 
07044:  CLRF   xDD
07046:  CLRF   xDC
07048:  CLRF   xDB
0704A:  MOVFF  4E2,9DA
0704E:  MOVLW  1F
07050:  ANDWF  xDA,F
07052:  CLRF   xDB
07054:  CLRF   xDC
07056:  CLRF   xDD
07058:  CLRF   00
0705A:  CLRF   01
0705C:  MOVF   00,W
0705E:  IORWF  xD6,F
07060:  MOVF   01,W
07062:  IORWF  xD7,F
07064:  MOVF   xDA,W
07066:  IORWF  xD8,F
07068:  MOVF   xDB,W
0706A:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.hour & 0x1f) << 11; 
0706C:  CLRF   xDD
0706E:  CLRF   xDC
07070:  CLRF   xDB
07072:  MOVFF  4E1,9DA
07076:  MOVLW  1F
07078:  ANDWF  xDA,F
0707A:  CLRF   xDB
0707C:  CLRF   xDC
0707E:  CLRF   xDD
07080:  CLRF   00
07082:  RLCF   xDA,W
07084:  MOVWF  01
07086:  RLCF   xDB,W
07088:  MOVWF  02
0708A:  RLCF   xDC,W
0708C:  MOVWF  03
0708E:  RLCF   01,F
07090:  RLCF   02,F
07092:  RLCF   03,F
07094:  RLCF   01,F
07096:  RLCF   02,F
07098:  RLCF   03,F
0709A:  MOVLW  F8
0709C:  ANDWF  01,F
0709E:  MOVF   00,W
070A0:  IORWF  xD6,F
070A2:  MOVF   01,W
070A4:  IORWF  xD7,F
070A6:  MOVF   02,W
070A8:  IORWF  xD8,F
070AA:  MOVF   03,W
070AC:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.min & 0x3f) << 5; 
070AE:  CLRF   xDD
070B0:  CLRF   xDC
070B2:  CLRF   xDB
070B4:  MOVFF  4E0,9DA
070B8:  MOVLW  3F
070BA:  ANDWF  xDA,F
070BC:  CLRF   xDB
070BE:  CLRF   xDC
070C0:  CLRF   xDD
070C2:  RLCF   xDA,W
070C4:  MOVWF  00
070C6:  RLCF   xDB,W
070C8:  MOVWF  01
070CA:  RLCF   xDC,W
070CC:  MOVWF  02
070CE:  RLCF   xDD,W
070D0:  MOVWF  03
070D2:  RLCF   00,F
070D4:  RLCF   01,F
070D6:  RLCF   02,F
070D8:  RLCF   03,F
070DA:  RLCF   00,F
070DC:  RLCF   01,F
070DE:  RLCF   02,F
070E0:  RLCF   03,F
070E2:  RLCF   00,F
070E4:  RLCF   01,F
070E6:  RLCF   02,F
070E8:  RLCF   03,F
070EA:  RLCF   00,F
070EC:  RLCF   01,F
070EE:  RLCF   02,F
070F0:  RLCF   03,F
070F2:  MOVLW  E0
070F4:  ANDWF  00,F
070F6:  MOVF   00,W
070F8:  IORWF  xD6,F
070FA:  MOVF   01,W
070FC:  IORWF  xD7,F
070FE:  MOVF   02,W
07100:  IORWF  xD8,F
07102:  MOVF   03,W
07104:  IORWF  xD9,F
....................    work |= ((DWORD)rtc.sec & 0x3f) >> 1; 
07106:  CLRF   xDD
07108:  CLRF   xDC
0710A:  CLRF   xDB
0710C:  MOVFF  4DF,9DA
07110:  MOVLW  3F
07112:  ANDWF  xDA,F
07114:  CLRF   xDB
07116:  CLRF   xDC
07118:  CLRF   xDD
0711A:  BCF    FD8.0
0711C:  RRCF   xDD,W
0711E:  MOVWF  03
07120:  RRCF   xDC,W
07122:  MOVWF  02
07124:  RRCF   xDB,W
07126:  MOVWF  01
07128:  RRCF   xDA,W
0712A:  IORWF  xD6,F
0712C:  MOVF   01,W
0712E:  IORWF  xD7,F
07130:  MOVF   02,W
07132:  IORWF  xD8,F
07134:  MOVF   03,W
07136:  IORWF  xD9,F
....................    return (work); 
07138:  MOVFF  9D6,00
0713C:  MOVFF  9D7,01
07140:  MOVFF  9D8,02
07144:  MOVFF  9D9,03
07148:  MOVLB  0
0714A:  RETURN 0
....................    }    
....................  
.................... void file_list(char *ptr) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Lists the contents of a text file 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fsrc; 
....................    FRESULT result;      // FatFs function common result code 
....................    char mesg[32]; 
....................  
....................    result = f_open(&fsrc, ptr, FA_OPEN_EXISTING | FA_READ); 
*
0BB18:  MOVLW  08
0BB1A:  MOVLB  9
0BB1C:  MOVWF  xB1
0BB1E:  MOVLW  8B
0BB20:  MOVWF  xB0
0BB22:  MOVFF  88A,9B3
0BB26:  MOVFF  889,9B2
0BB2A:  MOVLW  01
0BB2C:  MOVWF  xB4
0BB2E:  MOVLB  0
0BB30:  CALL   714C
0BB34:  MOVFF  01,8A7
....................  
....................     // display the contents of the file 
....................    if (result == FR_OK) 
0BB38:  MOVLB  8
0BB3A:  MOVF   xA7,F
0BB3C:  BTFSS  FD8.2
0BB3E:  BRA    BC40
....................    { 
....................       WORD i, br; 
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................  
....................       do 
....................       { 
....................          result = f_read(&fsrc, mesg, sizeof(mesg), &br); 
0BB40:  MOVLW  08
0BB42:  MOVWF  xCD
0BB44:  MOVLW  8B
0BB46:  MOVWF  xCC
0BB48:  MOVLW  08
0BB4A:  MOVWF  xCF
0BB4C:  MOVLW  A8
0BB4E:  MOVWF  xCE
0BB50:  CLRF   xD1
0BB52:  MOVLW  20
0BB54:  MOVWF  xD0
0BB56:  MOVLW  08
0BB58:  MOVWF  xD3
0BB5A:  MOVLW  CA
0BB5C:  MOVWF  xD2
0BB5E:  MOVLB  0
0BB60:  BRA    B45C
0BB62:  MOVFF  01,8A7
....................          for (i = 0; i < br; i++) 
0BB66:  MOVLB  8
0BB68:  CLRF   xC9
0BB6A:  CLRF   xC8
0BB6C:  MOVF   xC9,W
0BB6E:  SUBWF  xCB,W
0BB70:  BNC   BB9C
0BB72:  BNZ   BB7A
0BB74:  MOVF   xCA,W
0BB76:  SUBWF  xC8,W
0BB78:  BC    BB9C
....................          { 
....................             putc(mesg[i]); 
0BB7A:  MOVLW  A8
0BB7C:  ADDWF  xC8,W
0BB7E:  MOVWF  FE9
0BB80:  MOVLW  08
0BB82:  ADDWFC xC9,W
0BB84:  MOVWF  FEA
0BB86:  MOVFF  FEF,8CC
0BB8A:  MOVF   xCC,W
0BB8C:  MOVLB  0
0BB8E:  CALL   AEAC
0BB92:  MOVLB  8
0BB94:  INCF   xC8,F
0BB96:  BTFSC  FD8.2
0BB98:  INCF   xC9,F
0BB9A:  BRA    BB6C
....................          } 
....................       } while ((result == FR_OK) && br); 
0BB9C:  MOVF   xA7,F
0BB9E:  BNZ   BBA6
0BBA0:  MOVF   xCA,W
0BBA2:  IORWF  xCB,W
0BBA4:  BNZ   BB40
....................  
....................       // Display the file's FIL data structure 
....................       // f_show_FIL_structure(&fsrc); 
....................       if (result != FR_OK) 
0BBA6:  MOVF   xA7,F
0BBA8:  BZ    BC1C
....................       { 
....................          printf("TYPE command ERROR\r\n"); 
0BBAA:  MOVLW  16
0BBAC:  MOVWF  FF6
0BBAE:  MOVLW  0C
0BBB0:  MOVWF  FF7
0BBB2:  MOVLW  00
0BBB4:  MOVWF  FF8
0BBB6:  CLRF   1B
0BBB8:  BTFSC  FF2.7
0BBBA:  BSF    1B.7
0BBBC:  BCF    FF2.7
0BBBE:  MOVLB  0
0BBC0:  CALL   0E42
0BBC4:  BTFSC  1B.7
0BBC6:  BSF    FF2.7
....................          f_get_error_mesg(result,mesg); 
0BBC8:  MOVFF  8A7,8CC
0BBCC:  MOVLW  08
0BBCE:  MOVLB  8
0BBD0:  MOVWF  xCE
0BBD2:  MOVLW  A8
0BBD4:  MOVWF  xCD
0BBD6:  MOVLB  0
0BBD8:  RCALL  B96A
....................          printf("@FS: %s\r\n",mesg); 
0BBDA:  MOVLW  2C
0BBDC:  MOVWF  FF6
0BBDE:  MOVLW  0C
0BBE0:  MOVWF  FF7
0BBE2:  MOVLW  00
0BBE4:  MOVWF  FF8
0BBE6:  CLRF   1B
0BBE8:  BTFSC  FF2.7
0BBEA:  BSF    1B.7
0BBEC:  BCF    FF2.7
0BBEE:  MOVLW  05
0BBF0:  MOVLB  A
0BBF2:  MOVWF  x40
0BBF4:  MOVLB  0
0BBF6:  CALL   1018
0BBFA:  BTFSC  1B.7
0BBFC:  BSF    FF2.7
0BBFE:  MOVLW  08
0BC00:  MOVWF  FEA
0BC02:  MOVLW  A8
0BC04:  MOVWF  FE9
0BC06:  CALL   798A
0BC0A:  MOVLW  0D
0BC0C:  BTFSS  F9E.4
0BC0E:  BRA    BC0C
0BC10:  MOVWF  FAD
0BC12:  MOVLW  0A
0BC14:  BTFSS  F9E.4
0BC16:  BRA    BC14
0BC18:  MOVWF  FAD
0BC1A:  MOVLB  8
....................       } 
....................  
....................       // Close all files 
....................       f_close(&fsrc); 
0BC1C:  MOVLW  08
0BC1E:  MOVLB  9
0BC20:  MOVWF  xB1
0BC22:  MOVLW  8B
0BC24:  MOVWF  xB0
0BC26:  MOVLB  0
0BC28:  CALL   82A0
....................       printf("\r\n");       
0BC2C:  MOVLW  0D
0BC2E:  BTFSS  F9E.4
0BC30:  BRA    BC2E
0BC32:  MOVWF  FAD
0BC34:  MOVLW  0A
0BC36:  BTFSS  F9E.4
0BC38:  BRA    BC36
0BC3A:  MOVWF  FAD
....................    } 
0BC3C:  BRA    BC90
0BC3E:  MOVLB  8
....................    else 
....................    { 
....................       f_get_error_mesg(result,mesg); 
0BC40:  MOVFF  8A7,8CC
0BC44:  MOVLW  08
0BC46:  MOVWF  xCE
0BC48:  MOVLW  A8
0BC4A:  MOVWF  xCD
0BC4C:  MOVLB  0
0BC4E:  RCALL  B96A
....................       printf("@FS: %s\r\n",mesg); 
0BC50:  MOVLW  36
0BC52:  MOVWF  FF6
0BC54:  MOVLW  0C
0BC56:  MOVWF  FF7
0BC58:  MOVLW  00
0BC5A:  MOVWF  FF8
0BC5C:  CLRF   1B
0BC5E:  BTFSC  FF2.7
0BC60:  BSF    1B.7
0BC62:  BCF    FF2.7
0BC64:  MOVLW  05
0BC66:  MOVLB  A
0BC68:  MOVWF  x40
0BC6A:  MOVLB  0
0BC6C:  CALL   1018
0BC70:  BTFSC  1B.7
0BC72:  BSF    FF2.7
0BC74:  MOVLW  08
0BC76:  MOVWF  FEA
0BC78:  MOVLW  A8
0BC7A:  MOVWF  FE9
0BC7C:  CALL   798A
0BC80:  MOVLW  0D
0BC82:  BTFSS  F9E.4
0BC84:  BRA    BC82
0BC86:  MOVWF  FAD
0BC88:  MOVLW  0A
0BC8A:  BTFSS  F9E.4
0BC8C:  BRA    BC8A
0BC8E:  MOVWF  FAD
....................    } 
0BC90:  RETURN 0
.................... } 
....................  
.................... void display_file_result(FRESULT status) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Display the result of file operations  
.................... /////////////////////////////////////////////////////////////////////////// 
....................    { 
....................    printf("** @FS: ERROR\r\n"); 
*
04DE8:  MOVLW  40
04DEA:  MOVWF  FF6
04DEC:  MOVLW  0C
04DEE:  MOVWF  FF7
04DF0:  MOVLW  00
04DF2:  MOVWF  FF8
04DF4:  CLRF   1B
04DF6:  BTFSC  FF2.7
04DF8:  BSF    1B.7
04DFA:  BCF    FF2.7
04DFC:  CALL   0E42
04E00:  BTFSC  1B.7
04E02:  BSF    FF2.7
....................    if (status & FR_OK) 
04E04:  ANDLW  00
04E06:  BZ    4E24
....................       printf("   NoError\r\n"); 
04E08:  MOVLW  50
04E0A:  MOVWF  FF6
04E0C:  MOVLW  0C
04E0E:  MOVWF  FF7
04E10:  MOVLW  00
04E12:  MOVWF  FF8
04E14:  CLRF   1B
04E16:  BTFSC  FF2.7
04E18:  BSF    1B.7
04E1A:  BCF    FF2.7
04E1C:  CALL   0E42
04E20:  BTFSC  1B.7
04E22:  BSF    FF2.7
....................    if (status & FR_NOT_READY) 
04E24:  MOVLB  8
04E26:  BTFSS  x8A.0
04E28:  BRA    4E4A
....................       printf("   Media Not Ready\r\n"); 
04E2A:  MOVLW  5E
04E2C:  MOVWF  FF6
04E2E:  MOVLW  0C
04E30:  MOVWF  FF7
04E32:  MOVLW  00
04E34:  MOVWF  FF8
04E36:  CLRF   1B
04E38:  BTFSC  FF2.7
04E3A:  BSF    1B.7
04E3C:  BCF    FF2.7
04E3E:  MOVLB  0
04E40:  CALL   0E42
04E44:  BTFSC  1B.7
04E46:  BSF    FF2.7
04E48:  MOVLB  8
....................    if (status & FR_NO_FILE) 
04E4A:  BTFSS  x8A.1
04E4C:  BRA    4E6E
....................       printf("   File Not Found\r\n"); 
04E4E:  MOVLW  74
04E50:  MOVWF  FF6
04E52:  MOVLW  0C
04E54:  MOVWF  FF7
04E56:  MOVLW  00
04E58:  MOVWF  FF8
04E5A:  CLRF   1B
04E5C:  BTFSC  FF2.7
04E5E:  BSF    1B.7
04E60:  BCF    FF2.7
04E62:  MOVLB  0
04E64:  CALL   0E42
04E68:  BTFSC  1B.7
04E6A:  BSF    FF2.7
04E6C:  MOVLB  8
....................    if (status & FR_NO_PATH) 
04E6E:  MOVF   x8A,W
04E70:  ANDLW  03
04E72:  BZ    4E94
....................       printf("   Invalid Path\r\n"); 
04E74:  MOVLW  88
04E76:  MOVWF  FF6
04E78:  MOVLW  0C
04E7A:  MOVWF  FF7
04E7C:  MOVLW  00
04E7E:  MOVWF  FF8
04E80:  CLRF   1B
04E82:  BTFSC  FF2.7
04E84:  BSF    1B.7
04E86:  BCF    FF2.7
04E88:  MOVLB  0
04E8A:  CALL   0E42
04E8E:  BTFSC  1B.7
04E90:  BSF    FF2.7
04E92:  MOVLB  8
....................    if (status & FR_INVALID_NAME) 
04E94:  BTFSS  x8A.2
04E96:  BRA    4EB8
....................       printf("   Invalid Name\r\n"); 
04E98:  MOVLW  9A
04E9A:  MOVWF  FF6
04E9C:  MOVLW  0C
04E9E:  MOVWF  FF7
04EA0:  MOVLW  00
04EA2:  MOVWF  FF8
04EA4:  CLRF   1B
04EA6:  BTFSC  FF2.7
04EA8:  BSF    1B.7
04EAA:  BCF    FF2.7
04EAC:  MOVLB  0
04EAE:  CALL   0E42
04EB2:  BTFSC  1B.7
04EB4:  BSF    FF2.7
04EB6:  MOVLB  8
....................    if (status & FR_DENIED) 
04EB8:  MOVF   x8A,W
04EBA:  ANDLW  05
04EBC:  BZ    4EDE
....................       printf("   Access Denied\r\n"); 
04EBE:  MOVLW  AC
04EC0:  MOVWF  FF6
04EC2:  MOVLW  0C
04EC4:  MOVWF  FF7
04EC6:  MOVLW  00
04EC8:  MOVWF  FF8
04ECA:  CLRF   1B
04ECC:  BTFSC  FF2.7
04ECE:  BSF    1B.7
04ED0:  BCF    FF2.7
04ED2:  MOVLB  0
04ED4:  CALL   0E42
04ED8:  BTFSC  1B.7
04EDA:  BSF    FF2.7
04EDC:  MOVLB  8
....................    if (status & FR_DISK_FULL) 
04EDE:  MOVF   x8A,W
04EE0:  ANDLW  06
04EE2:  BZ    4F04
....................       printf("   Disk Full\r\n"); 
04EE4:  MOVLW  C0
04EE6:  MOVWF  FF6
04EE8:  MOVLW  0C
04EEA:  MOVWF  FF7
04EEC:  MOVLW  00
04EEE:  MOVWF  FF8
04EF0:  CLRF   1B
04EF2:  BTFSC  FF2.7
04EF4:  BSF    1B.7
04EF6:  BCF    FF2.7
04EF8:  MOVLB  0
04EFA:  CALL   0E42
04EFE:  BTFSC  1B.7
04F00:  BSF    FF2.7
04F02:  MOVLB  8
....................    if (status & FR_RW_ERROR) 
04F04:  MOVF   x8A,W
04F06:  ANDLW  07
04F08:  BZ    4F2A
....................       printf("   Read/Write Error\r\n"); 
04F0A:  MOVLW  D0
04F0C:  MOVWF  FF6
04F0E:  MOVLW  0C
04F10:  MOVWF  FF7
04F12:  MOVLW  00
04F14:  MOVWF  FF8
04F16:  CLRF   1B
04F18:  BTFSC  FF2.7
04F1A:  BSF    1B.7
04F1C:  BCF    FF2.7
04F1E:  MOVLB  0
04F20:  CALL   0E42
04F24:  BTFSC  1B.7
04F26:  BSF    FF2.7
04F28:  MOVLB  8
....................    if (status & FR_INCORRECT_DISK_CHANGE) 
04F2A:  MOVF   x8A,W
04F2C:  ANDLW  09
04F2E:  BZ    4F50
....................       printf("   Incorrect Media Change\r\n"); 
04F30:  MOVLW  E6
04F32:  MOVWF  FF6
04F34:  MOVLW  0C
04F36:  MOVWF  FF7
04F38:  MOVLW  00
04F3A:  MOVWF  FF8
04F3C:  CLRF   1B
04F3E:  BTFSC  FF2.7
04F40:  BSF    1B.7
04F42:  BCF    FF2.7
04F44:  MOVLB  0
04F46:  CALL   0E42
04F4A:  BTFSC  1B.7
04F4C:  BSF    FF2.7
04F4E:  MOVLB  8
....................    if (status & FR_WRITE_PROTECTED) 
04F50:  MOVF   x8A,W
04F52:  ANDLW  0A
04F54:  BZ    4F76
....................       printf("   Write Protected\r\n"); 
04F56:  MOVLW  02
04F58:  MOVWF  FF6
04F5A:  MOVLW  0D
04F5C:  MOVWF  FF7
04F5E:  MOVLW  00
04F60:  MOVWF  FF8
04F62:  CLRF   1B
04F64:  BTFSC  FF2.7
04F66:  BSF    1B.7
04F68:  BCF    FF2.7
04F6A:  MOVLB  0
04F6C:  CALL   0E42
04F70:  BTFSC  1B.7
04F72:  BSF    FF2.7
04F74:  MOVLB  8
....................    if (status & FR_NOT_ENABLED) 
04F76:  MOVF   x8A,W
04F78:  ANDLW  0B
04F7A:  BZ    4F9C
....................       printf("   Not Enabled\r\n"); 
04F7C:  MOVLW  18
04F7E:  MOVWF  FF6
04F80:  MOVLW  0D
04F82:  MOVWF  FF7
04F84:  MOVLW  00
04F86:  MOVWF  FF8
04F88:  CLRF   1B
04F8A:  BTFSC  FF2.7
04F8C:  BSF    1B.7
04F8E:  BCF    FF2.7
04F90:  MOVLB  0
04F92:  CALL   0E42
04F96:  BTFSC  1B.7
04F98:  BSF    FF2.7
04F9A:  MOVLB  8
....................    if (status & FR_NO_FILESYSTEM) 
04F9C:  MOVF   x8A,W
04F9E:  ANDLW  0C
04FA0:  BZ    4FC2
....................       printf("   No File System\r\n"); 
04FA2:  MOVLW  2A
04FA4:  MOVWF  FF6
04FA6:  MOVLW  0D
04FA8:  MOVWF  FF7
04FAA:  MOVLW  00
04FAC:  MOVWF  FF8
04FAE:  CLRF   1B
04FB0:  BTFSC  FF2.7
04FB2:  BSF    1B.7
04FB4:  BCF    FF2.7
04FB6:  MOVLB  0
04FB8:  CALL   0E42
04FBC:  BTFSC  1B.7
04FBE:  BSF    FF2.7
04FC0:  MOVLB  8
04FC2:  MOVLB  0
04FC4:  GOTO   504E (RETURN)
....................    } 
....................  
.................... BYTE append_data (char *target) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... //   Opens the file to be appended and writes to it. If the file exists it  
.................... //   is opened. If it does not exist it is created. The file this 
.................... //   then closed. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... { 
....................    FIL fdst;           // file structures 
....................    FRESULT result;     // FatFs function common result code 
....................    WORD btw, bw;       // File R/W count 
....................    //char target[16]; 
....................    char mesg[BUFFER_LEN]; 
....................  
....................    memset (&mesg[0], 0x00, BUFFER_LEN);  //blank it 
*
082EC:  MOVLW  09
082EE:  MOVWF  FEA
082F0:  MOVLW  10
082F2:  MOVWF  FE9
082F4:  CLRF   00
082F6:  CLRF   02
082F8:  MOVLW  A0
082FA:  MOVWF  01
082FC:  CALL   351A
....................  
....................    // Create destination file 
....................    //strcpy(target,"data_all.txt"); 
....................    result = f_open(&fdst, target, FA_OPEN_ALWAYS | FA_WRITE); 
08300:  MOVLW  08
08302:  MOVLB  9
08304:  MOVWF  xB1
08306:  MOVLW  EF
08308:  MOVWF  xB0
0830A:  MOVFF  8EE,9B3
0830E:  MOVFF  8ED,9B2
08312:  MOVLW  12
08314:  MOVWF  xB4
08316:  MOVLB  0
08318:  CALL   714C
0831C:  MOVFF  01,90B
....................    if (result) 
08320:  MOVLB  9
08322:  MOVF   x0B,F
08324:  BZ    8348
....................    { 
....................       printf("append: FS ERROR on file_open\r\n"); 
08326:  MOVLW  3E
08328:  MOVWF  FF6
0832A:  MOVLW  0D
0832C:  MOVWF  FF7
0832E:  MOVLW  00
08330:  MOVWF  FF8
08332:  CLRF   1B
08334:  BTFSC  FF2.7
08336:  BSF    1B.7
08338:  BCF    FF2.7
0833A:  MOVLB  0
0833C:  CALL   0E42
08340:  BTFSC  1B.7
08342:  BSF    FF2.7
....................    } 
08344:  BRA    84C4
08346:  MOVLB  9
....................    else 
....................    { 
....................       // if the file already exists then append to the end of the file 
....................       if (fdst.fsize != 0) 
08348:  MOVLB  8
0834A:  MOVF   xF3,F
0834C:  BNZ   835A
0834E:  MOVF   xF4,F
08350:  BNZ   835A
08352:  MOVF   xF5,F
08354:  BNZ   835A
08356:  MOVF   xF6,F
08358:  BZ    8380
....................          result = f_lseek(&fdst, fdst.fsize);  
0835A:  MOVLW  08
0835C:  MOVLB  9
0835E:  MOVWF  xB1
08360:  MOVLW  EF
08362:  MOVWF  xB0
08364:  MOVFF  8F6,9B5
08368:  MOVFF  8F5,9B4
0836C:  MOVFF  8F4,9B3
08370:  MOVFF  8F3,9B2
08374:  MOVLB  0
08376:  GOTO   7594
0837A:  MOVFF  01,90B
0837E:  MOVLB  8
....................  
....................       // write a short string to destination file 
....................       if (buffer_select == 0) strncpy(mesg, data_buffer, BUFFER_LEN - 1); 
08380:  MOVLB  0
08382:  MOVF   x66,F
08384:  BNZ   83A2
08386:  MOVLW  09
08388:  MOVLB  9
0838A:  MOVWF  xB1
0838C:  MOVLW  10
0838E:  MOVWF  xB0
08390:  CLRF   xB3
08392:  MOVLW  67
08394:  MOVWF  xB2
08396:  CLRF   xB5
08398:  MOVLW  9F
0839A:  MOVWF  xB4
0839C:  MOVLB  0
0839E:  CALL   78FC
....................       if (buffer_select == 1) strncpy(mesg, event_buffer, BUFFER_LEN - 1);   
083A2:  DECFSZ x66,W
083A4:  BRA    83C4
083A6:  MOVLW  09
083A8:  MOVLB  9
083AA:  MOVWF  xB1
083AC:  MOVLW  10
083AE:  MOVWF  xB0
083B0:  MOVLW  01
083B2:  MOVWF  xB3
083B4:  MOVLW  07
083B6:  MOVWF  xB2
083B8:  CLRF   xB5
083BA:  MOVLW  9F
083BC:  MOVWF  xB4
083BE:  MOVLB  0
083C0:  CALL   78FC
....................       if (nv_report_mode > 4) printf("@FS:Writing\r\n[%s]\r\n", mesg); 
083C4:  MOVF   20,F
083C6:  BNZ   83CE
083C8:  MOVF   1F,W
083CA:  SUBLW  04
083CC:  BC    8422
083CE:  MOVLW  5E
083D0:  MOVWF  FF6
083D2:  MOVLW  0D
083D4:  MOVWF  FF7
083D6:  MOVLW  00
083D8:  MOVWF  FF8
083DA:  CLRF   1B
083DC:  BTFSC  FF2.7
083DE:  BSF    1B.7
083E0:  BCF    FF2.7
083E2:  MOVLW  0E
083E4:  MOVLB  A
083E6:  MOVWF  x40
083E8:  MOVLB  0
083EA:  CALL   1018
083EE:  BTFSC  1B.7
083F0:  BSF    FF2.7
083F2:  MOVLW  09
083F4:  MOVWF  FEA
083F6:  MOVLW  10
083F8:  MOVWF  FE9
083FA:  CALL   798A
083FE:  MOVLW  6E
08400:  MOVWF  FF6
08402:  MOVLW  0D
08404:  MOVWF  FF7
08406:  MOVLW  00
08408:  MOVWF  FF8
0840A:  CLRF   1B
0840C:  BTFSC  FF2.7
0840E:  BSF    1B.7
08410:  BCF    FF2.7
08412:  MOVLW  03
08414:  MOVLB  A
08416:  MOVWF  x40
08418:  MOVLB  0
0841A:  CALL   1018
0841E:  BTFSC  1B.7
08420:  BSF    FF2.7
....................  
....................       btw = strlen16(mesg); 
08422:  MOVLW  09
08424:  MOVLB  9
08426:  MOVWF  xB1
08428:  MOVLW  10
0842A:  MOVWF  xB0
0842C:  MOVLB  0
0842E:  GOTO   79B0
08432:  MOVFF  02,90D
08436:  MOVFF  01,90C
....................       result = f_write(&fdst, mesg, btw, &bw); 
0843A:  MOVLW  08
0843C:  MOVLB  9
0843E:  MOVWF  xB1
08440:  MOVLW  EF
08442:  MOVWF  xB0
08444:  MOVLW  09
08446:  MOVWF  xB3
08448:  MOVLW  10
0844A:  MOVWF  xB2
0844C:  MOVFF  90D,9B5
08450:  MOVFF  90C,9B4
08454:  MOVLW  09
08456:  MOVWF  xB7
08458:  MOVLW  0E
0845A:  MOVWF  xB6
0845C:  MOVLB  0
0845E:  GOTO   79EE
08462:  MOVFF  01,90B
....................       if (result) 
08466:  MOVLB  9
08468:  MOVF   x0B,F
0846A:  BZ    848E
....................       { 
....................          printf("@FS:ERROR[append]\r\n"); 
0846C:  MOVLW  72
0846E:  MOVWF  FF6
08470:  MOVLW  0D
08472:  MOVWF  FF7
08474:  MOVLW  00
08476:  MOVWF  FF8
08478:  CLRF   1B
0847A:  BTFSC  FF2.7
0847C:  BSF    1B.7
0847E:  BCF    FF2.7
08480:  MOVLB  0
08482:  CALL   0E42
08486:  BTFSC  1B.7
08488:  BSF    FF2.7
....................       } 
0848A:  BRA    84B6
0848C:  MOVLB  9
....................       else 
....................       { 
....................          if (nv_report_mode > 4) printf("@FS:Closing\r\n"); 
0848E:  MOVF   20,F
08490:  BNZ   8498
08492:  MOVF   1F,W
08494:  SUBLW  04
08496:  BC    84B8
08498:  MOVLW  86
0849A:  MOVWF  FF6
0849C:  MOVLW  0D
0849E:  MOVWF  FF7
084A0:  MOVLW  00
084A2:  MOVWF  FF8
084A4:  CLRF   1B
084A6:  BTFSC  FF2.7
084A8:  BSF    1B.7
084AA:  BCF    FF2.7
084AC:  MOVLB  0
084AE:  CALL   0E42
084B2:  BTFSC  1B.7
084B4:  BSF    FF2.7
084B6:  MOVLB  9
....................       } 
....................  
....................       f_close(&fdst); 
084B8:  MOVLW  08
084BA:  MOVWF  xB1
084BC:  MOVLW  EF
084BE:  MOVWF  xB0
084C0:  MOVLB  0
084C2:  RCALL  82A0
....................    } 
....................  
....................    return (result); 
084C4:  MOVLB  9
084C6:  MOVFF  90B,01
084CA:  MOVLB  0
084CC:  RETURN 0
.................... } 
....................     
....................  
....................  
.................... #include "rtc.c" 
.................... /* Note: BCD conversion 
....................  
....................    Decimal:    0     1     2     3     4     5     6     7     8     9 
....................    BCD:     0000  0001  0010  0011  0100  0101  0110  0111  1000  1001 
....................     
....................    SPI read  = addr + data1 + data2 
....................    addr = 0XXXXXXX (for read) 
....................         = 0x0X hex 
....................    SPI write = addr + data 
....................    addr = 1XXXXXXX (for write) 
....................         = 0x8X hex 
.................... */ 
....................  
.................... int8 RTC_Sec_Reg, RTC_Min_Reg, RTC_Hr_Reg; 
.................... int8 RTC_DOW_Reg, RTC_DOM_Reg, RTC_Mon_Reg, RTC_Yr_Reg; 
.................... int8 RTC_Tenths_Sec_Reg; 
.................... int8 RTC_Al_Yr_Reg, RTC_Al_Mon_Reg, RTC_Al_DOM_Reg; 
.................... int8 RTC_Al_Hr_Reg, RTC_Al_Min_Reg, RTC_Al_Sec_Reg; 
.................... int8 RTC_Flags_Reg; 
....................  
.................... int8 RTC_Sec_Data, RTC_Min_Data, RTC_Hr_Data; 
.................... int8 RTC_DOM_Data, RTC_Mon_Data, RTC_Yr_Data; 
....................  
.................... int8 rtc_last_month; 
.................... int8 rtc_last_day; 
.................... int8 rtc_last_year; 
.................... int8 rtc_last_hour; 
.................... int8 rtc_last_min; 
.................... int8 rtc_last_sec; 
....................  
.................... short alarm_passed; 
....................  
.................... int Dec2Bcd(int8 data) 
*
17B08:  CLRF   1B
17B0A:  BTFSC  FF2.7
17B0C:  BSF    1B.7
17B0E:  BCF    FF2.7
.................... { 
....................    int nibh; 
....................    int nibl; 
....................  
....................    nibh=data/10; 
17B10:  MOVFF  887,A42
17B14:  MOVLW  0A
17B16:  MOVLB  A
17B18:  MOVWF  x43
17B1A:  MOVLB  0
17B1C:  CALL   0F6E
17B20:  BTFSC  1B.7
17B22:  BSF    FF2.7
17B24:  MOVFF  01,888
....................    nibl=data-(nibh*10); 
17B28:  MOVLB  8
17B2A:  MOVF   x88,W
17B2C:  MULLW  0A
17B2E:  MOVF   FF3,W
17B30:  SUBWF  x87,W
17B32:  MOVWF  x89
....................  
....................    return((nibh<<4)|nibl); 
17B34:  SWAPF  x88,W
17B36:  MOVWF  00
17B38:  MOVLW  F0
17B3A:  ANDWF  00,F
17B3C:  MOVF   00,W
17B3E:  IORWF  x89,W
17B40:  MOVWF  01
17B42:  MOVLB  0
17B44:  RETURN 0
.................... } 
....................  
.................... int Bcd2Dec(int8 data) 
.................... { 
....................    int i; 
....................  
....................    i=data; 
*
03306:  MOVFF  8EE,8EF
....................    data=(i>>4)*10; 
0330A:  MOVLB  8
0330C:  SWAPF  xEF,W
0330E:  MOVWF  00
03310:  MOVLW  0F
03312:  ANDWF  00,F
03314:  MOVF   00,W
03316:  MULLW  0A
03318:  MOVFF  FF3,8EE
....................    data=data+(i<<4>>4); 
0331C:  SWAPF  xEF,W
0331E:  MOVWF  00
03320:  MOVLW  F0
03322:  ANDWF  00,F
03324:  MOVF   00,W
03326:  SWAPF  00,F
03328:  MOVLW  0F
0332A:  ANDWF  00,F
0332C:  MOVF   00,W
0332E:  ADDWF  xEE,F
....................  
....................    return data; 
03330:  MOVFF  8EE,01
03334:  MOVLB  0
03336:  RETURN 0
.................... } 
....................  
.................... // When power failure occurs HT (halt update) is set to 1 
.................... // ... preventing the clock from updating registers 
.................... // HT must be set to 0 to resume register updates 
.................... void RTC_reset_HT() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
034A6:  MOVLB  8
034A8:  CLRF   xCB
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
034AA:  BCF    FC6.5
034AC:  MOVLW  21
034AE:  MOVWF  FC6
034B0:  MOVLW  40
034B2:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
034B4:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0C); 
034B6:  MOVF   FC9,W
034B8:  MOVLW  0C
034BA:  MOVWF  FC9
034BC:  RRCF   FC7,W
034BE:  BNC   34BC
034C0:  MOVFF  FC9,8CB
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
034C4:  MOVF   FC9,W
034C6:  MOVFF  8CB,FC9
034CA:  RRCF   FC7,W
034CC:  BNC   34CA
034CE:  MOVFF  FC9,730
....................    output_bit(RTC_CS, DISABLE); 
034D2:  BSF    F91.0
....................     
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b10111111; 
034D4:  MOVLB  7
034D6:  BCF    x30.6
....................     
....................    output_bit(RTC_CS, ENABLE); 
034D8:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);                 // address - Hour 
034DA:  MOVF   FC9,W
034DC:  MOVLW  8C
034DE:  MOVWF  FC9
034E0:  RRCF   FC7,W
034E2:  BNC   34E0
034E4:  MOVFF  FC9,8CB
....................    RTC_buffer = spi_read(RTC_Al_Hr_Reg);        // data 
034E8:  MOVF   FC9,W
034EA:  MOVFF  730,FC9
034EE:  RRCF   FC7,W
034F0:  BNC   34EE
034F2:  MOVFF  FC9,8CB
....................    output_bit(RTC_CS, DISABLE); 
034F6:  BSF    F91.0
034F8:  MOVLB  0
034FA:  RETURN 0
.................... } 
....................  
.................... void RTC_display() 
.................... {   
....................    RTCfmt = read16(ADDR_RTCfmt); 
*
0E27E:  MOVLW  1A
0E280:  MOVLB  8
0E282:  MOVWF  x97
0E284:  MOVLB  0
0E286:  CALL   29BE
0E28A:  MOVFF  01,4F
....................    if (RTCfmt == 0) // default format MM/DD/YY HH:mm:SS 
0E28E:  MOVF   4F,F
0E290:  BNZ   E2FE
....................    { 
....................    fprintf (COM_A, "@RTC:%02u/", RTC_Mon_Reg); 
0E292:  MOVLW  94
0E294:  MOVWF  FF6
0E296:  MOVLW  0D
0E298:  MOVWF  FF7
0E29A:  MOVLW  00
0E29C:  MOVWF  FF8
0E29E:  CLRF   1B
0E2A0:  BTFSC  FF2.7
0E2A2:  BSF    1B.7
0E2A4:  BCF    FF2.7
0E2A6:  MOVLW  05
0E2A8:  MOVLB  A
0E2AA:  MOVWF  x40
0E2AC:  MOVLB  0
0E2AE:  CALL   1018
0E2B2:  BTFSC  1B.7
0E2B4:  BSF    FF2.7
0E2B6:  CLRF   1B
0E2B8:  BTFSC  FF2.7
0E2BA:  BSF    1B.7
0E2BC:  BCF    FF2.7
0E2BE:  MOVFF  72A,A40
0E2C2:  MOVLW  01
0E2C4:  MOVLB  A
0E2C6:  MOVWF  x41
0E2C8:  MOVLB  0
0E2CA:  CALL   0F9A
0E2CE:  BTFSC  1B.7
0E2D0:  BSF    FF2.7
0E2D2:  MOVLW  2F
0E2D4:  BTFSS  F9E.4
0E2D6:  BRA    E2D4
0E2D8:  MOVWF  FAD
0E2DA:  CLRF   1B
0E2DC:  BTFSC  FF2.7
0E2DE:  BSF    1B.7
0E2E0:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_DOM_Reg); 
0E2E2:  MOVFF  729,A40
0E2E6:  MOVLW  01
0E2E8:  MOVLB  A
0E2EA:  MOVWF  x41
0E2EC:  MOVLB  0
0E2EE:  CALL   0F9A
0E2F2:  BTFSC  1B.7
0E2F4:  BSF    FF2.7
0E2F6:  MOVLW  2F
0E2F8:  BTFSS  F9E.4
0E2FA:  BRA    E2F8
0E2FC:  MOVWF  FAD
....................    } 
....................     
....................    if (RTCfmt == 1) // Euro/Asia format DD/MM/YY HH:mm:SS 
0E2FE:  DECFSZ 4F,W
0E300:  BRA    E36E
....................    { 
....................     fprintf (COM_A, "@RTC:%02u/", RTC_DOM_Reg); 
0E302:  MOVLW  A0
0E304:  MOVWF  FF6
0E306:  MOVLW  0D
0E308:  MOVWF  FF7
0E30A:  MOVLW  00
0E30C:  MOVWF  FF8
0E30E:  CLRF   1B
0E310:  BTFSC  FF2.7
0E312:  BSF    1B.7
0E314:  BCF    FF2.7
0E316:  MOVLW  05
0E318:  MOVLB  A
0E31A:  MOVWF  x40
0E31C:  MOVLB  0
0E31E:  CALL   1018
0E322:  BTFSC  1B.7
0E324:  BSF    FF2.7
0E326:  CLRF   1B
0E328:  BTFSC  FF2.7
0E32A:  BSF    1B.7
0E32C:  BCF    FF2.7
0E32E:  MOVFF  729,A40
0E332:  MOVLW  01
0E334:  MOVLB  A
0E336:  MOVWF  x41
0E338:  MOVLB  0
0E33A:  CALL   0F9A
0E33E:  BTFSC  1B.7
0E340:  BSF    FF2.7
0E342:  MOVLW  2F
0E344:  BTFSS  F9E.4
0E346:  BRA    E344
0E348:  MOVWF  FAD
0E34A:  CLRF   1B
0E34C:  BTFSC  FF2.7
0E34E:  BSF    1B.7
0E350:  BCF    FF2.7
....................     fprintf (COM_A, "%02u/", RTC_Mon_Reg); 
0E352:  MOVFF  72A,A40
0E356:  MOVLW  01
0E358:  MOVLB  A
0E35A:  MOVWF  x41
0E35C:  MOVLB  0
0E35E:  CALL   0F9A
0E362:  BTFSC  1B.7
0E364:  BSF    FF2.7
0E366:  MOVLW  2F
0E368:  BTFSS  F9E.4
0E36A:  BRA    E368
0E36C:  MOVWF  FAD
0E36E:  CLRF   1B
0E370:  BTFSC  FF2.7
0E372:  BSF    1B.7
0E374:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Yr_Reg); 
0E376:  MOVFF  72B,A40
0E37A:  MOVLW  01
0E37C:  MOVLB  A
0E37E:  MOVWF  x41
0E380:  MOVLB  0
0E382:  CALL   0F9A
0E386:  BTFSC  1B.7
0E388:  BSF    FF2.7
0E38A:  MOVLW  20
0E38C:  BTFSS  F9E.4
0E38E:  BRA    E38C
0E390:  MOVWF  FAD
0E392:  CLRF   1B
0E394:  BTFSC  FF2.7
0E396:  BSF    1B.7
0E398:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Hr_Reg); 
0E39A:  MOVFF  727,A40
0E39E:  MOVLW  01
0E3A0:  MOVLB  A
0E3A2:  MOVWF  x41
0E3A4:  MOVLB  0
0E3A6:  CALL   0F9A
0E3AA:  BTFSC  1B.7
0E3AC:  BSF    FF2.7
0E3AE:  MOVLW  3A
0E3B0:  BTFSS  F9E.4
0E3B2:  BRA    E3B0
0E3B4:  MOVWF  FAD
0E3B6:  CLRF   1B
0E3B8:  BTFSC  FF2.7
0E3BA:  BSF    1B.7
0E3BC:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Min_Reg); 
0E3BE:  MOVFF  726,A40
0E3C2:  MOVLW  01
0E3C4:  MOVLB  A
0E3C6:  MOVWF  x41
0E3C8:  MOVLB  0
0E3CA:  CALL   0F9A
0E3CE:  BTFSC  1B.7
0E3D0:  BSF    FF2.7
0E3D2:  MOVLW  3A
0E3D4:  BTFSS  F9E.4
0E3D6:  BRA    E3D4
0E3D8:  MOVWF  FAD
0E3DA:  CLRF   1B
0E3DC:  BTFSC  FF2.7
0E3DE:  BSF    1B.7
0E3E0:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Sec_Reg); 
0E3E2:  MOVFF  725,A40
0E3E6:  MOVLW  01
0E3E8:  MOVLB  A
0E3EA:  MOVWF  x41
0E3EC:  MOVLB  0
0E3EE:  CALL   0F9A
0E3F2:  BTFSC  1B.7
0E3F4:  BSF    FF2.7
0E3F6:  MOVLW  0A
0E3F8:  BTFSS  F9E.4
0E3FA:  BRA    E3F8
0E3FC:  MOVWF  FAD
0E3FE:  MOVLW  0D
0E400:  BTFSS  F9E.4
0E402:  BRA    E400
0E404:  MOVWF  FAD
0E406:  RETURN 0
....................      
.................... } 
....................  
.................... void RTC_read() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
03338:  MOVLB  8
0333A:  CLRF   xED
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0333C:  BCF    FC6.5
0333E:  MOVLW  21
03340:  MOVWF  FC6
03342:  MOVLW  40
03344:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
03346:  BCF    F91.0
....................    RTC_buffer = spi_read(0x00); 
03348:  MOVF   FC9,W
0334A:  CLRF   FC9
0334C:  RRCF   FC7,W
0334E:  BNC   334C
03350:  MOVFF  FC9,8ED
....................    RTC_Tenths_Sec_Reg = spi_read(RTC_buffer); 
03354:  MOVF   FC9,W
03356:  MOVFF  8ED,FC9
0335A:  RRCF   FC7,W
0335C:  BNC   335A
0335E:  MOVFF  FC9,72C
....................    RTC_Sec_Reg = spi_read(RTC_buffer); 
03362:  MOVF   FC9,W
03364:  MOVFF  8ED,FC9
03368:  RRCF   FC7,W
0336A:  BNC   3368
0336C:  MOVFF  FC9,725
....................    RTC_Min_Reg = spi_read(RTC_buffer); 
03370:  MOVF   FC9,W
03372:  MOVFF  8ED,FC9
03376:  RRCF   FC7,W
03378:  BNC   3376
0337A:  MOVFF  FC9,726
....................    RTC_Hr_Reg =  spi_read(RTC_buffer); 
0337E:  MOVF   FC9,W
03380:  MOVFF  8ED,FC9
03384:  RRCF   FC7,W
03386:  BNC   3384
03388:  MOVFF  FC9,727
....................    RTC_DOW_Reg = spi_read(RTC_buffer); 
0338C:  MOVF   FC9,W
0338E:  MOVFF  8ED,FC9
03392:  RRCF   FC7,W
03394:  BNC   3392
03396:  MOVFF  FC9,728
....................    RTC_DOM_Reg = spi_read(RTC_buffer); 
0339A:  MOVF   FC9,W
0339C:  MOVFF  8ED,FC9
033A0:  RRCF   FC7,W
033A2:  BNC   33A0
033A4:  MOVFF  FC9,729
....................    RTC_Mon_Reg = spi_read(RTC_buffer); 
033A8:  MOVF   FC9,W
033AA:  MOVFF  8ED,FC9
033AE:  RRCF   FC7,W
033B0:  BNC   33AE
033B2:  MOVFF  FC9,72A
....................    RTC_Yr_Reg =  spi_read(RTC_buffer); 
033B6:  MOVF   FC9,W
033B8:  MOVFF  8ED,FC9
033BC:  RRCF   FC7,W
033BE:  BNC   33BC
033C0:  MOVFF  FC9,72B
....................    output_bit(RTC_CS, DISABLE); 
033C4:  BSF    F91.0
....................        
....................    RTC_Sec_Reg = Bcd2Dec(RTC_Sec_Reg); 
033C6:  MOVFF  725,8EE
033CA:  MOVLB  0
033CC:  RCALL  3306
033CE:  MOVFF  01,725
....................    RTC_Min_Reg = Bcd2Dec(RTC_Min_Reg); 
033D2:  MOVFF  726,8EE
033D6:  RCALL  3306
033D8:  MOVFF  01,726
....................    RTC_Hr_Reg = Bcd2Dec(RTC_Hr_Reg); 
033DC:  MOVFF  727,8EE
033E0:  RCALL  3306
033E2:  MOVFF  01,727
....................    RTC_DOM_Reg = Bcd2Dec(RTC_DOM_Reg); 
033E6:  MOVFF  729,8EE
033EA:  RCALL  3306
033EC:  MOVFF  01,729
....................    RTC_Mon_Reg = Bcd2Dec(RTC_Mon_Reg); 
033F0:  MOVFF  72A,8EE
033F4:  RCALL  3306
033F6:  MOVFF  01,72A
....................    RTC_Yr_Reg = Bcd2Dec(RTC_Yr_Reg); 
033FA:  MOVFF  72B,8EE
033FE:  RCALL  3306
03400:  MOVFF  01,72B
03404:  RETURN 0
.................... } 
....................  
.................... // RTC IRQ output is cleared & reset by reading the flags 
.................... // ... register 
.................... void RTC_read_flags() 
.................... { 
....................    int8 RTC_buffer; 
....................    RTC_buffer = 0; 
*
00DCC:  MOVLB  A
00DCE:  CLRF   x37
....................  
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
00DD0:  BCF    FC6.5
00DD2:  MOVLW  21
00DD4:  MOVWF  FC6
00DD6:  MOVLW  40
00DD8:  MOVWF  FC7
....................    output_bit(RTC_CS, ENABLE); 
00DDA:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0F); 
00DDC:  MOVF   FC9,W
00DDE:  MOVLW  0F
00DE0:  MOVWF  FC9
00DE2:  RRCF   FC7,W
00DE4:  BNC   0DE2
00DE6:  MOVFF  FC9,A37
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
00DEA:  MOVF   FC9,W
00DEC:  MOVFF  A37,FC9
00DF0:  RRCF   FC7,W
00DF2:  BNC   0DF0
00DF4:  MOVFF  FC9,733
....................    spi_read(0x00); 
00DF8:  MOVF   FC9,W
00DFA:  CLRF   FC9
00DFC:  RRCF   FC7,W
00DFE:  BNC   0DFC
....................    output_bit(RTC_CS, DISABLE); 
00E00:  BSF    F91.0
....................  
....................    RTC_read_flags_running = FALSE; 
00E02:  BCF    4D.2
00E04:  MOVLB  0
00E06:  RETURN 0
.................... } 
....................  
.................... void RTC_display_alarm() 
.................... { 
....................    if(RTCfmt == 0) 
*
0E4DE:  MOVF   4F,F
0E4E0:  BNZ   E54E
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_Mon_Reg ); 
0E4E2:  MOVLW  AC
0E4E4:  MOVWF  FF6
0E4E6:  MOVLW  0D
0E4E8:  MOVWF  FF7
0E4EA:  MOVLW  00
0E4EC:  MOVWF  FF8
0E4EE:  CLRF   1B
0E4F0:  BTFSC  FF2.7
0E4F2:  BSF    1B.7
0E4F4:  BCF    FF2.7
0E4F6:  MOVLW  05
0E4F8:  MOVLB  A
0E4FA:  MOVWF  x40
0E4FC:  MOVLB  0
0E4FE:  CALL   1018
0E502:  BTFSC  1B.7
0E504:  BSF    FF2.7
0E506:  CLRF   1B
0E508:  BTFSC  FF2.7
0E50A:  BSF    1B.7
0E50C:  BCF    FF2.7
0E50E:  MOVFF  72E,A40
0E512:  MOVLW  01
0E514:  MOVLB  A
0E516:  MOVWF  x41
0E518:  MOVLB  0
0E51A:  CALL   0F9A
0E51E:  BTFSC  1B.7
0E520:  BSF    FF2.7
0E522:  MOVLW  2F
0E524:  BTFSS  F9E.4
0E526:  BRA    E524
0E528:  MOVWF  FAD
0E52A:  CLRF   1B
0E52C:  BTFSC  FF2.7
0E52E:  BSF    1B.7
0E530:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_DOM_Reg); 
0E532:  MOVFF  72F,A40
0E536:  MOVLW  01
0E538:  MOVLB  A
0E53A:  MOVWF  x41
0E53C:  MOVLB  0
0E53E:  CALL   0F9A
0E542:  BTFSC  1B.7
0E544:  BSF    FF2.7
0E546:  MOVLW  2F
0E548:  BTFSS  F9E.4
0E54A:  BRA    E548
0E54C:  MOVWF  FAD
....................    } 
....................    if(RTCfmt == 1) 
0E54E:  DECFSZ 4F,W
0E550:  BRA    E5BE
....................    { 
....................    fprintf (COM_A, "@ALM:%02u/", RTC_Al_DOM_Reg ); 
0E552:  MOVLW  B8
0E554:  MOVWF  FF6
0E556:  MOVLW  0D
0E558:  MOVWF  FF7
0E55A:  MOVLW  00
0E55C:  MOVWF  FF8
0E55E:  CLRF   1B
0E560:  BTFSC  FF2.7
0E562:  BSF    1B.7
0E564:  BCF    FF2.7
0E566:  MOVLW  05
0E568:  MOVLB  A
0E56A:  MOVWF  x40
0E56C:  MOVLB  0
0E56E:  CALL   1018
0E572:  BTFSC  1B.7
0E574:  BSF    FF2.7
0E576:  CLRF   1B
0E578:  BTFSC  FF2.7
0E57A:  BSF    1B.7
0E57C:  BCF    FF2.7
0E57E:  MOVFF  72F,A40
0E582:  MOVLW  01
0E584:  MOVLB  A
0E586:  MOVWF  x41
0E588:  MOVLB  0
0E58A:  CALL   0F9A
0E58E:  BTFSC  1B.7
0E590:  BSF    FF2.7
0E592:  MOVLW  2F
0E594:  BTFSS  F9E.4
0E596:  BRA    E594
0E598:  MOVWF  FAD
0E59A:  CLRF   1B
0E59C:  BTFSC  FF2.7
0E59E:  BSF    1B.7
0E5A0:  BCF    FF2.7
....................    fprintf (COM_A, "%02u/", RTC_Al_Mon_Reg); 
0E5A2:  MOVFF  72E,A40
0E5A6:  MOVLW  01
0E5A8:  MOVLB  A
0E5AA:  MOVWF  x41
0E5AC:  MOVLB  0
0E5AE:  CALL   0F9A
0E5B2:  BTFSC  1B.7
0E5B4:  BSF    FF2.7
0E5B6:  MOVLW  2F
0E5B8:  BTFSS  F9E.4
0E5BA:  BRA    E5B8
0E5BC:  MOVWF  FAD
0E5BE:  CLRF   1B
0E5C0:  BTFSC  FF2.7
0E5C2:  BSF    1B.7
0E5C4:  BCF    FF2.7
....................    } 
....................     
....................    fprintf (COM_A, "%02u ", RTC_Al_Yr_Reg); 
0E5C6:  MOVFF  72D,A40
0E5CA:  MOVLW  01
0E5CC:  MOVLB  A
0E5CE:  MOVWF  x41
0E5D0:  MOVLB  0
0E5D2:  CALL   0F9A
0E5D6:  BTFSC  1B.7
0E5D8:  BSF    FF2.7
0E5DA:  MOVLW  20
0E5DC:  BTFSS  F9E.4
0E5DE:  BRA    E5DC
0E5E0:  MOVWF  FAD
0E5E2:  CLRF   1B
0E5E4:  BTFSC  FF2.7
0E5E6:  BSF    1B.7
0E5E8:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Hr_Reg); 
0E5EA:  MOVFF  730,A40
0E5EE:  MOVLW  01
0E5F0:  MOVLB  A
0E5F2:  MOVWF  x41
0E5F4:  MOVLB  0
0E5F6:  CALL   0F9A
0E5FA:  BTFSC  1B.7
0E5FC:  BSF    FF2.7
0E5FE:  MOVLW  3A
0E600:  BTFSS  F9E.4
0E602:  BRA    E600
0E604:  MOVWF  FAD
0E606:  CLRF   1B
0E608:  BTFSC  FF2.7
0E60A:  BSF    1B.7
0E60C:  BCF    FF2.7
....................    fprintf (COM_A, "%02u:", RTC_Al_Min_Reg); 
0E60E:  MOVFF  731,A40
0E612:  MOVLW  01
0E614:  MOVLB  A
0E616:  MOVWF  x41
0E618:  MOVLB  0
0E61A:  CALL   0F9A
0E61E:  BTFSC  1B.7
0E620:  BSF    FF2.7
0E622:  MOVLW  3A
0E624:  BTFSS  F9E.4
0E626:  BRA    E624
0E628:  MOVWF  FAD
0E62A:  CLRF   1B
0E62C:  BTFSC  FF2.7
0E62E:  BSF    1B.7
0E630:  BCF    FF2.7
....................    fprintf (COM_A, "%02u\n\r", RTC_Al_Sec_Reg); 
0E632:  MOVFF  732,A40
0E636:  MOVLW  01
0E638:  MOVLB  A
0E63A:  MOVWF  x41
0E63C:  MOVLB  0
0E63E:  CALL   0F9A
0E642:  BTFSC  1B.7
0E644:  BSF    FF2.7
0E646:  MOVLW  0A
0E648:  BTFSS  F9E.4
0E64A:  BRA    E648
0E64C:  MOVWF  FAD
0E64E:  MOVLW  0D
0E650:  BTFSS  F9E.4
0E652:  BRA    E650
0E654:  MOVWF  FAD
0E656:  RETURN 0
.................... } 
....................  
.................... void RTC_read_alarm(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
0E408:  MOVLB  8
0E40A:  CLRF   xB7
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
0E40C:  BCF    FC6.5
0E40E:  MOVLW  21
0E410:  MOVWF  FC6
0E412:  MOVLW  40
0E414:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
0E416:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
0E418:  MOVF   FC9,W
0E41A:  MOVLW  0A
0E41C:  MOVWF  FC9
0E41E:  RRCF   FC7,W
0E420:  BNC   E41E
0E422:  MOVFF  FC9,8B7
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
0E426:  MOVF   FC9,W
0E428:  MOVFF  8B7,FC9
0E42C:  RRCF   FC7,W
0E42E:  BNC   E42C
0E430:  MOVFF  FC9,72E
....................    RTC_Al_DOM_Reg = spi_read(RTC_buffer); 
0E434:  MOVF   FC9,W
0E436:  MOVFF  8B7,FC9
0E43A:  RRCF   FC7,W
0E43C:  BNC   E43A
0E43E:  MOVFF  FC9,72F
....................    RTC_Al_Hr_Reg = spi_read(RTC_buffer); 
0E442:  MOVF   FC9,W
0E444:  MOVFF  8B7,FC9
0E448:  RRCF   FC7,W
0E44A:  BNC   E448
0E44C:  MOVFF  FC9,730
....................    RTC_Al_Min_Reg = spi_read(RTC_buffer); 
0E450:  MOVF   FC9,W
0E452:  MOVFF  8B7,FC9
0E456:  RRCF   FC7,W
0E458:  BNC   E456
0E45A:  MOVFF  FC9,731
....................    RTC_Al_Sec_Reg = spi_read(RTC_buffer); 
0E45E:  MOVF   FC9,W
0E460:  MOVFF  8B7,FC9
0E464:  RRCF   FC7,W
0E466:  BNC   E464
0E468:  MOVFF  FC9,732
....................    RTC_Flags_Reg = spi_read(RTC_buffer); 
0E46C:  MOVF   FC9,W
0E46E:  MOVFF  8B7,FC9
0E472:  RRCF   FC7,W
0E474:  BNC   E472
0E476:  MOVFF  FC9,733
....................    output_bit(RTC_CS, DISABLE); 
0E47A:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg & 0b00011111; 
0E47C:  MOVLW  1F
0E47E:  MOVLB  7
0E480:  ANDWF  x2E,F
....................    RTC_Al_Mon_Reg = Bcd2Dec(RTC_Al_Mon_Reg); 
0E482:  MOVFF  72E,8EE
0E486:  MOVLB  0
0E488:  CALL   3306
0E48C:  MOVFF  01,72E
....................    RTC_Al_DOM_Reg = RTC_Al_DOM_Reg & 0b00111111; 
0E490:  MOVLW  3F
0E492:  MOVLB  7
0E494:  ANDWF  x2F,F
....................    RTC_Al_DOM_Reg = Bcd2Dec(RTC_Al_DOM_Reg); 
0E496:  MOVFF  72F,8EE
0E49A:  MOVLB  0
0E49C:  CALL   3306
0E4A0:  MOVFF  01,72F
....................    RTC_Al_Hr_Reg = RTC_Al_Hr_Reg & 0b00111111; 
0E4A4:  MOVLW  3F
0E4A6:  MOVLB  7
0E4A8:  ANDWF  x30,F
....................    RTC_Al_Hr_Reg = Bcd2Dec(RTC_Al_Hr_Reg); 
0E4AA:  MOVFF  730,8EE
0E4AE:  MOVLB  0
0E4B0:  CALL   3306
0E4B4:  MOVFF  01,730
....................    RTC_Al_Min_Reg = RTC_Al_Min_Reg & 0b01111111; 
0E4B8:  MOVLB  7
0E4BA:  BCF    x31.7
....................    RTC_Al_Min_Reg = Bcd2Dec(RTC_Al_Min_Reg); 
0E4BC:  MOVFF  731,8EE
0E4C0:  MOVLB  0
0E4C2:  CALL   3306
0E4C6:  MOVFF  01,731
....................    RTC_Al_Sec_Reg = RTC_Al_Sec_Reg & 0b01111111; 
0E4CA:  MOVLB  7
0E4CC:  BCF    x32.7
....................    RTC_Al_Sec_Reg = Bcd2Dec(RTC_Al_Sec_Reg); 
0E4CE:  MOVFF  732,8EE
0E4D2:  MOVLB  0
0E4D4:  CALL   3306
0E4D8:  MOVFF  01,732
0E4DC:  RETURN 0
.................... } 
....................  
.................... int8 get_time() 
.................... { 
....................    int8 c, n; 
....................    int8 t_entry[12]; 
....................    int8 time_error; 
....................  
....................    memset (&t_entry[0], 0x00, 12);  //blank it 
*
1774E:  MOVLW  08
17750:  MOVWF  FEA
17752:  MOVLW  89
17754:  MOVWF  FE9
17756:  CLRF   00
17758:  CLRF   02
1775A:  MOVLW  0C
1775C:  MOVWF  01
1775E:  CALL   351A
....................  
....................    time_error = 0; 
17762:  MOVLB  8
17764:  CLRF   x95
....................     
....................    fputc('[', COM_A); 
17766:  MOVLW  5B
17768:  MOVLB  0
1776A:  CALL   AEAC
....................     
....................    for (n=0; n<12; ++n){ 
1776E:  MOVLB  8
17770:  CLRF   x88
17772:  MOVF   x88,W
17774:  SUBLW  0B
17776:  BNC   177BC
....................       c = fgetc(COM_A); 
17778:  MOVLB  0
1777A:  CALL   0E2C
1777E:  MOVFF  01,887
....................       if (com_echo == TRUE) 
17782:  DECFSZ 4C,W
17784:  BRA    17790
....................       { 
....................          fputc(c, COM_A); 
17786:  MOVLB  8
17788:  MOVF   x87,W
1778A:  MOVLB  0
1778C:  CALL   AEAC
....................       } 
....................       if (c > 47 && c < 58) t_entry[n] = c; 
17790:  MOVLB  8
17792:  MOVF   x87,W
17794:  SUBLW  2F
17796:  BC    177B2
17798:  MOVF   x87,W
1779A:  SUBLW  39
1779C:  BNC   177B2
1779E:  CLRF   03
177A0:  MOVF   x88,W
177A2:  ADDLW  89
177A4:  MOVWF  FE9
177A6:  MOVLW  08
177A8:  ADDWFC 03,W
177AA:  MOVWF  FEA
177AC:  MOVFF  887,FEF
177B0:  BRA    177B8
....................       else 
....................       { 
....................          // it's not a number - kick it out 
....................          time_error = 1; 
177B2:  MOVLW  01
177B4:  MOVWF  x95
....................          break; 
177B6:  BRA    177BC
....................       } 
177B8:  INCF   x88,F
177BA:  BRA    17772
....................    } 
....................     
....................    if (time_error == 0){ 
177BC:  MOVF   x95,F
177BE:  BTFSS  FD8.2
177C0:  BRA    17AF8
....................     
....................       fputc(']', COM_A); 
177C2:  MOVLW  5D
177C4:  MOVLB  0
177C6:  CALL   AEAC
....................        
....................       for (n=0; n<12; ++n){ 
177CA:  MOVLB  8
177CC:  CLRF   x88
177CE:  MOVF   x88,W
177D0:  SUBLW  0B
177D2:  BNC   17804
....................          t_entry[n] = (t_entry[n] - 48); 
177D4:  CLRF   03
177D6:  MOVF   x88,W
177D8:  ADDLW  89
177DA:  MOVWF  01
177DC:  MOVLW  08
177DE:  ADDWFC 03,F
177E0:  MOVFF  03,897
177E4:  CLRF   03
177E6:  MOVF   x88,W
177E8:  ADDLW  89
177EA:  MOVWF  FE9
177EC:  MOVLW  08
177EE:  ADDWFC 03,W
177F0:  MOVWF  FEA
177F2:  MOVLW  30
177F4:  SUBWF  FEF,W
177F6:  MOVFF  897,FEA
177FA:  MOVFF  01,FE9
177FE:  MOVWF  FEF
17800:  INCF   x88,F
17802:  BRA    177CE
....................       } 
....................        
....................       if (RTCfmt == 0) 
17804:  MOVF   4F,F
17806:  BNZ   17844
....................       { 
....................       RTC_Mon_Data = (10 * t_entry[0]) + t_entry[1]; 
17808:  MOVF   x89,W
1780A:  MULLW  0A
1780C:  MOVF   FF3,W
1780E:  ADDWF  x8A,W
17810:  MOVLB  7
17812:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17814:  MOVF   x38,F
17816:  BZ    1781E
17818:  MOVF   x38,W
1781A:  SUBLW  0C
1781C:  BC    17826
1781E:  MOVLW  02
17820:  MOVLB  8
17822:  MOVWF  x95
17824:  MOVLB  7
....................        
....................       RTC_DOM_Data = (10 * t_entry[2]) + t_entry[3]; 
17826:  MOVLB  8
17828:  MOVF   x8B,W
1782A:  MULLW  0A
1782C:  MOVF   FF3,W
1782E:  ADDWF  x8C,W
17830:  MOVLB  7
17832:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17834:  MOVF   x37,F
17836:  BZ    1783E
17838:  MOVF   x37,W
1783A:  SUBLW  1F
1783C:  BC    17846
1783E:  MOVLW  02
17840:  MOVLB  8
17842:  MOVWF  x95
17844:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
17846:  DECFSZ 4F,W
17848:  BRA    1788A
....................       { 
....................       RTC_DOM_Data = (10 * t_entry[0]) + t_entry[1]; 
1784A:  MOVLB  8
1784C:  MOVF   x89,W
1784E:  MULLW  0A
17850:  MOVF   FF3,W
17852:  ADDWF  x8A,W
17854:  MOVLB  7
17856:  MOVWF  x37
....................       if (RTC_DOM_Data < 1 || RTC_DOM_Data > 31) time_error = 2; 
17858:  MOVF   x37,F
1785A:  BZ    17862
1785C:  MOVF   x37,W
1785E:  SUBLW  1F
17860:  BC    1786A
17862:  MOVLW  02
17864:  MOVLB  8
17866:  MOVWF  x95
17868:  MOVLB  7
....................        
....................       RTC_Mon_Data = (10 * t_entry[2]) + t_entry[3]; 
1786A:  MOVLB  8
1786C:  MOVF   x8B,W
1786E:  MULLW  0A
17870:  MOVF   FF3,W
17872:  ADDWF  x8C,W
17874:  MOVLB  7
17876:  MOVWF  x38
....................       if (RTC_Mon_Data < 1 || RTC_Mon_Data > 12) time_error = 2;  
17878:  MOVF   x38,F
1787A:  BZ    17882
1787C:  MOVF   x38,W
1787E:  SUBLW  0C
17880:  BC    1788A
17882:  MOVLW  02
17884:  MOVLB  8
17886:  MOVWF  x95
17888:  MOVLB  7
....................       } 
....................        
....................       RTC_Yr_Data = (10 * t_entry[4]) + t_entry[5]; 
1788A:  MOVLB  8
1788C:  MOVF   x8D,W
1788E:  MULLW  0A
17890:  MOVF   FF3,W
17892:  ADDWF  x8E,W
17894:  MOVLB  7
17896:  MOVWF  x39
....................       if (RTC_Yr_Data > 99) time_error = 2;  
17898:  MOVF   x39,W
1789A:  SUBLW  63
1789C:  BC    178A6
1789E:  MOVLW  02
178A0:  MOVLB  8
178A2:  MOVWF  x95
178A4:  MOVLB  7
....................        
....................       RTC_Hr_Data =  (10 * t_entry[6]) + t_entry[7]; 
178A6:  MOVLB  8
178A8:  MOVF   x8F,W
178AA:  MULLW  0A
178AC:  MOVF   FF3,W
178AE:  ADDWF  x90,W
178B0:  MOVLB  7
178B2:  MOVWF  x36
....................       if (RTC_Hr_Data > 24) time_error = 2;  
178B4:  MOVF   x36,W
178B6:  SUBLW  18
178B8:  BC    178C2
178BA:  MOVLW  02
178BC:  MOVLB  8
178BE:  MOVWF  x95
178C0:  MOVLB  7
....................        
....................       RTC_Min_Data = (10 * t_entry[8]) + t_entry[9]; 
178C2:  MOVLB  8
178C4:  MOVF   x91,W
178C6:  MULLW  0A
178C8:  MOVF   FF3,W
178CA:  ADDWF  x92,W
178CC:  MOVLB  7
178CE:  MOVWF  x35
....................       if (RTC_Min_Data > 60) time_error = 2;  
178D0:  MOVF   x35,W
178D2:  SUBLW  3C
178D4:  BC    178DE
178D6:  MOVLW  02
178D8:  MOVLB  8
178DA:  MOVWF  x95
178DC:  MOVLB  7
....................        
....................       RTC_Sec_Data = (10 * t_entry[10]) + t_entry[11]; 
178DE:  MOVLB  8
178E0:  MOVF   x93,W
178E2:  MULLW  0A
178E4:  MOVF   FF3,W
178E6:  ADDWF  x94,W
178E8:  MOVLB  7
178EA:  MOVWF  x34
....................       if (RTC_Sec_Data > 60) time_error = 2; 
178EC:  MOVF   x34,W
178EE:  SUBLW  3C
178F0:  BC    178FA
178F2:  MOVLW  02
178F4:  MOVLB  8
178F6:  MOVWF  x95
178F8:  MOVLB  7
....................        
....................       if (RTCfmt == 0) 
178FA:  MOVF   4F,F
178FC:  BTFSS  FD8.2
178FE:  BRA    179F2
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_Mon_Data, 
....................             RTC_DOM_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
17900:  MOVLW  0A
17902:  BTFSS  F9E.4
17904:  BRA    17902
17906:  MOVWF  FAD
17908:  MOVLW  0D
1790A:  BTFSS  F9E.4
1790C:  BRA    1790A
1790E:  MOVWF  FAD
17910:  CLRF   1B
17912:  BTFSC  FF2.7
17914:  BSF    1B.7
17916:  BCF    FF2.7
17918:  MOVFF  738,A40
1791C:  MOVLW  01
1791E:  MOVLB  A
17920:  MOVWF  x41
17922:  MOVLB  0
17924:  CALL   0F9A
17928:  BTFSC  1B.7
1792A:  BSF    FF2.7
1792C:  MOVLW  2F
1792E:  BTFSS  F9E.4
17930:  BRA    1792E
17932:  MOVWF  FAD
17934:  CLRF   1B
17936:  BTFSC  FF2.7
17938:  BSF    1B.7
1793A:  BCF    FF2.7
1793C:  MOVFF  737,A40
17940:  MOVLW  01
17942:  MOVLB  A
17944:  MOVWF  x41
17946:  MOVLB  0
17948:  CALL   0F9A
1794C:  BTFSC  1B.7
1794E:  BSF    FF2.7
17950:  MOVLW  2F
17952:  BTFSS  F9E.4
17954:  BRA    17952
17956:  MOVWF  FAD
17958:  CLRF   1B
1795A:  BTFSC  FF2.7
1795C:  BSF    1B.7
1795E:  BCF    FF2.7
17960:  MOVFF  739,A40
17964:  MOVLW  01
17966:  MOVLB  A
17968:  MOVWF  x41
1796A:  MOVLB  0
1796C:  CALL   0F9A
17970:  BTFSC  1B.7
17972:  BSF    FF2.7
17974:  MOVLW  20
17976:  BTFSS  F9E.4
17978:  BRA    17976
1797A:  MOVWF  FAD
1797C:  CLRF   1B
1797E:  BTFSC  FF2.7
17980:  BSF    1B.7
17982:  BCF    FF2.7
17984:  MOVFF  736,A40
17988:  MOVLW  01
1798A:  MOVLB  A
1798C:  MOVWF  x41
1798E:  MOVLB  0
17990:  CALL   0F9A
17994:  BTFSC  1B.7
17996:  BSF    FF2.7
17998:  MOVLW  3A
1799A:  BTFSS  F9E.4
1799C:  BRA    1799A
1799E:  MOVWF  FAD
179A0:  CLRF   1B
179A2:  BTFSC  FF2.7
179A4:  BSF    1B.7
179A6:  BCF    FF2.7
179A8:  MOVFF  735,A40
179AC:  MOVLW  01
179AE:  MOVLB  A
179B0:  MOVWF  x41
179B2:  MOVLB  0
179B4:  CALL   0F9A
179B8:  BTFSC  1B.7
179BA:  BSF    FF2.7
179BC:  MOVLW  3A
179BE:  BTFSS  F9E.4
179C0:  BRA    179BE
179C2:  MOVWF  FAD
179C4:  CLRF   1B
179C6:  BTFSC  FF2.7
179C8:  BSF    1B.7
179CA:  BCF    FF2.7
179CC:  MOVFF  734,A40
179D0:  MOVLW  01
179D2:  MOVLB  A
179D4:  MOVWF  x41
179D6:  MOVLB  0
179D8:  CALL   0F9A
179DC:  BTFSC  1B.7
179DE:  BSF    FF2.7
179E0:  MOVLW  0A
179E2:  BTFSS  F9E.4
179E4:  BRA    179E2
179E6:  MOVWF  FAD
179E8:  MOVLW  0D
179EA:  BTFSS  F9E.4
179EC:  BRA    179EA
179EE:  MOVWF  FAD
179F0:  MOVLB  7
....................       } 
....................        
....................       if (RTCfmt == 1) 
179F2:  DECFSZ 4F,W
179F4:  BRA    17AE8
....................       { 
....................       fprintf(COM_A, "\n\r%02u/%02u/%02u %02u:%02u:%02u\n\r", RTC_DOM_Data, 
....................             RTC_Mon_Data,RTC_Yr_Data,RTC_Hr_Data,RTC_Min_Data,RTC_Sec_Data); 
179F6:  MOVLW  0A
179F8:  BTFSS  F9E.4
179FA:  BRA    179F8
179FC:  MOVWF  FAD
179FE:  MOVLW  0D
17A00:  BTFSS  F9E.4
17A02:  BRA    17A00
17A04:  MOVWF  FAD
17A06:  CLRF   1B
17A08:  BTFSC  FF2.7
17A0A:  BSF    1B.7
17A0C:  BCF    FF2.7
17A0E:  MOVFF  737,A40
17A12:  MOVLW  01
17A14:  MOVLB  A
17A16:  MOVWF  x41
17A18:  MOVLB  0
17A1A:  CALL   0F9A
17A1E:  BTFSC  1B.7
17A20:  BSF    FF2.7
17A22:  MOVLW  2F
17A24:  BTFSS  F9E.4
17A26:  BRA    17A24
17A28:  MOVWF  FAD
17A2A:  CLRF   1B
17A2C:  BTFSC  FF2.7
17A2E:  BSF    1B.7
17A30:  BCF    FF2.7
17A32:  MOVFF  738,A40
17A36:  MOVLW  01
17A38:  MOVLB  A
17A3A:  MOVWF  x41
17A3C:  MOVLB  0
17A3E:  CALL   0F9A
17A42:  BTFSC  1B.7
17A44:  BSF    FF2.7
17A46:  MOVLW  2F
17A48:  BTFSS  F9E.4
17A4A:  BRA    17A48
17A4C:  MOVWF  FAD
17A4E:  CLRF   1B
17A50:  BTFSC  FF2.7
17A52:  BSF    1B.7
17A54:  BCF    FF2.7
17A56:  MOVFF  739,A40
17A5A:  MOVLW  01
17A5C:  MOVLB  A
17A5E:  MOVWF  x41
17A60:  MOVLB  0
17A62:  CALL   0F9A
17A66:  BTFSC  1B.7
17A68:  BSF    FF2.7
17A6A:  MOVLW  20
17A6C:  BTFSS  F9E.4
17A6E:  BRA    17A6C
17A70:  MOVWF  FAD
17A72:  CLRF   1B
17A74:  BTFSC  FF2.7
17A76:  BSF    1B.7
17A78:  BCF    FF2.7
17A7A:  MOVFF  736,A40
17A7E:  MOVLW  01
17A80:  MOVLB  A
17A82:  MOVWF  x41
17A84:  MOVLB  0
17A86:  CALL   0F9A
17A8A:  BTFSC  1B.7
17A8C:  BSF    FF2.7
17A8E:  MOVLW  3A
17A90:  BTFSS  F9E.4
17A92:  BRA    17A90
17A94:  MOVWF  FAD
17A96:  CLRF   1B
17A98:  BTFSC  FF2.7
17A9A:  BSF    1B.7
17A9C:  BCF    FF2.7
17A9E:  MOVFF  735,A40
17AA2:  MOVLW  01
17AA4:  MOVLB  A
17AA6:  MOVWF  x41
17AA8:  MOVLB  0
17AAA:  CALL   0F9A
17AAE:  BTFSC  1B.7
17AB0:  BSF    FF2.7
17AB2:  MOVLW  3A
17AB4:  BTFSS  F9E.4
17AB6:  BRA    17AB4
17AB8:  MOVWF  FAD
17ABA:  CLRF   1B
17ABC:  BTFSC  FF2.7
17ABE:  BSF    1B.7
17AC0:  BCF    FF2.7
17AC2:  MOVFF  734,A40
17AC6:  MOVLW  01
17AC8:  MOVLB  A
17ACA:  MOVWF  x41
17ACC:  MOVLB  0
17ACE:  CALL   0F9A
17AD2:  BTFSC  1B.7
17AD4:  BSF    FF2.7
17AD6:  MOVLW  0A
17AD8:  BTFSS  F9E.4
17ADA:  BRA    17AD8
17ADC:  MOVWF  FAD
17ADE:  MOVLW  0D
17AE0:  BTFSS  F9E.4
17AE2:  BRA    17AE0
17AE4:  MOVWF  FAD
17AE6:  MOVLB  7
....................       } 
....................       if (time_error == 2) cmd_inv();             
17AE8:  MOVLB  8
17AEA:  MOVF   x95,W
17AEC:  SUBLW  02
17AEE:  BNZ   17AF6
17AF0:  MOVLB  0
17AF2:  BRA    1772E
17AF4:  MOVLB  8
....................  
....................    } 
17AF6:  BRA    17B00
....................    else cmd_arg(); 
17AF8:  MOVLB  0
17AFA:  CALL   B2F2
17AFE:  MOVLB  8
....................     
....................    return time_error; 
17B00:  MOVFF  895,01
17B04:  MOVLB  0
17B06:  RETURN 0
.................... } 
....................  
.................... void RTC_Set(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    time_error = get_time(); 
*
17B46:  RCALL  1774E
17B48:  MOVFF  01,885
....................     
....................    if (time_error ==0 ){ 
17B4C:  MOVLB  8
17B4E:  MOVF   x85,F
17B50:  BTFSS  FD8.2
17B52:  BRA    17C8A
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
17B54:  BCF    FC6.5
17B56:  MOVLW  21
17B58:  MOVWF  FC6
17B5A:  MOVLW  40
17B5C:  MOVWF  FC7
....................     
....................       output_bit(RTC_CS, ENABLE); 
17B5E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x86);        // address - Month 
17B60:  MOVF   FC9,W
17B62:  MOVLW  86
17B64:  MOVWF  FC9
17B66:  RRCF   FC7,W
17B68:  BNC   17B66
17B6A:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Mon_Data));  // data 
17B6E:  MOVFF  738,887
17B72:  MOVLB  0
17B74:  RCALL  17B08
17B76:  MOVFF  01,887
17B7A:  MOVF   FC9,W
17B7C:  MOVFF  01,FC9
17B80:  RRCF   FC7,W
17B82:  BNC   17B80
17B84:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17B88:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17B8A:  BCF    F91.0
....................       RTC_buffer = spi_read(0x85);        // address - DOM 
17B8C:  MOVF   FC9,W
17B8E:  MOVLW  85
17B90:  MOVWF  FC9
17B92:  RRCF   FC7,W
17B94:  BNC   17B92
17B96:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
17B9A:  MOVFF  737,887
17B9E:  RCALL  17B08
17BA0:  MOVFF  01,887
17BA4:  MOVF   FC9,W
17BA6:  MOVFF  01,FC9
17BAA:  RRCF   FC7,W
17BAC:  BNC   17BAA
17BAE:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17BB2:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17BB4:  BCF    F91.0
....................       RTC_buffer = spi_read(0x87);        // address - Year 
17BB6:  MOVF   FC9,W
17BB8:  MOVLW  87
17BBA:  MOVWF  FC9
17BBC:  RRCF   FC7,W
17BBE:  BNC   17BBC
17BC0:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Yr_Data));  // data 
17BC4:  MOVFF  739,887
17BC8:  RCALL  17B08
17BCA:  MOVFF  01,887
17BCE:  MOVF   FC9,W
17BD0:  MOVFF  01,FC9
17BD4:  RRCF   FC7,W
17BD6:  BNC   17BD4
17BD8:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17BDC:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17BDE:  BCF    F91.0
....................       RTC_buffer = spi_read(0x83);        // address - Hour 
17BE0:  MOVF   FC9,W
17BE2:  MOVLW  83
17BE4:  MOVWF  FC9
17BE6:  RRCF   FC7,W
17BE8:  BNC   17BE6
17BEA:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
17BEE:  MOVFF  736,887
17BF2:  RCALL  17B08
17BF4:  MOVFF  01,887
17BF8:  MOVF   FC9,W
17BFA:  MOVFF  01,FC9
17BFE:  RRCF   FC7,W
17C00:  BNC   17BFE
17C02:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C06:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C08:  BCF    F91.0
....................       RTC_buffer = spi_read(0x82);        // address - Min 
17C0A:  MOVF   FC9,W
17C0C:  MOVLW  82
17C0E:  MOVWF  FC9
17C10:  RRCF   FC7,W
17C12:  BNC   17C10
17C14:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
17C18:  MOVFF  735,887
17C1C:  RCALL  17B08
17C1E:  MOVFF  01,887
17C22:  MOVF   FC9,W
17C24:  MOVFF  01,FC9
17C28:  RRCF   FC7,W
17C2A:  BNC   17C28
17C2C:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C30:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C32:  BCF    F91.0
....................       RTC_buffer = spi_read(0x81);        // address - Sec 
17C34:  MOVF   FC9,W
17C36:  MOVLW  81
17C38:  MOVWF  FC9
17C3A:  RRCF   FC7,W
17C3C:  BNC   17C3A
17C3E:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
17C42:  MOVFF  734,887
17C46:  RCALL  17B08
17C48:  MOVFF  01,887
17C4C:  MOVF   FC9,W
17C4E:  MOVFF  01,FC9
17C52:  RRCF   FC7,W
17C54:  BNC   17C52
17C56:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C5A:  BSF    F91.0
....................       output_bit(RTC_CS, ENABLE); 
17C5C:  BCF    F91.0
....................       RTC_buffer = spi_read(0x80);        // address - ms 
17C5E:  MOVF   FC9,W
17C60:  MOVLW  80
17C62:  MOVWF  FC9
17C64:  RRCF   FC7,W
17C66:  BNC   17C64
17C68:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(0));  // data 
17C6C:  MOVLB  8
17C6E:  CLRF   x87
17C70:  MOVLB  0
17C72:  RCALL  17B08
17C74:  MOVFF  01,887
17C78:  MOVF   FC9,W
17C7A:  MOVFF  01,FC9
17C7E:  RRCF   FC7,W
17C80:  BNC   17C7E
17C82:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
17C86:  BSF    F91.0
17C88:  MOVLB  8
....................    } 
17C8A:  MOVLB  0
17C8C:  GOTO   17D18 (RETURN)
.................... } 
....................  
.................... // set alarm to wake up at real-time 
.................... void RTC_alarm(){ 
....................  
....................    int8 time_error; 
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
*
18816:  CALL   E408
....................     
....................    time_error = get_time(); 
1881A:  CALL   1774E
1881E:  MOVFF  01,885
....................     
....................    if (time_error == 0 ){ 
18822:  MOVLB  8
18824:  MOVF   x85,F
18826:  BTFSS  FD8.2
18828:  BRA    1895E
....................     
....................       // RTC does not have a year register - store in EEPROM 
....................       RTC_Al_Yr_Reg = RTC_Yr_Data; 
1882A:  MOVFF  739,72D
....................       write8(ADDR_ALARM_YR, RTC_Al_Yr_Reg); 
1882E:  MOVLW  04
18830:  MOVWF  x89
18832:  MOVFF  72D,88A
18836:  MOVLB  0
18838:  CALL   3406
....................     
....................       // Masking AFE bit to ensure alarm output is enabled 
....................       RTC_Mon_Data = Dec2Bcd(RTC_Mon_Data); 
1883C:  MOVFF  738,887
18840:  CALL   17B08
18844:  MOVFF  01,738
....................       RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
18848:  MOVLB  7
1884A:  BSF    x38.7
....................        
....................       // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................       setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
1884C:  BCF    FC6.5
1884E:  MOVLW  21
18850:  MOVWF  FC6
18852:  MOVLW  40
18854:  MOVWF  FC7
....................       delay_us(10); 
18856:  MOVLW  35
18858:  MOVWF  00
1885A:  DECFSZ 00,F
1885C:  BRA    1885A
....................        
....................       // Do not write alarm seconds last 
....................       // ... it disables the interrupt/flag 
....................     
....................       output_bit(RTC_CS, ENABLE); 
1885E:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8E);        // address - Sec 
18860:  MOVF   FC9,W
18862:  MOVLW  8E
18864:  MOVWF  FC9
18866:  RRCF   FC7,W
18868:  BNC   18866
1886A:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Sec_Data));  // data 
1886E:  MOVFF  734,887
18872:  MOVLB  0
18874:  CALL   17B08
18878:  MOVFF  01,887
1887C:  MOVF   FC9,W
1887E:  MOVFF  01,FC9
18882:  RRCF   FC7,W
18884:  BNC   18882
18886:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
1888A:  BSF    F91.0
....................       delay_us(1); // Delays added 1.020A 
1888C:  MOVLW  05
1888E:  MOVWF  00
18890:  DECFSZ 00,F
18892:  BRA    18890
....................        
....................       output_bit(RTC_CS, ENABLE); 
18894:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8D);        // address - Min 
18896:  MOVF   FC9,W
18898:  MOVLW  8D
1889A:  MOVWF  FC9
1889C:  RRCF   FC7,W
1889E:  BNC   1889C
188A0:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Min_Data));  // data 
188A4:  MOVFF  735,887
188A8:  CALL   17B08
188AC:  MOVFF  01,887
188B0:  MOVF   FC9,W
188B2:  MOVFF  01,FC9
188B6:  RRCF   FC7,W
188B8:  BNC   188B6
188BA:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
188BE:  BSF    F91.0
....................       delay_us(1); 
188C0:  MOVLW  05
188C2:  MOVWF  00
188C4:  DECFSZ 00,F
188C6:  BRA    188C4
....................        
....................       output_bit(RTC_CS, ENABLE); 
188C8:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8C);        // address - Hour 
188CA:  MOVF   FC9,W
188CC:  MOVLW  8C
188CE:  MOVWF  FC9
188D0:  RRCF   FC7,W
188D2:  BNC   188D0
188D4:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_Hr_Data));  // data 
188D8:  MOVFF  736,887
188DC:  CALL   17B08
188E0:  MOVFF  01,887
188E4:  MOVF   FC9,W
188E6:  MOVFF  01,FC9
188EA:  RRCF   FC7,W
188EC:  BNC   188EA
188EE:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
188F2:  BSF    F91.0
....................       delay_us(1);  
188F4:  MOVLW  05
188F6:  MOVWF  00
188F8:  DECFSZ 00,F
188FA:  BRA    188F8
....................        
....................       output_bit(RTC_CS, ENABLE); 
188FC:  BCF    F91.0
....................       RTC_buffer = spi_read(0x8B);        // address - DOM 
188FE:  MOVF   FC9,W
18900:  MOVLW  8B
18902:  MOVWF  FC9
18904:  RRCF   FC7,W
18906:  BNC   18904
18908:  MOVFF  FC9,886
....................       RTC_buffer = spi_read(Dec2Bcd(RTC_DOM_Data));  // data 
1890C:  MOVFF  737,887
18910:  CALL   17B08
18914:  MOVFF  01,887
18918:  MOVF   FC9,W
1891A:  MOVFF  01,FC9
1891E:  RRCF   FC7,W
18920:  BNC   1891E
18922:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE);  
18926:  BSF    F91.0
....................       delay_us(1); 
18928:  MOVLW  05
1892A:  MOVWF  00
1892C:  DECFSZ 00,F
1892E:  BRA    1892C
....................        
....................       output_bit(RTC_CS, ENABLE); 
18930:  BCF    F91.0
....................       //fprintf(COM_A,"test61\r\n"); 
....................       RTC_buffer = spi_read(0x8A);// address - Month 
18932:  MOVF   FC9,W
18934:  MOVLW  8A
18936:  MOVWF  FC9
18938:  RRCF   FC7,W
1893A:  BNC   18938
1893C:  MOVFF  FC9,886
....................       //fprintf(COM_A,"test62\r\n"); 
....................       //fprintf(COM_A,"test6: %d\r\n",RTC_Mon_Data); 
....................       RTC_buffer = spi_read(RTC_Mon_Data);  // data 
18940:  MOVF   FC9,W
18942:  MOVFF  738,FC9
18946:  RRCF   FC7,W
18948:  BNC   18946
1894A:  MOVFF  FC9,886
....................       output_bit(RTC_CS, DISABLE); 
1894E:  BSF    F91.0
....................       delay_us(1); 
18950:  MOVLW  05
18952:  MOVWF  00
18954:  DECFSZ 00,F
18956:  BRA    18954
....................       //fprintf(COM_A,"test6\r\n"); 
....................     
....................    RTC_read_alarm(); 
18958:  CALL   E408
1895C:  MOVLB  8
....................    } 
1895E:  MOVLB  0
18960:  GOTO   18976 (RETURN)
.................... } 
....................  
.................... // set default / valid alarm 
.................... void RTC_alarm_reset(){ 
....................  
....................    int8 RTC_buffer; 
....................     
....................    RTC_read_alarm(); 
....................     
....................    // RTC does not have a year register - store in EEPROM 
....................    RTC_Al_Yr_Reg = RTC_Yr_Data; 
....................    write8(ADDR_ALARM_YR, 10);    // 2010 
....................  
....................    // Masking AFE bit to ensure alarm output is enabled 
....................    RTC_Mon_Data = Dec2Bcd(1);    // = Jan 
....................    RTC_Mon_Data = RTC_Mon_Data | 0b10000000; 
....................     
....................    // Freq DC to 2 MHz ((10/4)/16) = 625 kHz 
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
....................    delay_us(10); 
....................     
....................    // Do not write alarm seconds last 
....................    // ... it disables the interrupt/flag 
....................  
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);            // Delays added 1.020A 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
....................    RTC_buffer = spi_read(Dec2Bcd(0));  // data = 0 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
....................    RTC_buffer = spi_read(Dec2Bcd(13));  // data = 13:00 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1);    
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
....................    RTC_buffer = spi_read(Dec2Bcd(1));  // data = 1st 
....................    output_bit(RTC_CS, DISABLE);  
....................    delay_us(1); 
....................     
....................    output_bit(RTC_CS, ENABLE); 
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
....................    RTC_buffer = spi_read(RTC_Mon_Data);  // data = Jan 
....................    output_bit(RTC_CS, DISABLE); 
....................    delay_us(1); 
....................     
....................    RTC_read_alarm(); 
.................... } 
....................  
.................... // set alarm to go off every minute 
.................... void RTC_minute() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
*
15EDE:  BCF    FC6.5
15EE0:  MOVLW  21
15EE2:  MOVWF  FC6
15EE4:  MOVLW  40
15EE6:  MOVWF  FC7
....................     
....................    // Do not write alarm seconds last. It will disable the interrupt/flag 
....................    output_bit(RTC_CS, ENABLE); 
15EE8:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8E);        // address - Sec 
15EEA:  MOVF   FC9,W
15EEC:  MOVLW  8E
15EEE:  MOVWF  FC9
15EF0:  RRCF   FC7,W
15EF2:  BNC   15EF0
15EF4:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b00000000);  // data 
15EF8:  MOVF   FC9,W
15EFA:  CLRF   FC9
15EFC:  RRCF   FC7,W
15EFE:  BNC   15EFC
15F00:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F04:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F06:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8D);        // address - Min 
15F08:  MOVF   FC9,W
15F0A:  MOVLW  8D
15F0C:  MOVWF  FC9
15F0E:  RRCF   FC7,W
15F10:  BNC   15F0E
15F12:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F16:  MOVF   FC9,W
15F18:  MOVLW  80
15F1A:  MOVWF  FC9
15F1C:  RRCF   FC7,W
15F1E:  BNC   15F1C
15F20:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F24:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F26:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8C);        // address - Hour 
15F28:  MOVF   FC9,W
15F2A:  MOVLW  8C
15F2C:  MOVWF  FC9
15F2E:  RRCF   FC7,W
15F30:  BNC   15F2E
15F32:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F36:  MOVF   FC9,W
15F38:  MOVLW  80
15F3A:  MOVWF  FC9
15F3C:  RRCF   FC7,W
15F3E:  BNC   15F3C
15F40:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F44:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F46:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8B);        // address - DOM 
15F48:  MOVF   FC9,W
15F4A:  MOVLW  8B
15F4C:  MOVWF  FC9
15F4E:  RRCF   FC7,W
15F50:  BNC   15F4E
15F52:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b11000000);  // data 
15F56:  MOVF   FC9,W
15F58:  MOVLW  C0
15F5A:  MOVWF  FC9
15F5C:  RRCF   FC7,W
15F5E:  BNC   15F5C
15F60:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE);    
15F64:  BSF    F91.0
....................    output_bit(RTC_CS, ENABLE); 
15F66:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15F68:  MOVF   FC9,W
15F6A:  MOVLW  8A
15F6C:  MOVWF  FC9
15F6E:  RRCF   FC7,W
15F70:  BNC   15F6E
15F72:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(0b10000000);  // data 
15F76:  MOVF   FC9,W
15F78:  MOVLW  80
15F7A:  MOVWF  FC9
15F7C:  RRCF   FC7,W
15F7E:  BNC   15F7C
15F80:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
15F84:  BSF    F91.0
....................     
....................    RTC_read_alarm(); 
15F86:  CALL   E408
15F8A:  GOTO   16D4A (RETURN)
.................... } 
....................  
.................... // Enables IRQ output (hardware) 
.................... void RTC_set_AFE() 
.................... { 
....................    int8 RTC_buffer; 
....................     
....................    RTC_buffer = 0; 
*
1570E:  MOVLB  8
15710:  CLRF   x87
....................     
....................    setup_spi(SPI_MASTER|SPI_MODE_0_0|SPI_CLK_DIV_16); 
15712:  BCF    FC6.5
15714:  MOVLW  21
15716:  MOVWF  FC6
15718:  MOVLW  40
1571A:  MOVWF  FC7
....................     
....................    output_bit(RTC_CS, ENABLE); 
1571C:  BCF    F91.0
....................    RTC_buffer = spi_read(0x0A); 
1571E:  MOVF   FC9,W
15720:  MOVLW  0A
15722:  MOVWF  FC9
15724:  RRCF   FC7,W
15726:  BNC   15724
15728:  MOVFF  FC9,887
....................    RTC_Al_Mon_Reg = spi_read(RTC_buffer); 
1572C:  MOVF   FC9,W
1572E:  MOVFF  887,FC9
15732:  RRCF   FC7,W
15734:  BNC   15732
15736:  MOVFF  FC9,72E
....................    output_bit(RTC_CS, DISABLE); 
1573A:  BSF    F91.0
....................     
....................    RTC_Al_Mon_Reg = RTC_Al_Mon_Reg | 0b10000000; 
1573C:  MOVLB  7
1573E:  BSF    x2E.7
....................     
....................    output_bit(RTC_CS, ENABLE); 
15740:  BCF    F91.0
....................    RTC_buffer = spi_read(0x8A);        // address - Month 
15742:  MOVF   FC9,W
15744:  MOVLW  8A
15746:  MOVWF  FC9
15748:  RRCF   FC7,W
1574A:  BNC   15748
1574C:  MOVFF  FC9,887
....................    RTC_buffer = spi_read(RTC_Al_Mon_Reg);  // data 
15750:  MOVF   FC9,W
15752:  MOVFF  72E,FC9
15756:  RRCF   FC7,W
15758:  BNC   15756
1575A:  MOVFF  FC9,887
....................    output_bit(RTC_CS, DISABLE); 
1575E:  BSF    F91.0
15760:  MOVLB  0
15762:  GOTO   16C74 (RETURN)
.................... } 
....................  
.................... // *** RTC checks & status *** // 
....................  
.................... void RTC_last_power() 
.................... { 
....................    rtc_last_sec   = RTC_Sec_Reg; 
*
03436:  MOVFF  725,73F
....................    rtc_last_min   = RTC_Min_Reg; 
0343A:  MOVFF  726,73E
....................    rtc_last_hour  = RTC_Hr_Reg; 
0343E:  MOVFF  727,73D
....................    rtc_last_day   = RTC_DOM_Reg; 
03442:  MOVFF  729,73B
....................    rtc_last_month = RTC_Mon_Reg; 
03446:  MOVFF  72A,73A
....................    rtc_last_year  = RTC_Yr_Reg; 
0344A:  MOVFF  72B,73C
....................     
....................    write8(ADDR_LAST_MONTH, rtc_last_month); 
0344E:  MOVLW  06
03450:  MOVLB  8
03452:  MOVWF  x89
03454:  MOVFF  73A,88A
03458:  MOVLB  0
0345A:  RCALL  3406
....................    write8(ADDR_LAST_DAY, rtc_last_day); 
0345C:  MOVLW  08
0345E:  MOVLB  8
03460:  MOVWF  x89
03462:  MOVFF  73B,88A
03466:  MOVLB  0
03468:  RCALL  3406
....................    write8(ADDR_LAST_YEAR, rtc_last_year); 
0346A:  MOVLW  0A
0346C:  MOVLB  8
0346E:  MOVWF  x89
03470:  MOVFF  73C,88A
03474:  MOVLB  0
03476:  RCALL  3406
....................    write8(ADDR_LAST_HOUR, rtc_last_hour); 
03478:  MOVLW  0C
0347A:  MOVLB  8
0347C:  MOVWF  x89
0347E:  MOVFF  73D,88A
03482:  MOVLB  0
03484:  RCALL  3406
....................    write8(ADDR_LAST_MIN, rtc_last_min); 
03486:  MOVLW  0E
03488:  MOVLB  8
0348A:  MOVWF  x89
0348C:  MOVFF  73E,88A
03490:  MOVLB  0
03492:  RCALL  3406
....................    write8(ADDR_LAST_SEC, rtc_last_sec); 
03494:  MOVLW  10
03496:  MOVLB  8
03498:  MOVWF  x89
0349A:  MOVFF  73F,88A
0349E:  MOVLB  0
034A0:  RCALL  3406
034A2:  GOTO   1B784 (RETURN)
.................... } 
....................  
.................... void RTC_late() 
*
15766:  MOVLB  8
15768:  CLRF   x8A
1576A:  CLRF   x89
1576C:  CLRF   x88
1576E:  CLRF   x87
15770:  CLRF   x8E
15772:  CLRF   x8D
15774:  CLRF   x8C
15776:  CLRF   x8B
15778:  CLRF   x92
1577A:  CLRF   x91
1577C:  CLRF   x90
1577E:  CLRF   x8F
.................... { 
....................    float time_now = 0; 
....................    float time_alarm = 0; 
....................    float fraction_of_day = 0; 
....................    float hour, minute, second; 
....................     
....................    //                        J F  M  A  M   J   J   A   S   O   N   D 
....................    int16 end_of_month[12] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
15780:  CLRF   x9F
15782:  CLRF   xA0
15784:  MOVLW  1F
15786:  MOVWF  xA1
15788:  CLRF   xA2
1578A:  MOVLW  3B
1578C:  MOVWF  xA3
1578E:  CLRF   xA4
15790:  MOVLW  5A
15792:  MOVWF  xA5
15794:  CLRF   xA6
15796:  MOVLW  78
15798:  MOVWF  xA7
1579A:  CLRF   xA8
1579C:  MOVLW  97
1579E:  MOVWF  xA9
157A0:  CLRF   xAA
157A2:  MOVLW  B5
157A4:  MOVWF  xAB
157A6:  CLRF   xAC
157A8:  MOVLW  D4
157AA:  MOVWF  xAD
157AC:  CLRF   xAE
157AE:  MOVLW  F3
157B0:  MOVWF  xAF
157B2:  CLRF   xB0
157B4:  MOVLW  11
157B6:  MOVWF  xB1
157B8:  MOVLW  01
157BA:  MOVWF  xB2
157BC:  MOVLW  30
157BE:  MOVWF  xB3
157C0:  MOVLW  01
157C2:  MOVWF  xB4
157C4:  MOVLW  4E
157C6:  MOVWF  xB5
157C8:  MOVLW  01
157CA:  MOVWF  xB6
....................    //                        0  1  2  3   4   5   6   7   8   9  10  11 
....................     
....................    alarm_passed = FALSE; 
157CC:  BCF    4D.3
....................     
....................    RTC_read(); 
157CE:  MOVLB  0
157D0:  CALL   3338
....................    RTC_read_alarm(); 
157D4:  CALL   E408
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR); 
157D8:  MOVLW  04
157DA:  MOVLB  8
157DC:  MOVWF  xB7
157DE:  MOVLB  0
157E0:  CALL   2A18
157E4:  MOVFF  01,72D
....................    // if current year > alarm year .. alarm is in the past 
....................    if (RTC_Yr_Reg > RTC_Al_Yr_Reg) alarm_passed = TRUE; 
157E8:  MOVLB  7
157EA:  MOVF   x2B,W
157EC:  SUBWF  x2D,W
157EE:  BC    157F4
157F0:  BSF    4D.3
157F2:  BRA    15C28
....................    else { 
....................       // if current year = alarm year .. test rest of fields 
....................       if (RTC_Yr_Reg == RTC_Al_Yr_Reg) { 
157F4:  MOVF   x2D,W
157F6:  SUBWF  x2B,W
157F8:  BTFSS  FD8.2
157FA:  BRA    15C28
....................        
....................          // calculate fractional current time 
....................          time_now = end_of_month[RTC_Mon_Reg-1]; 
157FC:  MOVLW  01
157FE:  SUBWF  x2A,W
15800:  MOVWF  00
15802:  BCF    FD8.0
15804:  RLCF   00,F
15806:  MOVF   00,W
15808:  CLRF   03
1580A:  ADDLW  9F
1580C:  MOVWF  FE9
1580E:  MOVLW  08
15810:  ADDWFC 03,W
15812:  MOVWF  FEA
15814:  MOVFF  FEC,03
15818:  MOVF   FED,F
1581A:  MOVFF  FEF,917
1581E:  MOVFF  03,918
15822:  MOVLB  0
15824:  CALL   C8EA
15828:  MOVFF  03,88A
1582C:  MOVFF  02,889
15830:  MOVFF  01,888
15834:  MOVFF  00,887
....................          time_now = time_now + RTC_DOM_Reg; 
15838:  MOVLB  9
1583A:  CLRF   x18
1583C:  MOVFF  729,917
15840:  MOVLB  0
15842:  CALL   C8EA
15846:  BCF    FD8.1
15848:  MOVFF  88A,91A
1584C:  MOVFF  889,919
15850:  MOVFF  888,918
15854:  MOVFF  887,917
15858:  MOVFF  03,91E
1585C:  MOVFF  02,91D
15860:  MOVFF  01,91C
15864:  MOVFF  00,91B
15868:  CALL   C3AE
1586C:  MOVFF  03,88A
15870:  MOVFF  02,889
15874:  MOVFF  01,888
15878:  MOVFF  00,887
....................           
....................          hour = RTC_Hr_Reg; 
1587C:  MOVLB  9
1587E:  CLRF   x18
15880:  MOVFF  727,917
15884:  MOVLB  0
15886:  CALL   C8EA
1588A:  MOVFF  03,896
1588E:  MOVFF  02,895
15892:  MOVFF  01,894
15896:  MOVFF  00,893
....................          minute = RTC_Min_Reg; 
1589A:  MOVLB  9
1589C:  CLRF   x18
1589E:  MOVFF  726,917
158A2:  MOVLB  0
158A4:  CALL   C8EA
158A8:  MOVFF  03,89A
158AC:  MOVFF  02,899
158B0:  MOVFF  01,898
158B4:  MOVFF  00,897
....................          second = RTC_Sec_Reg; 
158B8:  MOVLB  9
158BA:  CLRF   x18
158BC:  MOVFF  725,917
158C0:  MOVLB  0
158C2:  CALL   C8EA
158C6:  MOVFF  03,89E
158CA:  MOVFF  02,89D
158CE:  MOVFF  01,89C
158D2:  MOVFF  00,89B
....................           
....................          fraction_of_day = (hour / 24); 
158D6:  MOVFF  896,8FE
158DA:  MOVFF  895,8FD
158DE:  MOVFF  894,8FC
158E2:  MOVFF  893,8FB
158E6:  MOVLB  9
158E8:  CLRF   x02
158EA:  CLRF   x01
158EC:  MOVLW  40
158EE:  MOVWF  x00
158F0:  MOVLW  83
158F2:  MOVLB  8
158F4:  MOVWF  xFF
158F6:  MOVLB  0
158F8:  CALL   C920
158FC:  MOVFF  03,892
15900:  MOVFF  02,891
15904:  MOVFF  01,890
15908:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
1590C:  MOVFF  89A,8FE
15910:  MOVFF  899,8FD
15914:  MOVFF  898,8FC
15918:  MOVFF  897,8FB
1591C:  MOVLB  9
1591E:  CLRF   x02
15920:  CLRF   x01
15922:  MOVLW  34
15924:  MOVWF  x00
15926:  MOVLW  89
15928:  MOVLB  8
1592A:  MOVWF  xFF
1592C:  MOVLB  0
1592E:  CALL   C920
15932:  BCF    FD8.1
15934:  MOVFF  892,91A
15938:  MOVFF  891,919
1593C:  MOVFF  890,918
15940:  MOVFF  88F,917
15944:  MOVFF  03,91E
15948:  MOVFF  02,91D
1594C:  MOVFF  01,91C
15950:  MOVFF  00,91B
15954:  CALL   C3AE
15958:  MOVFF  03,892
1595C:  MOVFF  02,891
15960:  MOVFF  01,890
15964:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
15968:  MOVFF  89E,8FE
1596C:  MOVFF  89D,8FD
15970:  MOVFF  89C,8FC
15974:  MOVFF  89B,8FB
15978:  MOVLB  9
1597A:  CLRF   x02
1597C:  MOVLW  C0
1597E:  MOVWF  x01
15980:  MOVLW  28
15982:  MOVWF  x00
15984:  MOVLW  8F
15986:  MOVLB  8
15988:  MOVWF  xFF
1598A:  MOVLB  0
1598C:  CALL   C920
15990:  BCF    FD8.1
15992:  MOVFF  892,91A
15996:  MOVFF  891,919
1599A:  MOVFF  890,918
1599E:  MOVFF  88F,917
159A2:  MOVFF  03,91E
159A6:  MOVFF  02,91D
159AA:  MOVFF  01,91C
159AE:  MOVFF  00,91B
159B2:  CALL   C3AE
159B6:  MOVFF  03,892
159BA:  MOVFF  02,891
159BE:  MOVFF  01,890
159C2:  MOVFF  00,88F
....................           
....................          time_now = time_now + fraction_of_day; 
159C6:  BCF    FD8.1
159C8:  MOVFF  88A,91A
159CC:  MOVFF  889,919
159D0:  MOVFF  888,918
159D4:  MOVFF  887,917
159D8:  MOVFF  892,91E
159DC:  MOVFF  891,91D
159E0:  MOVFF  890,91C
159E4:  MOVFF  88F,91B
159E8:  CALL   C3AE
159EC:  MOVFF  03,88A
159F0:  MOVFF  02,889
159F4:  MOVFF  01,888
159F8:  MOVFF  00,887
....................           
....................          // calculate fractional alarm time 
....................          hour = RTC_Al_Hr_Reg; 
159FC:  MOVLB  9
159FE:  CLRF   x18
15A00:  MOVFF  730,917
15A04:  MOVLB  0
15A06:  CALL   C8EA
15A0A:  MOVFF  03,896
15A0E:  MOVFF  02,895
15A12:  MOVFF  01,894
15A16:  MOVFF  00,893
....................          minute = RTC_Al_Min_Reg; 
15A1A:  MOVLB  9
15A1C:  CLRF   x18
15A1E:  MOVFF  731,917
15A22:  MOVLB  0
15A24:  CALL   C8EA
15A28:  MOVFF  03,89A
15A2C:  MOVFF  02,899
15A30:  MOVFF  01,898
15A34:  MOVFF  00,897
....................          second = RTC_Al_Sec_Reg; 
15A38:  MOVLB  9
15A3A:  CLRF   x18
15A3C:  MOVFF  732,917
15A40:  MOVLB  0
15A42:  CALL   C8EA
15A46:  MOVFF  03,89E
15A4A:  MOVFF  02,89D
15A4E:  MOVFF  01,89C
15A52:  MOVFF  00,89B
....................           
....................          time_alarm = end_of_month[RTC_Al_Mon_Reg-1]; 
15A56:  MOVLW  01
15A58:  MOVLB  7
15A5A:  SUBWF  x2E,W
15A5C:  MOVWF  00
15A5E:  BCF    FD8.0
15A60:  RLCF   00,F
15A62:  MOVF   00,W
15A64:  CLRF   03
15A66:  ADDLW  9F
15A68:  MOVWF  FE9
15A6A:  MOVLW  08
15A6C:  ADDWFC 03,W
15A6E:  MOVWF  FEA
15A70:  MOVFF  FEC,03
15A74:  MOVF   FED,F
15A76:  MOVFF  FEF,917
15A7A:  MOVFF  03,918
15A7E:  MOVLB  0
15A80:  CALL   C8EA
15A84:  MOVFF  03,88E
15A88:  MOVFF  02,88D
15A8C:  MOVFF  01,88C
15A90:  MOVFF  00,88B
....................          time_alarm = time_alarm + RTC_Al_DOM_Reg; 
15A94:  MOVLB  9
15A96:  CLRF   x18
15A98:  MOVFF  72F,917
15A9C:  MOVLB  0
15A9E:  CALL   C8EA
15AA2:  BCF    FD8.1
15AA4:  MOVFF  88E,91A
15AA8:  MOVFF  88D,919
15AAC:  MOVFF  88C,918
15AB0:  MOVFF  88B,917
15AB4:  MOVFF  03,91E
15AB8:  MOVFF  02,91D
15ABC:  MOVFF  01,91C
15AC0:  MOVFF  00,91B
15AC4:  CALL   C3AE
15AC8:  MOVFF  03,88E
15ACC:  MOVFF  02,88D
15AD0:  MOVFF  01,88C
15AD4:  MOVFF  00,88B
....................           
....................          fraction_of_day = (hour / 24); 
15AD8:  MOVFF  896,8FE
15ADC:  MOVFF  895,8FD
15AE0:  MOVFF  894,8FC
15AE4:  MOVFF  893,8FB
15AE8:  MOVLB  9
15AEA:  CLRF   x02
15AEC:  CLRF   x01
15AEE:  MOVLW  40
15AF0:  MOVWF  x00
15AF2:  MOVLW  83
15AF4:  MOVLB  8
15AF6:  MOVWF  xFF
15AF8:  MOVLB  0
15AFA:  CALL   C920
15AFE:  MOVFF  03,892
15B02:  MOVFF  02,891
15B06:  MOVFF  01,890
15B0A:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (minute / (24*60)); 
15B0E:  MOVFF  89A,8FE
15B12:  MOVFF  899,8FD
15B16:  MOVFF  898,8FC
15B1A:  MOVFF  897,8FB
15B1E:  MOVLB  9
15B20:  CLRF   x02
15B22:  CLRF   x01
15B24:  MOVLW  34
15B26:  MOVWF  x00
15B28:  MOVLW  89
15B2A:  MOVLB  8
15B2C:  MOVWF  xFF
15B2E:  MOVLB  0
15B30:  CALL   C920
15B34:  BCF    FD8.1
15B36:  MOVFF  892,91A
15B3A:  MOVFF  891,919
15B3E:  MOVFF  890,918
15B42:  MOVFF  88F,917
15B46:  MOVFF  03,91E
15B4A:  MOVFF  02,91D
15B4E:  MOVFF  01,91C
15B52:  MOVFF  00,91B
15B56:  CALL   C3AE
15B5A:  MOVFF  03,892
15B5E:  MOVFF  02,891
15B62:  MOVFF  01,890
15B66:  MOVFF  00,88F
....................          fraction_of_day = fraction_of_day + (second / (24*60*60)); 
15B6A:  MOVFF  89E,8FE
15B6E:  MOVFF  89D,8FD
15B72:  MOVFF  89C,8FC
15B76:  MOVFF  89B,8FB
15B7A:  MOVLB  9
15B7C:  CLRF   x02
15B7E:  MOVLW  C0
15B80:  MOVWF  x01
15B82:  MOVLW  28
15B84:  MOVWF  x00
15B86:  MOVLW  8F
15B88:  MOVLB  8
15B8A:  MOVWF  xFF
15B8C:  MOVLB  0
15B8E:  CALL   C920
15B92:  BCF    FD8.1
15B94:  MOVFF  892,91A
15B98:  MOVFF  891,919
15B9C:  MOVFF  890,918
15BA0:  MOVFF  88F,917
15BA4:  MOVFF  03,91E
15BA8:  MOVFF  02,91D
15BAC:  MOVFF  01,91C
15BB0:  MOVFF  00,91B
15BB4:  CALL   C3AE
15BB8:  MOVFF  03,892
15BBC:  MOVFF  02,891
15BC0:  MOVFF  01,890
15BC4:  MOVFF  00,88F
....................           
....................          time_alarm = time_alarm + fraction_of_day; 
15BC8:  BCF    FD8.1
15BCA:  MOVFF  88E,91A
15BCE:  MOVFF  88D,919
15BD2:  MOVFF  88C,918
15BD6:  MOVFF  88B,917
15BDA:  MOVFF  892,91E
15BDE:  MOVFF  891,91D
15BE2:  MOVFF  890,91C
15BE6:  MOVFF  88F,91B
15BEA:  CALL   C3AE
15BEE:  MOVFF  03,88E
15BF2:  MOVFF  02,88D
15BF6:  MOVFF  01,88C
15BFA:  MOVFF  00,88B
....................           
....................          // compare real and alarm time 
....................          if (time_now > time_alarm) alarm_passed = TRUE; 
15BFE:  MOVFF  88E,916
15C02:  MOVFF  88D,915
15C06:  MOVFF  88C,914
15C0A:  MOVFF  88B,913
15C0E:  MOVFF  88A,91A
15C12:  MOVFF  889,919
15C16:  MOVFF  888,918
15C1A:  MOVFF  887,917
15C1E:  CALL   1075E
15C22:  BNC   15C26
15C24:  BSF    4D.3
15C26:  MOVLB  7
....................       } 
....................    } 
15C28:  MOVLB  0
15C2A:  RETURN 0
.................... } 
....................  
.................... void RTC_alarm_status() 
.................... { 
....................    if (alarm_passed == TRUE) fprintf(COM_A, "@ALM\r\n"); 
15C2C:  BTFSS  4D.3
15C2E:  BRA    15C4C
15C30:  MOVLW  C4
15C32:  MOVWF  FF6
15C34:  MOVLW  0D
15C36:  MOVWF  FF7
15C38:  MOVLW  00
15C3A:  MOVWF  FF8
15C3C:  CLRF   1B
15C3E:  BTFSC  FF2.7
15C40:  BSF    1B.7
15C42:  BCF    FF2.7
15C44:  CALL   0E42
15C48:  BTFSC  1B.7
15C4A:  BSF    FF2.7
15C4C:  RETURN 0
.................... } 
....................  
....................  
.................... #include "max525.c" 
....................  
.................... void DAC_set(int8 channel, int16 setting) 
.................... { 
....................    int16 data; 
....................    int8 DAC_MS_byte; 
....................    int8 DAC_LS_byte; 
....................     
....................    setup_spi2(SPI_MASTER|SPI_H_TO_L|SPI_CLK_DIV_64); 
*
0F56C:  BCF    F67.5
0F56E:  MOVLW  32
0F570:  MOVWF  F67
0F572:  MOVLW  40
0F574:  MOVWF  F68
....................     
....................    data = 0; 
0F576:  MOVLB  8
0F578:  CLRF   xD7
0F57A:  CLRF   xD6
....................     
....................    DAC_MS_byte = 0; 
0F57C:  CLRF   xD8
....................    DAC_LS_byte = 0; 
0F57E:  CLRF   xD9
....................     
....................    data = setting & 0b0000111100000000; 
0F580:  CLRF   xD6
0F582:  MOVF   xD5,W
0F584:  ANDLW  0F
0F586:  MOVWF  xD7
....................    data = data >> 8; 
0F588:  MOVFF  8D7,8D6
0F58C:  CLRF   xD7
....................    DAC_MS_byte = data; 
0F58E:  MOVFF  8D6,8D8
....................     
....................    data = setting & 0b0000000011111111; 
0F592:  MOVFF  8D4,8D6
0F596:  CLRF   xD7
....................    DAC_LS_byte = data; 
0F598:  MOVFF  8D6,8D9
....................  
....................    // ChA = 0011xxxx 
....................    // ChB = 0111xxxx 
....................    // ChC = 1011xxxx 
....................    // ChD = 1111xxxx 
....................     
....................    switch(channel) 
0F59C:  MOVLW  01
0F59E:  SUBWF  xD3,W
0F5A0:  ADDLW  FC
0F5A2:  BC    F5CE
0F5A4:  ADDLW  04
0F5A6:  MOVLB  0
0F5A8:  GOTO   F5EC
....................    { 
....................       case 1: (DAC_MS_byte = DAC_MS_byte | 0b00110000); 
0F5AC:  MOVLW  30
0F5AE:  MOVLB  8
0F5B0:  IORWF  xD8,F
....................          break; 
0F5B2:  BRA    F5CE
....................       case 2: (DAC_MS_byte = DAC_MS_byte | 0b01110000); 
0F5B4:  MOVLW  70
0F5B6:  MOVLB  8
0F5B8:  IORWF  xD8,F
....................          break; 
0F5BA:  BRA    F5CE
....................       case 3: (DAC_MS_byte = DAC_MS_byte | 0b10110000); 
0F5BC:  MOVLW  B0
0F5BE:  MOVLB  8
0F5C0:  IORWF  xD8,F
....................          break; 
0F5C2:  BRA    F5CE
....................       case 4: (DAC_MS_byte = DAC_MS_byte | 0b11110000); 
0F5C4:  MOVLW  F0
0F5C6:  MOVLB  8
0F5C8:  IORWF  xD8,F
....................          break; 
0F5CA:  BRA    F5CE
0F5CC:  MOVLB  8
....................    } 
....................  
....................    output_bit(DAC_CL, DISABLE);  // CL HIGH 
0F5CE:  BSF    F8C.2
....................    output_bit(DAC_CS, ENABLE);   // CS-DAC LOW 
0F5D0:  BCF    F8C.3
....................  
....................    spi_write2(DAC_MS_byte); 
0F5D2:  MOVF   F6A,W
0F5D4:  MOVFF  8D8,F6A
0F5D8:  RRCF   F68,W
0F5DA:  BNC   F5D8
....................    spi_write2(DAC_LS_byte); 
0F5DC:  MOVF   F6A,W
0F5DE:  MOVFF  8D9,F6A
0F5E2:  RRCF   F68,W
0F5E4:  BNC   F5E2
....................  
....................    output_bit(DAC_CS, DISABLE);   // CS-DAC LOW 
0F5E6:  BSF    F8C.3
0F5E8:  MOVLB  0
0F5EA:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "adc.c" 
.................... void ADC_average(int16 scans) 
.................... { 
....................    int8 n; 
....................    int16 j; 
....................    int32 ADC_mean[8] = {0,0,0,0,0,0,0,0}; 
*
0F614:  MOVLB  8
0F616:  CLRF   xD8
0F618:  CLRF   xD9
0F61A:  CLRF   xDA
0F61C:  CLRF   xDB
0F61E:  CLRF   xDC
0F620:  CLRF   xDD
0F622:  CLRF   xDE
0F624:  CLRF   xDF
0F626:  CLRF   xE0
0F628:  CLRF   xE1
0F62A:  CLRF   xE2
0F62C:  CLRF   xE3
0F62E:  CLRF   xE4
0F630:  CLRF   xE5
0F632:  CLRF   xE6
0F634:  CLRF   xE7
0F636:  CLRF   xE8
0F638:  CLRF   xE9
0F63A:  CLRF   xEA
0F63C:  CLRF   xEB
0F63E:  CLRF   xEC
0F640:  CLRF   xED
0F642:  CLRF   xEE
0F644:  CLRF   xEF
0F646:  CLRF   xF0
0F648:  CLRF   xF1
0F64A:  CLRF   xF2
0F64C:  CLRF   xF3
0F64E:  CLRF   xF4
0F650:  CLRF   xF5
0F652:  CLRF   xF6
0F654:  CLRF   xF7
....................    int32 ADC_last_sample[8] = {0,0,0,0,0,0,0,0}; 
0F656:  CLRF   xF8
0F658:  CLRF   xF9
0F65A:  CLRF   xFA
0F65C:  CLRF   xFB
0F65E:  CLRF   xFC
0F660:  CLRF   xFD
0F662:  CLRF   xFE
0F664:  CLRF   xFF
0F666:  MOVLB  9
0F668:  CLRF   x00
0F66A:  CLRF   x01
0F66C:  CLRF   x02
0F66E:  CLRF   x03
0F670:  CLRF   x04
0F672:  CLRF   x05
0F674:  CLRF   x06
0F676:  CLRF   x07
0F678:  CLRF   x08
0F67A:  CLRF   x09
0F67C:  CLRF   x0A
0F67E:  CLRF   x0B
0F680:  CLRF   x0C
0F682:  CLRF   x0D
0F684:  CLRF   x0E
0F686:  CLRF   x0F
0F688:  CLRF   x10
0F68A:  CLRF   x11
0F68C:  CLRF   x12
0F68E:  CLRF   x13
0F690:  CLRF   x14
0F692:  CLRF   x15
0F694:  CLRF   x16
0F696:  CLRF   x17
....................     
....................    for (j=1; j<(scans+1); ++j) 
0F698:  MOVLB  8
0F69A:  CLRF   xD7
0F69C:  MOVLW  01
0F69E:  MOVWF  xD6
0F6A0:  MOVLW  01
0F6A2:  ADDWF  xD3,W
0F6A4:  MOVWF  01
0F6A6:  MOVLW  00
0F6A8:  ADDWFC xD4,W
0F6AA:  MOVWF  03
0F6AC:  MOVF   xD7,W
0F6AE:  SUBWF  03,W
0F6B0:  BTFSS  FD8.0
0F6B2:  BRA    F79E
0F6B4:  BNZ   F6BC
0F6B6:  MOVF   01,W
0F6B8:  SUBWF  xD6,W
0F6BA:  BC    F79E
....................    { 
....................       for (n=1; n<5; ++n) 
0F6BC:  MOVLW  01
0F6BE:  MOVWF  xD5
0F6C0:  MOVF   xD5,W
0F6C2:  SUBLW  04
0F6C4:  BNC   F796
....................       { 
....................          set_adc_channel(n,VSS); 
0F6C6:  RLCF   xD5,W
0F6C8:  MOVWF  00
0F6CA:  RLCF   00,F
0F6CC:  MOVLW  FC
0F6CE:  ANDWF  00,F
0F6D0:  MOVF   FC2,W
0F6D2:  ANDLW  83
0F6D4:  IORWF  00,W
0F6D6:  MOVWF  FC2
0F6D8:  MOVLW  00
0F6DA:  MOVWF  01
0F6DC:  MOVF   FC1,W
0F6DE:  ANDLW  F8
0F6E0:  IORWF  01,W
0F6E2:  MOVWF  FC1
....................          ADC_last_sample[n] = read_adc(); 
0F6E4:  MOVF   xD5,W
0F6E6:  MULLW  04
0F6E8:  MOVF   FF3,W
0F6EA:  CLRF   03
0F6EC:  ADDLW  F8
0F6EE:  MOVWF  FE9
0F6F0:  MOVLW  08
0F6F2:  ADDWFC 03,W
0F6F4:  MOVWF  FEA
0F6F6:  BSF    FC2.1
0F6F8:  BTFSC  FC2.1
0F6FA:  BRA    F6F8
0F6FC:  MOVFF  FC3,FEF
0F700:  MOVFF  FC4,FEC
0F704:  CLRF   FEC
0F706:  CLRF   FEC
....................          ADC_mean[n] = (ADC_mean[n] + ADC_last_sample[n]); 
0F708:  MOVF   xD5,W
0F70A:  MULLW  04
0F70C:  MOVF   FF3,W
0F70E:  CLRF   03
0F710:  ADDLW  D8
0F712:  MOVWF  01
0F714:  MOVLW  08
0F716:  ADDWFC 03,F
0F718:  MOVFF  01,918
0F71C:  MOVFF  03,919
0F720:  MOVLB  8
0F722:  MOVF   xD5,W
0F724:  MULLW  04
0F726:  MOVF   FF3,W
0F728:  CLRF   03
0F72A:  ADDLW  D8
0F72C:  MOVWF  FE9
0F72E:  MOVLW  08
0F730:  ADDWFC 03,W
0F732:  MOVWF  FEA
0F734:  MOVFF  FEF,91A
0F738:  MOVFF  FEC,91B
0F73C:  MOVFF  FEC,91C
0F740:  MOVFF  FEC,91D
0F744:  MOVF   xD5,W
0F746:  MULLW  04
0F748:  MOVF   FF3,W
0F74A:  CLRF   03
0F74C:  ADDLW  F8
0F74E:  MOVWF  FE9
0F750:  MOVLW  08
0F752:  ADDWFC 03,W
0F754:  MOVWF  FEA
0F756:  MOVFF  FEF,00
0F75A:  MOVFF  FEC,01
0F75E:  MOVFF  FEC,02
0F762:  MOVFF  FEC,03
0F766:  MOVLB  9
0F768:  MOVF   x1A,W
0F76A:  ADDWF  00,F
0F76C:  MOVF   x1B,W
0F76E:  ADDWFC 01,F
0F770:  MOVF   x1C,W
0F772:  ADDWFC 02,F
0F774:  MOVF   x1D,W
0F776:  ADDWFC 03,F
0F778:  MOVFF  919,FEA
0F77C:  MOVFF  918,FE9
0F780:  MOVFF  00,FEF
0F784:  MOVFF  01,FEC
0F788:  MOVFF  02,FEC
0F78C:  MOVFF  03,FEC
0F790:  MOVLB  8
0F792:  INCF   xD5,F
0F794:  BRA    F6C0
....................       } 
0F796:  INCF   xD6,F
0F798:  BTFSC  FD8.2
0F79A:  INCF   xD7,F
0F79C:  BRA    F6A0
....................    } 
....................     
....................    for (n=1; n<5; ++n) 
0F79E:  MOVLW  01
0F7A0:  MOVWF  xD5
0F7A2:  MOVF   xD5,W
0F7A4:  SUBLW  04
0F7A6:  BNC   F81A
....................    { 
....................       ADC_val[n] = (ADC_mean[n]/scans); 
0F7A8:  BCF    FD8.0
0F7AA:  RLCF   xD5,W
0F7AC:  CLRF   03
0F7AE:  ADDLW  A5
0F7B0:  MOVWF  01
0F7B2:  MOVLW  04
0F7B4:  ADDWFC 03,F
0F7B6:  MOVFF  01,918
0F7BA:  MOVFF  03,919
0F7BE:  MOVLB  8
0F7C0:  MOVF   xD5,W
0F7C2:  MULLW  04
0F7C4:  MOVF   FF3,W
0F7C6:  CLRF   03
0F7C8:  ADDLW  D8
0F7CA:  MOVWF  FE9
0F7CC:  MOVLW  08
0F7CE:  ADDWFC 03,W
0F7D0:  MOVWF  FEA
0F7D2:  MOVFF  FEF,A4C
0F7D6:  MOVFF  FEC,A4D
0F7DA:  MOVFF  FEC,A4E
0F7DE:  MOVFF  FEC,A4F
0F7E2:  BCF    FD8.1
0F7E4:  CLRF   1B
0F7E6:  BTFSC  FF2.7
0F7E8:  BSF    1B.7
0F7EA:  BCF    FF2.7
0F7EC:  MOVLB  A
0F7EE:  CLRF   x53
0F7F0:  CLRF   x52
0F7F2:  MOVFF  8D4,A51
0F7F6:  MOVFF  8D3,A50
0F7FA:  MOVLB  0
0F7FC:  CALL   104A
0F800:  BTFSC  1B.7
0F802:  BSF    FF2.7
0F804:  MOVFF  919,FEA
0F808:  MOVFF  918,FE9
0F80C:  MOVFF  00,FEF
0F810:  MOVFF  01,FEC
0F814:  MOVLB  8
0F816:  INCF   xD5,F
0F818:  BRA    F7A2
....................    } 
0F81A:  MOVLB  0
0F81C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "interrupts.c" 
.................... #int_ext 
.................... void rtc_wakeup_isr() 
.................... { 
.................... //   delay_cycles(10);       // mo ??? 
....................    //Handle updating variables for the valve timeout 
....................    /*if(valve_align_timeout != -1){ 
....................       fprintf(COM_A,"align_var: %Ld \r\n",valve_align_timeout); 
....................       if(valve_align_timeout >= 2){ 
....................          valve_align_timeout = -1; 
....................          reset_cpu(); 
....................       } 
....................       valve_align_timeout++; 
....................    }*/ 
....................    //Service watchdog 
....................    output_bit(PIN_J7,(!input(PIN_J7))); 
*
00E08:  BTFSS  F88.7
00E0A:  BRA    0E10
00E0C:  BCF    F91.7
00E0E:  BRA    0E12
00E10:  BSF    F91.7
....................     
....................    rtc_alarm = TRUE; 
00E12:  BSF    4D.0
....................    sleep_mode = FALSE; 
00E14:  BCF    4D.1
....................  
....................    while (TRUE == RTC_read_flags_running) 
00E16:  BTFSS  4D.2
00E18:  BRA    0E1C
....................    { 
....................       ; 
00E1A:  BRA    0E16
....................    } 
....................    RTC_read_flags_running = TRUE; 
00E1C:  BSF    4D.2
....................    RTC_read_flags(); 
00E1E:  RCALL  0DCC
....................    ++nv_elapsed; 
00E20:  INCF   35,F
00E22:  BTFSC  FD8.2
00E24:  INCF   36,F
.................... } 
....................  
00E26:  BCF    FF2.1
00E28:  GOTO   00B0
.................... #int_RDA 
.................... void RDA_isr() 
.................... { 
....................    int8 c; 
....................  
....................    clear_interrupt(INT_RDA); 
*
00E6C:  MOVF   FAE,W
....................  
....................    if (FALSE == sleep_mode) 
00E6E:  BTFSC  4D.1
00E70:  BRA    0EC2
....................    { 
....................       if (kbhit(COM_A)) 
00E72:  BTFSS  F9E.5
00E74:  BRA    0EC0
....................       { 
....................          c = getc(COM_A); 
00E76:  RCALL  0E2C
00E78:  MOVFF  01,A37
....................          switch (c) 
00E7C:  MOVLB  A
00E7E:  MOVF   x37,W
00E80:  XORLW  3F
00E82:  MOVLB  0
00E84:  BZ    0E90
00E86:  XORLW  2E
00E88:  BZ    0EB4
00E8A:  XORLW  0A
00E8C:  BZ    0EBA
00E8E:  BRA    0EC0
....................          { 
....................             case QUESTION_MRK: 
....................             { 
....................                if (busy_status == TRUE) fprintf(COM_A, "?@BSY\r\n"); 
00E90:  DECFSZ 4E,W
00E92:  BRA    0EA4
00E94:  MOVLW  CC
00E96:  MOVWF  FF6
00E98:  MOVLW  0E
00E9A:  MOVWF  FF7
00E9C:  MOVLW  00
00E9E:  MOVWF  FF8
00EA0:  RCALL  0E42
00EA2:  BRA    0EB2
....................                else fprintf(COM_A, "@RDY\r\n"); 
00EA4:  MOVLW  D4
00EA6:  MOVWF  FF6
00EA8:  MOVLW  0E
00EAA:  MOVWF  FF7
00EAC:  MOVLW  00
00EAE:  MOVWF  FF8
00EB0:  RCALL  0E42
....................                break; 
00EB2:  BRA    0EC0
....................             } 
....................             case DEVICE_CNTRL_1: 
....................             { 
....................                user_quit = TRUE; 
00EB4:  MOVLW  01
00EB6:  MOVWF  50
....................                break;          
00EB8:  BRA    0EC0
....................             } 
....................             case ESCAPE: 
....................             { 
....................                nv_cmd_mode = TRUE; 
00EBA:  CLRF   32
00EBC:  MOVLW  01
00EBE:  MOVWF  31
....................                break;                 
....................             } 
....................          } 
....................       } 
....................    } 
00EC0:  BRA    0EC6
....................    // if asleep and char received 
....................    else 
....................    { 
....................       // signal that wake-up was serial (not positive wake-up yet) 
....................       bit_clear(INTCON,PEIE);    // Disable Peripheral Interrupt Enable bit 
00EC2:  BCF    FF2.6
....................       bit_clear(PIR1,RC1IF);     // Clear USART Receive Interrupt Flag bit 
00EC4:  BCF    F9E.5
....................    } 
00EC6:  BCF    F9E.5
00EC8:  GOTO   00B0
.................... } 
....................  
.................... void busy_clear() 
.................... { 
....................    disable_interrupts(INT_RDA); 
*
0AEA4:  BCF    F9D.5
....................    clear_interrupt(INT_RDA); 
0AEA6:  MOVF   FAE,W
....................    busy_status = FALSE; 
0AEA8:  CLRF   4E
0AEAA:  RETURN 0
.................... } 
....................  
.................... void busy_set() 
.................... { 
....................    busy_status = TRUE; 
*
029B4:  MOVLW  01
029B6:  MOVWF  4E
....................    clear_interrupt(INT_RDA); 
029B8:  MOVF   FAE,W
....................    enable_interrupts(INT_RDA); 
029BA:  BSF    F9D.5
029BC:  RETURN 0
.................... } 
....................  
.................... /*#int_rda2 
.................... void serial2_isr() 
.................... { 
....................    int t; 
....................  
....................    buffer[next_in] = fgetc(COM_B); 
....................    t=next_in; 
....................    next_in = (next_in+1) % BUFFER_SIZE; 
....................    if(next_in == next_out) 
....................    { 
....................       next_in = t;           // Buffer full !! 
....................    } 
.................... } 
.................... */ 
....................  
.................... /* 
....................    This interrupt should fire before the WDT barks 
....................    .. it will reset the timer and the WDT 
.................... */ 
.................... #int_timer0 
.................... void timer0_isr() 
.................... { 
.................... //   heartbeat(TRUE); 
....................  
....................    set_timer0(TIMER0_PRESET); 
*
00EDC:  MOVLW  0B
00EDE:  MOVWF  FD7
00EE0:  MOVLW  DC
00EE2:  MOVWF  FD6
....................    restart_wdt(); 
00EE4:  CLRWDT
....................    clear_interrupt(INT_TIMER0); 
00EE6:  BCF    FF2.2
....................    enable_interrupts(INT_TIMER0); 
00EE8:  BSF    FF2.5
....................  
....................    set_timer1(0); 
00EEA:  CLRF   FCF
00EEC:  CLRF   FCE
....................    output_high(BOARD_LED);                // LED is turned OFF by timer1_isr() 
00EEE:  BSF    F89.4
....................    if(nv_product==AWS)output_high(PANEL_LED);  
00EF0:  MOVF   2F,W
00EF2:  SUBLW  02
00EF4:  BNZ   0EFC
00EF6:  MOVF   30,F
00EF8:  BNZ   0EFC
00EFA:  BSF    F90.6
....................    clear_interrupt(INT_TIMER1); 
00EFC:  BCF    F9E.0
....................    enable_interrupts(INT_TIMER1); 
00EFE:  BSF    F9D.0
....................     
....................   // fprintf(COM_A, "*"); 
....................  
.................... } 
....................  
00F00:  BCF    FF2.2
00F02:  GOTO   00B0
.................... #int_timer1 
.................... void timer1_isr() 
.................... { 
....................    // disables timer1 ints, LED OFF (to end "blink") 
....................    // this ISR is triggered ~105 ms after LED ON by timer0_isr() 
....................    disable_interrupts(INT_TIMER1); 
00F06:  BCF    F9D.0
....................    output_low(BOARD_LED); 
00F08:  BCF    F89.4
....................    if(nv_product==AWS)output_low(PANEL_LED);   
00F0A:  MOVF   2F,W
00F0C:  SUBLW  02
00F0E:  BNZ   0F16
00F10:  MOVF   30,F
00F12:  BNZ   0F16
00F14:  BCF    F90.6
.................... } 
....................  
.................... //!#int_timer4 
.................... //!void tick_interrupt(void) {  
.................... //!   if (tick) --tick;  
.................... //!   else { 
.................... //!      timeout=TRUE; 
.................... //!      exit=TRUE; 
.................... //!   }       
.................... //!} 
....................  
....................  
00F16:  BCF    F9E.0
00F18:  GOTO   00B0
.................... #include "serial.c" 
.................... // *** Timed getc() for each port *** // 
....................  
.................... int8 timed_getc_A() 
*
15D20:  MOVLB  8
15D22:  CLRF   x8C
15D24:  CLRF   x90
15D26:  CLRF   x8F
15D28:  CLRF   x8E
15D2A:  CLRF   x8D
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_A = 0; 
....................  
....................    while (++timeout_A < GETC_TIMEOUT) 
15D2C:  MOVLW  01
15D2E:  ADDWF  x8D,F
15D30:  BTFSC  FD8.0
15D32:  INCF   x8E,F
15D34:  BTFSC  FD8.2
15D36:  INCF   x8F,F
15D38:  BTFSC  FD8.2
15D3A:  INCF   x90,F
15D3C:  MOVF   x90,F
15D3E:  BNZ   15D80
15D40:  MOVF   x8F,W
15D42:  SUBLW  04
15D44:  BNC   15D80
15D46:  BNZ   15D56
15D48:  MOVF   x8E,W
15D4A:  SUBLW  93
15D4C:  BNC   15D80
15D4E:  BNZ   15D56
15D50:  MOVF   x8D,W
15D52:  SUBLW  DF
15D54:  BNC   15D80
....................    { 
....................       if(kbhit(COM_A)) 
15D56:  BTFSS  F9E.5
15D58:  BRA    15D76
....................       { 
....................          c = fgetc(COM_A); 
15D5A:  MOVLB  0
15D5C:  CALL   0E2C
15D60:  MOVFF  01,88C
....................          if (com_echo == TRUE) 
15D64:  DECFSZ 4C,W
15D66:  BRA    15D72
....................          { 
....................             fputc(c, COM_A); 
15D68:  MOVLB  8
15D6A:  MOVF   x8C,W
15D6C:  MOVLB  0
15D6E:  CALL   AEAC
....................          } 
....................          break; 
15D72:  MOVLB  8
15D74:  BRA    15D80
....................       } 
....................  
....................       delay_us(10); 
15D76:  MOVLW  35
15D78:  MOVWF  00
15D7A:  DECFSZ 00,F
15D7C:  BRA    15D7A
15D7E:  BRA    15D2C
....................    } 
....................  
....................    return(c); 
15D80:  MOVFF  88C,01
15D84:  MOVLB  0
15D86:  GOTO   15D96 (RETURN)
.................... } 
....................  
.................... int8 TestForEsc () 
*
0AE20:  MOVLW  58
0AE22:  MOVLB  8
0AE24:  MOVWF  x64
0AE26:  CLRF   x68
0AE28:  CLRF   x67
0AE2A:  CLRF   x66
0AE2C:  CLRF   x65
.................... { 
....................    int8 EscChar = 88; 
....................    int32 timeout_A = 0; 
....................    //EscChar=timed_getc_A(); 
....................    // fputc('*',COM_A); 
....................    while(++timeout_A < 50000) 
0AE2E:  MOVLW  01
0AE30:  ADDWF  x65,F
0AE32:  BTFSC  FD8.0
0AE34:  INCF   x66,F
0AE36:  BTFSC  FD8.2
0AE38:  INCF   x67,F
0AE3A:  BTFSC  FD8.2
0AE3C:  INCF   x68,F
0AE3E:  MOVF   x68,F
0AE40:  BNZ   AE70
0AE42:  MOVF   x67,F
0AE44:  BNZ   AE70
0AE46:  MOVF   x66,W
0AE48:  SUBLW  C3
0AE4A:  BNC   AE70
0AE4C:  BNZ   AE54
0AE4E:  MOVF   x65,W
0AE50:  SUBLW  4F
0AE52:  BNC   AE70
....................    { //fputc('!',COM_A); 
....................       delay_us(1); 
0AE54:  MOVLW  05
0AE56:  MOVWF  00
0AE58:  DECFSZ 00,F
0AE5A:  BRA    AE58
....................  
....................       if(kbhit()) 
0AE5C:  BTFSS  F9E.5
0AE5E:  BRA    AE6E
....................       {//fprintf(COM_A, "kbhit=true\r\n"); 
....................          EscChar = fgetc(COM_A); 
0AE60:  MOVLB  0
0AE62:  CALL   0E2C
0AE66:  MOVFF  01,864
....................          // fprintf(COM_A, "EscChar is:%u\r\n",EscChar); 
....................          break; 
0AE6A:  MOVLB  8
0AE6C:  BRA    AE70
....................       } 
0AE6E:  BRA    AE2E
....................    } 
....................  
....................    return(EscChar); 
0AE70:  MOVFF  864,01
0AE74:  MOVLB  0
0AE76:  GOTO   1B978 (RETURN)
.................... } 
....................  
.................... int8 timed_getc_B(int8 timeout_sec) 
.................... { 
....................    int8 c = 0; 
....................    int32 timeout_B, timeout_limit; 
....................     
....................    timeout_B=0; 
....................    timeout_limit = (timeout_sec * 100000); 
....................  
....................    while (++timeout_B < timeout_limit) 
....................    { 
....................       if (kbhit(COM_B)) 
....................       { 
....................           c = fgetc(COM_B); 
....................           break; 
....................       } 
....................  
....................       delay_us(10); 
....................    } 
....................  
....................    return (c); 
.................... } 
....................  
....................  
.................... // *** Serial "pipes" to each COM port *** // 
....................  
.................... void multidrop_on() 
.................... { 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
*
0DA6C:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen) 
0DA6E:  BCF    F8F.4
....................    output_high(MD2_TXEN);     // Tx enable  
0DA70:  BSF    F8F.3
....................    delay_ms(10); 
0DA72:  MOVLW  0A
0DA74:  MOVLB  9
0DA76:  MOVWF  xEC
0DA78:  MOVLB  0
0DA7A:  CALL   2904
0DA7E:  RETURN 0
.................... } 
....................  
.................... void multidrop_off() 
*
0DB58:  MOVLB  8
0DB5A:  CLRF   xF4
0DB5C:  CLRF   xF3
.................... { 
....................    /* 
....................    TXSTAx: TRANSMIT STATUS AND CONTROL REGISTER 
....................    bit 1 = TRMT: Transmit Shift Register Status bit 
....................    1 = TSRx empty 
....................    0 = TSRx full 
....................    TXSTA2 addr = 0xF21 
....................    */ 
....................    int16 c=0; 
....................    while(TRMT2 == 0){ 
0DB5E:  MOVLB  F
0DB60:  BTFSC  x21.1
0DB62:  BRA    DB70
....................       ++c; 
0DB64:  MOVLB  8
0DB66:  INCF   xF3,F
0DB68:  BTFSC  FD8.2
0DB6A:  INCF   xF4,F
0DB6C:  BRA    DB5E
0DB6E:  MOVLB  F
....................    } 
....................    output_high(MD2_SHDN);     // MAX3323 ON 
0DB70:  BSF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
0DB72:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
0DB74:  BCF    F8F.3
0DB76:  MOVLB  0
0DB78:  RETURN 0
.................... } 
....................  
.................... void multidrop_shdn() 
.................... { 
....................    output_low(MD2_SHDN);      // MAX3323 OFF 
*
16F5A:  BCF    F8F.0
....................    output_low(MD2_REN);       // Rx high impedance (listen)    
16F5C:  BCF    F8F.4
....................    output_low(MD2_TXEN);      // Tx disable 
16F5E:  BCF    F8F.3
16F60:  GOTO   1704E (RETURN)
.................... } 
....................  
....................  
.................... void open_pipe() 
16F64:  MOVLB  8
16F66:  CLRF   x85
16F68:  CLRF   x86
16F6A:  CLRF   xD7
16F6C:  CLRF   xD8
.................... { 
....................    int8 charFromA = 0; 
....................    int8 charFromB = 0; 
....................  
....................    char tempBuffer[MAX_CMD_SIZE]; 
....................    int index = 0; 
....................    int charCount = 0; 
....................  
....................    fprintf(COM_A, "@[O]\r\n"); 
16F6E:  MOVLW  1C
16F70:  MOVWF  FF6
16F72:  MOVLW  0F
16F74:  MOVWF  FF7
16F76:  MOVLW  00
16F78:  MOVWF  FF8
16F7A:  CLRF   1B
16F7C:  BTFSC  FF2.7
16F7E:  BSF    1B.7
16F80:  BCF    FF2.7
16F82:  MOVLB  0
16F84:  CALL   0E42
16F88:  BTFSC  1B.7
16F8A:  BSF    FF2.7
....................  
....................    while (charFromB != EOT) 
16F8C:  MOVLB  8
16F8E:  MOVF   x86,W
16F90:  SUBLW  04
16F92:  BZ    1704A
....................    { 
....................        if (kbhit(COM_A)) 
16F94:  BTFSS  F9E.5
16F96:  BRA    1702E
....................        {          // if data is received 
....................           charFromA = fgetc(COM_A);                // read the received data 
16F98:  MOVLB  0
16F9A:  CALL   0E2C
16F9E:  MOVFF  01,885
....................           if (com_echo == TRUE) 
16FA2:  DECFSZ 4C,W
16FA4:  BRA    16FB0
....................           { 
....................              fputc(charFromA, COM_A); 
16FA6:  MOVLB  8
16FA8:  MOVF   x85,W
16FAA:  MOVLB  0
16FAC:  CALL   AEAC
....................           } 
....................  
....................           if (charCount < MAX_CMD_SIZE) 
16FB0:  MOVLB  8
16FB2:  MOVF   xD8,W
16FB4:  SUBLW  4F
16FB6:  BNC   1700C
....................           { 
....................              tempBuffer[charCount++] = charFromA; 
16FB8:  MOVF   xD8,W
16FBA:  INCF   xD8,F
16FBC:  CLRF   03
16FBE:  ADDLW  87
16FC0:  MOVWF  FE9
16FC2:  MOVLW  08
16FC4:  ADDWFC 03,W
16FC6:  MOVWF  FEA
16FC8:  MOVFF  885,FEF
....................              if (CARRIAGE_RET == charFromA) 
16FCC:  MOVF   x85,W
16FCE:  SUBLW  0D
16FD0:  BNZ   1700A
....................              { 
....................                 multidrop_on(); 
16FD2:  MOVLB  0
16FD4:  CALL   DA6C
....................                 for (index = 0 ; index < charCount; index++) 
16FD8:  MOVLB  8
16FDA:  CLRF   xD7
16FDC:  MOVF   xD8,W
16FDE:  SUBWF  xD7,W
16FE0:  BC    17000
....................                 { 
....................                    fputc(tempBuffer[index], COM_B); 
16FE2:  CLRF   03
16FE4:  MOVF   xD7,W
16FE6:  ADDLW  87
16FE8:  MOVWF  FE9
16FEA:  MOVLW  08
16FEC:  ADDWFC 03,W
16FEE:  MOVWF  FEA
16FF0:  MOVFF  FEF,8D9
16FF4:  MOVF   xD9,W
16FF6:  MOVLB  0
16FF8:  BRA    16F4C
16FFA:  MOVLB  8
16FFC:  INCF   xD7,F
16FFE:  BRA    16FDC
....................                 } 
....................                 charCount = 0; 
17000:  CLRF   xD8
....................                 multidrop_off(); 
17002:  MOVLB  0
17004:  CALL   DB58
17008:  MOVLB  8
....................              } 
....................           } 
1700A:  BRA    1702E
....................           else 
....................           { 
....................              fprintf(COM_A, "@CMD too long\r\n"); 
1700C:  MOVLW  24
1700E:  MOVWF  FF6
17010:  MOVLW  0F
17012:  MOVWF  FF7
17014:  MOVLW  00
17016:  MOVWF  FF8
17018:  CLRF   1B
1701A:  BTFSC  FF2.7
1701C:  BSF    1B.7
1701E:  BCF    FF2.7
17020:  MOVLB  0
17022:  CALL   0E42
17026:  BTFSC  1B.7
17028:  BSF    FF2.7
....................              charCount = 0; 
1702A:  MOVLB  8
1702C:  CLRF   xD8
....................           } 
....................  
....................        }                                 // send data via USART 
....................  
....................        if (kbhit(COM_B)) 
1702E:  BTFSS  FA4.5
17030:  BRA    17048
....................        {          // if data is received 
....................           charFromB = fgetc(COM_B);                // read the received data 
17032:  MOVLB  0
17034:  CALL   12E1E
17038:  MOVFF  01,886
....................           fputc(charFromB, COM_A);                  // send data via USART 
1703C:  MOVLB  8
1703E:  MOVF   x86,W
17040:  MOVLB  0
17042:  CALL   AEAC
17046:  MOVLB  8
....................        } 
17048:  BRA    16F8E
....................    } 
....................  
....................    multidrop_shdn(); 
1704A:  MOVLB  0
1704C:  BRA    16F5A
....................  
....................    fprintf(COM_A, "@[C]\r\n"); 
1704E:  MOVLW  34
17050:  MOVWF  FF6
17052:  MOVLW  0F
17054:  MOVWF  FF7
17056:  MOVLW  00
17058:  MOVWF  FF8
1705A:  CLRF   1B
1705C:  BTFSC  FF2.7
1705E:  BSF    1B.7
17060:  BCF    FF2.7
17062:  CALL   0E42
17066:  BTFSC  1B.7
17068:  BSF    FF2.7
1706A:  GOTO   17084 (RETURN)
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    --max; 
*
0C868:  MOVLB  8
0C86A:  DECF   x9F,F
....................    len=0; 
0C86C:  CLRF   xA0
....................    do { 
....................      c=getc(); 
0C86E:  MOVLB  0
0C870:  CALL   0E2C
0C874:  MOVFF  01,8A1
....................      if(c==8) {  // Backspace 
0C878:  MOVLB  8
0C87A:  MOVF   xA1,W
0C87C:  SUBLW  08
0C87E:  BNZ   C8A2
....................         if(len>0) { 
0C880:  MOVF   xA0,F
0C882:  BZ    C8A0
....................           len--; 
0C884:  DECF   xA0,F
....................           putc(c); 
0C886:  MOVF   xA1,W
0C888:  MOVLB  0
0C88A:  CALL   AEAC
....................           putc(' '); 
0C88E:  MOVLW  20
0C890:  CALL   AEAC
....................           putc(c); 
0C894:  MOVLB  8
0C896:  MOVF   xA1,W
0C898:  MOVLB  0
0C89A:  CALL   AEAC
0C89E:  MOVLB  8
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
0C8A0:  BRA    C8D0
0C8A2:  MOVF   xA1,W
0C8A4:  SUBLW  1F
0C8A6:  BC    C8D0
0C8A8:  MOVF   xA1,W
0C8AA:  SUBLW  7E
0C8AC:  BNC   C8D0
....................        if(len<=max) { 
0C8AE:  MOVF   xA0,W
0C8B0:  SUBWF  x9F,W
0C8B2:  BNC   C8D0
....................          s[len++]=c; 
0C8B4:  MOVF   xA0,W
0C8B6:  INCF   xA0,F
0C8B8:  ADDWF  x9D,W
0C8BA:  MOVWF  FE9
0C8BC:  MOVLW  00
0C8BE:  ADDWFC x9E,W
0C8C0:  MOVWF  FEA
0C8C2:  MOVFF  8A1,FEF
....................          putc(c); 
0C8C6:  MOVF   xA1,W
0C8C8:  MOVLB  0
0C8CA:  CALL   AEAC
0C8CE:  MOVLB  8
....................        } 
....................    } while(c != CARRIAGE_RET); 
0C8D0:  MOVF   xA1,W
0C8D2:  SUBLW  0D
0C8D4:  BNZ   C86E
....................    s[len]=0; 
0C8D6:  MOVF   xA0,W
0C8D8:  ADDWF  x9D,W
0C8DA:  MOVWF  FE9
0C8DC:  MOVLW  00
0C8DE:  ADDWFC x9E,W
0C8E0:  MOVWF  FEA
0C8E2:  CLRF   FEF
0C8E4:  MOVLB  0
0C8E6:  GOTO   CD0C (RETURN)
.................... } 
....................  
.................... float get_float()  
.................... { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
*
0CCFA:  MOVLW  08
0CCFC:  MOVLB  8
0CCFE:  MOVWF  x9E
0CD00:  MOVLW  85
0CD02:  MOVWF  x9D
0CD04:  MOVLW  14
0CD06:  MOVWF  x9F
0CD08:  MOVLB  0
0CD0A:  BRA    C868
....................   f = atof(s); 
0CD0C:  MOVLW  08
0CD0E:  MOVLB  8
0CD10:  MOVWF  x9E
0CD12:  MOVLW  85
0CD14:  MOVWF  x9D
0CD16:  CLRF   xA0
0CD18:  CLRF   x9F
0CD1A:  MOVLB  0
0CD1C:  BRA    CA9E
0CD1E:  MOVFF  03,89C
0CD22:  MOVFF  02,89B
0CD26:  MOVFF  01,89A
0CD2A:  MOVFF  00,899
....................   return(f); 
0CD2E:  MOVFF  899,00
0CD32:  MOVFF  89A,01
0CD36:  MOVFF  89B,02
0CD3A:  MOVFF  89C,03
0CD3E:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "init_hw.c" 
.................... void init_hardware() 
.................... { 
....................    set_tris_a(0b00101111); 
*
0292E:  MOVLW  2F
02930:  MOVWF  F92
....................    set_tris_b(0b00110111); 
02932:  MOVLW  37
02934:  MOVWF  F93
....................    set_tris_c(0b10010000); 
02936:  MOVLW  90
02938:  MOVWF  F94
....................    set_tris_d(0b00100000); 
0293A:  MOVLW  20
0293C:  MOVWF  F95
....................    set_tris_e(0b01000000); 
0293E:  MOVLW  40
02940:  MOVWF  F96
....................    set_tris_f(0b00000000); 
02942:  MOVLW  00
02944:  MOVWF  F97
....................    set_tris_g(0b11100100); 
02946:  MOVLW  E4
02948:  MOVWF  F98
....................    set_tris_h(0b01000000); 
0294A:  MOVLW  40
0294C:  MOVWF  F99
....................    set_tris_j(0b00000000); 
0294E:  MOVLW  00
02950:  MOVWF  F9A
....................     
....................    // H-BRIDGE 
....................    output_low(HB_EN); 
02952:  BCF    F8E.3
....................    output_low(HB_IN1); 
02954:  BCF    F8E.4
....................    output_low(HB_IN2); 
02956:  BCF    F8E.5
....................     
....................    // SPI 
....................    output_low(EEP_WP); 
02958:  BCF    F91.3
....................    output_high(EEP_CS);        
0295A:  BSF    F91.2
....................    output_high(RTC_CS); 
0295C:  BSF    F91.0
....................    output_high(SD1_CS);     // Req for init_sd(card) 
0295E:  BSF    F91.1
....................     
....................    // RS232 
....................    output_high(MD1_SHDN);   // MAX3323 ON 
02960:  BSF    F91.4
....................    output_high(MD1_REN);    // Rx enable 
02962:  BSF    F91.6
....................    output_high(MD1_TXEN);   // Tx enable 
02964:  BSF    F91.5
....................    output_low(MD2_SHDN);    // MAX3323 OFF 
02966:  BCF    F8F.0
....................    output_low(MD2_REN);     // Rx high impedance (listen) 
02968:  BCF    F8F.4
....................    output_low(MD2_TXEN);    // Tx disable 
0296A:  BCF    F8F.3
....................    delay_ms(20);   
0296C:  MOVLW  14
0296E:  MOVLB  9
02970:  MOVWF  xEC
02972:  MOVLB  0
02974:  RCALL  2904
....................     
....................    //PERIPHERALS 
....................    output_low(VMOT);         
02976:  BCF    F8E.1
....................    output_low(VDET);     
02978:  BCF    F90.7
....................    bus_pwr_status=0; 
0297A:  MOVLB  4
0297C:  CLRF   xB6
....................     
....................    //DAC 
....................    output_high(DAC_CL); 
0297E:  BSF    F8C.2
....................    output_high(DAC_CS); 
02980:  BSF    F8C.3
....................     
....................    //Heaters 
....................    output_low(HSW1); 
02982:  BCF    F8C.0
....................    output_low(HSW2); 
02984:  BCF    F8C.1
....................    heater_stat=0; 
02986:  CLRF   xB5
02988:  MOVLB  0
0298A:  RETURN 0
.................... } 
....................  
.................... void shutdown() 
.................... { 
....................    // SPI DEVICES 
....................    output_high(SD1_CS);  
*
15C4E:  BSF    F91.1
....................    output_low(EEP_WP);        
15C50:  BCF    F91.3
....................    output_high(EEP_CS);        
15C52:  BSF    F91.2
....................    output_high(RTC_CS);  
15C54:  BSF    F91.0
....................    // H-BRIDGE DEVICES 
....................    output_low(HB_EN);         
15C56:  BCF    F8E.3
....................    output_low(HB_IN1);        
15C58:  BCF    F8E.4
....................    output_low(HB_IN2); 
15C5A:  BCF    F8E.5
....................    //DAC 
....................    output_low(DAC_CL); 
15C5C:  BCF    F8C.2
....................    output_low(DAC_CS); 
15C5E:  BCF    F8C.3
....................    //Heaters 
....................    output_low(HSW1); 
15C60:  BCF    F8C.0
....................    output_low(HSW2); 
15C62:  BCF    F8C.1
....................    heater_stat=0; 
15C64:  MOVLB  4
15C66:  CLRF   xB5
....................    // Power switches 
....................    output_low(VMOT);         
15C68:  BCF    F8E.1
....................    output_low(VDET);  
15C6A:  BCF    F90.7
....................    bus_pwr_status=0; 
15C6C:  CLRF   xB6
....................    output_low(VENC1);         
15C6E:  BCF    F8E.6
....................    output_low(VENC2);         
15C70:  BCF    F8E.7
....................    output_low(VHBRDG);  
15C72:  BCF    F8E.2
....................    fprintf(COM_A, "@SLEEP\r\n");//Changed from off. 
15C74:  MOVLW  3C
15C76:  MOVWF  FF6
15C78:  MOVLW  0F
15C7A:  MOVWF  FF7
15C7C:  MOVLW  00
15C7E:  MOVWF  FF8
15C80:  CLRF   1B
15C82:  BTFSC  FF2.7
15C84:  BSF    1B.7
15C86:  BCF    FF2.7
15C88:  MOVLB  0
15C8A:  CALL   0E42
15C8E:  BTFSC  1B.7
15C90:  BSF    FF2.7
....................    delay_ms(50); 
15C92:  MOVLW  32
15C94:  MOVLB  9
15C96:  MOVWF  xEC
15C98:  MOVLB  0
15C9A:  CALL   2904
....................    // RS232 
....................    output_high(MD1_SHDN);        // must be on to "hear" characters 
15C9E:  BSF    F91.4
....................    output_high(MD1_REN);         // enable 5k.Ohm termination 
15CA0:  BSF    F91.6
....................    output_low(MD1_TXEN); 
15CA2:  BCF    F91.5
....................    output_low(MD2_SHDN);    
15CA4:  BCF    F8F.0
....................    output_low(MD2_REN); 
15CA6:  BCF    F8F.4
....................    output_low(MD2_TXEN);    
15CA8:  BCF    F8F.3
....................  
....................    delay_ms(30); 
15CAA:  MOVLW  1E
15CAC:  MOVLB  9
15CAE:  MOVWF  xEC
15CB0:  MOVLB  0
15CB2:  CALL   2904
15CB6:  RETURN 0
.................... } 
....................  
.................... // initialise the media and filesystem 
.................... int8 init_sdcard() 
.................... { 
....................    int8 n;    
....................    // FS_Status is 0 when all OK 
....................    // error state = 1 to 12 
....................    // this will loop until the card is found 
....................    for (n=0; n<3; n++){ 
*
0502E:  MOVLB  8
05030:  CLRF   x89
05032:  MOVF   x89,W
05034:  SUBLW  02
05036:  BNC   505C
....................       FS_Status = f_mountdrv(); 
05038:  MOVLB  0
0503A:  RCALL  484A
0503C:  MOVFF  01,724
....................       if (FS_Status) 
05040:  MOVLB  7
05042:  MOVF   x24,F
05044:  BZ    5050
....................          { 
....................          display_file_result(FS_Status); 
05046:  MOVFF  724,88A
0504A:  MOVLB  0
0504C:  BRA    4DE8
....................          } 
0504E:  BRA    5056
....................       else break; 
05050:  MOVLB  8
05052:  BRA    505C
05054:  MOVLB  0
05056:  MOVLB  8
05058:  INCF   x89,F
0505A:  BRA    5032
....................    } 
....................     
....................    write16(ADDR_SD_STATUS,FS_Status); 
0505C:  MOVLW  3E
0505E:  MOVWF  xEE
05060:  CLRF   xF0
05062:  MOVFF  724,8EF
05066:  MOVLB  0
05068:  RCALL  4FC8
....................     
....................    return(FS_Status); 
0506A:  MOVLB  7
0506C:  MOVFF  724,01
05070:  MOVLB  0
05072:  RETURN 0
.................... } 
....................  
....................  
.................... #include "util.c" 
.................... // blink LED 3 times 
.................... void blink() 
.................... { 
....................    int8 i; 
....................    for (i=1;i<=3;++i) 
*
030F0:  MOVLW  01
030F2:  MOVLB  8
030F4:  MOVWF  x64
030F6:  MOVF   x64,W
030F8:  SUBLW  03
030FA:  BNC   3136
....................    { 
....................       output_bit(BOARD_LED, ON); 
030FC:  BSF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, ON); 
030FE:  MOVF   2F,W
03100:  SUBLW  02
03102:  BNZ   310A
03104:  MOVF   30,F
03106:  BNZ   310A
03108:  BSF    F90.6
....................       delay_ms(32); 
0310A:  MOVLW  20
0310C:  MOVLB  9
0310E:  MOVWF  xEC
03110:  MOVLB  0
03112:  CALL   2904
....................       output_bit(BOARD_LED, OFF); 
03116:  BCF    F89.4
....................       if(nv_product==AWS)output_bit(PANEL_LED, OFF);  
03118:  MOVF   2F,W
0311A:  SUBLW  02
0311C:  BNZ   3124
0311E:  MOVF   30,F
03120:  BNZ   3124
03122:  BCF    F90.6
....................       delay_ms(32); 
03124:  MOVLW  20
03126:  MOVLB  9
03128:  MOVWF  xEC
0312A:  MOVLB  0
0312C:  CALL   2904
03130:  MOVLB  8
03132:  INCF   x64,F
03134:  BRA    30F6
....................    } 
03136:  MOVLB  0
03138:  GOTO   1B778 (RETURN)
.................... } 
....................  
.................... int16 read_supply() 
.................... { 
....................    int8 i; 
....................    int16 volts; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
050F0:  MOVLB  8
050F2:  CLRF   xF3
050F4:  CLRF   xF2
050F6:  CLRF   xF1
050F8:  CLRF   xF0
....................    set_adc_channel(0,VSS); 
050FA:  MOVLW  00
050FC:  MOVWF  01
050FE:  MOVF   FC2,W
05100:  ANDLW  83
05102:  IORWF  01,W
05104:  MOVWF  FC2
05106:  MOVLW  00
05108:  MOVWF  01
0510A:  MOVF   FC1,W
0510C:  ANDLW  F8
0510E:  IORWF  01,W
05110:  MOVWF  FC1
....................     
....................    for(i=1;i<51;++i){ 
05112:  MOVLW  01
05114:  MOVWF  xED
05116:  MOVF   xED,W
05118:  SUBLW  32
0511A:  BNC   5140
....................       reading=read_adc(); 
0511C:  BSF    FC2.1
0511E:  BTFSC  FC2.1
05120:  BRA    511E
05122:  MOVFF  FC3,8F4
05126:  MOVFF  FC4,8F5
0512A:  CLRF   xF6
0512C:  CLRF   xF7
....................       delay_ms(5); 
0512E:  MOVLW  05
05130:  MOVLB  9
05132:  MOVWF  xEC
05134:  MOVLB  0
05136:  CALL   2904
0513A:  MOVLB  8
0513C:  INCF   xED,F
0513E:  BRA    5116
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
05140:  MOVLW  01
05142:  MOVWF  xED
05144:  MOVF   xED,W
05146:  SUBLW  64
05148:  BNC   51F6
....................       reading=read_adc(); 
0514A:  BSF    FC2.1
0514C:  BTFSC  FC2.1
0514E:  BRA    514C
05150:  MOVFF  FC3,8F4
05154:  MOVFF  FC4,8F5
05158:  CLRF   xF6
0515A:  CLRF   xF7
....................       result=(((result*(i-1))+reading)/i); 
0515C:  MOVLW  01
0515E:  SUBWF  xED,W
05160:  MOVWF  xF8
05162:  MOVFF  8F3,9F9
05166:  MOVFF  8F2,9F8
0516A:  MOVFF  8F1,9F7
0516E:  MOVFF  8F0,9F6
05172:  MOVLB  9
05174:  CLRF   xFD
05176:  CLRF   xFC
05178:  CLRF   xFB
0517A:  MOVWF  xFA
0517C:  MOVLB  0
0517E:  CALL   47E4
05182:  MOVFF  03,8FB
05186:  MOVFF  02,8FA
0518A:  MOVFF  01,8F9
0518E:  MOVFF  00,8F8
05192:  MOVLB  8
05194:  MOVF   xF4,W
05196:  ADDWF  xF8,F
05198:  MOVF   xF5,W
0519A:  ADDWFC xF9,F
0519C:  MOVF   xF6,W
0519E:  ADDWFC xFA,F
051A0:  MOVF   xF7,W
051A2:  ADDWFC xFB,F
051A4:  BCF    FD8.1
051A6:  CLRF   1B
051A8:  BTFSC  FF2.7
051AA:  BSF    1B.7
051AC:  BCF    FF2.7
051AE:  MOVFF  8FB,A4F
051B2:  MOVFF  8FA,A4E
051B6:  MOVFF  8F9,A4D
051BA:  MOVFF  8F8,A4C
051BE:  MOVLB  A
051C0:  CLRF   x53
051C2:  CLRF   x52
051C4:  CLRF   x51
051C6:  MOVFF  8ED,A50
051CA:  MOVLB  0
051CC:  CALL   104A
051D0:  BTFSC  1B.7
051D2:  BSF    FF2.7
051D4:  MOVFF  03,8F3
051D8:  MOVFF  02,8F2
051DC:  MOVFF  01,8F1
051E0:  MOVFF  00,8F0
....................       delay_ms(5); 
051E4:  MOVLW  05
051E6:  MOVLB  9
051E8:  MOVWF  xEC
051EA:  MOVLB  0
051EC:  CALL   2904
051F0:  MOVLB  8
051F2:  INCF   xED,F
051F4:  BRA    5144
....................    }    
....................  
....................    volts=((result*100)/272)+86; 
051F6:  MOVFF  8F3,9F9
051FA:  MOVFF  8F2,9F8
051FE:  MOVFF  8F1,9F7
05202:  MOVFF  8F0,9F6
05206:  MOVLB  9
05208:  CLRF   xFD
0520A:  CLRF   xFC
0520C:  CLRF   xFB
0520E:  MOVLW  64
05210:  MOVWF  xFA
05212:  MOVLB  0
05214:  CALL   47E4
05218:  MOVFF  03,8FB
0521C:  MOVFF  02,8FA
05220:  MOVFF  01,8F9
05224:  MOVFF  00,8F8
05228:  BCF    FD8.1
0522A:  CLRF   1B
0522C:  BTFSC  FF2.7
0522E:  BSF    1B.7
05230:  BCF    FF2.7
05232:  MOVFF  03,A4F
05236:  MOVFF  02,A4E
0523A:  MOVFF  01,A4D
0523E:  MOVFF  00,A4C
05242:  MOVLB  A
05244:  CLRF   x53
05246:  CLRF   x52
05248:  MOVLW  01
0524A:  MOVWF  x51
0524C:  MOVLW  10
0524E:  MOVWF  x50
05250:  MOVLB  0
05252:  CALL   104A
05256:  BTFSC  1B.7
05258:  BSF    FF2.7
0525A:  MOVLW  56
0525C:  MOVLB  8
0525E:  ADDWF  00,W
05260:  MOVWF  xEE
05262:  MOVLW  00
05264:  ADDWFC 01,W
05266:  MOVWF  xEF
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,volts); 
....................  
....................    return(volts); 
05268:  MOVFF  8EE,01
0526C:  MOVFF  8EF,02
05270:  MOVLB  0
05272:  RETURN 0
.................... } 
....................  
.................... void clear_time_stmp_str() 
.................... { 
....................    memset (&time_stmp_str[0], 0x00, 30);   //blank it 
*
050DA:  MOVLW  02
050DC:  MOVWF  FEA
050DE:  MOVLW  99
050E0:  MOVWF  FE9
050E2:  CLRF   00
050E4:  CLRF   02
050E6:  MOVLW  1E
050E8:  MOVWF  01
050EA:  CALL   351A
050EE:  RETURN 0
.................... } 
....................  
.................... void clear_proc_time_stmp_str() 
.................... { 
....................    memset (&proc_time_stmp_str[0], 0x00, 30);   //blank it 
*
12D46:  MOVLW  02
12D48:  MOVWF  FEA
12D4A:  MOVLW  B7
12D4C:  MOVWF  FE9
12D4E:  CLRF   00
12D50:  CLRF   02
12D52:  MOVLW  1E
12D54:  MOVWF  01
12D56:  CALL   351A
12D5A:  GOTO   13002 (RETURN)
.................... } 
....................  
.................... void time_stamp() 
.................... { 
....................    int16 v_supply; 
....................     
....................    clear_time_stmp_str(); 
*
0540E:  RCALL  50DA
....................     
....................    v_supply = read_supply(); 
05410:  RCALL  50F0
05412:  MOVFF  02,8EC
05416:  MOVFF  01,8EB
....................    RTC_read(); 
0541A:  CALL   3338
....................     
....................    sprintf (time_stmp_str, "%02u/%02u/%02u %02u:%02u:%02u,%04.2w", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg,v_supply); 
0541E:  MOVLW  02
05420:  MOVWF  1E
05422:  MOVLW  99
05424:  MOVWF  1D
05426:  MOVFF  72A,8ED
0542A:  MOVLW  01
0542C:  MOVLB  8
0542E:  MOVWF  xEE
05430:  MOVLB  0
05432:  RCALL  5274
05434:  MOVLW  2F
05436:  MOVLB  8
05438:  MOVWF  xFF
0543A:  MOVLB  0
0543C:  RCALL  5092
0543E:  MOVFF  729,8ED
05442:  MOVLW  01
05444:  MOVLB  8
05446:  MOVWF  xEE
05448:  MOVLB  0
0544A:  RCALL  5274
0544C:  MOVLW  2F
0544E:  MOVLB  8
05450:  MOVWF  xFF
05452:  MOVLB  0
05454:  RCALL  5092
05456:  MOVFF  72B,8ED
0545A:  MOVLW  01
0545C:  MOVLB  8
0545E:  MOVWF  xEE
05460:  MOVLB  0
05462:  RCALL  5274
05464:  MOVLW  20
05466:  MOVLB  8
05468:  MOVWF  xFF
0546A:  MOVLB  0
0546C:  RCALL  5092
0546E:  MOVFF  727,8ED
05472:  MOVLW  01
05474:  MOVLB  8
05476:  MOVWF  xEE
05478:  MOVLB  0
0547A:  RCALL  5274
0547C:  MOVLW  3A
0547E:  MOVLB  8
05480:  MOVWF  xFF
05482:  MOVLB  0
05484:  RCALL  5092
05486:  MOVFF  726,8ED
0548A:  MOVLW  01
0548C:  MOVLB  8
0548E:  MOVWF  xEE
05490:  MOVLB  0
05492:  RCALL  5274
05494:  MOVLW  3A
05496:  MOVLB  8
05498:  MOVWF  xFF
0549A:  MOVLB  0
0549C:  RCALL  5092
0549E:  MOVFF  725,8ED
054A2:  MOVLW  01
054A4:  MOVLB  8
054A6:  MOVWF  xEE
054A8:  MOVLB  0
054AA:  RCALL  5274
054AC:  MOVLW  2C
054AE:  MOVLB  8
054B0:  MOVWF  xFF
054B2:  MOVLB  0
054B4:  RCALL  5092
054B6:  MOVLW  44
054B8:  MOVWF  FE9
054BA:  MOVLB  8
054BC:  CLRF   xF0
054BE:  CLRF   xEF
054C0:  MOVFF  8EC,8EE
054C4:  MOVFF  8EB,8ED
054C8:  MOVLW  02
054CA:  MOVWF  xF1
054CC:  MOVLB  0
054CE:  RCALL  530E
054D0:  RETURN 0
.................... } 
....................  
.................... void record_event() 
.................... { 
....................    if(sd_status==0) 
*
084CE:  MOVLB  2
084D0:  MOVF   xDC,F
084D2:  BNZ   854E
....................    { 
....................       strcopy(event_buffer,""); 
084D4:  MOVLW  01
084D6:  MOVWF  FEA
084D8:  MOVLW  07
084DA:  MOVWF  FE9
084DC:  MOVLW  00
084DE:  MOVLB  0
084E0:  CALL   02CE
084E4:  TBLRD*-
084E6:  TBLRD*+
084E8:  MOVF   FF5,W
084EA:  MOVWF  FEE
084EC:  IORLW  00
084EE:  BNZ   84E6
....................       time_stamp(); 
084F0:  CALL   540E
....................       strcat(event_buffer, time_stmp_str); 
084F4:  MOVLW  01
084F6:  MOVLB  8
084F8:  MOVWF  xF9
084FA:  MOVLW  07
084FC:  MOVWF  xF8
084FE:  MOVLW  02
08500:  MOVWF  xFB
08502:  MOVLW  99
08504:  MOVWF  xFA
08506:  MOVLB  0
08508:  CALL   54D2
....................       strcat(event_buffer, event_str); 
0850C:  MOVLW  01
0850E:  MOVLB  8
08510:  MOVWF  xF9
08512:  MOVLW  07
08514:  MOVWF  xF8
08516:  MOVLW  01
08518:  MOVWF  xFB
0851A:  MOVLW  A7
0851C:  MOVWF  xFA
0851E:  MOVLB  0
08520:  CALL   54D2
....................       buffer_select = 1; 
08524:  MOVLW  01
08526:  MOVWF  x66
....................     
....................       heartbeat(FALSE); 
08528:  MOVLB  8
0852A:  CLRF   xED
0852C:  MOVLB  0
0852E:  CALL   557A
....................          append_data(file_ptr_events); 
08532:  MOVLW  03
08534:  MOVLB  8
08536:  MOVWF  xEE
08538:  MOVLW  15
0853A:  MOVWF  xED
0853C:  MOVLB  0
0853E:  RCALL  82EC
....................       heartbeat(TRUE); 
08540:  MOVLW  01
08542:  MOVLB  8
08544:  MOVWF  xED
08546:  MOVLB  0
08548:  CALL   557A
0854C:  MOVLB  2
....................    } 
0854E:  MOVLB  0
08550:  RETURN 0
.................... } 
....................  
....................  
.................... #include "stepper.c" 
.................... // MOTOR 1 
.................... #define M1_RESET     PIN_H0 
.................... #define M1_ENABLE    PIN_H1 
.................... #define M1_CONTROL   PIN_H2 
.................... #define M1_STEPMODE  PIN_H3 
.................... #define M1_CLOCK     PIN_H4 
.................... #define M1_DIR       PIN_H5 
.................... #define M1_PWM       PIN_C2 
.................... // MOTOR 2 
.................... #define M2_RESET     PIN_E0 
.................... #define M2_ENABLE    PIN_E1 
.................... #define M2_CONTROL   PIN_E2 
.................... #define M2_STEPMODE  PIN_E3 
.................... #define M2_CLOCK     PIN_E4 
.................... #define M2_DIR       PIN_E5 
.................... #define M2_PWM       PIN_C1 
.................... // ENCODER 1 
.................... #define ENC1_IND     PIN_B4 
.................... #define ENC1_PHA     PIN_B1 
.................... //#define ENC1_PHB     PIN_H6 
.................... // ENCODER 2 
.................... #define ENC2_IND     PIN_B5 
.................... #define ENC2_PHA     PIN_B2 
.................... //#define ENC2_PHB     PIN_E6 
....................  
.................... // *** timer2 *** // 
.................... #define T2_MID_VAL 127 
.................... /* 
....................    T2 is used for PWM duty 
....................    the duty value cannot be bigger than 
....................    ((T2_MID_VAL + 1) *4 ) -1 
....................    pwm value = (duty%/100) *[(T2_MID_VAL+1) *4 ) -1] 
.................... */ 
....................  
.................... // *** timer3 *** // 
.................... //#define STEP_INTERVAL 63936 
.................... /* 
....................    64MHz / 4 = 16 Mhz >> 0.0625 us 
....................    TIMER DIV 1 (no division) 
....................    1600 * 0.0625 us = 100 us 
....................    65536 - 1600 = 63936 
.................... */ 
.................... // stepper vars start at 110 // 
.................... #define ADDR_M1_ERROR     110 
.................... #define ADDR_M2_ERROR     112 
.................... #define ADDR_M1_BKLSH     114 
.................... #define ADDR_M2_BKLSH     116 
.................... #define ADDR_M1_RUN       118 
.................... #define ADDR_M2_RUN       120 
.................... #define ADDR_E1_TYPE      122 
.................... #define ADDR_E2_TYPE      124 
.................... #define ADDR_E1_POS       126 
.................... #define ADDR_E2_POS       128 
.................... #define ADDR_E1_MODE      130  
.................... #define ADDR_E2_MODE      132 
.................... #define ADDR_M1_CTRL      134 
.................... #define ADDR_M2_CTRL      136 
.................... #define ADDR_M1_MODE      138 
.................... #define ADDR_M2_MODE      140 
.................... #define ADDR_M1_STP_INT   142 
.................... #define ADDR_M2_STP_INT   144 
.................... #define ADDR_M1_POS_DIR   146  
.................... #define ADDR_M2_POS_DIR   148 
.................... #define ADDR_M1_PWM_HLD   150 
.................... #define ADDR_M2_PWM_HLD   152 
.................... #define ADDR_M1_PWM_DRV   154 
.................... #define ADDR_M2_PWM_DRV   156 
.................... #define ADDR_M1_GB_ERR    158 
.................... #define ADDR_M2_GB_ERR    160 
.................... #define ADDR_E1_CPR       162 
.................... #define ADDR_E2_CPR       164 
.................... #define ADDR_E1_PPR       166  
.................... #define ADDR_E2_PPR       168 
.................... #define ADDR_E1_PORT      170 
.................... #define ADDR_E2_PORT      172 
.................... #define ADDR_M1_SPR       174 
.................... #define ADDR_M2_SPR       176 
.................... #define ADDR_M1_COMP      178 
.................... #define ADDR_M2_COMP      180 
.................... #define ADDR_M1_LIN_POS   182 
.................... #define ADDR_M2_LIN_POS   184 
.................... #define ADDR_E1_INDEX     186 
.................... #define ADDR_E2_INDEX     188 
.................... #define ADDR_M1_EVN_SO    190  // Even # ports - additional motor steps to run past enc tic 
.................... #define ADDR_M2_EVN_SO    192 
.................... #define ADDR_M1_ALIGN_OS  194 
.................... #define ADDR_M2_ALIGN_OS  196 
....................  
.................... #define RUN          1 
.................... #define RESET        0 
.................... #define SLOW         1 
.................... #define FAST         0 
.................... #define HALF         1 
.................... #define FULL         0 
.................... #define POS          0 
.................... #define NEG          1 
....................  
.................... // *** motor variables *** // 
....................  
.................... // user variables 
.................... int8  motor;                  // active motor 
.................... int8  m_fixed;                // allows +/- commands to use "motor" (=0) 
.................... int16 m_ctrl[2];              // L6208 control (decay mode) 
.................... int16 m_mode[2];              // L6208 full/half 
.................... int16 m_stp_int[2];           // step trigger interval 
.................... int16 m_pos_dir[2];           // pos direction (0=natural, 1 = opposite) 
.................... int16 m_pwm_hld[2];           // pwm hold current duty 
.................... int16 m_pwm_drv[2];           // pwm drive current duty 
.................... int16 m_gb_err[2];            // "gearbox error" = trigger after no encoder for x m steps 
.................... int16 e_cpr[2];               // encoder cpr  
.................... int16 e_ppr[2];               // ports per revolution 
.................... int16 e_mode[2];              // encoder mode (steps, enc ticks, ports, align, etc.) 
.................... int16 e_type[2];              // encoder type (quadrature(1), disk(2), flag(3), etc.) 
.................... int16 m_run[2];               // run-on value (past slot edge) for disk encoders for odd ports 
.................... int16 m_bklsh[2];             // back-lash vlaue 
.................... int16 m_spr[2];               // steps per rev 
.................... int16 e_index[2];             // index polarity (HEDS=1 / Baumer=0) 
.................... int16 evn_so[2];              // adjustment run-on value (past slot edge) for disk encoders even ports 
.................... int16 align_os[2];            // adjustment of motor steps to move after encoder finds index position 
....................  
.................... // code variables 
.................... int16 m_way[2];               // L6208 direction 
.................... int16 m_way_rst[2];           // last direction 
.................... int16 m_trig_cnt[2];          // step trigger counter 
.................... int16 m_running[2];           // motor running flag 
.................... int16 m_error[2];             // indiactes a movement error 
.................... int16 m_gb_cnt[2];            // "gearbox count" = counts motor steps 
.................... int16 e_mode_rst[2]; 
.................... int32 m_step_cnt[2];          // motor step counter 
.................... int8  edge_mode; 
.................... int16 m_ppp[2];               // pulses per port 
.................... int16 m_comp[2];              // move complete 
.................... signed int16 m_lin_pos[2];    // linear position 
.................... int16 e_port_dist[2];         // distance between ports (in ports) 
....................  
.................... // *** encoder variables *** // 
....................  
.................... int16 e_cha_cnt[2];           // channel A counter 
.................... int16 e_pos[2];               // encoder current position 
.................... int16 e_port[2];              // current encoder port position 
.................... int16 e_target_port[2];       // commanded encoder port position 
.................... int8  e_ch_n[2];              // polled index level 
....................  
....................  
.................... void setup_stepper_pwm() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
028B8:  BCF    F8B.2
028BA:  MOVLW  0C
028BC:  MOVWF  FBB
028BE:  CLRF   FBE
028C0:  CLRF   FBF
028C2:  MOVLW  01
028C4:  MOVWF  F9C
028C6:  MOVLW  F8
028C8:  MOVLB  F
028CA:  ANDWF  x2D,F
028CC:  MOVLW  00
028CE:  IORWF  x2D,F
....................    setup_ccp2(CCP_PWM); 
028D0:  BCF    F8B.1
028D2:  MOVLW  0C
028D4:  MOVWF  x4E
028D6:  CLRF   x51
028D8:  CLRF   x52
028DA:  MOVLW  01
028DC:  MOVWF  x1B
028DE:  MOVLW  C7
028E0:  ANDWF  x2D,F
028E2:  MOVLW  00
028E4:  IORWF  x2D,F
....................     
....................           //   The cycle time will be (1/clock)*4*t2div*(period+1) 
....................           //   In this program clock=64000000 and period=127 (below) 
....................           //   For the three possible selections the cycle time is: 
....................           //     (1/64000000)*4*1*128 =   8 us or 125.00   khz 
....................           //     (1/64000000)*4*4*128 =  32 us or  31.25   khz 
....................           //     (1/64000000)*4*16*128= 128 us or   7.8125 khz    
....................     
....................    // TIMER 2 is use for PWM. 8-bit timer. 
....................    setup_timer_2(T2_DIV_BY_4, T2_MID_VAL, 1); 
028E6:  IORLW  05
028E8:  MOVWF  FCA
028EA:  MOVLW  7F
028EC:  MOVWF  FCB
028EE:  MOVLB  0
028F0:  GOTO   1B72E (RETURN)
.................... } 
....................  
.................... void msg_mer() 
.................... { 
....................    fprintf(COM_A, "@MER,%Lu,%Lu\r\n",m_error[0],m_error[1]); 
*
09CF6:  MOVLW  46
09CF8:  MOVWF  FF6
09CFA:  MOVLW  0F
09CFC:  MOVWF  FF7
09CFE:  MOVLW  00
09D00:  MOVWF  FF8
09D02:  CLRF   1B
09D04:  BTFSC  FF2.7
09D06:  BSF    1B.7
09D08:  BCF    FF2.7
09D0A:  MOVLW  05
09D0C:  MOVLB  A
09D0E:  MOVWF  x40
09D10:  MOVLB  0
09D12:  CALL   1018
09D16:  BTFSC  1B.7
09D18:  BSF    FF2.7
09D1A:  MOVLW  10
09D1C:  MOVWF  FE9
09D1E:  CLRF   1B
09D20:  BTFSC  FF2.7
09D22:  BSF    1B.7
09D24:  BCF    FF2.7
09D26:  MOVFF  797,A41
09D2A:  MOVFF  796,A40
09D2E:  CALL   119A
09D32:  BTFSC  1B.7
09D34:  BSF    FF2.7
09D36:  MOVLW  2C
09D38:  BTFSS  F9E.4
09D3A:  BRA    9D38
09D3C:  MOVWF  FAD
09D3E:  MOVLW  10
09D40:  MOVWF  FE9
09D42:  CLRF   1B
09D44:  BTFSC  FF2.7
09D46:  BSF    1B.7
09D48:  BCF    FF2.7
09D4A:  MOVFF  799,A41
09D4E:  MOVFF  798,A40
09D52:  CALL   119A
09D56:  BTFSC  1B.7
09D58:  BSF    FF2.7
09D5A:  MOVLW  0D
09D5C:  BTFSS  F9E.4
09D5E:  BRA    9D5C
09D60:  MOVWF  FAD
09D62:  MOVLW  0A
09D64:  BTFSS  F9E.4
09D66:  BRA    9D64
09D68:  MOVWF  FAD
09D6A:  RETURN 0
.................... } 
....................  
.................... void get_step_vars() 
.................... { 
....................    m_ctrl[0]      = read16(ADDR_M1_CTRL);       // y.. 
*
02D0E:  MOVLW  86
02D10:  MOVLB  8
02D12:  MOVWF  x97
02D14:  MOVLB  0
02D16:  RCALL  29BE
02D18:  MOVFF  02,743
02D1C:  MOVFF  01,742
....................    m_mode[0]      = read16(ADDR_M1_MODE);       // m.. 
02D20:  MOVLW  8A
02D22:  MOVLB  8
02D24:  MOVWF  x97
02D26:  MOVLB  0
02D28:  RCALL  29BE
02D2A:  MOVFF  02,747
02D2E:  MOVFF  01,746
....................    m_stp_int[0]   = read16(ADDR_M1_STP_INT);    // i.. 
02D32:  MOVLW  8E
02D34:  MOVLB  8
02D36:  MOVWF  x97
02D38:  MOVLB  0
02D3A:  RCALL  29BE
02D3C:  MOVFF  02,74B
02D40:  MOVFF  01,74A
....................    m_pos_dir[0]   = read16(ADDR_M1_POS_DIR);    // d.. 
02D44:  MOVLW  92
02D46:  MOVLB  8
02D48:  MOVWF  x97
02D4A:  MOVLB  0
02D4C:  RCALL  29BE
02D4E:  MOVFF  02,74F
02D52:  MOVFF  01,74E
....................    m_pwm_hld[0]   = read16(ADDR_M1_PWM_HLD);    // h.. 
02D56:  MOVLW  96
02D58:  MOVLB  8
02D5A:  MOVWF  x97
02D5C:  MOVLB  0
02D5E:  RCALL  29BE
02D60:  MOVFF  02,753
02D64:  MOVFF  01,752
....................    m_pwm_drv[0]   = read16(ADDR_M1_PWM_DRV);    // w.. 
02D68:  MOVLW  9A
02D6A:  MOVLB  8
02D6C:  MOVWF  x97
02D6E:  MOVLB  0
02D70:  RCALL  29BE
02D72:  MOVFF  02,757
02D76:  MOVFF  01,756
....................    m_gb_err[0]    = read16(ADDR_M1_GB_ERR);     // g.. 
02D7A:  MOVLW  9E
02D7C:  MOVLB  8
02D7E:  MOVWF  x97
02D80:  MOVLB  0
02D82:  RCALL  29BE
02D84:  MOVFF  02,75B
02D88:  MOVFF  01,75A
....................    e_cpr[0]       = read16(ADDR_E1_CPR);        // e.. 
02D8C:  MOVLW  A2
02D8E:  MOVLB  8
02D90:  MOVWF  x97
02D92:  MOVLB  0
02D94:  RCALL  29BE
02D96:  MOVFF  02,75F
02D9A:  MOVFF  01,75E
....................    e_ppr[0]       = read16(ADDR_E1_PPR);        // p.. 
02D9E:  MOVLW  A6
02DA0:  MOVLB  8
02DA2:  MOVWF  x97
02DA4:  MOVLB  0
02DA6:  RCALL  29BE
02DA8:  MOVFF  02,763
02DAC:  MOVFF  01,762
....................    e_mode[0]      = read16(ADDR_E1_MODE);       // k.. 
02DB0:  MOVLW  82
02DB2:  MOVLB  8
02DB4:  MOVWF  x97
02DB6:  MOVLB  0
02DB8:  RCALL  29BE
02DBA:  MOVFF  02,767
02DBE:  MOVFF  01,766
....................    e_pos[0]       = read16(ADDR_E1_POS);        // z (to zero) .. 
02DC2:  MOVLW  7E
02DC4:  MOVLB  8
02DC6:  MOVWF  x97
02DC8:  MOVLB  0
02DCA:  RCALL  29BE
02DCC:  MOVFF  02,7C0
02DD0:  MOVFF  01,7BF
....................    e_port[0]      = read16(ADDR_E1_PORT);   
02DD4:  MOVLW  AA
02DD6:  MOVLB  8
02DD8:  MOVWF  x97
02DDA:  MOVLB  0
02DDC:  RCALL  29BE
02DDE:  MOVFF  02,7C4
02DE2:  MOVFF  01,7C3
....................    e_type[0]      = read16(ADDR_E1_TYPE);       // t 
02DE6:  MOVLW  7A
02DE8:  MOVLB  8
02DEA:  MOVWF  x97
02DEC:  MOVLB  0
02DEE:  RCALL  29BE
02DF0:  MOVFF  02,76B
02DF4:  MOVFF  01,76A
....................    m_run[0]       = read16(ADDR_M1_RUN);        // j 
02DF8:  MOVLW  76
02DFA:  MOVLB  8
02DFC:  MOVWF  x97
02DFE:  MOVLB  0
02E00:  RCALL  29BE
02E02:  MOVFF  02,76F
02E06:  MOVFF  01,76E
....................    m_bklsh[0]     = read16(ADDR_M1_BKLSH);      // b 
02E0A:  MOVLW  72
02E0C:  MOVLB  8
02E0E:  MOVWF  x97
02E10:  MOVLB  0
02E12:  RCALL  29BE
02E14:  MOVFF  02,773
02E18:  MOVFF  01,772
....................    m_error[0]     = read16(ADDR_M1_ERROR);   
02E1C:  MOVLW  6E
02E1E:  MOVLB  8
02E20:  MOVWF  x97
02E22:  MOVLB  0
02E24:  RCALL  29BE
02E26:  MOVFF  02,797
02E2A:  MOVFF  01,796
....................    m_spr[0]       = read16(ADDR_M1_SPR);        // s 
02E2E:  MOVLW  AE
02E30:  MOVLB  8
02E32:  MOVWF  x97
02E34:  MOVLB  0
02E36:  RCALL  29BE
02E38:  MOVFF  02,777
02E3C:  MOVFF  01,776
....................    m_comp[0]      = read16(ADDR_M1_COMP); 
02E40:  MOVLW  B2
02E42:  MOVLB  8
02E44:  MOVWF  x97
02E46:  MOVLB  0
02E48:  RCALL  29BE
02E4A:  MOVFF  02,7B0
02E4E:  MOVFF  01,7AF
....................    m_lin_pos[0]   = read16(ADDR_M1_LIN_POS); 
02E52:  MOVLW  B6
02E54:  MOVLB  8
02E56:  MOVWF  x97
02E58:  MOVLB  0
02E5A:  RCALL  29BE
02E5C:  MOVFF  02,7B4
02E60:  MOVFF  01,7B3
....................    e_index[0]     = read16(ADDR_E1_INDEX); 
02E64:  MOVLW  BA
02E66:  MOVLB  8
02E68:  MOVWF  x97
02E6A:  MOVLB  0
02E6C:  RCALL  29BE
02E6E:  MOVFF  02,77B
02E72:  MOVFF  01,77A
....................    evn_so[0]      = read16(ADDR_M1_EVN_SO);     // 0 
02E76:  MOVLW  BE
02E78:  MOVLB  8
02E7A:  MOVWF  x97
02E7C:  MOVLB  0
02E7E:  RCALL  29BE
02E80:  MOVFF  02,77F
02E84:  MOVFF  01,77E
....................    align_os[0]    = read16(ADDR_M1_ALIGN_OS);   // x 
02E88:  MOVLW  C2
02E8A:  MOVLB  8
02E8C:  MOVWF  x97
02E8E:  MOVLB  0
02E90:  RCALL  29BE
02E92:  MOVFF  02,783
02E96:  MOVFF  01,782
....................     
....................    m_ctrl[1]      = read16(ADDR_M2_CTRL); 
02E9A:  MOVLW  88
02E9C:  MOVLB  8
02E9E:  MOVWF  x97
02EA0:  MOVLB  0
02EA2:  RCALL  29BE
02EA4:  MOVFF  02,745
02EA8:  MOVFF  01,744
....................    m_mode[1]      = read16(ADDR_M2_MODE); 
02EAC:  MOVLW  8C
02EAE:  MOVLB  8
02EB0:  MOVWF  x97
02EB2:  MOVLB  0
02EB4:  RCALL  29BE
02EB6:  MOVFF  02,749
02EBA:  MOVFF  01,748
....................    m_stp_int[1]   = read16(ADDR_M2_STP_INT); 
02EBE:  MOVLW  90
02EC0:  MOVLB  8
02EC2:  MOVWF  x97
02EC4:  MOVLB  0
02EC6:  RCALL  29BE
02EC8:  MOVFF  02,74D
02ECC:  MOVFF  01,74C
....................    m_pos_dir[1]   = read16(ADDR_M2_POS_DIR); 
02ED0:  MOVLW  94
02ED2:  MOVLB  8
02ED4:  MOVWF  x97
02ED6:  MOVLB  0
02ED8:  RCALL  29BE
02EDA:  MOVFF  02,751
02EDE:  MOVFF  01,750
....................    m_pwm_hld[1]   = read16(ADDR_M2_PWM_HLD); 
02EE2:  MOVLW  98
02EE4:  MOVLB  8
02EE6:  MOVWF  x97
02EE8:  MOVLB  0
02EEA:  RCALL  29BE
02EEC:  MOVFF  02,755
02EF0:  MOVFF  01,754
....................    m_pwm_drv[1]   = read16(ADDR_M2_PWM_DRV); 
02EF4:  MOVLW  9C
02EF6:  MOVLB  8
02EF8:  MOVWF  x97
02EFA:  MOVLB  0
02EFC:  RCALL  29BE
02EFE:  MOVFF  02,759
02F02:  MOVFF  01,758
....................    m_gb_err[1]    = read16(ADDR_M2_GB_ERR); 
02F06:  MOVLW  A0
02F08:  MOVLB  8
02F0A:  MOVWF  x97
02F0C:  MOVLB  0
02F0E:  RCALL  29BE
02F10:  MOVFF  02,75D
02F14:  MOVFF  01,75C
....................    e_cpr[1]       = read16(ADDR_E2_CPR); 
02F18:  MOVLW  A4
02F1A:  MOVLB  8
02F1C:  MOVWF  x97
02F1E:  MOVLB  0
02F20:  RCALL  29BE
02F22:  MOVFF  02,761
02F26:  MOVFF  01,760
....................    e_ppr[1]       = read16(ADDR_E2_PPR); 
02F2A:  MOVLW  A8
02F2C:  MOVLB  8
02F2E:  MOVWF  x97
02F30:  MOVLB  0
02F32:  RCALL  29BE
02F34:  MOVFF  02,765
02F38:  MOVFF  01,764
....................    e_mode[1]      = read16(ADDR_E2_MODE);     
02F3C:  MOVLW  84
02F3E:  MOVLB  8
02F40:  MOVWF  x97
02F42:  MOVLB  0
02F44:  RCALL  29BE
02F46:  MOVFF  02,769
02F4A:  MOVFF  01,768
....................    e_pos[1]       = read16(ADDR_E2_POS);    
02F4E:  MOVLW  80
02F50:  MOVLB  8
02F52:  MOVWF  x97
02F54:  MOVLB  0
02F56:  RCALL  29BE
02F58:  MOVFF  02,7C2
02F5C:  MOVFF  01,7C1
....................    e_port[1]      = read16(ADDR_E2_PORT);     
02F60:  MOVLW  AC
02F62:  MOVLB  8
02F64:  MOVWF  x97
02F66:  MOVLB  0
02F68:  RCALL  29BE
02F6A:  MOVFF  02,7C6
02F6E:  MOVFF  01,7C5
....................    e_type[1]      = read16(ADDR_E2_TYPE); 
02F72:  MOVLW  7C
02F74:  MOVLB  8
02F76:  MOVWF  x97
02F78:  MOVLB  0
02F7A:  RCALL  29BE
02F7C:  MOVFF  02,76D
02F80:  MOVFF  01,76C
....................    m_run[1]       = read16(ADDR_M2_RUN);         
02F84:  MOVLW  78
02F86:  MOVLB  8
02F88:  MOVWF  x97
02F8A:  MOVLB  0
02F8C:  RCALL  29BE
02F8E:  MOVFF  02,771
02F92:  MOVFF  01,770
....................    m_bklsh[1]     = read16(ADDR_M2_BKLSH);   
02F96:  MOVLW  74
02F98:  MOVLB  8
02F9A:  MOVWF  x97
02F9C:  MOVLB  0
02F9E:  RCALL  29BE
02FA0:  MOVFF  02,775
02FA4:  MOVFF  01,774
....................    m_error[1]     = read16(ADDR_M2_ERROR);      
02FA8:  MOVLW  70
02FAA:  MOVLB  8
02FAC:  MOVWF  x97
02FAE:  MOVLB  0
02FB0:  RCALL  29BE
02FB2:  MOVFF  02,799
02FB6:  MOVFF  01,798
....................    m_spr[1]       = read16(ADDR_M2_SPR);        // s 
02FBA:  MOVLW  B0
02FBC:  MOVLB  8
02FBE:  MOVWF  x97
02FC0:  MOVLB  0
02FC2:  RCALL  29BE
02FC4:  MOVFF  02,779
02FC8:  MOVFF  01,778
....................    m_comp[1]      = read16(ADDR_M2_COMP); 
02FCC:  MOVLW  B4
02FCE:  MOVLB  8
02FD0:  MOVWF  x97
02FD2:  MOVLB  0
02FD4:  RCALL  29BE
02FD6:  MOVFF  02,7B2
02FDA:  MOVFF  01,7B1
....................    m_lin_pos[1]   = read16(ADDR_M2_LIN_POS);    
02FDE:  MOVLW  B8
02FE0:  MOVLB  8
02FE2:  MOVWF  x97
02FE4:  MOVLB  0
02FE6:  RCALL  29BE
02FE8:  MOVFF  02,7B6
02FEC:  MOVFF  01,7B5
....................    e_index[1]     = read16(ADDR_E2_INDEX); 
02FF0:  MOVLW  BC
02FF2:  MOVLB  8
02FF4:  MOVWF  x97
02FF6:  MOVLB  0
02FF8:  RCALL  29BE
02FFA:  MOVFF  02,77D
02FFE:  MOVFF  01,77C
....................    evn_so[1]      = read16(ADDR_M2_EVN_SO); 
03002:  MOVLW  C0
03004:  MOVLB  8
03006:  MOVWF  x97
03008:  MOVLB  0
0300A:  RCALL  29BE
0300C:  MOVFF  02,781
03010:  MOVFF  01,780
....................    align_os[1]    = read16(ADDR_M2_ALIGN_OS);   // x 
03014:  MOVLW  C4
03016:  MOVLB  8
03018:  MOVWF  x97
0301A:  MOVLB  0
0301C:  RCALL  29BE
0301E:  MOVFF  02,785
03022:  MOVFF  01,784
....................     
....................    motor=0; 
03026:  MOVLB  7
03028:  CLRF   x40
....................    m_fixed=1; 
0302A:  MOVLW  01
0302C:  MOVWF  x41
....................    m_step_cnt[0]=0; 
0302E:  CLRF   xA5
03030:  CLRF   xA4
03032:  CLRF   xA3
03034:  CLRF   xA2
....................    m_step_cnt[1]=0; 
03036:  CLRF   xA9
03038:  CLRF   xA8
0303A:  CLRF   xA7
0303C:  CLRF   xA6
....................    e_cha_cnt[0]=0; 
0303E:  CLRF   xBC
03040:  CLRF   xBB
....................    e_cha_cnt[1]=0;  
03042:  CLRF   xBE
03044:  CLRF   xBD
....................    m_gb_cnt[0]=0; 
03046:  CLRF   x9B
03048:  CLRF   x9A
....................    m_gb_cnt[1]=0; 
0304A:  CLRF   x9D
0304C:  CLRF   x9C
....................    e_mode_rst[0]=0; 
0304E:  CLRF   x9F
03050:  CLRF   x9E
....................    e_mode_rst[1]=0;    
03052:  CLRF   xA1
03054:  CLRF   xA0
....................    e_port_dist[0]=0; 
03056:  CLRF   xB8
03058:  CLRF   xB7
....................    e_port_dist[1]=0; 
0305A:  CLRF   xBA
0305C:  CLRF   xB9
....................     
....................    m_ppp[0] = (m_spr[0]/e_ppr[0])*2; 
0305E:  MOVFF  777,8DC
03062:  MOVFF  776,8DB
03066:  MOVFF  763,8DE
0306A:  MOVFF  762,8DD
0306E:  MOVLB  0
03070:  RCALL  2CC8
03072:  BCF    FD8.0
03074:  MOVLB  8
03076:  RLCF   01,W
03078:  MOVLB  7
0307A:  MOVWF  xAB
0307C:  MOVLB  8
0307E:  RLCF   02,W
03080:  MOVLB  7
03082:  MOVWF  xAC
....................    m_ppp[1] = (m_spr[1]/e_ppr[1])*2; 
03084:  MOVFF  779,8DC
03088:  MOVFF  778,8DB
0308C:  MOVFF  765,8DE
03090:  MOVFF  764,8DD
03094:  MOVLB  0
03096:  RCALL  2CC8
03098:  BCF    FD8.0
0309A:  MOVLB  8
0309C:  RLCF   01,W
0309E:  MOVLB  7
030A0:  MOVWF  xAD
030A2:  MOVLB  8
030A4:  RLCF   02,W
030A6:  MOVLB  7
030A8:  MOVWF  xAE
030AA:  MOVLB  0
030AC:  RETURN 0
.................... } 
....................  
.................... void rst_step_vars_eco() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
*
1A0EC:  MOVLW  86
1A0EE:  MOVLB  8
1A0F0:  MOVWF  xEE
1A0F2:  CLRF   xF0
1A0F4:  MOVLW  01
1A0F6:  MOVWF  xEF
1A0F8:  MOVLB  0
1A0FA:  CALL   4FC8
....................    write16(ADDR_M1_MODE,FULL); 
1A0FE:  MOVLW  8A
1A100:  MOVLB  8
1A102:  MOVWF  xEE
1A104:  CLRF   xF0
1A106:  CLRF   xEF
1A108:  MOVLB  0
1A10A:  CALL   4FC8
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A10E:  MOVLW  8E
1A110:  MOVLB  8
1A112:  MOVWF  xEE
1A114:  CLRF   xF0
1A116:  MOVLW  0A
1A118:  MOVWF  xEF
1A11A:  MOVLB  0
1A11C:  CALL   4FC8
....................    write16(ADDR_M1_POS_DIR,0); 
1A120:  MOVLW  92
1A122:  MOVLB  8
1A124:  MOVWF  xEE
1A126:  CLRF   xF0
1A128:  CLRF   xEF
1A12A:  MOVLB  0
1A12C:  CALL   4FC8
....................    write16(ADDR_M1_PWM_HLD,0); 
1A130:  MOVLW  96
1A132:  MOVLB  8
1A134:  MOVWF  xEE
1A136:  CLRF   xF0
1A138:  CLRF   xEF
1A13A:  MOVLB  0
1A13C:  CALL   4FC8
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A140:  MOVLW  9A
1A142:  MOVLB  8
1A144:  MOVWF  xEE
1A146:  CLRF   xF0
1A148:  MOVLW  7F
1A14A:  MOVWF  xEF
1A14C:  MOVLB  0
1A14E:  CALL   4FC8
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A152:  MOVLW  9E
1A154:  MOVLB  8
1A156:  MOVWF  xEE
1A158:  MOVLW  17
1A15A:  MOVWF  xF0
1A15C:  MOVLW  70
1A15E:  MOVWF  xEF
1A160:  MOVLB  0
1A162:  CALL   4FC8
....................    write16(ADDR_E1_CPR,16); 
1A166:  MOVLW  A2
1A168:  MOVLB  8
1A16A:  MOVWF  xEE
1A16C:  CLRF   xF0
1A16E:  MOVLW  10
1A170:  MOVWF  xEF
1A172:  MOVLB  0
1A174:  CALL   4FC8
....................    write16(ADDR_E1_PPR,16); 
1A178:  MOVLW  A6
1A17A:  MOVLB  8
1A17C:  MOVWF  xEE
1A17E:  CLRF   xF0
1A180:  MOVLW  10
1A182:  MOVWF  xEF
1A184:  MOVLB  0
1A186:  CALL   4FC8
....................    write16(ADDR_E1_MODE,2); 
1A18A:  MOVLW  82
1A18C:  MOVLB  8
1A18E:  MOVWF  xEE
1A190:  CLRF   xF0
1A192:  MOVLW  02
1A194:  MOVWF  xEF
1A196:  MOVLB  0
1A198:  CALL   4FC8
....................    write16(ADDR_E1_POS,0); 
1A19C:  MOVLW  7E
1A19E:  MOVLB  8
1A1A0:  MOVWF  xEE
1A1A2:  CLRF   xF0
1A1A4:  CLRF   xEF
1A1A6:  MOVLB  0
1A1A8:  CALL   4FC8
....................    write16(ADDR_E1_PORT,0); 
1A1AC:  MOVLW  AA
1A1AE:  MOVLB  8
1A1B0:  MOVWF  xEE
1A1B2:  CLRF   xF0
1A1B4:  CLRF   xEF
1A1B6:  MOVLB  0
1A1B8:  CALL   4FC8
....................    write16(ADDR_E1_TYPE,2); 
1A1BC:  MOVLW  7A
1A1BE:  MOVLB  8
1A1C0:  MOVWF  xEE
1A1C2:  CLRF   xF0
1A1C4:  MOVLW  02
1A1C6:  MOVWF  xEF
1A1C8:  MOVLB  0
1A1CA:  CALL   4FC8
....................    write16(ADDR_M1_RUN,270); 
1A1CE:  MOVLW  76
1A1D0:  MOVLB  8
1A1D2:  MOVWF  xEE
1A1D4:  MOVLW  01
1A1D6:  MOVWF  xF0
1A1D8:  MOVLW  0E
1A1DA:  MOVWF  xEF
1A1DC:  MOVLB  0
1A1DE:  CALL   4FC8
....................    write16(ADDR_M1_BKLSH,0); 
1A1E2:  MOVLW  72
1A1E4:  MOVLB  8
1A1E6:  MOVWF  xEE
1A1E8:  CLRF   xF0
1A1EA:  CLRF   xEF
1A1EC:  MOVLB  0
1A1EE:  CALL   4FC8
....................    write16(ADDR_M1_ERROR,0);   
1A1F2:  MOVLW  6E
1A1F4:  MOVLB  8
1A1F6:  MOVWF  xEE
1A1F8:  CLRF   xF0
1A1FA:  CLRF   xEF
1A1FC:  MOVLB  0
1A1FE:  CALL   4FC8
....................    write16(ADDR_M1_SPR,38400); 
1A202:  MOVLW  AE
1A204:  MOVLB  8
1A206:  MOVWF  xEE
1A208:  MOVLW  96
1A20A:  MOVWF  xF0
1A20C:  CLRF   xEF
1A20E:  MOVLB  0
1A210:  CALL   4FC8
....................    write16(ADDR_M1_COMP,0); 
1A214:  MOVLW  B2
1A216:  MOVLB  8
1A218:  MOVWF  xEE
1A21A:  CLRF   xF0
1A21C:  CLRF   xEF
1A21E:  MOVLB  0
1A220:  CALL   4FC8
....................    write16(ADDR_M1_LIN_POS,0); 
1A224:  MOVLW  B6
1A226:  MOVLB  8
1A228:  MOVWF  xEE
1A22A:  CLRF   xF0
1A22C:  CLRF   xEF
1A22E:  MOVLB  0
1A230:  CALL   4FC8
....................    write16(ADDR_E1_INDEX,1); 
1A234:  MOVLW  BA
1A236:  MOVLB  8
1A238:  MOVWF  xEE
1A23A:  CLRF   xF0
1A23C:  MOVLW  01
1A23E:  MOVWF  xEF
1A240:  MOVLB  0
1A242:  CALL   4FC8
....................    write16(ADDR_M1_EVN_SO,0); 
1A246:  MOVLW  BE
1A248:  MOVLB  8
1A24A:  MOVWF  xEE
1A24C:  CLRF   xF0
1A24E:  CLRF   xEF
1A250:  MOVLB  0
1A252:  CALL   4FC8
....................    write16(ADDR_M1_ALIGN_OS,0); 
1A256:  MOVLW  C2
1A258:  MOVLB  8
1A25A:  MOVWF  xEE
1A25C:  CLRF   xF0
1A25E:  CLRF   xEF
1A260:  MOVLB  0
1A262:  CALL   4FC8
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A266:  MOVLW  88
1A268:  MOVLB  8
1A26A:  MOVWF  xEE
1A26C:  CLRF   xF0
1A26E:  MOVLW  01
1A270:  MOVWF  xEF
1A272:  MOVLB  0
1A274:  CALL   4FC8
....................    write16(ADDR_M2_MODE,HALF); 
1A278:  MOVLW  8C
1A27A:  MOVLB  8
1A27C:  MOVWF  xEE
1A27E:  CLRF   xF0
1A280:  MOVLW  01
1A282:  MOVWF  xEF
1A284:  MOVLB  0
1A286:  CALL   4FC8
....................    write16(ADDR_M2_STP_INT,5);         // multiply by 100 us 
1A28A:  MOVLW  90
1A28C:  MOVLB  8
1A28E:  MOVWF  xEE
1A290:  CLRF   xF0
1A292:  MOVLW  05
1A294:  MOVWF  xEF
1A296:  MOVLB  0
1A298:  CALL   4FC8
....................    write16(ADDR_M2_POS_DIR,0); 
1A29C:  MOVLW  94
1A29E:  MOVLB  8
1A2A0:  MOVWF  xEE
1A2A2:  CLRF   xF0
1A2A4:  CLRF   xEF
1A2A6:  MOVLB  0
1A2A8:  CALL   4FC8
....................    write16(ADDR_M2_PWM_HLD,0); 
1A2AC:  MOVLW  98
1A2AE:  MOVLB  8
1A2B0:  MOVWF  xEE
1A2B2:  CLRF   xF0
1A2B4:  CLRF   xEF
1A2B6:  MOVLB  0
1A2B8:  CALL   4FC8
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A2BC:  MOVLW  9C
1A2BE:  MOVLB  8
1A2C0:  MOVWF  xEE
1A2C2:  CLRF   xF0
1A2C4:  MOVLW  7F
1A2C6:  MOVWF  xEF
1A2C8:  MOVLB  0
1A2CA:  CALL   4FC8
....................    write16(ADDR_M2_GB_ERR,0); 
1A2CE:  MOVLW  A0
1A2D0:  MOVLB  8
1A2D2:  MOVWF  xEE
1A2D4:  CLRF   xF0
1A2D6:  CLRF   xEF
1A2D8:  MOVLB  0
1A2DA:  CALL   4FC8
....................    write16(ADDR_E2_CPR,0); 
1A2DE:  MOVLW  A4
1A2E0:  MOVLB  8
1A2E2:  MOVWF  xEE
1A2E4:  CLRF   xF0
1A2E6:  CLRF   xEF
1A2E8:  MOVLB  0
1A2EA:  CALL   4FC8
....................    write16(ADDR_E2_PPR,0);   
1A2EE:  MOVLW  A8
1A2F0:  MOVLB  8
1A2F2:  MOVWF  xEE
1A2F4:  CLRF   xF0
1A2F6:  CLRF   xEF
1A2F8:  MOVLB  0
1A2FA:  CALL   4FC8
....................    write16(ADDR_E2_MODE,0); 
1A2FE:  MOVLW  84
1A300:  MOVLB  8
1A302:  MOVWF  xEE
1A304:  CLRF   xF0
1A306:  CLRF   xEF
1A308:  MOVLB  0
1A30A:  CALL   4FC8
....................    write16(ADDR_E2_POS,0); 
1A30E:  MOVLW  80
1A310:  MOVLB  8
1A312:  MOVWF  xEE
1A314:  CLRF   xF0
1A316:  CLRF   xEF
1A318:  MOVLB  0
1A31A:  CALL   4FC8
....................    write16(ADDR_E2_PORT,0); 
1A31E:  MOVLW  AC
1A320:  MOVLB  8
1A322:  MOVWF  xEE
1A324:  CLRF   xF0
1A326:  CLRF   xEF
1A328:  MOVLB  0
1A32A:  CALL   4FC8
....................    write16(ADDR_E2_TYPE,0); 
1A32E:  MOVLW  7C
1A330:  MOVLB  8
1A332:  MOVWF  xEE
1A334:  CLRF   xF0
1A336:  CLRF   xEF
1A338:  MOVLB  0
1A33A:  CALL   4FC8
....................    write16(ADDR_M2_RUN,0); 
1A33E:  MOVLW  78
1A340:  MOVLB  8
1A342:  MOVWF  xEE
1A344:  CLRF   xF0
1A346:  CLRF   xEF
1A348:  MOVLB  0
1A34A:  CALL   4FC8
....................    write16(ADDR_M2_BKLSH,0); 
1A34E:  MOVLW  74
1A350:  MOVLB  8
1A352:  MOVWF  xEE
1A354:  CLRF   xF0
1A356:  CLRF   xEF
1A358:  MOVLB  0
1A35A:  CALL   4FC8
....................    write16(ADDR_M2_ERROR,0);   
1A35E:  MOVLW  70
1A360:  MOVLB  8
1A362:  MOVWF  xEE
1A364:  CLRF   xF0
1A366:  CLRF   xEF
1A368:  MOVLB  0
1A36A:  CALL   4FC8
....................    write16(ADDR_M2_SPR,0); 
1A36E:  MOVLW  B0
1A370:  MOVLB  8
1A372:  MOVWF  xEE
1A374:  CLRF   xF0
1A376:  CLRF   xEF
1A378:  MOVLB  0
1A37A:  CALL   4FC8
....................    write16(ADDR_M2_COMP,0); 
1A37E:  MOVLW  B4
1A380:  MOVLB  8
1A382:  MOVWF  xEE
1A384:  CLRF   xF0
1A386:  CLRF   xEF
1A388:  MOVLB  0
1A38A:  CALL   4FC8
....................    write16(ADDR_M2_LIN_POS,0);    
1A38E:  MOVLW  B8
1A390:  MOVLB  8
1A392:  MOVWF  xEE
1A394:  CLRF   xF0
1A396:  CLRF   xEF
1A398:  MOVLB  0
1A39A:  CALL   4FC8
....................    write16(ADDR_E2_INDEX,0); 
1A39E:  MOVLW  BC
1A3A0:  MOVLB  8
1A3A2:  MOVWF  xEE
1A3A4:  CLRF   xF0
1A3A6:  CLRF   xEF
1A3A8:  MOVLB  0
1A3AA:  CALL   4FC8
....................    write16(ADDR_M2_EVN_SO,0); 
1A3AE:  MOVLW  C0
1A3B0:  MOVLB  8
1A3B2:  MOVWF  xEE
1A3B4:  CLRF   xF0
1A3B6:  CLRF   xEF
1A3B8:  MOVLB  0
1A3BA:  CALL   4FC8
....................    write16(ADDR_M2_ALIGN_OS,0); 
1A3BE:  MOVLW  C4
1A3C0:  MOVLB  8
1A3C2:  MOVWF  xEE
1A3C4:  CLRF   xF0
1A3C6:  CLRF   xEF
1A3C8:  MOVLB  0
1A3CA:  CALL   4FC8
....................     
....................    get_step_vars(); 
1A3CE:  CALL   2D0E
1A3D2:  GOTO   1AC1C (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms4() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A3D6:  MOVLW  86
1A3D8:  MOVLB  8
1A3DA:  MOVWF  xEE
1A3DC:  CLRF   xF0
1A3DE:  MOVLW  01
1A3E0:  MOVWF  xEF
1A3E2:  MOVLB  0
1A3E4:  CALL   4FC8
....................    write16(ADDR_M1_MODE,FULL); 
1A3E8:  MOVLW  8A
1A3EA:  MOVLB  8
1A3EC:  MOVWF  xEE
1A3EE:  CLRF   xF0
1A3F0:  CLRF   xEF
1A3F2:  MOVLB  0
1A3F4:  CALL   4FC8
....................    write16(ADDR_M1_STP_INT,20);        // multiply by 100 us 
1A3F8:  MOVLW  8E
1A3FA:  MOVLB  8
1A3FC:  MOVWF  xEE
1A3FE:  CLRF   xF0
1A400:  MOVLW  14
1A402:  MOVWF  xEF
1A404:  MOVLB  0
1A406:  CALL   4FC8
....................    write16(ADDR_M1_POS_DIR,1); 
1A40A:  MOVLW  92
1A40C:  MOVLB  8
1A40E:  MOVWF  xEE
1A410:  CLRF   xF0
1A412:  MOVLW  01
1A414:  MOVWF  xEF
1A416:  MOVLB  0
1A418:  CALL   4FC8
....................    write16(ADDR_M1_PWM_HLD,51); 
1A41C:  MOVLW  96
1A41E:  MOVLB  8
1A420:  MOVWF  xEE
1A422:  CLRF   xF0
1A424:  MOVLW  33
1A426:  MOVWF  xEF
1A428:  MOVLB  0
1A42A:  CALL   4FC8
....................    write16(ADDR_M1_PWM_DRV,511); 
1A42E:  MOVLW  9A
1A430:  MOVLB  8
1A432:  MOVWF  xEE
1A434:  MOVLW  01
1A436:  MOVWF  xF0
1A438:  SETF   xEF
1A43A:  MOVLB  0
1A43C:  CALL   4FC8
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/24 rev +25% 
1A440:  MOVLW  9E
1A442:  MOVLB  8
1A444:  MOVWF  xEE
1A446:  MOVLW  02
1A448:  MOVWF  xF0
1A44A:  MOVLW  9E
1A44C:  MOVWF  xEF
1A44E:  MOVLB  0
1A450:  CALL   4FC8
....................    write16(ADDR_E1_CPR,24); 
1A454:  MOVLW  A2
1A456:  MOVLB  8
1A458:  MOVWF  xEE
1A45A:  CLRF   xF0
1A45C:  MOVLW  18
1A45E:  MOVWF  xEF
1A460:  MOVLB  0
1A462:  CALL   4FC8
....................    write16(ADDR_E1_PPR,48); 
1A466:  MOVLW  A6
1A468:  MOVLB  8
1A46A:  MOVWF  xEE
1A46C:  CLRF   xF0
1A46E:  MOVLW  30
1A470:  MOVWF  xEF
1A472:  MOVLB  0
1A474:  CALL   4FC8
....................    write16(ADDR_E1_MODE,2); 
1A478:  MOVLW  82
1A47A:  MOVLB  8
1A47C:  MOVWF  xEE
1A47E:  CLRF   xF0
1A480:  MOVLW  02
1A482:  MOVWF  xEF
1A484:  MOVLB  0
1A486:  CALL   4FC8
....................    write16(ADDR_E1_POS,0); 
1A48A:  MOVLW  7E
1A48C:  MOVLB  8
1A48E:  MOVWF  xEE
1A490:  CLRF   xF0
1A492:  CLRF   xEF
1A494:  MOVLB  0
1A496:  CALL   4FC8
....................    write16(ADDR_E1_PORT,0); 
1A49A:  MOVLW  AA
1A49C:  MOVLB  8
1A49E:  MOVWF  xEE
1A4A0:  CLRF   xF0
1A4A2:  CLRF   xEF
1A4A4:  MOVLB  0
1A4A6:  CALL   4FC8
....................    write16(ADDR_E1_TYPE,2); 
1A4AA:  MOVLW  7A
1A4AC:  MOVLB  8
1A4AE:  MOVWF  xEE
1A4B0:  CLRF   xF0
1A4B2:  MOVLW  02
1A4B4:  MOVWF  xEF
1A4B6:  MOVLB  0
1A4B8:  CALL   4FC8
....................    write16(ADDR_M1_RUN,34); 
1A4BC:  MOVLW  76
1A4BE:  MOVLB  8
1A4C0:  MOVWF  xEE
1A4C2:  CLRF   xF0
1A4C4:  MOVLW  22
1A4C6:  MOVWF  xEF
1A4C8:  MOVLB  0
1A4CA:  CALL   4FC8
....................    write16(ADDR_M1_BKLSH,0); 
1A4CE:  MOVLW  72
1A4D0:  MOVLB  8
1A4D2:  MOVWF  xEE
1A4D4:  CLRF   xF0
1A4D6:  CLRF   xEF
1A4D8:  MOVLB  0
1A4DA:  CALL   4FC8
....................    write16(ADDR_M1_ERROR,0);   
1A4DE:  MOVLW  6E
1A4E0:  MOVLB  8
1A4E2:  MOVWF  xEE
1A4E4:  CLRF   xF0
1A4E6:  CLRF   xEF
1A4E8:  MOVLB  0
1A4EA:  CALL   4FC8
....................    write16(ADDR_M1_SPR,6400); 
1A4EE:  MOVLW  AE
1A4F0:  MOVLB  8
1A4F2:  MOVWF  xEE
1A4F4:  MOVLW  19
1A4F6:  MOVWF  xF0
1A4F8:  CLRF   xEF
1A4FA:  MOVLB  0
1A4FC:  CALL   4FC8
....................    write16(ADDR_M1_COMP,0); 
1A500:  MOVLW  B2
1A502:  MOVLB  8
1A504:  MOVWF  xEE
1A506:  CLRF   xF0
1A508:  CLRF   xEF
1A50A:  MOVLB  0
1A50C:  CALL   4FC8
....................    write16(ADDR_M1_LIN_POS,0); 
1A510:  MOVLW  B6
1A512:  MOVLB  8
1A514:  MOVWF  xEE
1A516:  CLRF   xF0
1A518:  CLRF   xEF
1A51A:  MOVLB  0
1A51C:  CALL   4FC8
....................    write16(ADDR_E1_INDEX,1);    
1A520:  MOVLW  BA
1A522:  MOVLB  8
1A524:  MOVWF  xEE
1A526:  CLRF   xF0
1A528:  MOVLW  01
1A52A:  MOVWF  xEF
1A52C:  MOVLB  0
1A52E:  CALL   4FC8
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A532:  MOVLW  88
1A534:  MOVLB  8
1A536:  MOVWF  xEE
1A538:  CLRF   xF0
1A53A:  MOVLW  01
1A53C:  MOVWF  xEF
1A53E:  MOVLB  0
1A540:  CALL   4FC8
....................    write16(ADDR_M2_MODE,HALF); 
1A544:  MOVLW  8C
1A546:  MOVLB  8
1A548:  MOVWF  xEE
1A54A:  CLRF   xF0
1A54C:  MOVLW  01
1A54E:  MOVWF  xEF
1A550:  MOVLB  0
1A552:  CALL   4FC8
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1A556:  MOVLW  90
1A558:  MOVLB  8
1A55A:  MOVWF  xEE
1A55C:  CLRF   xF0
1A55E:  MOVLW  28
1A560:  MOVWF  xEF
1A562:  MOVLB  0
1A564:  CALL   4FC8
....................    write16(ADDR_M2_POS_DIR,0); 
1A568:  MOVLW  94
1A56A:  MOVLB  8
1A56C:  MOVWF  xEE
1A56E:  CLRF   xF0
1A570:  CLRF   xEF
1A572:  MOVLB  0
1A574:  CALL   4FC8
....................    write16(ADDR_M2_PWM_HLD,0); 
1A578:  MOVLW  98
1A57A:  MOVLB  8
1A57C:  MOVWF  xEE
1A57E:  CLRF   xF0
1A580:  CLRF   xEF
1A582:  MOVLB  0
1A584:  CALL   4FC8
....................    write16(ADDR_M2_PWM_DRV,511); 
1A588:  MOVLW  9C
1A58A:  MOVLB  8
1A58C:  MOVWF  xEE
1A58E:  MOVLW  01
1A590:  MOVWF  xF0
1A592:  SETF   xEF
1A594:  MOVLB  0
1A596:  CALL   4FC8
....................    write16(ADDR_M2_GB_ERR,0); 
1A59A:  MOVLW  A0
1A59C:  MOVLB  8
1A59E:  MOVWF  xEE
1A5A0:  CLRF   xF0
1A5A2:  CLRF   xEF
1A5A4:  MOVLB  0
1A5A6:  CALL   4FC8
....................    write16(ADDR_E2_CPR,0); 
1A5AA:  MOVLW  A4
1A5AC:  MOVLB  8
1A5AE:  MOVWF  xEE
1A5B0:  CLRF   xF0
1A5B2:  CLRF   xEF
1A5B4:  MOVLB  0
1A5B6:  CALL   4FC8
....................    write16(ADDR_E2_PPR,0);   
1A5BA:  MOVLW  A8
1A5BC:  MOVLB  8
1A5BE:  MOVWF  xEE
1A5C0:  CLRF   xF0
1A5C2:  CLRF   xEF
1A5C4:  MOVLB  0
1A5C6:  CALL   4FC8
....................    write16(ADDR_E2_MODE,0); 
1A5CA:  MOVLW  84
1A5CC:  MOVLB  8
1A5CE:  MOVWF  xEE
1A5D0:  CLRF   xF0
1A5D2:  CLRF   xEF
1A5D4:  MOVLB  0
1A5D6:  CALL   4FC8
....................    write16(ADDR_E2_POS,0); 
1A5DA:  MOVLW  80
1A5DC:  MOVLB  8
1A5DE:  MOVWF  xEE
1A5E0:  CLRF   xF0
1A5E2:  CLRF   xEF
1A5E4:  MOVLB  0
1A5E6:  CALL   4FC8
....................    write16(ADDR_E2_PORT,0); 
1A5EA:  MOVLW  AC
1A5EC:  MOVLB  8
1A5EE:  MOVWF  xEE
1A5F0:  CLRF   xF0
1A5F2:  CLRF   xEF
1A5F4:  MOVLB  0
1A5F6:  CALL   4FC8
....................    write16(ADDR_E2_TYPE,0); 
1A5FA:  MOVLW  7C
1A5FC:  MOVLB  8
1A5FE:  MOVWF  xEE
1A600:  CLRF   xF0
1A602:  CLRF   xEF
1A604:  MOVLB  0
1A606:  CALL   4FC8
....................    write16(ADDR_M2_RUN,0); 
1A60A:  MOVLW  78
1A60C:  MOVLB  8
1A60E:  MOVWF  xEE
1A610:  CLRF   xF0
1A612:  CLRF   xEF
1A614:  MOVLB  0
1A616:  CALL   4FC8
....................    write16(ADDR_M2_BKLSH,0); 
1A61A:  MOVLW  74
1A61C:  MOVLB  8
1A61E:  MOVWF  xEE
1A620:  CLRF   xF0
1A622:  CLRF   xEF
1A624:  MOVLB  0
1A626:  CALL   4FC8
....................    write16(ADDR_M2_ERROR,0);   
1A62A:  MOVLW  70
1A62C:  MOVLB  8
1A62E:  MOVWF  xEE
1A630:  CLRF   xF0
1A632:  CLRF   xEF
1A634:  MOVLB  0
1A636:  CALL   4FC8
....................    write16(ADDR_M2_SPR,0); 
1A63A:  MOVLW  B0
1A63C:  MOVLB  8
1A63E:  MOVWF  xEE
1A640:  CLRF   xF0
1A642:  CLRF   xEF
1A644:  MOVLB  0
1A646:  CALL   4FC8
....................    write16(ADDR_M2_COMP,0); 
1A64A:  MOVLW  B4
1A64C:  MOVLB  8
1A64E:  MOVWF  xEE
1A650:  CLRF   xF0
1A652:  CLRF   xEF
1A654:  MOVLB  0
1A656:  CALL   4FC8
....................    write16(ADDR_M2_LIN_POS,0);   
1A65A:  MOVLW  B8
1A65C:  MOVLB  8
1A65E:  MOVWF  xEE
1A660:  CLRF   xF0
1A662:  CLRF   xEF
1A664:  MOVLB  0
1A666:  CALL   4FC8
....................    write16(ADDR_E2_INDEX,0);    
1A66A:  MOVLW  BC
1A66C:  MOVLB  8
1A66E:  MOVWF  xEE
1A670:  CLRF   xF0
1A672:  CLRF   xEF
1A674:  MOVLB  0
1A676:  CALL   4FC8
....................     
....................    get_step_vars(); 
1A67A:  CALL   2D0E
1A67E:  GOTO   1AC1C (RETURN)
.................... } 
....................  
.................... void rst_step_vars_aws() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A682:  MOVLW  86
1A684:  MOVLB  8
1A686:  MOVWF  xEE
1A688:  CLRF   xF0
1A68A:  MOVLW  01
1A68C:  MOVWF  xEF
1A68E:  MOVLB  0
1A690:  CALL   4FC8
....................    write16(ADDR_M1_MODE,FULL); 
1A694:  MOVLW  8A
1A696:  MOVLB  8
1A698:  MOVWF  xEE
1A69A:  CLRF   xF0
1A69C:  CLRF   xEF
1A69E:  MOVLB  0
1A6A0:  CALL   4FC8
....................    write16(ADDR_M1_STP_INT,10);        // multiply by 100 us 
1A6A4:  MOVLW  8E
1A6A6:  MOVLB  8
1A6A8:  MOVWF  xEE
1A6AA:  CLRF   xF0
1A6AC:  MOVLW  0A
1A6AE:  MOVWF  xEF
1A6B0:  MOVLB  0
1A6B2:  CALL   4FC8
....................    write16(ADDR_M1_POS_DIR,0); 
1A6B6:  MOVLW  92
1A6B8:  MOVLB  8
1A6BA:  MOVWF  xEE
1A6BC:  CLRF   xF0
1A6BE:  CLRF   xEF
1A6C0:  MOVLB  0
1A6C2:  CALL   4FC8
....................    write16(ADDR_M1_PWM_HLD,0); 
1A6C6:  MOVLW  96
1A6C8:  MOVLB  8
1A6CA:  MOVWF  xEE
1A6CC:  CLRF   xF0
1A6CE:  CLRF   xEF
1A6D0:  MOVLB  0
1A6D2:  CALL   4FC8
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A6D6:  MOVLW  9A
1A6D8:  MOVLB  8
1A6DA:  MOVWF  xEE
1A6DC:  CLRF   xF0
1A6DE:  MOVLW  7F
1A6E0:  MOVWF  xEF
1A6E2:  MOVLB  0
1A6E4:  CALL   4FC8
....................    write16(ADDR_M1_GB_ERR,6000);       // = 1/16 rev +25% 
1A6E8:  MOVLW  9E
1A6EA:  MOVLB  8
1A6EC:  MOVWF  xEE
1A6EE:  MOVLW  17
1A6F0:  MOVWF  xF0
1A6F2:  MOVLW  70
1A6F4:  MOVWF  xEF
1A6F6:  MOVLB  0
1A6F8:  CALL   4FC8
....................    write16(ADDR_E1_CPR,16); 
1A6FC:  MOVLW  A2
1A6FE:  MOVLB  8
1A700:  MOVWF  xEE
1A702:  CLRF   xF0
1A704:  MOVLW  10
1A706:  MOVWF  xEF
1A708:  MOVLB  0
1A70A:  CALL   4FC8
....................    write16(ADDR_E1_PPR,16); 
1A70E:  MOVLW  A6
1A710:  MOVLB  8
1A712:  MOVWF  xEE
1A714:  CLRF   xF0
1A716:  MOVLW  10
1A718:  MOVWF  xEF
1A71A:  MOVLB  0
1A71C:  CALL   4FC8
....................    write16(ADDR_E1_MODE,2); 
1A720:  MOVLW  82
1A722:  MOVLB  8
1A724:  MOVWF  xEE
1A726:  CLRF   xF0
1A728:  MOVLW  02
1A72A:  MOVWF  xEF
1A72C:  MOVLB  0
1A72E:  CALL   4FC8
....................    write16(ADDR_E1_POS,0); 
1A732:  MOVLW  7E
1A734:  MOVLB  8
1A736:  MOVWF  xEE
1A738:  CLRF   xF0
1A73A:  CLRF   xEF
1A73C:  MOVLB  0
1A73E:  CALL   4FC8
....................    write16(ADDR_E1_PORT,0); 
1A742:  MOVLW  AA
1A744:  MOVLB  8
1A746:  MOVWF  xEE
1A748:  CLRF   xF0
1A74A:  CLRF   xEF
1A74C:  MOVLB  0
1A74E:  CALL   4FC8
....................    write16(ADDR_E1_TYPE,2); 
1A752:  MOVLW  7A
1A754:  MOVLB  8
1A756:  MOVWF  xEE
1A758:  CLRF   xF0
1A75A:  MOVLW  02
1A75C:  MOVWF  xEF
1A75E:  MOVLB  0
1A760:  CALL   4FC8
....................    write16(ADDR_M1_RUN,270); 
1A764:  MOVLW  76
1A766:  MOVLB  8
1A768:  MOVWF  xEE
1A76A:  MOVLW  01
1A76C:  MOVWF  xF0
1A76E:  MOVLW  0E
1A770:  MOVWF  xEF
1A772:  MOVLB  0
1A774:  CALL   4FC8
....................    write16(ADDR_M1_BKLSH,0); 
1A778:  MOVLW  72
1A77A:  MOVLB  8
1A77C:  MOVWF  xEE
1A77E:  CLRF   xF0
1A780:  CLRF   xEF
1A782:  MOVLB  0
1A784:  CALL   4FC8
....................    write16(ADDR_M1_ERROR,0);   
1A788:  MOVLW  6E
1A78A:  MOVLB  8
1A78C:  MOVWF  xEE
1A78E:  CLRF   xF0
1A790:  CLRF   xEF
1A792:  MOVLB  0
1A794:  CALL   4FC8
....................    write16(ADDR_M1_SPR,38400); 
1A798:  MOVLW  AE
1A79A:  MOVLB  8
1A79C:  MOVWF  xEE
1A79E:  MOVLW  96
1A7A0:  MOVWF  xF0
1A7A2:  CLRF   xEF
1A7A4:  MOVLB  0
1A7A6:  CALL   4FC8
....................    write16(ADDR_M1_COMP,0); 
1A7AA:  MOVLW  B2
1A7AC:  MOVLB  8
1A7AE:  MOVWF  xEE
1A7B0:  CLRF   xF0
1A7B2:  CLRF   xEF
1A7B4:  MOVLB  0
1A7B6:  CALL   4FC8
....................    write16(ADDR_M1_LIN_POS,0); 
1A7BA:  MOVLW  B6
1A7BC:  MOVLB  8
1A7BE:  MOVWF  xEE
1A7C0:  CLRF   xF0
1A7C2:  CLRF   xEF
1A7C4:  MOVLB  0
1A7C6:  CALL   4FC8
....................    write16(ADDR_E1_INDEX,1); 
1A7CA:  MOVLW  BA
1A7CC:  MOVLB  8
1A7CE:  MOVWF  xEE
1A7D0:  CLRF   xF0
1A7D2:  MOVLW  01
1A7D4:  MOVWF  xEF
1A7D6:  MOVLB  0
1A7D8:  CALL   4FC8
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1A7DC:  MOVLW  88
1A7DE:  MOVLB  8
1A7E0:  MOVWF  xEE
1A7E2:  CLRF   xF0
1A7E4:  MOVLW  01
1A7E6:  MOVWF  xEF
1A7E8:  MOVLB  0
1A7EA:  CALL   4FC8
....................    write16(ADDR_M2_MODE,HALF); 
1A7EE:  MOVLW  8C
1A7F0:  MOVLB  8
1A7F2:  MOVWF  xEE
1A7F4:  CLRF   xF0
1A7F6:  MOVLW  01
1A7F8:  MOVWF  xEF
1A7FA:  MOVLB  0
1A7FC:  CALL   4FC8
....................    write16(ADDR_M2_STP_INT,100);         // multiply by 100 us 
1A800:  MOVLW  90
1A802:  MOVLB  8
1A804:  MOVWF  xEE
1A806:  CLRF   xF0
1A808:  MOVLW  64
1A80A:  MOVWF  xEF
1A80C:  MOVLB  0
1A80E:  CALL   4FC8
....................    write16(ADDR_M2_POS_DIR,0); 
1A812:  MOVLW  94
1A814:  MOVLB  8
1A816:  MOVWF  xEE
1A818:  CLRF   xF0
1A81A:  CLRF   xEF
1A81C:  MOVLB  0
1A81E:  CALL   4FC8
....................    write16(ADDR_M2_PWM_HLD,0); 
1A822:  MOVLW  98
1A824:  MOVLB  8
1A826:  MOVWF  xEE
1A828:  CLRF   xF0
1A82A:  CLRF   xEF
1A82C:  MOVLB  0
1A82E:  CALL   4FC8
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1A832:  MOVLW  9C
1A834:  MOVLB  8
1A836:  MOVWF  xEE
1A838:  CLRF   xF0
1A83A:  MOVLW  7F
1A83C:  MOVWF  xEF
1A83E:  MOVLB  0
1A840:  CALL   4FC8
....................    write16(ADDR_M2_GB_ERR,0); 
1A844:  MOVLW  A0
1A846:  MOVLB  8
1A848:  MOVWF  xEE
1A84A:  CLRF   xF0
1A84C:  CLRF   xEF
1A84E:  MOVLB  0
1A850:  CALL   4FC8
....................    write16(ADDR_E2_CPR,0); 
1A854:  MOVLW  A4
1A856:  MOVLB  8
1A858:  MOVWF  xEE
1A85A:  CLRF   xF0
1A85C:  CLRF   xEF
1A85E:  MOVLB  0
1A860:  CALL   4FC8
....................    write16(ADDR_E2_PPR,0);   
1A864:  MOVLW  A8
1A866:  MOVLB  8
1A868:  MOVWF  xEE
1A86A:  CLRF   xF0
1A86C:  CLRF   xEF
1A86E:  MOVLB  0
1A870:  CALL   4FC8
....................    write16(ADDR_E2_MODE,0); 
1A874:  MOVLW  84
1A876:  MOVLB  8
1A878:  MOVWF  xEE
1A87A:  CLRF   xF0
1A87C:  CLRF   xEF
1A87E:  MOVLB  0
1A880:  CALL   4FC8
....................    write16(ADDR_E2_POS,0); 
1A884:  MOVLW  80
1A886:  MOVLB  8
1A888:  MOVWF  xEE
1A88A:  CLRF   xF0
1A88C:  CLRF   xEF
1A88E:  MOVLB  0
1A890:  CALL   4FC8
....................    write16(ADDR_E2_PORT,0); 
1A894:  MOVLW  AC
1A896:  MOVLB  8
1A898:  MOVWF  xEE
1A89A:  CLRF   xF0
1A89C:  CLRF   xEF
1A89E:  MOVLB  0
1A8A0:  CALL   4FC8
....................    write16(ADDR_E2_TYPE,0); 
1A8A4:  MOVLW  7C
1A8A6:  MOVLB  8
1A8A8:  MOVWF  xEE
1A8AA:  CLRF   xF0
1A8AC:  CLRF   xEF
1A8AE:  MOVLB  0
1A8B0:  CALL   4FC8
....................    write16(ADDR_M2_RUN,0); 
1A8B4:  MOVLW  78
1A8B6:  MOVLB  8
1A8B8:  MOVWF  xEE
1A8BA:  CLRF   xF0
1A8BC:  CLRF   xEF
1A8BE:  MOVLB  0
1A8C0:  CALL   4FC8
....................    write16(ADDR_M2_BKLSH,0); 
1A8C4:  MOVLW  74
1A8C6:  MOVLB  8
1A8C8:  MOVWF  xEE
1A8CA:  CLRF   xF0
1A8CC:  CLRF   xEF
1A8CE:  MOVLB  0
1A8D0:  CALL   4FC8
....................    write16(ADDR_M2_ERROR,0);   
1A8D4:  MOVLW  70
1A8D6:  MOVLB  8
1A8D8:  MOVWF  xEE
1A8DA:  CLRF   xF0
1A8DC:  CLRF   xEF
1A8DE:  MOVLB  0
1A8E0:  CALL   4FC8
....................    write16(ADDR_M2_SPR,0); 
1A8E4:  MOVLW  B0
1A8E6:  MOVLB  8
1A8E8:  MOVWF  xEE
1A8EA:  CLRF   xF0
1A8EC:  CLRF   xEF
1A8EE:  MOVLB  0
1A8F0:  CALL   4FC8
....................    write16(ADDR_M2_COMP,0); 
1A8F4:  MOVLW  B4
1A8F6:  MOVLB  8
1A8F8:  MOVWF  xEE
1A8FA:  CLRF   xF0
1A8FC:  CLRF   xEF
1A8FE:  MOVLB  0
1A900:  CALL   4FC8
....................    write16(ADDR_M2_LIN_POS,0);    
1A904:  MOVLW  B8
1A906:  MOVLB  8
1A908:  MOVWF  xEE
1A90A:  CLRF   xF0
1A90C:  CLRF   xEF
1A90E:  MOVLB  0
1A910:  CALL   4FC8
....................     
....................    get_step_vars(); 
1A914:  CALL   2D0E
1A918:  GOTO   1AC1C (RETURN)
.................... } 
....................  
.................... void rst_step_vars_wms2() 
.................... { 
....................    write16(ADDR_M1_CTRL,SLOW); 
1A91C:  MOVLW  86
1A91E:  MOVLB  8
1A920:  MOVWF  xEE
1A922:  CLRF   xF0
1A924:  MOVLW  01
1A926:  MOVWF  xEF
1A928:  MOVLB  0
1A92A:  CALL   4FC8
....................    write16(ADDR_M1_MODE,FULL); 
1A92E:  MOVLW  8A
1A930:  MOVLB  8
1A932:  MOVWF  xEE
1A934:  CLRF   xF0
1A936:  CLRF   xEF
1A938:  MOVLB  0
1A93A:  CALL   4FC8
....................    write16(ADDR_M1_STP_INT,40);        // multiply by 100 us 
1A93E:  MOVLW  8E
1A940:  MOVLB  8
1A942:  MOVWF  xEE
1A944:  CLRF   xF0
1A946:  MOVLW  28
1A948:  MOVWF  xEF
1A94A:  MOVLB  0
1A94C:  CALL   4FC8
....................    write16(ADDR_M1_POS_DIR,1); 
1A950:  MOVLW  92
1A952:  MOVLB  8
1A954:  MOVWF  xEE
1A956:  CLRF   xF0
1A958:  MOVLW  01
1A95A:  MOVWF  xEF
1A95C:  MOVLB  0
1A95E:  CALL   4FC8
....................    write16(ADDR_M1_PWM_HLD,0); 
1A962:  MOVLW  96
1A964:  MOVLB  8
1A966:  MOVWF  xEE
1A968:  CLRF   xF0
1A96A:  CLRF   xEF
1A96C:  MOVLB  0
1A96E:  CALL   4FC8
....................    write16(ADDR_M1_PWM_DRV,T2_MID_VAL); 
1A972:  MOVLW  9A
1A974:  MOVLB  8
1A976:  MOVWF  xEE
1A978:  CLRF   xF0
1A97A:  MOVLW  7F
1A97C:  MOVWF  xEF
1A97E:  MOVLB  0
1A980:  CALL   4FC8
....................    write16(ADDR_M1_GB_ERR,670);       // = 1/16 rev +25% 
1A984:  MOVLW  9E
1A986:  MOVLB  8
1A988:  MOVWF  xEE
1A98A:  MOVLW  02
1A98C:  MOVWF  xF0
1A98E:  MOVLW  9E
1A990:  MOVWF  xEF
1A992:  MOVLB  0
1A994:  CALL   4FC8
....................    write16(ADDR_E1_CPR,500); 
1A998:  MOVLW  A2
1A99A:  MOVLB  8
1A99C:  MOVWF  xEE
1A99E:  MOVLW  01
1A9A0:  MOVWF  xF0
1A9A2:  MOVLW  F4
1A9A4:  MOVWF  xEF
1A9A6:  MOVLB  0
1A9A8:  CALL   4FC8
....................    write16(ADDR_E1_PPR,50); 
1A9AC:  MOVLW  A6
1A9AE:  MOVLB  8
1A9B0:  MOVWF  xEE
1A9B2:  CLRF   xF0
1A9B4:  MOVLW  32
1A9B6:  MOVWF  xEF
1A9B8:  MOVLB  0
1A9BA:  CALL   4FC8
....................    write16(ADDR_E1_MODE,2); 
1A9BE:  MOVLW  82
1A9C0:  MOVLB  8
1A9C2:  MOVWF  xEE
1A9C4:  CLRF   xF0
1A9C6:  MOVLW  02
1A9C8:  MOVWF  xEF
1A9CA:  MOVLB  0
1A9CC:  CALL   4FC8
....................    write16(ADDR_E1_POS,0); 
1A9D0:  MOVLW  7E
1A9D2:  MOVLB  8
1A9D4:  MOVWF  xEE
1A9D6:  CLRF   xF0
1A9D8:  CLRF   xEF
1A9DA:  MOVLB  0
1A9DC:  CALL   4FC8
....................    write16(ADDR_E1_PORT,0); 
1A9E0:  MOVLW  AA
1A9E2:  MOVLB  8
1A9E4:  MOVWF  xEE
1A9E6:  CLRF   xF0
1A9E8:  CLRF   xEF
1A9EA:  MOVLB  0
1A9EC:  CALL   4FC8
....................    write16(ADDR_E1_TYPE,1); 
1A9F0:  MOVLW  7A
1A9F2:  MOVLB  8
1A9F4:  MOVWF  xEE
1A9F6:  CLRF   xF0
1A9F8:  MOVLW  01
1A9FA:  MOVWF  xEF
1A9FC:  MOVLB  0
1A9FE:  CALL   4FC8
....................    write16(ADDR_M1_RUN,0); 
1AA02:  MOVLW  76
1AA04:  MOVLB  8
1AA06:  MOVWF  xEE
1AA08:  CLRF   xF0
1AA0A:  CLRF   xEF
1AA0C:  MOVLB  0
1AA0E:  CALL   4FC8
....................    write16(ADDR_M1_BKLSH,1300); 
1AA12:  MOVLW  72
1AA14:  MOVLB  8
1AA16:  MOVWF  xEE
1AA18:  MOVLW  05
1AA1A:  MOVWF  xF0
1AA1C:  MOVLW  14
1AA1E:  MOVWF  xEF
1AA20:  MOVLB  0
1AA22:  CALL   4FC8
....................    write16(ADDR_M1_ERROR,0);   
1AA26:  MOVLW  6E
1AA28:  MOVLB  8
1AA2A:  MOVWF  xEE
1AA2C:  CLRF   xF0
1AA2E:  CLRF   xEF
1AA30:  MOVLB  0
1AA32:  CALL   4FC8
....................    write16(ADDR_M1_SPR,20000); 
1AA36:  MOVLW  AE
1AA38:  MOVLB  8
1AA3A:  MOVWF  xEE
1AA3C:  MOVLW  4E
1AA3E:  MOVWF  xF0
1AA40:  MOVLW  20
1AA42:  MOVWF  xEF
1AA44:  MOVLB  0
1AA46:  CALL   4FC8
....................    write16(ADDR_M1_COMP,0); 
1AA4A:  MOVLW  B2
1AA4C:  MOVLB  8
1AA4E:  MOVWF  xEE
1AA50:  CLRF   xF0
1AA52:  CLRF   xEF
1AA54:  MOVLB  0
1AA56:  CALL   4FC8
....................    write16(ADDR_M1_LIN_POS,0); 
1AA5A:  MOVLW  B6
1AA5C:  MOVLB  8
1AA5E:  MOVWF  xEE
1AA60:  CLRF   xF0
1AA62:  CLRF   xEF
1AA64:  MOVLB  0
1AA66:  CALL   4FC8
....................    write16(ADDR_E1_INDEX,0); 
1AA6A:  MOVLW  BA
1AA6C:  MOVLB  8
1AA6E:  MOVWF  xEE
1AA70:  CLRF   xF0
1AA72:  CLRF   xEF
1AA74:  MOVLB  0
1AA76:  CALL   4FC8
....................     
....................    write16(ADDR_M2_CTRL,SLOW); 
1AA7A:  MOVLW  88
1AA7C:  MOVLB  8
1AA7E:  MOVWF  xEE
1AA80:  CLRF   xF0
1AA82:  MOVLW  01
1AA84:  MOVWF  xEF
1AA86:  MOVLB  0
1AA88:  CALL   4FC8
....................    write16(ADDR_M2_MODE,HALF); 
1AA8C:  MOVLW  8C
1AA8E:  MOVLB  8
1AA90:  MOVWF  xEE
1AA92:  CLRF   xF0
1AA94:  MOVLW  01
1AA96:  MOVWF  xEF
1AA98:  MOVLB  0
1AA9A:  CALL   4FC8
....................    write16(ADDR_M2_STP_INT,40);         // multiply by 100 us 
1AA9E:  MOVLW  90
1AAA0:  MOVLB  8
1AAA2:  MOVWF  xEE
1AAA4:  CLRF   xF0
1AAA6:  MOVLW  28
1AAA8:  MOVWF  xEF
1AAAA:  MOVLB  0
1AAAC:  CALL   4FC8
....................    write16(ADDR_M2_POS_DIR,1); 
1AAB0:  MOVLW  94
1AAB2:  MOVLB  8
1AAB4:  MOVWF  xEE
1AAB6:  CLRF   xF0
1AAB8:  MOVLW  01
1AABA:  MOVWF  xEF
1AABC:  MOVLB  0
1AABE:  CALL   4FC8
....................    write16(ADDR_M2_PWM_HLD,0); 
1AAC2:  MOVLW  98
1AAC4:  MOVLB  8
1AAC6:  MOVWF  xEE
1AAC8:  CLRF   xF0
1AACA:  CLRF   xEF
1AACC:  MOVLB  0
1AACE:  CALL   4FC8
....................    write16(ADDR_M2_PWM_DRV,T2_MID_VAL); 
1AAD2:  MOVLW  9C
1AAD4:  MOVLB  8
1AAD6:  MOVWF  xEE
1AAD8:  CLRF   xF0
1AADA:  MOVLW  7F
1AADC:  MOVWF  xEF
1AADE:  MOVLB  0
1AAE0:  CALL   4FC8
....................    write16(ADDR_M2_GB_ERR,0); 
1AAE4:  MOVLW  A0
1AAE6:  MOVLB  8
1AAE8:  MOVWF  xEE
1AAEA:  CLRF   xF0
1AAEC:  CLRF   xEF
1AAEE:  MOVLB  0
1AAF0:  CALL   4FC8
....................    write16(ADDR_E2_CPR,0); 
1AAF4:  MOVLW  A4
1AAF6:  MOVLB  8
1AAF8:  MOVWF  xEE
1AAFA:  CLRF   xF0
1AAFC:  CLRF   xEF
1AAFE:  MOVLB  0
1AB00:  CALL   4FC8
....................    write16(ADDR_E2_PPR,0);   
1AB04:  MOVLW  A8
1AB06:  MOVLB  8
1AB08:  MOVWF  xEE
1AB0A:  CLRF   xF0
1AB0C:  CLRF   xEF
1AB0E:  MOVLB  0
1AB10:  CALL   4FC8
....................    write16(ADDR_E2_MODE,0); 
1AB14:  MOVLW  84
1AB16:  MOVLB  8
1AB18:  MOVWF  xEE
1AB1A:  CLRF   xF0
1AB1C:  CLRF   xEF
1AB1E:  MOVLB  0
1AB20:  CALL   4FC8
....................    write16(ADDR_E2_POS,0); 
1AB24:  MOVLW  80
1AB26:  MOVLB  8
1AB28:  MOVWF  xEE
1AB2A:  CLRF   xF0
1AB2C:  CLRF   xEF
1AB2E:  MOVLB  0
1AB30:  CALL   4FC8
....................    write16(ADDR_E2_PORT,0); 
1AB34:  MOVLW  AC
1AB36:  MOVLB  8
1AB38:  MOVWF  xEE
1AB3A:  CLRF   xF0
1AB3C:  CLRF   xEF
1AB3E:  MOVLB  0
1AB40:  CALL   4FC8
....................    write16(ADDR_E2_TYPE,0); 
1AB44:  MOVLW  7C
1AB46:  MOVLB  8
1AB48:  MOVWF  xEE
1AB4A:  CLRF   xF0
1AB4C:  CLRF   xEF
1AB4E:  MOVLB  0
1AB50:  CALL   4FC8
....................    write16(ADDR_M2_RUN,0); 
1AB54:  MOVLW  78
1AB56:  MOVLB  8
1AB58:  MOVWF  xEE
1AB5A:  CLRF   xF0
1AB5C:  CLRF   xEF
1AB5E:  MOVLB  0
1AB60:  CALL   4FC8
....................    write16(ADDR_M2_BKLSH,0); 
1AB64:  MOVLW  74
1AB66:  MOVLB  8
1AB68:  MOVWF  xEE
1AB6A:  CLRF   xF0
1AB6C:  CLRF   xEF
1AB6E:  MOVLB  0
1AB70:  CALL   4FC8
....................    write16(ADDR_M2_ERROR,0);   
1AB74:  MOVLW  70
1AB76:  MOVLB  8
1AB78:  MOVWF  xEE
1AB7A:  CLRF   xF0
1AB7C:  CLRF   xEF
1AB7E:  MOVLB  0
1AB80:  CALL   4FC8
....................    write16(ADDR_M2_SPR,0); 
1AB84:  MOVLW  B0
1AB86:  MOVLB  8
1AB88:  MOVWF  xEE
1AB8A:  CLRF   xF0
1AB8C:  CLRF   xEF
1AB8E:  MOVLB  0
1AB90:  CALL   4FC8
....................    write16(ADDR_M2_COMP,0); 
1AB94:  MOVLW  B4
1AB96:  MOVLB  8
1AB98:  MOVWF  xEE
1AB9A:  CLRF   xF0
1AB9C:  CLRF   xEF
1AB9E:  MOVLB  0
1ABA0:  CALL   4FC8
....................    write16(ADDR_M2_LIN_POS,0);    
1ABA4:  MOVLW  B8
1ABA6:  MOVLB  8
1ABA8:  MOVWF  xEE
1ABAA:  CLRF   xF0
1ABAC:  CLRF   xEF
1ABAE:  MOVLB  0
1ABB0:  CALL   4FC8
....................    write16(ADDR_E2_INDEX,0); 
1ABB4:  MOVLW  BC
1ABB6:  MOVLB  8
1ABB8:  MOVWF  xEE
1ABBA:  CLRF   xF0
1ABBC:  CLRF   xEF
1ABBE:  MOVLB  0
1ABC0:  CALL   4FC8
....................     
....................    get_step_vars(); 
1ABC4:  CALL   2D0E
1ABC8:  GOTO   1AC1C (RETURN)
.................... } 
....................  
.................... void motor_sleep_rdy() 
.................... { 
....................    output_bit(M1_RESET,OFF); 
*
0298C:  BCF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
0298E:  BCF    F90.1
....................    output_bit(M1_CONTROL, OFF); 
02990:  BCF    F90.2
....................    output_bit(M1_STEPMODE, OFF); 
02992:  BCF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
02994:  BCF    F90.4
....................    output_bit(M1_DIR, OFF); 
02996:  BCF    F90.5
....................    set_pwm1_duty(0);    
02998:  CLRF   FBC
....................     
....................    output_bit(M2_RESET,OFF); 
0299A:  BCF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
0299C:  BCF    F8D.1
....................    output_bit(M2_CONTROL, OFF); 
0299E:  BCF    F8D.2
....................    output_bit(M2_STEPMODE, OFF); 
029A0:  BCF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
029A2:  BCF    F8D.4
....................    output_bit(M2_DIR, OFF); 
029A4:  BCF    F8D.5
....................    set_pwm2_duty(0);  
029A6:  MOVLB  F
029A8:  CLRF   x4F
....................  
....................    output_low(VENC1); 
029AA:  BCF    F8E.6
....................    output_low(VENC2);         
029AC:  BCF    F8E.7
....................    output_low(VHBRDG); 
029AE:  BCF    F8E.2
029B0:  MOVLB  0
029B2:  RETURN 0
.................... } 
....................  
.................... /* 
....................    SB4222-048-008-04 
....................     
....................    Step angle = 7.5 deg >> 360/7.5 = 48 steps / rev 
....................     
....................    Kloen Valve 
....................    Gearbox = 60:1 >> 48 * 60 = 2880 (full step / m_mode = 0) 
....................    Gearbox = 60:1 >> 48 * 60 * 4 = 11520 (half step / m_mode = 1) 
....................     
....................    Omnifit Valve 
....................    Gearbox = 800:1 >> 48 * 800 = 38400 (full step / m_mode = 0) 
....................    Gearbox = 800:1 >> 48 * 800 * 4 = 153600 (half step / m_mode = 1) 
....................     
....................    HEDS encoder CPR = 500 
.................... */ 
....................  
.................... void update_e_pos() 
.................... { 
....................    if (m_pos_dir[motor]==POS){ 
*
0124E:  BCF    FD8.0
01250:  MOVLB  7
01252:  RLCF   x40,W
01254:  CLRF   03
01256:  ADDLW  4E
01258:  MOVWF  FE9
0125A:  MOVLW  07
0125C:  ADDWFC 03,W
0125E:  MOVWF  FEA
01260:  MOVFF  FEC,A38
01264:  MOVF   FED,F
01266:  MOVFF  FEF,A37
0126A:  MOVLB  A
0126C:  MOVF   x37,F
0126E:  BTFSS  FD8.2
01270:  BRA    13F8
01272:  MOVF   x38,F
01274:  BTFSS  FD8.2
01276:  BRA    13F8
....................       if(m_way[motor]==POS) { 
01278:  BCF    FD8.0
0127A:  MOVLB  7
0127C:  RLCF   x40,W
0127E:  CLRF   03
01280:  ADDLW  86
01282:  MOVWF  FE9
01284:  MOVLW  07
01286:  ADDWFC 03,W
01288:  MOVWF  FEA
0128A:  MOVFF  FEC,A38
0128E:  MOVF   FED,F
01290:  MOVFF  FEF,A37
01294:  MOVLB  A
01296:  MOVF   x37,F
01298:  BNZ   1332
0129A:  MOVF   x38,F
0129C:  BNZ   1332
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
0129E:  BCF    FD8.0
012A0:  MOVLB  7
012A2:  RLCF   x40,W
012A4:  CLRF   03
012A6:  ADDLW  BF
012A8:  MOVWF  FE9
012AA:  MOVLW  07
012AC:  ADDWFC 03,W
012AE:  MOVWF  FEA
012B0:  MOVFF  FEC,A38
012B4:  MOVF   FED,F
012B6:  MOVFF  FEF,A37
012BA:  BCF    FD8.0
012BC:  RLCF   x40,W
012BE:  CLRF   03
012C0:  ADDLW  5E
012C2:  MOVWF  FE9
012C4:  MOVLW  07
012C6:  ADDWFC 03,W
012C8:  MOVWF  FEA
012CA:  MOVFF  FEC,03
012CE:  MOVF   FED,F
012D0:  MOVFF  FEF,01
012D4:  MOVF   03,W
012D6:  MOVLB  A
012D8:  SUBWF  x38,W
012DA:  BNC   12FE
012DC:  BNZ   12E4
012DE:  MOVF   01,W
012E0:  SUBWF  x37,W
012E2:  BNC   12FE
012E4:  BCF    FD8.0
012E6:  MOVLB  7
012E8:  RLCF   x40,W
012EA:  CLRF   03
012EC:  ADDLW  BF
012EE:  MOVWF  FE9
012F0:  MOVLW  07
012F2:  ADDWFC 03,W
012F4:  MOVWF  FEA
012F6:  CLRF   FEC
012F8:  MOVF   FED,F
012FA:  CLRF   FEF
012FC:  MOVLB  A
....................          e_pos[motor]++; 
012FE:  BCF    FD8.0
01300:  MOVLB  7
01302:  RLCF   x40,W
01304:  CLRF   03
01306:  ADDLW  BF
01308:  MOVWF  FE9
0130A:  MOVLW  07
0130C:  ADDWFC 03,W
0130E:  MOVWF  FEA
01310:  MOVLW  01
01312:  ADDWF  FEE,F
01314:  BNC   1318
01316:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
01318:  BCF    FD8.0
0131A:  RLCF   x40,W
0131C:  CLRF   03
0131E:  ADDLW  9A
01320:  MOVWF  FE9
01322:  MOVLW  07
01324:  ADDWFC 03,W
01326:  MOVWF  FEA
01328:  CLRF   FEC
0132A:  MOVF   FED,F
0132C:  CLRF   FEF
....................       } 
0132E:  BRA    13F6
01330:  MOVLB  A
....................       else if(m_way[motor]==NEG) { 
01332:  BCF    FD8.0
01334:  MOVLB  7
01336:  RLCF   x40,W
01338:  CLRF   03
0133A:  ADDLW  86
0133C:  MOVWF  FE9
0133E:  MOVLW  07
01340:  ADDWFC 03,W
01342:  MOVWF  FEA
01344:  MOVFF  FEC,A38
01348:  MOVF   FED,F
0134A:  MOVFF  FEF,A37
0134E:  MOVLB  A
01350:  DECFSZ x37,W
01352:  BRA    13F8
01354:  MOVF   x38,F
01356:  BNZ   13F8
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01358:  BCF    FD8.0
0135A:  MOVLB  7
0135C:  RLCF   x40,W
0135E:  CLRF   03
01360:  ADDLW  BF
01362:  MOVWF  FE9
01364:  MOVLW  07
01366:  ADDWFC 03,W
01368:  MOVWF  FEA
0136A:  MOVFF  FEC,A38
0136E:  MOVF   FED,F
01370:  MOVFF  FEF,A37
01374:  MOVLB  A
01376:  MOVF   x37,F
01378:  BNZ   13C4
0137A:  MOVF   x38,F
0137C:  BNZ   13C4
0137E:  BCF    FD8.0
01380:  MOVLB  7
01382:  RLCF   x40,W
01384:  CLRF   03
01386:  ADDLW  BF
01388:  MOVWF  01
0138A:  MOVLW  07
0138C:  ADDWFC 03,F
0138E:  MOVLB  A
01390:  MOVFF  03,A38
01394:  BCF    FD8.0
01396:  MOVLB  7
01398:  RLCF   x40,W
0139A:  CLRF   03
0139C:  ADDLW  5E
0139E:  MOVWF  FE9
013A0:  MOVLW  07
013A2:  ADDWFC 03,W
013A4:  MOVWF  FEA
013A6:  MOVFF  FEC,03
013AA:  MOVF   FED,F
013AC:  MOVFF  FEF,A39
013B0:  MOVLB  A
013B2:  MOVFF  A38,FEA
013B6:  MOVFF  01,FE9
013BA:  MOVFF  03,FEC
013BE:  MOVF   FED,F
013C0:  MOVFF  A39,FEF
....................          e_pos[motor]--; 
013C4:  BCF    FD8.0
013C6:  MOVLB  7
013C8:  RLCF   x40,W
013CA:  CLRF   03
013CC:  ADDLW  BF
013CE:  MOVWF  FE9
013D0:  MOVLW  07
013D2:  ADDWFC 03,W
013D4:  MOVWF  FEA
013D6:  MOVLW  FF
013D8:  ADDWF  FEF,F
013DA:  BC    13E0
013DC:  MOVF   FEE,F
013DE:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
013E0:  BCF    FD8.0
013E2:  RLCF   x40,W
013E4:  CLRF   03
013E6:  ADDLW  9A
013E8:  MOVWF  FE9
013EA:  MOVLW  07
013EC:  ADDWFC 03,W
013EE:  MOVWF  FEA
013F0:  CLRF   FEC
013F2:  MOVF   FED,F
013F4:  CLRF   FEF
013F6:  MOVLB  A
....................       } 
....................    } 
....................     
....................    if (m_pos_dir[motor]==NEG){ 
013F8:  BCF    FD8.0
013FA:  MOVLB  7
013FC:  RLCF   x40,W
013FE:  CLRF   03
01400:  ADDLW  4E
01402:  MOVWF  FE9
01404:  MOVLW  07
01406:  ADDWFC 03,W
01408:  MOVWF  FEA
0140A:  MOVFF  FEC,A38
0140E:  MOVF   FED,F
01410:  MOVFF  FEF,A37
01414:  MOVLB  A
01416:  DECFSZ x37,W
01418:  BRA    15A0
0141A:  MOVF   x38,F
0141C:  BTFSS  FD8.2
0141E:  BRA    15A0
....................       if(m_way[motor]==NEG) { 
01420:  BCF    FD8.0
01422:  MOVLB  7
01424:  RLCF   x40,W
01426:  CLRF   03
01428:  ADDLW  86
0142A:  MOVWF  FE9
0142C:  MOVLW  07
0142E:  ADDWFC 03,W
01430:  MOVWF  FEA
01432:  MOVFF  FEC,A38
01436:  MOVF   FED,F
01438:  MOVFF  FEF,A37
0143C:  MOVLB  A
0143E:  DECFSZ x37,W
01440:  BRA    14DA
01442:  MOVF   x38,F
01444:  BNZ   14DA
....................          if (e_pos[motor]>=e_cpr[motor]) e_pos[motor]=0; 
01446:  BCF    FD8.0
01448:  MOVLB  7
0144A:  RLCF   x40,W
0144C:  CLRF   03
0144E:  ADDLW  BF
01450:  MOVWF  FE9
01452:  MOVLW  07
01454:  ADDWFC 03,W
01456:  MOVWF  FEA
01458:  MOVFF  FEC,A38
0145C:  MOVF   FED,F
0145E:  MOVFF  FEF,A37
01462:  BCF    FD8.0
01464:  RLCF   x40,W
01466:  CLRF   03
01468:  ADDLW  5E
0146A:  MOVWF  FE9
0146C:  MOVLW  07
0146E:  ADDWFC 03,W
01470:  MOVWF  FEA
01472:  MOVFF  FEC,03
01476:  MOVF   FED,F
01478:  MOVFF  FEF,01
0147C:  MOVF   03,W
0147E:  MOVLB  A
01480:  SUBWF  x38,W
01482:  BNC   14A6
01484:  BNZ   148C
01486:  MOVF   01,W
01488:  SUBWF  x37,W
0148A:  BNC   14A6
0148C:  BCF    FD8.0
0148E:  MOVLB  7
01490:  RLCF   x40,W
01492:  CLRF   03
01494:  ADDLW  BF
01496:  MOVWF  FE9
01498:  MOVLW  07
0149A:  ADDWFC 03,W
0149C:  MOVWF  FEA
0149E:  CLRF   FEC
014A0:  MOVF   FED,F
014A2:  CLRF   FEF
014A4:  MOVLB  A
....................          e_pos[motor]++; 
014A6:  BCF    FD8.0
014A8:  MOVLB  7
014AA:  RLCF   x40,W
014AC:  CLRF   03
014AE:  ADDLW  BF
014B0:  MOVWF  FE9
014B2:  MOVLW  07
014B4:  ADDWFC 03,W
014B6:  MOVWF  FEA
014B8:  MOVLW  01
014BA:  ADDWF  FEE,F
014BC:  BNC   14C0
014BE:  INCF   FEF,F
....................          m_gb_cnt[motor]=0; 
014C0:  BCF    FD8.0
014C2:  RLCF   x40,W
014C4:  CLRF   03
014C6:  ADDLW  9A
014C8:  MOVWF  FE9
014CA:  MOVLW  07
014CC:  ADDWFC 03,W
014CE:  MOVWF  FEA
014D0:  CLRF   FEC
014D2:  MOVF   FED,F
014D4:  CLRF   FEF
....................       } 
014D6:  BRA    159E
014D8:  MOVLB  A
....................       else if(m_way[motor]==POS) { 
014DA:  BCF    FD8.0
014DC:  MOVLB  7
014DE:  RLCF   x40,W
014E0:  CLRF   03
014E2:  ADDLW  86
014E4:  MOVWF  FE9
014E6:  MOVLW  07
014E8:  ADDWFC 03,W
014EA:  MOVWF  FEA
014EC:  MOVFF  FEC,A38
014F0:  MOVF   FED,F
014F2:  MOVFF  FEF,A37
014F6:  MOVLB  A
014F8:  MOVF   x37,F
014FA:  BNZ   15A0
014FC:  MOVF   x38,F
014FE:  BNZ   15A0
....................          if (e_pos[motor]==0) e_pos[motor]=e_cpr[motor]; 
01500:  BCF    FD8.0
01502:  MOVLB  7
01504:  RLCF   x40,W
01506:  CLRF   03
01508:  ADDLW  BF
0150A:  MOVWF  FE9
0150C:  MOVLW  07
0150E:  ADDWFC 03,W
01510:  MOVWF  FEA
01512:  MOVFF  FEC,A38
01516:  MOVF   FED,F
01518:  MOVFF  FEF,A37
0151C:  MOVLB  A
0151E:  MOVF   x37,F
01520:  BNZ   156C
01522:  MOVF   x38,F
01524:  BNZ   156C
01526:  BCF    FD8.0
01528:  MOVLB  7
0152A:  RLCF   x40,W
0152C:  CLRF   03
0152E:  ADDLW  BF
01530:  MOVWF  01
01532:  MOVLW  07
01534:  ADDWFC 03,F
01536:  MOVLB  A
01538:  MOVFF  03,A38
0153C:  BCF    FD8.0
0153E:  MOVLB  7
01540:  RLCF   x40,W
01542:  CLRF   03
01544:  ADDLW  5E
01546:  MOVWF  FE9
01548:  MOVLW  07
0154A:  ADDWFC 03,W
0154C:  MOVWF  FEA
0154E:  MOVFF  FEC,03
01552:  MOVF   FED,F
01554:  MOVFF  FEF,A39
01558:  MOVLB  A
0155A:  MOVFF  A38,FEA
0155E:  MOVFF  01,FE9
01562:  MOVFF  03,FEC
01566:  MOVF   FED,F
01568:  MOVFF  A39,FEF
....................          e_pos[motor]--; 
0156C:  BCF    FD8.0
0156E:  MOVLB  7
01570:  RLCF   x40,W
01572:  CLRF   03
01574:  ADDLW  BF
01576:  MOVWF  FE9
01578:  MOVLW  07
0157A:  ADDWFC 03,W
0157C:  MOVWF  FEA
0157E:  MOVLW  FF
01580:  ADDWF  FEF,F
01582:  BC    1588
01584:  MOVF   FEE,F
01586:  DECF   FED,F
....................          m_gb_cnt[motor]=0; 
01588:  BCF    FD8.0
0158A:  RLCF   x40,W
0158C:  CLRF   03
0158E:  ADDLW  9A
01590:  MOVWF  FE9
01592:  MOVLW  07
01594:  ADDWFC 03,W
01596:  MOVWF  FEA
01598:  CLRF   FEC
0159A:  MOVF   FED,F
0159C:  CLRF   FEF
0159E:  MOVLB  A
....................       } 
....................    }    
....................     
....................    if(nv_report_mode==4 && e_type[motor]==2) { 
015A0:  MOVF   1F,W
015A2:  SUBLW  04
015A4:  BTFSS  FD8.2
015A6:  BRA    16DA
015A8:  MOVF   20,F
015AA:  BTFSS  FD8.2
015AC:  BRA    16DA
015AE:  BCF    FD8.0
015B0:  MOVLB  7
015B2:  RLCF   x40,W
015B4:  CLRF   03
015B6:  ADDLW  6A
015B8:  MOVWF  FE9
015BA:  MOVLW  07
015BC:  ADDWFC 03,W
015BE:  MOVWF  FEA
015C0:  MOVFF  FEC,A38
015C4:  MOVF   FED,F
015C6:  MOVFF  FEF,A37
015CA:  MOVLB  A
015CC:  MOVF   x37,W
015CE:  SUBLW  02
015D0:  BTFSS  FD8.2
015D2:  BRA    16DA
015D4:  MOVF   x38,F
015D6:  BTFSS  FD8.2
015D8:  BRA    16DA
....................       fprintf(COM_A, "m:%u,%u c:%Lu,%Lu,%Lu\r\n", 
....................                (motor+1),edge_mode,m_step_cnt[motor],e_cha_cnt[motor],e_pos[motor]); 
015DA:  MOVLW  01
015DC:  MOVLB  7
015DE:  ADDWF  x40,W
015E0:  MOVLB  A
015E2:  MOVWF  x37
015E4:  MOVLB  7
015E6:  MOVF   x40,W
015E8:  MULLW  04
015EA:  MOVF   FF3,W
015EC:  CLRF   03
015EE:  ADDLW  A2
015F0:  MOVWF  FE9
015F2:  MOVLW  07
015F4:  ADDWFC 03,W
015F6:  MOVWF  FEA
015F8:  MOVFF  FEF,A38
015FC:  MOVFF  FEC,A39
01600:  MOVFF  FEC,A3A
01604:  MOVFF  FEC,A3B
01608:  BCF    FD8.0
0160A:  RLCF   x40,W
0160C:  CLRF   03
0160E:  ADDLW  BB
01610:  MOVWF  FE9
01612:  MOVLW  07
01614:  ADDWFC 03,W
01616:  MOVWF  FEA
01618:  MOVFF  FEC,A3D
0161C:  MOVF   FED,F
0161E:  MOVFF  FEF,A3C
01622:  BCF    FD8.0
01624:  RLCF   x40,W
01626:  CLRF   03
01628:  ADDLW  BF
0162A:  MOVWF  FE9
0162C:  MOVLW  07
0162E:  ADDWFC 03,W
01630:  MOVWF  FEA
01632:  MOVFF  FEC,A3F
01636:  MOVF   FED,F
01638:  MOVFF  FEF,A3E
0163C:  MOVLW  6D
0163E:  BTFSS  F9E.4
01640:  BRA    163E
01642:  MOVWF  FAD
01644:  MOVLW  3A
01646:  BTFSS  F9E.4
01648:  BRA    1646
0164A:  MOVWF  FAD
0164C:  MOVFF  A37,A40
01650:  MOVLW  1B
01652:  MOVLB  A
01654:  MOVWF  x41
01656:  MOVLB  0
01658:  RCALL  0F9A
0165A:  MOVLW  2C
0165C:  BTFSS  F9E.4
0165E:  BRA    165C
01660:  MOVWF  FAD
01662:  MOVFF  7AA,A40
01666:  MOVLW  1B
01668:  MOVLB  A
0166A:  MOVWF  x41
0166C:  MOVLB  0
0166E:  RCALL  0F9A
01670:  MOVLW  5D
01672:  MOVWF  FF6
01674:  MOVLW  0F
01676:  MOVWF  FF7
01678:  MOVLW  00
0167A:  MOVWF  FF8
0167C:  MOVLW  03
0167E:  MOVLB  A
01680:  MOVWF  x40
01682:  MOVLB  0
01684:  RCALL  1018
01686:  MOVLW  41
01688:  MOVWF  FE9
0168A:  MOVFF  A3B,A43
0168E:  MOVFF  A3A,A42
01692:  MOVFF  A39,A41
01696:  MOVFF  A38,A40
0169A:  RCALL  10DE
0169C:  MOVLW  2C
0169E:  BTFSS  F9E.4
016A0:  BRA    169E
016A2:  MOVWF  FAD
016A4:  MOVLW  10
016A6:  MOVWF  FE9
016A8:  MOVFF  A3D,A41
016AC:  MOVFF  A3C,A40
016B0:  RCALL  119A
016B2:  MOVLW  2C
016B4:  BTFSS  F9E.4
016B6:  BRA    16B4
016B8:  MOVWF  FAD
016BA:  MOVLW  10
016BC:  MOVWF  FE9
016BE:  MOVFF  A3F,A41
016C2:  MOVFF  A3E,A40
016C6:  RCALL  119A
016C8:  MOVLW  0D
016CA:  BTFSS  F9E.4
016CC:  BRA    16CA
016CE:  MOVWF  FAD
016D0:  MOVLW  0A
016D2:  BTFSS  F9E.4
016D4:  BRA    16D2
016D6:  MOVWF  FAD
016D8:  MOVLB  A
....................    }    
016DA:  MOVLB  0
016DC:  RETURN 0
.................... } 
....................  
.................... void poll_index() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
0A776:  MOVLB  7
0A778:  MOVF   x40,W
0A77A:  XORLW  00
0A77C:  MOVLB  0
0A77E:  BZ    A786
0A780:  XORLW  01
0A782:  BZ    A816
0A784:  BRA    A8A4
....................       case 0 : if (e_type[motor]==1) { 
0A786:  BCF    FD8.0
0A788:  MOVLB  7
0A78A:  RLCF   x40,W
0A78C:  CLRF   03
0A78E:  ADDLW  6A
0A790:  MOVWF  FE9
0A792:  MOVLW  07
0A794:  ADDWFC 03,W
0A796:  MOVWF  FEA
0A798:  MOVFF  FEC,8C8
0A79C:  MOVF   FED,F
0A79E:  MOVFF  FEF,8C7
0A7A2:  MOVLB  8
0A7A4:  DECFSZ xC7,W
0A7A6:  BRA    A7C6
0A7A8:  MOVF   xC8,F
0A7AA:  BNZ   A7C6
....................                   e_ch_n[motor]=input(ENC1_IND); 
0A7AC:  CLRF   03
0A7AE:  MOVLB  7
0A7B0:  MOVF   x40,W
0A7B2:  ADDLW  CB
0A7B4:  MOVWF  FE9
0A7B6:  MOVLW  07
0A7B8:  ADDWFC 03,W
0A7BA:  MOVWF  FEA
0A7BC:  MOVLW  00
0A7BE:  BTFSC  F81.4
0A7C0:  MOVLW  01
0A7C2:  MOVWF  FEF
0A7C4:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A7C6:  BCF    FD8.0
0A7C8:  MOVLB  7
0A7CA:  RLCF   x40,W
0A7CC:  CLRF   03
0A7CE:  ADDLW  6A
0A7D0:  MOVWF  FE9
0A7D2:  MOVLW  07
0A7D4:  ADDWFC 03,W
0A7D6:  MOVWF  FEA
0A7D8:  MOVFF  FEC,8C8
0A7DC:  MOVF   FED,F
0A7DE:  MOVFF  FEF,8C7
0A7E2:  MOVLB  8
0A7E4:  MOVF   xC7,W
0A7E6:  SUBLW  02
0A7E8:  BNZ   A812
0A7EA:  MOVF   xC8,F
0A7EC:  BNZ   A812
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
0A7EE:  CLRF   03
0A7F0:  MOVLB  7
0A7F2:  MOVF   x40,W
0A7F4:  ADDLW  CB
0A7F6:  MOVWF  FE9
0A7F8:  MOVLW  07
0A7FA:  ADDWFC 03,W
0A7FC:  MOVWF  FEA
0A7FE:  MOVLW  00
0A800:  BTFSC  F81.4
0A802:  MOVLW  01
0A804:  MOVLB  8
0A806:  MOVWF  xC9
0A808:  MOVLW  00
0A80A:  BTFSC  F81.1
0A80C:  MOVLW  01
0A80E:  ANDWF  xC9,W
0A810:  MOVWF  FEF
....................                } 
....................          break; 
0A812:  MOVLB  0
0A814:  BRA    A8A4
....................       case 1 : if (e_type[motor]==1) { 
0A816:  BCF    FD8.0
0A818:  MOVLB  7
0A81A:  RLCF   x40,W
0A81C:  CLRF   03
0A81E:  ADDLW  6A
0A820:  MOVWF  FE9
0A822:  MOVLW  07
0A824:  ADDWFC 03,W
0A826:  MOVWF  FEA
0A828:  MOVFF  FEC,8C8
0A82C:  MOVF   FED,F
0A82E:  MOVFF  FEF,8C7
0A832:  MOVLB  8
0A834:  DECFSZ xC7,W
0A836:  BRA    A856
0A838:  MOVF   xC8,F
0A83A:  BNZ   A856
....................                   e_ch_n[motor]=input(ENC2_IND); 
0A83C:  CLRF   03
0A83E:  MOVLB  7
0A840:  MOVF   x40,W
0A842:  ADDLW  CB
0A844:  MOVWF  FE9
0A846:  MOVLW  07
0A848:  ADDWFC 03,W
0A84A:  MOVWF  FEA
0A84C:  MOVLW  00
0A84E:  BTFSC  F81.5
0A850:  MOVLW  01
0A852:  MOVWF  FEF
0A854:  MOVLB  8
....................                } 
....................                if (e_type[motor]==2) { 
0A856:  BCF    FD8.0
0A858:  MOVLB  7
0A85A:  RLCF   x40,W
0A85C:  CLRF   03
0A85E:  ADDLW  6A
0A860:  MOVWF  FE9
0A862:  MOVLW  07
0A864:  ADDWFC 03,W
0A866:  MOVWF  FEA
0A868:  MOVFF  FEC,8C8
0A86C:  MOVF   FED,F
0A86E:  MOVFF  FEF,8C7
0A872:  MOVLB  8
0A874:  MOVF   xC7,W
0A876:  SUBLW  02
0A878:  BNZ   A8A2
0A87A:  MOVF   xC8,F
0A87C:  BNZ   A8A2
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
0A87E:  CLRF   03
0A880:  MOVLB  7
0A882:  MOVF   x40,W
0A884:  ADDLW  CB
0A886:  MOVWF  FE9
0A888:  MOVLW  07
0A88A:  ADDWFC 03,W
0A88C:  MOVWF  FEA
0A88E:  MOVLW  00
0A890:  BTFSC  F81.5
0A892:  MOVLW  01
0A894:  MOVLB  8
0A896:  MOVWF  xC9
0A898:  MOVLW  00
0A89A:  BTFSC  F81.2
0A89C:  MOVLW  01
0A89E:  ANDWF  xC9,W
0A8A0:  MOVWF  FEF
....................                } 
....................          break; 
0A8A2:  MOVLB  0
....................    } 
0A8A4:  GOTO   A95E (RETURN)
.................... } 
....................  
.................... void poll_index_isr() 
.................... { 
....................    // (e_type) 1 = quad, 2 = slotted disk 
....................    switch (motor){ 
*
017CA:  MOVLB  7
017CC:  MOVF   x40,W
017CE:  XORLW  00
017D0:  MOVLB  0
017D2:  BZ    17DA
017D4:  XORLW  01
017D6:  BZ    186A
017D8:  BRA    18F8
....................       case 0 : if (e_type[motor]==1) { 
017DA:  BCF    FD8.0
017DC:  MOVLB  7
017DE:  RLCF   x40,W
017E0:  CLRF   03
017E2:  ADDLW  6A
017E4:  MOVWF  FE9
017E6:  MOVLW  07
017E8:  ADDWFC 03,W
017EA:  MOVWF  FEA
017EC:  MOVFF  FEC,A38
017F0:  MOVF   FED,F
017F2:  MOVFF  FEF,A37
017F6:  MOVLB  A
017F8:  DECFSZ x37,W
017FA:  BRA    181A
017FC:  MOVF   x38,F
017FE:  BNZ   181A
....................                   e_ch_n[motor]=input(ENC1_IND); 
01800:  CLRF   03
01802:  MOVLB  7
01804:  MOVF   x40,W
01806:  ADDLW  CB
01808:  MOVWF  FE9
0180A:  MOVLW  07
0180C:  ADDWFC 03,W
0180E:  MOVWF  FEA
01810:  MOVLW  00
01812:  BTFSC  F81.4
01814:  MOVLW  01
01816:  MOVWF  FEF
01818:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
0181A:  BCF    FD8.0
0181C:  MOVLB  7
0181E:  RLCF   x40,W
01820:  CLRF   03
01822:  ADDLW  6A
01824:  MOVWF  FE9
01826:  MOVLW  07
01828:  ADDWFC 03,W
0182A:  MOVWF  FEA
0182C:  MOVFF  FEC,A38
01830:  MOVF   FED,F
01832:  MOVFF  FEF,A37
01836:  MOVLB  A
01838:  MOVF   x37,W
0183A:  SUBLW  02
0183C:  BNZ   1866
0183E:  MOVF   x38,F
01840:  BNZ   1866
....................                   e_ch_n[motor]=(input(ENC1_IND) & input(ENC1_PHA)); 
01842:  CLRF   03
01844:  MOVLB  7
01846:  MOVF   x40,W
01848:  ADDLW  CB
0184A:  MOVWF  FE9
0184C:  MOVLW  07
0184E:  ADDWFC 03,W
01850:  MOVWF  FEA
01852:  MOVLW  00
01854:  BTFSC  F81.4
01856:  MOVLW  01
01858:  MOVLB  A
0185A:  MOVWF  x39
0185C:  MOVLW  00
0185E:  BTFSC  F81.1
01860:  MOVLW  01
01862:  ANDWF  x39,W
01864:  MOVWF  FEF
....................                } 
....................          break; 
01866:  MOVLB  0
01868:  BRA    18F8
....................       case 1 : if (e_type[motor]==1) { 
0186A:  BCF    FD8.0
0186C:  MOVLB  7
0186E:  RLCF   x40,W
01870:  CLRF   03
01872:  ADDLW  6A
01874:  MOVWF  FE9
01876:  MOVLW  07
01878:  ADDWFC 03,W
0187A:  MOVWF  FEA
0187C:  MOVFF  FEC,A38
01880:  MOVF   FED,F
01882:  MOVFF  FEF,A37
01886:  MOVLB  A
01888:  DECFSZ x37,W
0188A:  BRA    18AA
0188C:  MOVF   x38,F
0188E:  BNZ   18AA
....................                   e_ch_n[motor]=input(ENC2_IND); 
01890:  CLRF   03
01892:  MOVLB  7
01894:  MOVF   x40,W
01896:  ADDLW  CB
01898:  MOVWF  FE9
0189A:  MOVLW  07
0189C:  ADDWFC 03,W
0189E:  MOVWF  FEA
018A0:  MOVLW  00
018A2:  BTFSC  F81.5
018A4:  MOVLW  01
018A6:  MOVWF  FEF
018A8:  MOVLB  A
....................                } 
....................                if (e_type[motor]==2) { 
018AA:  BCF    FD8.0
018AC:  MOVLB  7
018AE:  RLCF   x40,W
018B0:  CLRF   03
018B2:  ADDLW  6A
018B4:  MOVWF  FE9
018B6:  MOVLW  07
018B8:  ADDWFC 03,W
018BA:  MOVWF  FEA
018BC:  MOVFF  FEC,A38
018C0:  MOVF   FED,F
018C2:  MOVFF  FEF,A37
018C6:  MOVLB  A
018C8:  MOVF   x37,W
018CA:  SUBLW  02
018CC:  BNZ   18F6
018CE:  MOVF   x38,F
018D0:  BNZ   18F6
....................                   e_ch_n[motor]=(input(ENC2_IND) & input(ENC2_PHA)); 
018D2:  CLRF   03
018D4:  MOVLB  7
018D6:  MOVF   x40,W
018D8:  ADDLW  CB
018DA:  MOVWF  FE9
018DC:  MOVLW  07
018DE:  ADDWFC 03,W
018E0:  MOVWF  FEA
018E2:  MOVLW  00
018E4:  BTFSC  F81.5
018E6:  MOVLW  01
018E8:  MOVLB  A
018EA:  MOVWF  x39
018EC:  MOVLW  00
018EE:  BTFSC  F81.2
018F0:  MOVLW  01
018F2:  ANDWF  x39,W
018F4:  MOVWF  FEF
....................                } 
....................          break; 
018F6:  MOVLB  0
....................    } 
018F8:  GOTO   1A46 (RETURN)
.................... } 
....................  
.................... // encoder 1 chan B interrupt 
.................... #int_ext1 
.................... void int1_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
*
016DE:  BCF    FD8.0
016E0:  MOVLB  7
016E2:  RLCF   x40,W
016E4:  CLRF   03
016E6:  ADDLW  BB
016E8:  MOVWF  FE9
016EA:  MOVLW  07
016EC:  ADDWFC 03,W
016EE:  MOVWF  FEA
016F0:  MOVLW  01
016F2:  ADDWF  FEE,F
016F4:  BNC   16F8
016F6:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
016F8:  MOVF   xAA,W
016FA:  XORLW  00
016FC:  MOVLB  0
016FE:  BZ    170A
01700:  XORLW  01
01702:  BZ    1710
01704:  XORLW  03
01706:  BZ    1722
01708:  BRA    174C
....................       case 0 : clear_interrupt(INT_EXT1_H2L);       
0170A:  BCF    FF0.0
....................                clear_interrupt(INT_EXT1_L2H); 
0170C:  BCF    FF0.0
....................          break; 
0170E:  BRA    174C
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01710:  MOVLW  02
01712:  MOVLB  7
01714:  MOVWF  xAA
....................                disable_interrupts(INT_EXT1_L2H); 
01716:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_H2L); 
01718:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_H2L); 
0171A:  BSF    FF0.3
0171C:  BCF    FF1.5
....................          break; 
0171E:  MOVLB  0
01720:  BRA    174C
....................       case 2 : edge_mode=1; 
01722:  MOVLW  01
01724:  MOVLB  7
01726:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
01728:  BCF    FD8.0
0172A:  RLCF   x40,W
0172C:  CLRF   03
0172E:  ADDLW  BB
01730:  MOVWF  FE9
01732:  MOVLW  07
01734:  ADDWFC 03,W
01736:  MOVWF  FEA
01738:  MOVLW  FF
0173A:  ADDWF  FEF,F
0173C:  BC    1742
0173E:  MOVF   FEE,F
01740:  DECF   FED,F
....................                disable_interrupts(INT_EXT1_H2L); 
01742:  BCF    FF0.3
....................                clear_interrupt(INT_EXT1_L2H); 
01744:  BCF    FF0.0
....................                enable_interrupts(INT_EXT1_L2H); 
01746:  BSF    FF0.3
01748:  BSF    FF1.5
....................          break; 
0174A:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
0174C:  RCALL  124E
.................... } 
....................  
.................... // encoder 2 chan B interrupt 
0174E:  BCF    FF0.0
01750:  GOTO   00B0
.................... #int_ext2 
.................... void int2_isr() 
.................... { 
....................    e_cha_cnt[motor]++; 
01754:  BCF    FD8.0
01756:  MOVLB  7
01758:  RLCF   x40,W
0175A:  CLRF   03
0175C:  ADDLW  BB
0175E:  MOVWF  FE9
01760:  MOVLW  07
01762:  ADDWFC 03,W
01764:  MOVWF  FEA
01766:  MOVLW  01
01768:  ADDWF  FEE,F
0176A:  BNC   176E
0176C:  INCF   FEF,F
....................     
....................    switch (edge_mode){ 
0176E:  MOVF   xAA,W
01770:  XORLW  00
01772:  MOVLB  0
01774:  BZ    1780
01776:  XORLW  01
01778:  BZ    1786
0177A:  XORLW  03
0177C:  BZ    1798
0177E:  BRA    17C2
....................       case 0 : clear_interrupt(INT_EXT2_H2L);       
01780:  BCF    FF0.1
....................                clear_interrupt(INT_EXT2_L2H); 
01782:  BCF    FF0.1
....................          break; 
01784:  BRA    17C2
....................       case 1 : edge_mode=2;                     // L2H will trigger first 
01786:  MOVLW  02
01788:  MOVLB  7
0178A:  MOVWF  xAA
....................                disable_interrupts(INT_EXT2_L2H); 
0178C:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_H2L); 
0178E:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_H2L); 
01790:  BSF    FF0.4
01792:  BCF    FF1.4
....................          break; 
01794:  MOVLB  0
01796:  BRA    17C2
....................       case 2 : edge_mode=1; 
01798:  MOVLW  01
0179A:  MOVLB  7
0179C:  MOVWF  xAA
....................                e_cha_cnt[motor]--;              // do not add second edge to port count 
0179E:  BCF    FD8.0
017A0:  RLCF   x40,W
017A2:  CLRF   03
017A4:  ADDLW  BB
017A6:  MOVWF  FE9
017A8:  MOVLW  07
017AA:  ADDWFC 03,W
017AC:  MOVWF  FEA
017AE:  MOVLW  FF
017B0:  ADDWF  FEF,F
017B2:  BC    17B8
017B4:  MOVF   FEE,F
017B6:  DECF   FED,F
....................                disable_interrupts(INT_EXT2_H2L); 
017B8:  BCF    FF0.4
....................                clear_interrupt(INT_EXT2_L2H); 
017BA:  BCF    FF0.1
....................                enable_interrupts(INT_EXT2_L2H); 
017BC:  BSF    FF0.4
017BE:  BSF    FF1.4
....................          break; 
017C0:  MOVLB  0
....................    } 
....................     
....................    update_e_pos(); 
017C2:  RCALL  124E
.................... } 
....................  
.................... // motor step timer interrupt 
017C4:  BCF    FF0.1
017C6:  GOTO   00B0
.................... #int_timer3 
.................... void timer3_isr() 
.................... { 
....................    set_timer3(STEP_INTERVAL); 
*
018FC:  MOVLW  F9
018FE:  MOVWF  FB3
01900:  MOVLW  C0
01902:  MOVWF  FB2
....................    m_trig_cnt[motor]++; 
01904:  BCF    FD8.0
01906:  MOVLB  7
01908:  RLCF   x40,W
0190A:  CLRF   03
0190C:  ADDLW  8E
0190E:  MOVWF  FE9
01910:  MOVLW  07
01912:  ADDWFC 03,W
01914:  MOVWF  FEA
01916:  MOVLW  01
01918:  ADDWF  FEE,F
0191A:  BNC   191E
0191C:  INCF   FEF,F
....................  
....................    if (m_trig_cnt[motor] >= m_stp_int[motor]) 
0191E:  BCF    FD8.0
01920:  RLCF   x40,W
01922:  CLRF   03
01924:  ADDLW  8E
01926:  MOVWF  FE9
01928:  MOVLW  07
0192A:  ADDWFC 03,W
0192C:  MOVWF  FEA
0192E:  MOVFF  FEC,A38
01932:  MOVF   FED,F
01934:  MOVFF  FEF,A37
01938:  BCF    FD8.0
0193A:  RLCF   x40,W
0193C:  CLRF   03
0193E:  ADDLW  4A
01940:  MOVWF  FE9
01942:  MOVLW  07
01944:  ADDWFC 03,W
01946:  MOVWF  FEA
01948:  MOVFF  FEC,03
0194C:  MOVF   FED,F
0194E:  MOVFF  FEF,01
01952:  MOVF   03,W
01954:  MOVLB  A
01956:  SUBWF  x38,W
01958:  BTFSS  FD8.0
0195A:  BRA    1A48
0195C:  BNZ   1966
0195E:  MOVF   01,W
01960:  SUBWF  x37,W
01962:  BTFSS  FD8.0
01964:  BRA    1A48
....................    { 
....................       m_step_cnt[motor]++; 
01966:  MOVLB  7
01968:  MOVF   x40,W
0196A:  MULLW  04
0196C:  MOVF   FF3,W
0196E:  CLRF   03
01970:  ADDLW  A2
01972:  MOVWF  FE9
01974:  MOVLW  07
01976:  ADDWFC 03,W
01978:  MOVWF  FEA
0197A:  MOVLW  01
0197C:  ADDWF  FEE,F
0197E:  MOVLW  00
01980:  ADDWFC FEE,F
01982:  ADDWFC FEE,F
01984:  ADDWFC FED,F
....................       m_gb_cnt[motor]++; 
01986:  BCF    FD8.0
01988:  RLCF   x40,W
0198A:  CLRF   03
0198C:  ADDLW  9A
0198E:  MOVWF  FE9
01990:  MOVLW  07
01992:  ADDWFC 03,W
01994:  MOVWF  FEA
01996:  MOVLW  01
01998:  ADDWF  FEE,F
0199A:  BNC   199E
0199C:  INCF   FEF,F
....................       m_trig_cnt[motor] = 0; 
0199E:  BCF    FD8.0
019A0:  RLCF   x40,W
019A2:  CLRF   03
019A4:  ADDLW  8E
019A6:  MOVWF  FE9
019A8:  MOVLW  07
019AA:  ADDWFC 03,W
019AC:  MOVWF  FEA
019AE:  CLRF   FEC
019B0:  MOVF   FED,F
019B2:  CLRF   FEF
....................  
....................       if (motor==0) 
019B4:  MOVF   x40,F
019B6:  BNZ   19BC
....................       { 
....................          output_toggle(M1_CLOCK); 
019B8:  BTG    F90.4
....................       } 
019BA:  BRA    1A1C
....................       else 
....................       { 
....................          output_toggle(M2_CLOCK); 
019BC:  BTG    F8D.4
....................          if(m_way[motor]==0)m_lin_pos[motor]--; 
019BE:  BCF    FD8.0
019C0:  RLCF   x40,W
019C2:  CLRF   03
019C4:  ADDLW  86
019C6:  MOVWF  FE9
019C8:  MOVLW  07
019CA:  ADDWFC 03,W
019CC:  MOVWF  FEA
019CE:  MOVFF  FEC,A38
019D2:  MOVF   FED,F
019D4:  MOVFF  FEF,A37
019D8:  MOVLB  A
019DA:  MOVF   x37,F
019DC:  BNZ   1A02
019DE:  MOVF   x38,F
019E0:  BNZ   1A02
019E2:  BCF    FD8.0
019E4:  MOVLB  7
019E6:  RLCF   x40,W
019E8:  CLRF   03
019EA:  ADDLW  B3
019EC:  MOVWF  FE9
019EE:  MOVLW  07
019F0:  ADDWFC 03,W
019F2:  MOVWF  FEA
019F4:  MOVLW  FF
019F6:  ADDWF  FEF,F
019F8:  BC    19FE
019FA:  MOVF   FEE,F
019FC:  DECF   FED,F
019FE:  BRA    1A1C
01A00:  MOVLB  A
....................          else m_lin_pos[motor]++;          
01A02:  BCF    FD8.0
01A04:  MOVLB  7
01A06:  RLCF   x40,W
01A08:  CLRF   03
01A0A:  ADDLW  B3
01A0C:  MOVWF  FE9
01A0E:  MOVLW  07
01A10:  ADDWFC 03,W
01A12:  MOVWF  FEA
01A14:  MOVLW  01
01A16:  ADDWF  FEE,F
01A18:  BNC   1A1C
01A1A:  INCF   FEF,F
....................       } 
....................  
.................... //      if(e_mode[motor]==3) poll_index();        // aligning 
....................       if(e_mode[motor]==3) poll_index_isr();    // aligning 
01A1C:  BCF    FD8.0
01A1E:  RLCF   x40,W
01A20:  CLRF   03
01A22:  ADDLW  66
01A24:  MOVWF  FE9
01A26:  MOVLW  07
01A28:  ADDWFC 03,W
01A2A:  MOVWF  FEA
01A2C:  MOVFF  FEC,A38
01A30:  MOVF   FED,F
01A32:  MOVFF  FEF,A37
01A36:  MOVLB  A
01A38:  MOVF   x37,W
01A3A:  SUBLW  03
01A3C:  BNZ   1A48
01A3E:  MOVF   x38,F
01A40:  BNZ   1A48
01A42:  MOVLB  0
01A44:  BRA    17CA
01A46:  MOVLB  A
....................    } 
....................    clear_interrupt(INT_TIMER3); 
01A48:  BCF    FA1.1
01A4A:  BCF    FA1.1
01A4C:  MOVLB  0
01A4E:  GOTO   00B0
.................... } 
....................  
.................... void motor_setup1() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
*
089D8:  BCF    FD8.0
089DA:  MOVLB  7
089DC:  RLCF   x40,W
089DE:  CLRF   03
089E0:  ADDLW  4E
089E2:  MOVWF  FE9
089E4:  MOVLW  07
089E6:  ADDWFC 03,W
089E8:  MOVWF  FEA
089EA:  MOVFF  FEC,8D9
089EE:  MOVF   FED,F
089F0:  MOVFF  FEF,8D8
089F4:  MOVLB  8
089F6:  DECFSZ xD8,W
089F8:  BRA    8A48
089FA:  MOVF   xD9,F
089FC:  BNZ   8A48
089FE:  BCF    FD8.0
08A00:  MOVLB  7
08A02:  RLCF   x40,W
08A04:  CLRF   03
08A06:  ADDLW  86
08A08:  MOVWF  01
08A0A:  MOVLW  07
08A0C:  ADDWFC 03,F
08A0E:  MOVFF  01,8D8
08A12:  MOVLB  8
08A14:  MOVFF  03,8D9
08A18:  BCF    FD8.0
08A1A:  MOVLB  7
08A1C:  RLCF   x40,W
08A1E:  CLRF   03
08A20:  ADDLW  86
08A22:  MOVWF  FE9
08A24:  MOVLW  07
08A26:  ADDWFC 03,W
08A28:  MOVWF  FEA
08A2A:  MOVF   FEF,F
08A2C:  BNZ   8A32
08A2E:  MOVF   FEC,F
08A30:  BZ    8A36
08A32:  MOVLW  00
08A34:  BRA    8A38
08A36:  MOVLW  01
08A38:  MOVLB  8
08A3A:  MOVFF  8D9,FEA
08A3E:  MOVFF  8D8,FE9
08A42:  CLRF   FEC
08A44:  MOVF   FED,F
08A46:  MOVWF  FEF
....................  
....................    output_bit(M1_RESET,RUN); 
08A48:  BSF    F90.0
....................    output_bit(M1_ENABLE,OFF); 
08A4A:  BCF    F90.1
....................    output_bit(M1_CONTROL, m_ctrl[motor]); 
08A4C:  BCF    FD8.0
08A4E:  MOVLB  7
08A50:  RLCF   x40,W
08A52:  CLRF   03
08A54:  ADDLW  42
08A56:  MOVWF  FE9
08A58:  MOVLW  07
08A5A:  ADDWFC 03,W
08A5C:  MOVWF  FEA
08A5E:  MOVF   FEF,F
08A60:  BNZ   8A6A
08A62:  MOVF   FEC,F
08A64:  BNZ   8A6A
08A66:  BCF    F90.2
08A68:  BRA    8A6C
08A6A:  BSF    F90.2
....................    output_bit(M1_STEPMODE, m_mode[motor]); 
08A6C:  BCF    FD8.0
08A6E:  RLCF   x40,W
08A70:  CLRF   03
08A72:  ADDLW  46
08A74:  MOVWF  FE9
08A76:  MOVLW  07
08A78:  ADDWFC 03,W
08A7A:  MOVWF  FEA
08A7C:  MOVF   FEF,F
08A7E:  BNZ   8A88
08A80:  MOVF   FEC,F
08A82:  BNZ   8A88
08A84:  BCF    F90.3
08A86:  BRA    8A8A
08A88:  BSF    F90.3
....................    output_bit(M1_CLOCK, OFF); 
08A8A:  BCF    F90.4
....................    output_bit(M1_DIR, m_way[motor]); 
08A8C:  BCF    FD8.0
08A8E:  RLCF   x40,W
08A90:  CLRF   03
08A92:  ADDLW  86
08A94:  MOVWF  FE9
08A96:  MOVLW  07
08A98:  ADDWFC 03,W
08A9A:  MOVWF  FEA
08A9C:  MOVF   FEF,F
08A9E:  BNZ   8AA8
08AA0:  MOVF   FEC,F
08AA2:  BNZ   8AA8
08AA4:  BCF    F90.5
08AA6:  BRA    8AAA
08AA8:  BSF    F90.5
....................    set_pwm1_duty(m_pwm_drv[motor]);              
08AAA:  BCF    FD8.0
08AAC:  RLCF   x40,W
08AAE:  CLRF   03
08AB0:  ADDLW  56
08AB2:  MOVWF  FE9
08AB4:  MOVLW  07
08AB6:  ADDWFC 03,W
08AB8:  MOVWF  FEA
08ABA:  MOVFF  FEC,8D9
08ABE:  MOVF   FED,F
08AC0:  MOVFF  FEF,8D8
08AC4:  MOVLB  8
08AC6:  RRCF   xD9,F
08AC8:  RRCF   xD8,F
08ACA:  RRCF   xD9,F
08ACC:  RRCF   xD8,F
08ACE:  RRCF   xD9,F
08AD0:  MOVFF  8D8,FBC
08AD4:  RRCF   xD9,F
08AD6:  RRCF   xD9,W
08AD8:  ANDLW  30
08ADA:  MOVWF  00
08ADC:  MOVF   FBB,W
08ADE:  ANDLW  CF
08AE0:  IORWF  00,W
08AE2:  MOVWF  FBB
08AE4:  MOVLB  0
08AE6:  GOTO   8C70 (RETURN)
.................... } 
....................  
.................... void motor_setup2() 
.................... { 
....................    if (m_pos_dir[motor]==1)m_way[motor]=!m_way[motor]; 
08AEA:  BCF    FD8.0
08AEC:  MOVLB  7
08AEE:  RLCF   x40,W
08AF0:  CLRF   03
08AF2:  ADDLW  4E
08AF4:  MOVWF  FE9
08AF6:  MOVLW  07
08AF8:  ADDWFC 03,W
08AFA:  MOVWF  FEA
08AFC:  MOVFF  FEC,8D9
08B00:  MOVF   FED,F
08B02:  MOVFF  FEF,8D8
08B06:  MOVLB  8
08B08:  DECFSZ xD8,W
08B0A:  BRA    8B5A
08B0C:  MOVF   xD9,F
08B0E:  BNZ   8B5A
08B10:  BCF    FD8.0
08B12:  MOVLB  7
08B14:  RLCF   x40,W
08B16:  CLRF   03
08B18:  ADDLW  86
08B1A:  MOVWF  01
08B1C:  MOVLW  07
08B1E:  ADDWFC 03,F
08B20:  MOVFF  01,8D8
08B24:  MOVLB  8
08B26:  MOVFF  03,8D9
08B2A:  BCF    FD8.0
08B2C:  MOVLB  7
08B2E:  RLCF   x40,W
08B30:  CLRF   03
08B32:  ADDLW  86
08B34:  MOVWF  FE9
08B36:  MOVLW  07
08B38:  ADDWFC 03,W
08B3A:  MOVWF  FEA
08B3C:  MOVF   FEF,F
08B3E:  BNZ   8B44
08B40:  MOVF   FEC,F
08B42:  BZ    8B48
08B44:  MOVLW  00
08B46:  BRA    8B4A
08B48:  MOVLW  01
08B4A:  MOVLB  8
08B4C:  MOVFF  8D9,FEA
08B50:  MOVFF  8D8,FE9
08B54:  CLRF   FEC
08B56:  MOVF   FED,F
08B58:  MOVWF  FEF
....................     
....................    output_bit(M2_RESET,RUN); 
08B5A:  BSF    F8D.0
....................    output_bit(M2_ENABLE,OFF); 
08B5C:  BCF    F8D.1
....................    output_bit(M2_CONTROL, m_ctrl[motor]); 
08B5E:  BCF    FD8.0
08B60:  MOVLB  7
08B62:  RLCF   x40,W
08B64:  CLRF   03
08B66:  ADDLW  42
08B68:  MOVWF  FE9
08B6A:  MOVLW  07
08B6C:  ADDWFC 03,W
08B6E:  MOVWF  FEA
08B70:  MOVF   FEF,F
08B72:  BNZ   8B7C
08B74:  MOVF   FEC,F
08B76:  BNZ   8B7C
08B78:  BCF    F8D.2
08B7A:  BRA    8B7E
08B7C:  BSF    F8D.2
....................    output_bit(M2_STEPMODE, m_mode[motor]); 
08B7E:  BCF    FD8.0
08B80:  RLCF   x40,W
08B82:  CLRF   03
08B84:  ADDLW  46
08B86:  MOVWF  FE9
08B88:  MOVLW  07
08B8A:  ADDWFC 03,W
08B8C:  MOVWF  FEA
08B8E:  MOVF   FEF,F
08B90:  BNZ   8B9A
08B92:  MOVF   FEC,F
08B94:  BNZ   8B9A
08B96:  BCF    F8D.3
08B98:  BRA    8B9C
08B9A:  BSF    F8D.3
....................    output_bit(M2_CLOCK, OFF); 
08B9C:  BCF    F8D.4
....................    output_bit(M2_DIR, m_way[motor]);    
08B9E:  BCF    FD8.0
08BA0:  RLCF   x40,W
08BA2:  CLRF   03
08BA4:  ADDLW  86
08BA6:  MOVWF  FE9
08BA8:  MOVLW  07
08BAA:  ADDWFC 03,W
08BAC:  MOVWF  FEA
08BAE:  MOVF   FEF,F
08BB0:  BNZ   8BBA
08BB2:  MOVF   FEC,F
08BB4:  BNZ   8BBA
08BB6:  BCF    F8D.5
08BB8:  BRA    8BBC
08BBA:  BSF    F8D.5
....................    set_pwm2_duty(m_pwm_drv[motor]); 
08BBC:  BCF    FD8.0
08BBE:  RLCF   x40,W
08BC0:  CLRF   03
08BC2:  ADDLW  56
08BC4:  MOVWF  FE9
08BC6:  MOVLW  07
08BC8:  ADDWFC 03,W
08BCA:  MOVWF  FEA
08BCC:  MOVFF  FEC,8D9
08BD0:  MOVF   FED,F
08BD2:  MOVFF  FEF,8D8
08BD6:  MOVLB  8
08BD8:  RRCF   xD9,F
08BDA:  RRCF   xD8,F
08BDC:  RRCF   xD9,F
08BDE:  RRCF   xD8,F
08BE0:  RRCF   xD9,F
08BE2:  MOVFF  8D8,F4F
08BE6:  RRCF   xD9,F
08BE8:  RRCF   xD9,W
08BEA:  ANDLW  30
08BEC:  MOVWF  00
08BEE:  MOVLB  F
08BF0:  MOVF   x4E,W
08BF2:  ANDLW  CF
08BF4:  IORWF  00,W
08BF6:  MOVWF  x4E
08BF8:  MOVLB  0
08BFA:  GOTO   8C70 (RETURN)
.................... } 
....................  
.................... // switch power to encoder 
.................... void enc_pwr(int8 pwr) 
.................... { 
....................    if(pwr){ 
*
089C4:  MOVLB  8
089C6:  MOVF   xEC,F
089C8:  BZ    89D0
....................       output_bit(VENC1,ON); 
089CA:  BSF    F8E.6
....................       output_bit(VENC2,ON); 
089CC:  BSF    F8E.7
....................    } 
089CE:  BRA    89D4
....................    else {       
....................       output_bit(VENC1,OFF); 
089D0:  BCF    F8E.6
....................       output_bit(VENC2,OFF); 
089D2:  BCF    F8E.7
....................    } 
089D4:  MOVLB  0
089D6:  RETURN 0
.................... } 
....................  
.................... void enable_enc_isr(int16 edge) 
.................... { 
....................    // edge 0 = H to L transition (disk mainly clear) 
....................    if(edge==0){ 
*
08D5E:  MOVLB  8
08D60:  MOVF   xED,F
08D62:  BNZ   8D8A
08D64:  MOVF   xEE,F
08D66:  BNZ   8D8A
....................       edge_mode=0; 
08D68:  MOVLB  7
08D6A:  CLRF   xAA
....................       switch (motor){ 
08D6C:  MOVF   x40,W
08D6E:  XORLW  00
08D70:  MOVLB  0
08D72:  BZ    8D7A
08D74:  XORLW  01
08D76:  BZ    8D82
08D78:  BRA    8D88
....................          case 0 : clear_interrupt(INT_EXT1_H2L); 
08D7A:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_H2L); 
08D7C:  BSF    FF0.3
08D7E:  BCF    FF1.5
....................             break; 
08D80:  BRA    8D88
....................          case 1 : clear_interrupt(INT_EXT2_H2L); 
08D82:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_H2L); 
08D84:  BSF    FF0.4
08D86:  BCF    FF1.4
....................             break; 
08D88:  MOVLB  8
....................       }  
....................    } 
....................    // edge 1 = L to H transition (disk mainly opaque) 
....................    if(edge==1){ 
08D8A:  DECFSZ xED,W
08D8C:  BRA    8DB4
08D8E:  MOVF   xEE,F
08D90:  BNZ   8DB4
....................       edge_mode=0; 
08D92:  MOVLB  7
08D94:  CLRF   xAA
....................       switch (motor){ 
08D96:  MOVF   x40,W
08D98:  XORLW  00
08D9A:  MOVLB  0
08D9C:  BZ    8DA4
08D9E:  XORLW  01
08DA0:  BZ    8DAC
08DA2:  BRA    8DB2
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08DA4:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08DA6:  BSF    FF0.3
08DA8:  BSF    FF1.5
....................             break; 
08DAA:  BRA    8DB2
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08DAC:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08DAE:  BSF    FF0.4
08DB0:  BSF    FF1.4
....................             break; 
08DB2:  MOVLB  8
....................       }  
....................    }  
....................    // edge 2 = HL & LH transition (every edge - only slotted disk) 
....................    if(edge==2 && e_type[motor]==2){ 
08DB4:  MOVF   xED,W
08DB6:  SUBLW  02
08DB8:  BNZ   8E0A
08DBA:  MOVF   xEE,F
08DBC:  BNZ   8E0A
08DBE:  BCF    FD8.0
08DC0:  MOVLB  7
08DC2:  RLCF   x40,W
08DC4:  CLRF   03
08DC6:  ADDLW  6A
08DC8:  MOVWF  FE9
08DCA:  MOVLW  07
08DCC:  ADDWFC 03,W
08DCE:  MOVWF  FEA
08DD0:  MOVFF  FEC,8F0
08DD4:  MOVF   FED,F
08DD6:  MOVFF  FEF,8EF
08DDA:  MOVLB  8
08DDC:  MOVF   xEF,W
08DDE:  SUBLW  02
08DE0:  BNZ   8E0A
08DE2:  MOVF   xF0,F
08DE4:  BNZ   8E0A
....................       edge_mode=1; 
08DE6:  MOVLW  01
08DE8:  MOVLB  7
08DEA:  MOVWF  xAA
....................       switch (motor){ 
08DEC:  MOVF   x40,W
08DEE:  XORLW  00
08DF0:  MOVLB  0
08DF2:  BZ    8DFA
08DF4:  XORLW  01
08DF6:  BZ    8E02
08DF8:  BRA    8E08
....................          case 0 : clear_interrupt(INT_EXT1_L2H); 
08DFA:  BCF    FF0.0
....................                   enable_interrupts(INT_EXT1_L2H); 
08DFC:  BSF    FF0.3
08DFE:  BSF    FF1.5
....................             break; 
08E00:  BRA    8E08
....................          case 1 : clear_interrupt(INT_EXT2_L2H); 
08E02:  BCF    FF0.1
....................                   enable_interrupts(INT_EXT2_L2H); 
08E04:  BSF    FF0.4
08E06:  BSF    FF1.4
....................             break; 
08E08:  MOVLB  8
....................       }  
....................    }     
08E0A:  MOVLB  0
08E0C:  RETURN 0
.................... } 
....................  
.................... void wrt_m_error() 
.................... { 
....................    switch(motor){ 
*
08F74:  MOVLB  7
08F76:  MOVF   x40,W
08F78:  XORLW  00
08F7A:  MOVLB  0
08F7C:  BZ    8F84
08F7E:  XORLW  01
08F80:  BZ    8FAE
08F82:  BRA    8FD6
....................       case 0 : write16(ADDR_M1_ERROR,m_error[motor]); 
08F84:  BCF    FD8.0
08F86:  MOVLB  7
08F88:  RLCF   x40,W
08F8A:  CLRF   03
08F8C:  ADDLW  96
08F8E:  MOVWF  FE9
08F90:  MOVLW  07
08F92:  ADDWFC 03,W
08F94:  MOVWF  FEA
08F96:  MOVFF  FEC,8F0
08F9A:  MOVF   FED,F
08F9C:  MOVFF  FEF,8EF
08FA0:  MOVLW  6E
08FA2:  MOVLB  8
08FA4:  MOVWF  xEE
08FA6:  MOVLB  0
08FA8:  CALL   4FC8
....................          break; 
08FAC:  BRA    8FD6
....................       case 1 : write16(ADDR_M2_ERROR,m_error[motor]); 
08FAE:  BCF    FD8.0
08FB0:  MOVLB  7
08FB2:  RLCF   x40,W
08FB4:  CLRF   03
08FB6:  ADDLW  96
08FB8:  MOVWF  FE9
08FBA:  MOVLW  07
08FBC:  ADDWFC 03,W
08FBE:  MOVWF  FEA
08FC0:  MOVFF  FEC,8F0
08FC4:  MOVF   FED,F
08FC6:  MOVFF  FEF,8EF
08FCA:  MOVLW  70
08FCC:  MOVLB  8
08FCE:  MOVWF  xEE
08FD0:  MOVLB  0
08FD2:  CALL   4FC8
....................          break;          
....................    } 
08FD6:  RETURN 0
.................... } 
....................  
.................... // enable encoder interrupts 
.................... void enc_isr(int8 enable) 
.................... { 
....................    // disable interrupts 
....................    if(enable==0) 
*
08E0E:  MOVLB  8
08E10:  MOVF   xEC,F
08E12:  BNZ   8E30
....................    { 
....................       switch (motor) 
08E14:  MOVLB  7
08E16:  MOVF   x40,W
08E18:  XORLW  00
08E1A:  MOVLB  0
08E1C:  BZ    8E24
08E1E:  XORLW  01
08E20:  BZ    8E2A
08E22:  BRA    8E2E
....................       { 
....................          case 0 : disable_interrupts(INT_EXT1_H2L); 
08E24:  BCF    FF0.3
....................                   disable_interrupts(INT_EXT1_L2H); 
08E26:  BCF    FF0.3
....................             break; 
08E28:  BRA    8E2E
....................          case 1 : disable_interrupts(INT_EXT2_H2L); 
08E2A:  BCF    FF0.4
....................                   disable_interrupts(INT_EXT2_L2H); 
08E2C:  BCF    FF0.4
....................             break; 
08E2E:  MOVLB  8
....................       }       
....................    } 
....................    // enable normal interrupts 
....................    if(enable==1) 
08E30:  DECFSZ xEC,W
08E32:  BRA    8E98
....................    { 
....................       if (e_type[motor]==1) enable_enc_isr(0);  // e_type 1 = quad, e.g. HEDS 
08E34:  BCF    FD8.0
08E36:  MOVLB  7
08E38:  RLCF   x40,W
08E3A:  CLRF   03
08E3C:  ADDLW  6A
08E3E:  MOVWF  FE9
08E40:  MOVLW  07
08E42:  ADDWFC 03,W
08E44:  MOVWF  FEA
08E46:  MOVFF  FEC,8EE
08E4A:  MOVF   FED,F
08E4C:  MOVFF  FEF,8ED
08E50:  MOVLB  8
08E52:  DECFSZ xED,W
08E54:  BRA    8E64
08E56:  MOVF   xEE,F
08E58:  BNZ   8E64
08E5A:  CLRF   xEE
08E5C:  CLRF   xED
08E5E:  MOVLB  0
08E60:  RCALL  8D5E
08E62:  MOVLB  8
....................       if (e_type[motor]==2) enable_enc_isr(1);  // e_type 2 = slotted disk 
08E64:  BCF    FD8.0
08E66:  MOVLB  7
08E68:  RLCF   x40,W
08E6A:  CLRF   03
08E6C:  ADDLW  6A
08E6E:  MOVWF  FE9
08E70:  MOVLW  07
08E72:  ADDWFC 03,W
08E74:  MOVWF  FEA
08E76:  MOVFF  FEC,8EE
08E7A:  MOVF   FED,F
08E7C:  MOVFF  FEF,8ED
08E80:  MOVLB  8
08E82:  MOVF   xED,W
08E84:  SUBLW  02
08E86:  BNZ   8E98
08E88:  MOVF   xEE,F
08E8A:  BNZ   8E98
08E8C:  CLRF   xEE
08E8E:  MOVLW  01
08E90:  MOVWF  xED
08E92:  MOVLB  0
08E94:  RCALL  8D5E
08E96:  MOVLB  8
....................    } 
....................    // enable every edge interrupts (for measurement) for e_type 2 = slotted disk only 
....................    if(enable==2 && e_type[motor]==2) 
08E98:  MOVF   xEC,W
08E9A:  SUBLW  02
08E9C:  BNZ   8ED2
08E9E:  BCF    FD8.0
08EA0:  MOVLB  7
08EA2:  RLCF   x40,W
08EA4:  CLRF   03
08EA6:  ADDLW  6A
08EA8:  MOVWF  FE9
08EAA:  MOVLW  07
08EAC:  ADDWFC 03,W
08EAE:  MOVWF  FEA
08EB0:  MOVFF  FEC,8EE
08EB4:  MOVF   FED,F
08EB6:  MOVFF  FEF,8ED
08EBA:  MOVLB  8
08EBC:  MOVF   xED,W
08EBE:  SUBLW  02
08EC0:  BNZ   8ED2
08EC2:  MOVF   xEE,F
08EC4:  BNZ   8ED2
....................    { 
....................       enable_enc_isr(2);   
08EC6:  CLRF   xEE
08EC8:  MOVLW  02
08ECA:  MOVWF  xED
08ECC:  MOVLB  0
08ECE:  RCALL  8D5E
08ED0:  MOVLB  8
....................    } 
08ED2:  MOVLB  0
08ED4:  RETURN 0
.................... } 
....................  
.................... void motor_init() 
.................... { 
....................    m_trig_cnt[motor] = 0; 
*
08BFE:  BCF    FD8.0
08C00:  MOVLB  7
08C02:  RLCF   x40,W
08C04:  CLRF   03
08C06:  ADDLW  8E
08C08:  MOVWF  FE9
08C0A:  MOVLW  07
08C0C:  ADDWFC 03,W
08C0E:  MOVWF  FEA
08C10:  CLRF   FEC
08C12:  MOVF   FED,F
08C14:  CLRF   FEF
....................    e_cha_cnt[motor] = 0;  
08C16:  BCF    FD8.0
08C18:  RLCF   x40,W
08C1A:  CLRF   03
08C1C:  ADDLW  BB
08C1E:  MOVWF  FE9
08C20:  MOVLW  07
08C22:  ADDWFC 03,W
08C24:  MOVWF  FEA
08C26:  CLRF   FEC
08C28:  MOVF   FED,F
08C2A:  CLRF   FEF
....................    m_gb_cnt[motor] = 0; 
08C2C:  BCF    FD8.0
08C2E:  RLCF   x40,W
08C30:  CLRF   03
08C32:  ADDLW  9A
08C34:  MOVWF  FE9
08C36:  MOVLW  07
08C38:  ADDWFC 03,W
08C3A:  MOVWF  FEA
08C3C:  CLRF   FEC
08C3E:  MOVF   FED,F
08C40:  CLRF   FEF
....................     
....................    output_bit(VMOT,ON); 
08C42:  BSF    F8E.1
....................    enc_pwr(ON); 
08C44:  MOVLW  01
08C46:  MOVLB  8
08C48:  MOVWF  xEC
08C4A:  MOVLB  0
08C4C:  RCALL  89C4
....................    delay_ms(100); 
08C4E:  MOVLW  64
08C50:  MOVLB  9
08C52:  MOVWF  xEC
08C54:  MOVLB  0
08C56:  CALL   2904
....................     
....................    switch (motor){ 
08C5A:  MOVLB  7
08C5C:  MOVF   x40,W
08C5E:  XORLW  00
08C60:  MOVLB  0
08C62:  BZ    8C6A
08C64:  XORLW  01
08C66:  BZ    8C6E
08C68:  BRA    8C70
....................       case 0 : motor_setup1(); 
08C6A:  BRA    89D8
....................          break; 
08C6C:  BRA    8C70
....................       case 1 : motor_setup2(); 
08C6E:  BRA    8AEA
....................          break; 
....................    } 
....................    // store actual direction 
....................    if(m_way_rst[motor]!=m_way[motor]){ 
08C70:  BCF    FD8.0
08C72:  MOVLB  7
08C74:  RLCF   x40,W
08C76:  CLRF   03
08C78:  ADDLW  8A
08C7A:  MOVWF  FE9
08C7C:  MOVLW  07
08C7E:  ADDWFC 03,W
08C80:  MOVWF  FEA
08C82:  MOVFF  FEC,8D9
08C86:  MOVF   FED,F
08C88:  MOVFF  FEF,8D8
08C8C:  BCF    FD8.0
08C8E:  RLCF   x40,W
08C90:  CLRF   03
08C92:  ADDLW  86
08C94:  MOVWF  FE9
08C96:  MOVLW  07
08C98:  ADDWFC 03,W
08C9A:  MOVWF  FEA
08C9C:  MOVFF  FEC,03
08CA0:  MOVF   FED,F
08CA2:  MOVF   FEF,W
08CA4:  MOVLB  8
08CA6:  SUBWF  xD8,W
08CA8:  BNZ   8CB0
08CAA:  MOVF   03,W
08CAC:  SUBWF  xD9,W
08CAE:  BZ    8D58
....................       m_way_rst[motor]=m_way[motor]; 
08CB0:  BCF    FD8.0
08CB2:  MOVLB  7
08CB4:  RLCF   x40,W
08CB6:  CLRF   03
08CB8:  ADDLW  8A
08CBA:  MOVWF  01
08CBC:  MOVLW  07
08CBE:  ADDWFC 03,F
08CC0:  MOVLB  8
08CC2:  MOVFF  03,8D9
08CC6:  BCF    FD8.0
08CC8:  MOVLB  7
08CCA:  RLCF   x40,W
08CCC:  CLRF   03
08CCE:  ADDLW  86
08CD0:  MOVWF  FE9
08CD2:  MOVLW  07
08CD4:  ADDWFC 03,W
08CD6:  MOVWF  FEA
08CD8:  MOVFF  FEC,03
08CDC:  MOVF   FED,F
08CDE:  MOVFF  FEF,8DA
08CE2:  MOVLB  8
08CE4:  MOVFF  8D9,FEA
08CE8:  MOVFF  01,FE9
08CEC:  MOVFF  03,FEC
08CF0:  MOVF   FED,F
08CF2:  MOVFF  8DA,FEF
....................       e_mode_rst[motor]= e_mode[motor]; 
08CF6:  BCF    FD8.0
08CF8:  MOVLB  7
08CFA:  RLCF   x40,W
08CFC:  CLRF   03
08CFE:  ADDLW  9E
08D00:  MOVWF  01
08D02:  MOVLW  07
08D04:  ADDWFC 03,F
08D06:  MOVLB  8
08D08:  MOVFF  03,8D9
08D0C:  BCF    FD8.0
08D0E:  MOVLB  7
08D10:  RLCF   x40,W
08D12:  CLRF   03
08D14:  ADDLW  66
08D16:  MOVWF  FE9
08D18:  MOVLW  07
08D1A:  ADDWFC 03,W
08D1C:  MOVWF  FEA
08D1E:  MOVFF  FEC,03
08D22:  MOVF   FED,F
08D24:  MOVFF  FEF,8DA
08D28:  MOVLB  8
08D2A:  MOVFF  8D9,FEA
08D2E:  MOVFF  01,FE9
08D32:  MOVFF  03,FEC
08D36:  MOVF   FED,F
08D38:  MOVFF  8DA,FEF
....................       // if change of direction set backlash mode 
....................       e_mode[motor]=5; 
08D3C:  BCF    FD8.0
08D3E:  MOVLB  7
08D40:  RLCF   x40,W
08D42:  CLRF   03
08D44:  ADDLW  66
08D46:  MOVWF  FE9
08D48:  MOVLW  07
08D4A:  ADDWFC 03,W
08D4C:  MOVWF  FEA
08D4E:  CLRF   FEC
08D50:  MOVF   FED,F
08D52:  MOVLW  05
08D54:  MOVWF  FEF
08D56:  MOVLB  8
....................    } 
08D58:  MOVLB  0
08D5A:  GOTO   8ED8 (RETURN)
.................... } 
....................  
.................... void start_motor(int8 int_mode) // 
.................... { 
....................    motor_init(); 
*
08ED6:  BRA    8BFE
....................     
....................    m_comp[motor]=FALSE; 
08ED8:  BCF    FD8.0
08EDA:  MOVLB  7
08EDC:  RLCF   x40,W
08EDE:  CLRF   03
08EE0:  ADDLW  AF
08EE2:  MOVWF  FE9
08EE4:  MOVLW  07
08EE6:  ADDWFC 03,W
08EE8:  MOVWF  FEA
08EEA:  CLRF   FEC
08EEC:  MOVF   FED,F
08EEE:  CLRF   FEF
....................     
....................    switch (motor){ 
08EF0:  MOVF   x40,W
08EF2:  XORLW  00
08EF4:  MOVLB  0
08EF6:  BZ    8EFE
08EF8:  XORLW  01
08EFA:  BZ    8F10
08EFC:  BRA    8F20
....................       case 0 : write16(ADDR_M1_COMP,FALSE);  
08EFE:  MOVLW  B2
08F00:  MOVLB  8
08F02:  MOVWF  xEE
08F04:  CLRF   xF0
08F06:  CLRF   xEF
08F08:  MOVLB  0
08F0A:  CALL   4FC8
....................          break; 
08F0E:  BRA    8F20
....................       case 1 : write16(ADDR_M2_COMP,FALSE); 
08F10:  MOVLW  B4
08F12:  MOVLB  8
08F14:  MOVWF  xEE
08F16:  CLRF   xF0
08F18:  CLRF   xEF
08F1A:  MOVLB  0
08F1C:  CALL   4FC8
....................          break; 
....................    } 
....................     
....................    switch(motor){ 
08F20:  MOVLB  7
08F22:  MOVF   x40,W
08F24:  XORLW  00
08F26:  MOVLB  0
08F28:  BZ    8F30
08F2A:  XORLW  01
08F2C:  BZ    8F34
08F2E:  BRA    8F36
....................       case 0 : output_bit(M1_ENABLE, ON); 
08F30:  BSF    F90.1
....................          break; 
08F32:  BRA    8F36
....................       case 1 : output_bit(M2_ENABLE, ON); 
08F34:  BSF    F8D.1
....................          break;          
....................    } 
....................     
....................    delay_ms(50); 
08F36:  MOVLW  32
08F38:  MOVLB  9
08F3A:  MOVWF  xEC
08F3C:  MOVLB  0
08F3E:  CALL   2904
....................     
....................    set_timer3(STEP_INTERVAL); 
08F42:  MOVLW  F9
08F44:  MOVWF  FB3
08F46:  MOVLW  C0
08F48:  MOVWF  FB2
....................    enc_isr(int_mode); 
08F4A:  MOVFF  8D7,8EC
08F4E:  RCALL  8E0E
....................    clear_interrupt(INT_TIMER3); 
08F50:  BCF    FA1.1
....................    m_running[motor] = TRUE;    
08F52:  BCF    FD8.0
08F54:  MOVLB  7
08F56:  RLCF   x40,W
08F58:  CLRF   03
08F5A:  ADDLW  92
08F5C:  MOVWF  FE9
08F5E:  MOVLW  07
08F60:  ADDWFC 03,W
08F62:  MOVWF  FEA
08F64:  CLRF   FEC
08F66:  MOVF   FED,F
08F68:  MOVLW  01
08F6A:  MOVWF  FEF
....................    enable_interrupts(INT_TIMER3); 
08F6C:  BSF    FA0.1
08F6E:  MOVLB  0
08F70:  GOTO   A1E8 (RETURN)
.................... } 
....................  
.................... // calculates absolute encoder position (enc_pos) of (port) 
.................... int32 abs_enc_pos(int32 port) 
.................... { 
....................    int32 enc_steps, enc_target, enc_res, enc_pos, ports; 
....................     
....................    enc_target = port; 
*
085FA:  MOVFF  8DA,8E2
085FE:  MOVFF  8D9,8E1
08602:  MOVFF  8D8,8E0
08606:  MOVFF  8D7,8DF
....................    enc_res    = e_cpr[motor]; 
0860A:  BCF    FD8.0
0860C:  MOVLB  7
0860E:  RLCF   x40,W
08610:  CLRF   03
08612:  ADDLW  5E
08614:  MOVWF  FE9
08616:  MOVLW  07
08618:  ADDWFC 03,W
0861A:  MOVWF  FEA
0861C:  MOVLB  8
0861E:  CLRF   xE6
08620:  CLRF   xE5
08622:  MOVFF  FEC,8E4
08626:  MOVF   FED,F
08628:  MOVFF  FEF,8E3
....................    ports      = e_ppr[motor]; 
0862C:  BCF    FD8.0
0862E:  MOVLB  7
08630:  RLCF   x40,W
08632:  CLRF   03
08634:  ADDLW  62
08636:  MOVWF  FE9
08638:  MOVLW  07
0863A:  ADDWFC 03,W
0863C:  MOVWF  FEA
0863E:  MOVLB  8
08640:  CLRF   xEE
08642:  CLRF   xED
08644:  MOVFF  FEC,8EC
08648:  MOVF   FED,F
0864A:  MOVFF  FEF,8EB
....................     
....................    enc_res = enc_res * 1000; 
0864E:  MOVFF  8E6,9F9
08652:  MOVFF  8E5,9F8
08656:  MOVFF  8E4,9F7
0865A:  MOVFF  8E3,9F6
0865E:  MOVLB  9
08660:  CLRF   xFD
08662:  CLRF   xFC
08664:  MOVLW  03
08666:  MOVWF  xFB
08668:  MOVLW  E8
0866A:  MOVWF  xFA
0866C:  MOVLB  0
0866E:  CALL   47E4
08672:  MOVFF  03,8E6
08676:  MOVFF  02,8E5
0867A:  MOVFF  01,8E4
0867E:  MOVFF  00,8E3
....................    // res = 1,000,000 
....................    enc_steps = enc_res / ports; 
08682:  BCF    FD8.1
08684:  CLRF   1B
08686:  BTFSC  FF2.7
08688:  BSF    1B.7
0868A:  BCF    FF2.7
0868C:  MOVFF  8E6,A4F
08690:  MOVFF  8E5,A4E
08694:  MOVFF  8E4,A4D
08698:  MOVFF  8E3,A4C
0869C:  MOVFF  8EE,A53
086A0:  MOVFF  8ED,A52
086A4:  MOVFF  8EC,A51
086A8:  MOVFF  8EB,A50
086AC:  CALL   104A
086B0:  BTFSC  1B.7
086B2:  BSF    FF2.7
086B4:  MOVFF  03,8DE
086B8:  MOVFF  02,8DD
086BC:  MOVFF  01,8DC
086C0:  MOVFF  00,8DB
....................    // steps = 1,000,000 / 48 
....................    //       = 20833 
....................    enc_target = (port * enc_steps) - enc_steps; 
086C4:  MOVFF  8DA,9F9
086C8:  MOVFF  8D9,9F8
086CC:  MOVFF  8D8,9F7
086D0:  MOVFF  8D7,9F6
086D4:  MOVFF  8DE,9FD
086D8:  MOVFF  8DD,9FC
086DC:  MOVFF  8DC,9FB
086E0:  MOVFF  8DB,9FA
086E4:  CALL   47E4
086E8:  MOVLB  8
086EA:  MOVF   xDB,W
086EC:  SUBWF  00,W
086EE:  MOVWF  xDF
086F0:  MOVF   xDC,W
086F2:  SUBWFB 01,W
086F4:  MOVWF  xE0
086F6:  MOVF   xDD,W
086F8:  SUBWFB 02,W
086FA:  MOVWF  xE1
086FC:  MOVF   xDE,W
086FE:  SUBWFB 03,W
08700:  MOVWF  xE2
....................    //     = (37 * 20833) - 20833 
....................    //     = 749,988 
....................    enc_pos = (enc_target / 1000);         // tail remainder 
08702:  BCF    FD8.1
08704:  CLRF   1B
08706:  BTFSC  FF2.7
08708:  BSF    1B.7
0870A:  BCF    FF2.7
0870C:  MOVFF  8E2,A4F
08710:  MOVFF  8E1,A4E
08714:  MOVFF  8E0,A4D
08718:  MOVFF  8DF,A4C
0871C:  MOVLB  A
0871E:  CLRF   x53
08720:  CLRF   x52
08722:  MOVLW  03
08724:  MOVWF  x51
08726:  MOVLW  E8
08728:  MOVWF  x50
0872A:  MOVLB  0
0872C:  CALL   104A
08730:  BTFSC  1B.7
08732:  BSF    FF2.7
08734:  MOVFF  03,8EA
08738:  MOVFF  02,8E9
0873C:  MOVFF  01,8E8
08740:  MOVFF  00,8E7
....................    //  = 749,988 / 1000 
....................    //  = 749 
....................    enc_pos = enc_pos * 1000;              // re-scaled up with remainder removed 
08744:  MOVFF  8EA,9F9
08748:  MOVFF  8E9,9F8
0874C:  MOVFF  8E8,9F7
08750:  MOVFF  8E7,9F6
08754:  MOVLB  9
08756:  CLRF   xFD
08758:  CLRF   xFC
0875A:  MOVLW  03
0875C:  MOVWF  xFB
0875E:  MOVLW  E8
08760:  MOVWF  xFA
08762:  MOVLB  0
08764:  CALL   47E4
08768:  MOVFF  03,8EA
0876C:  MOVFF  02,8E9
08770:  MOVFF  01,8E8
08774:  MOVFF  00,8E7
....................    //  = 749,000 
....................    enc_target = enc_target - enc_pos;     // calc scaled-up remainder 
08778:  MOVLB  8
0877A:  MOVF   xE7,W
0877C:  SUBWF  xDF,F
0877E:  MOVF   xE8,W
08780:  SUBWFB xE0,F
08782:  MOVF   xE9,W
08784:  SUBWFB xE1,F
08786:  MOVF   xEA,W
08788:  SUBWFB xE2,F
....................    //     = 749,988 - 749,000 
....................    //     = 988    
....................    enc_pos = enc_pos / 1000; 
0878A:  BCF    FD8.1
0878C:  CLRF   1B
0878E:  BTFSC  FF2.7
08790:  BSF    1B.7
08792:  BCF    FF2.7
08794:  MOVFF  8EA,A4F
08798:  MOVFF  8E9,A4E
0879C:  MOVFF  8E8,A4D
087A0:  MOVFF  8E7,A4C
087A4:  MOVLB  A
087A6:  CLRF   x53
087A8:  CLRF   x52
087AA:  MOVLW  03
087AC:  MOVWF  x51
087AE:  MOVLW  E8
087B0:  MOVWF  x50
087B2:  MOVLB  0
087B4:  CALL   104A
087B8:  BTFSC  1B.7
087BA:  BSF    FF2.7
087BC:  MOVFF  03,8EA
087C0:  MOVFF  02,8E9
087C4:  MOVFF  01,8E8
087C8:  MOVFF  00,8E7
....................    //  = 749,000 / 1000 
....................    //  = 749 
....................    if (enc_target > 499) enc_pos = ++enc_pos;  // where 500 = 0.500 step 
087CC:  MOVLB  8
087CE:  MOVF   xE2,F
087D0:  BNZ   87E6
087D2:  MOVF   xE1,F
087D4:  BNZ   87E6
087D6:  MOVF   xE0,W
087D8:  SUBLW  00
087DA:  BC    87F6
087DC:  XORLW  FF
087DE:  BNZ   87E6
087E0:  MOVF   xDF,W
087E2:  SUBLW  F3
087E4:  BC    87F6
087E6:  MOVLW  01
087E8:  ADDWF  xE7,F
087EA:  BTFSC  FD8.0
087EC:  INCF   xE8,F
087EE:  BTFSC  FD8.2
087F0:  INCF   xE9,F
087F2:  BTFSC  FD8.2
087F4:  INCF   xEA,F
....................    return(enc_pos); 
087F6:  MOVFF  8E7,00
087FA:  MOVFF  8E8,01
087FE:  MOVFF  8E9,02
08802:  MOVFF  8EA,03
08806:  MOVLB  0
08808:  GOTO   A170 (RETURN)
.................... } 
....................  
.................... int16 rel_enc_pos(int16 e_pos_a) 
.................... { 
....................    int16 e_pos_r; 
....................     
....................    if(e_pos_a > e_pos[motor]) 
0880C:  BCF    FD8.0
0880E:  MOVLB  7
08810:  RLCF   x40,W
08812:  CLRF   03
08814:  ADDLW  BF
08816:  MOVWF  FE9
08818:  MOVLW  07
0881A:  ADDWFC 03,W
0881C:  MOVWF  FEA
0881E:  MOVFF  FEC,03
08822:  MOVF   FED,F
08824:  MOVFF  FEF,01
08828:  MOVF   03,W
0882A:  MOVLB  8
0882C:  SUBWF  xDA,W
0882E:  BNC   88F6
08830:  BNZ   8838
08832:  MOVF   xD9,W
08834:  SUBWF  01,W
08836:  BC    88F6
....................    { 
....................       e_pos_r = e_pos_a - e_pos[motor]; 
08838:  BCF    FD8.0
0883A:  MOVLB  7
0883C:  RLCF   x40,W
0883E:  CLRF   03
08840:  ADDLW  BF
08842:  MOVWF  FE9
08844:  MOVLW  07
08846:  ADDWFC 03,W
08848:  MOVWF  FEA
0884A:  MOVFF  FEC,03
0884E:  MOVF   FED,F
08850:  MOVF   FEF,W
08852:  MOVLB  8
08854:  SUBWF  xD9,W
08856:  MOVWF  xDB
08858:  MOVF   03,W
0885A:  SUBWFB xDA,W
0885C:  MOVWF  xDC
....................       if (e_pos_r > (e_cpr[motor]/2)) 
0885E:  BCF    FD8.0
08860:  MOVLB  7
08862:  RLCF   x40,W
08864:  CLRF   03
08866:  ADDLW  5E
08868:  MOVWF  FE9
0886A:  MOVLW  07
0886C:  ADDWFC 03,W
0886E:  MOVWF  FEA
08870:  MOVFF  FEC,8DE
08874:  MOVF   FED,F
08876:  MOVFF  FEF,8DD
0887A:  BCF    FD8.0
0887C:  MOVLB  8
0887E:  RRCF   xDE,W
08880:  MOVWF  03
08882:  RRCF   xDD,W
08884:  MOVWF  02
08886:  MOVWF  01
08888:  MOVF   03,W
0888A:  SUBWF  xDC,W
0888C:  BNC   88DA
0888E:  BNZ   8896
08890:  MOVF   xDB,W
08892:  SUBWF  01,W
08894:  BC    88DA
....................       { 
....................          m_way[motor] = NEG; 
08896:  BCF    FD8.0
08898:  MOVLB  7
0889A:  RLCF   x40,W
0889C:  CLRF   03
0889E:  ADDLW  86
088A0:  MOVWF  FE9
088A2:  MOVLW  07
088A4:  ADDWFC 03,W
088A6:  MOVWF  FEA
088A8:  CLRF   FEC
088AA:  MOVF   FED,F
088AC:  MOVLW  01
088AE:  MOVWF  FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
088B0:  BCF    FD8.0
088B2:  RLCF   x40,W
088B4:  CLRF   03
088B6:  ADDLW  5E
088B8:  MOVWF  FE9
088BA:  MOVLW  07
088BC:  ADDWFC 03,W
088BE:  MOVWF  FEA
088C0:  MOVFF  FEC,8DE
088C4:  MOVF   FED,F
088C6:  MOVFF  FEF,8DD
088CA:  MOVLB  8
088CC:  MOVF   xDB,W
088CE:  SUBWF  xDD,W
088D0:  MOVWF  xDB
088D2:  MOVF   xDC,W
088D4:  SUBWFB xDE,W
088D6:  MOVWF  xDC
....................       } 
088D8:  BRA    88F4
....................       else 
....................       { 
....................          m_way[motor] = POS; 
088DA:  BCF    FD8.0
088DC:  MOVLB  7
088DE:  RLCF   x40,W
088E0:  CLRF   03
088E2:  ADDLW  86
088E4:  MOVWF  FE9
088E6:  MOVLW  07
088E8:  ADDWFC 03,W
088EA:  MOVWF  FEA
088EC:  CLRF   FEC
088EE:  MOVF   FED,F
088F0:  CLRF   FEF
088F2:  MOVLB  8
....................       } 
....................    } 
088F4:  BRA    89B6
....................    else 
....................    { 
....................       e_pos_r = e_pos[motor] - e_pos_a; 
088F6:  BCF    FD8.0
088F8:  MOVLB  7
088FA:  RLCF   x40,W
088FC:  CLRF   03
088FE:  ADDLW  BF
08900:  MOVWF  FE9
08902:  MOVLW  07
08904:  ADDWFC 03,W
08906:  MOVWF  FEA
08908:  MOVFF  FEC,8DE
0890C:  MOVF   FED,F
0890E:  MOVFF  FEF,8DD
08912:  MOVLB  8
08914:  MOVF   xD9,W
08916:  SUBWF  xDD,W
08918:  MOVWF  xDB
0891A:  MOVF   xDA,W
0891C:  SUBWFB xDE,W
0891E:  MOVWF  xDC
....................       if (e_pos_r > (e_cpr[motor]/2)) 
08920:  BCF    FD8.0
08922:  MOVLB  7
08924:  RLCF   x40,W
08926:  CLRF   03
08928:  ADDLW  5E
0892A:  MOVWF  FE9
0892C:  MOVLW  07
0892E:  ADDWFC 03,W
08930:  MOVWF  FEA
08932:  MOVFF  FEC,8DE
08936:  MOVF   FED,F
08938:  MOVFF  FEF,8DD
0893C:  BCF    FD8.0
0893E:  MOVLB  8
08940:  RRCF   xDE,W
08942:  MOVWF  03
08944:  RRCF   xDD,W
08946:  MOVWF  02
08948:  MOVWF  01
0894A:  MOVF   03,W
0894C:  SUBWF  xDC,W
0894E:  BNC   899A
08950:  BNZ   8958
08952:  MOVF   xDB,W
08954:  SUBWF  01,W
08956:  BC    899A
....................       { 
....................          m_way[motor] = POS; 
08958:  BCF    FD8.0
0895A:  MOVLB  7
0895C:  RLCF   x40,W
0895E:  CLRF   03
08960:  ADDLW  86
08962:  MOVWF  FE9
08964:  MOVLW  07
08966:  ADDWFC 03,W
08968:  MOVWF  FEA
0896A:  CLRF   FEC
0896C:  MOVF   FED,F
0896E:  CLRF   FEF
....................          e_pos_r = e_cpr[motor] - e_pos_r; 
08970:  BCF    FD8.0
08972:  RLCF   x40,W
08974:  CLRF   03
08976:  ADDLW  5E
08978:  MOVWF  FE9
0897A:  MOVLW  07
0897C:  ADDWFC 03,W
0897E:  MOVWF  FEA
08980:  MOVFF  FEC,8DE
08984:  MOVF   FED,F
08986:  MOVFF  FEF,8DD
0898A:  MOVLB  8
0898C:  MOVF   xDB,W
0898E:  SUBWF  xDD,W
08990:  MOVWF  xDB
08992:  MOVF   xDC,W
08994:  SUBWFB xDE,W
08996:  MOVWF  xDC
....................       } 
08998:  BRA    89B6
....................       else 
....................       { 
....................          m_way[motor] = NEG; 
0899A:  BCF    FD8.0
0899C:  MOVLB  7
0899E:  RLCF   x40,W
089A0:  CLRF   03
089A2:  ADDLW  86
089A4:  MOVWF  FE9
089A6:  MOVLW  07
089A8:  ADDWFC 03,W
089AA:  MOVWF  FEA
089AC:  CLRF   FEC
089AE:  MOVF   FED,F
089B0:  MOVLW  01
089B2:  MOVWF  FEF
089B4:  MOVLB  8
....................       } 
....................    } 
....................    return (e_pos_r); 
089B6:  MOVFF  8DB,01
089BA:  MOVFF  8DC,02
089BE:  MOVLB  0
089C0:  GOTO   A19C (RETURN)
.................... } 
....................  
.................... void terminate(int8 success) 
.................... { 
....................    m_running[motor] = FALSE; 
*
090C4:  BCF    FD8.0
090C6:  MOVLB  7
090C8:  RLCF   x40,W
090CA:  CLRF   03
090CC:  ADDLW  92
090CE:  MOVWF  FE9
090D0:  MOVLW  07
090D2:  ADDWFC 03,W
090D4:  MOVWF  FEA
090D6:  CLRF   FEC
090D8:  MOVF   FED,F
090DA:  CLRF   FEF
....................           
....................    switch (motor){ 
090DC:  MOVF   x40,W
090DE:  XORLW  00
090E0:  MOVLB  0
090E2:  BZ    90EA
090E4:  XORLW  01
090E6:  BZ    9154
090E8:  BRA    91C2
....................       case 0 :  
....................                if(m_pwm_hld[motor] > 0) set_pwm1_duty(m_pwm_hld[motor]); 
090EA:  BCF    FD8.0
090EC:  MOVLB  7
090EE:  RLCF   x40,W
090F0:  CLRF   03
090F2:  ADDLW  52
090F4:  MOVWF  FE9
090F6:  MOVLW  07
090F8:  ADDWFC 03,W
090FA:  MOVWF  FEA
090FC:  MOVFF  FEC,8ED
09100:  MOVF   FED,F
09102:  MOVFF  FEF,8EC
09106:  MOVLB  8
09108:  MOVF   xEC,F
0910A:  BNZ   9110
0910C:  MOVF   xED,F
0910E:  BZ    914E
09110:  BCF    FD8.0
09112:  MOVLB  7
09114:  RLCF   x40,W
09116:  CLRF   03
09118:  ADDLW  52
0911A:  MOVWF  FE9
0911C:  MOVLW  07
0911E:  ADDWFC 03,W
09120:  MOVWF  FEA
09122:  MOVFF  FEC,8ED
09126:  MOVF   FED,F
09128:  MOVFF  FEF,8EC
0912C:  MOVLB  8
0912E:  RRCF   xED,F
09130:  RRCF   xEC,F
09132:  RRCF   xED,F
09134:  RRCF   xEC,F
09136:  RRCF   xED,F
09138:  MOVFF  8EC,FBC
0913C:  RRCF   xED,F
0913E:  RRCF   xED,W
09140:  ANDLW  30
09142:  MOVWF  00
09144:  MOVF   FBB,W
09146:  ANDLW  CF
09148:  IORWF  00,W
0914A:  MOVWF  FBB
0914C:  BRA    9150
....................                else output_bit(M1_ENABLE, OFF); 
0914E:  BCF    F90.1
....................          break;   
09150:  MOVLB  0
09152:  BRA    91C2
....................       case 1 : 
....................                if(m_pwm_hld[motor] > 0) set_pwm2_duty(m_pwm_hld[motor]); 
09154:  BCF    FD8.0
09156:  MOVLB  7
09158:  RLCF   x40,W
0915A:  CLRF   03
0915C:  ADDLW  52
0915E:  MOVWF  FE9
09160:  MOVLW  07
09162:  ADDWFC 03,W
09164:  MOVWF  FEA
09166:  MOVFF  FEC,8ED
0916A:  MOVF   FED,F
0916C:  MOVFF  FEF,8EC
09170:  MOVLB  8
09172:  MOVF   xEC,F
09174:  BNZ   917A
09176:  MOVF   xED,F
09178:  BZ    91BC
0917A:  BCF    FD8.0
0917C:  MOVLB  7
0917E:  RLCF   x40,W
09180:  CLRF   03
09182:  ADDLW  52
09184:  MOVWF  FE9
09186:  MOVLW  07
09188:  ADDWFC 03,W
0918A:  MOVWF  FEA
0918C:  MOVFF  FEC,8ED
09190:  MOVF   FED,F
09192:  MOVFF  FEF,8EC
09196:  MOVLB  8
09198:  RRCF   xED,F
0919A:  RRCF   xEC,F
0919C:  RRCF   xED,F
0919E:  RRCF   xEC,F
091A0:  RRCF   xED,F
091A2:  MOVFF  8EC,F4F
091A6:  RRCF   xED,F
091A8:  RRCF   xED,W
091AA:  ANDLW  30
091AC:  MOVWF  00
091AE:  MOVLB  F
091B0:  MOVF   x4E,W
091B2:  ANDLW  CF
091B4:  IORWF  00,W
091B6:  MOVWF  x4E
091B8:  BRA    91C0
091BA:  MOVLB  8
....................                else output_bit(M2_ENABLE, OFF); 
091BC:  BCF    F8D.1
091BE:  MOVLB  F
....................          break; 
091C0:  MOVLB  0
....................    } 
....................  
....................    disable_interrupts(INT_TIMER3); 
091C2:  BCF    FA0.1
....................    enc_isr(OFF); 
091C4:  MOVLB  8
091C6:  CLRF   xEC
091C8:  MOVLB  0
091CA:  RCALL  8E0E
....................  
....................    if (m_pwm_hld[0]==0 && m_pwm_hld[1]==0) 
091CC:  MOVLB  7
091CE:  MOVF   x52,F
091D0:  BNZ   91E0
091D2:  MOVF   x53,F
091D4:  BNZ   91E0
091D6:  MOVF   x54,F
091D8:  BNZ   91E0
091DA:  MOVF   x55,F
091DC:  BNZ   91E0
....................    { 
....................       output_bit(VMOT,OFF); 
091DE:  BCF    F8E.1
....................    } 
....................  
....................    enc_pwr(OFF); 
091E0:  MOVLB  8
091E2:  CLRF   xEC
091E4:  MOVLB  0
091E6:  CALL   89C4
....................  
....................    if(success==TRUE) 
091EA:  MOVLB  8
091EC:  DECFSZ xEB,W
091EE:  BRA    938A
....................    { 
....................       m_error[motor]=FALSE; 
091F0:  BCF    FD8.0
091F2:  MOVLB  7
091F4:  RLCF   x40,W
091F6:  CLRF   03
091F8:  ADDLW  96
091FA:  MOVWF  FE9
091FC:  MOVLW  07
091FE:  ADDWFC 03,W
09200:  MOVWF  FEA
09202:  CLRF   FEC
09204:  MOVF   FED,F
09206:  CLRF   FEF
....................       wrt_m_error(); 
09208:  MOVLB  0
0920A:  RCALL  8F74
....................       // if aligning reset vars 
....................       if (e_mode[motor]==3) 
0920C:  BCF    FD8.0
0920E:  MOVLB  7
09210:  RLCF   x40,W
09212:  CLRF   03
09214:  ADDLW  66
09216:  MOVWF  FE9
09218:  MOVLW  07
0921A:  ADDWFC 03,W
0921C:  MOVWF  FEA
0921E:  MOVFF  FEC,8ED
09222:  MOVF   FED,F
09224:  MOVFF  FEF,8EC
09228:  MOVLB  8
0922A:  MOVF   xEC,W
0922C:  SUBLW  03
0922E:  BNZ   9266
09230:  MOVF   xED,F
09232:  BNZ   9266
....................       { 
....................          e_pos[motor] = 0; 
09234:  BCF    FD8.0
09236:  MOVLB  7
09238:  RLCF   x40,W
0923A:  CLRF   03
0923C:  ADDLW  BF
0923E:  MOVWF  FE9
09240:  MOVLW  07
09242:  ADDWFC 03,W
09244:  MOVWF  FEA
09246:  CLRF   FEC
09248:  MOVF   FED,F
0924A:  CLRF   FEF
....................          e_port[motor] = 1; 
0924C:  BCF    FD8.0
0924E:  RLCF   x40,W
09250:  CLRF   03
09252:  ADDLW  C3
09254:  MOVWF  FE9
09256:  MOVLW  07
09258:  ADDWFC 03,W
0925A:  MOVWF  FEA
0925C:  CLRF   FEC
0925E:  MOVF   FED,F
09260:  MOVLW  01
09262:  MOVWF  FEF
09264:  MOVLB  8
....................       } 
....................       // if normal move update port 
....................       if (e_mode[motor]==2) 
09266:  BCF    FD8.0
09268:  MOVLB  7
0926A:  RLCF   x40,W
0926C:  CLRF   03
0926E:  ADDLW  66
09270:  MOVWF  FE9
09272:  MOVLW  07
09274:  ADDWFC 03,W
09276:  MOVWF  FEA
09278:  MOVFF  FEC,8ED
0927C:  MOVF   FED,F
0927E:  MOVFF  FEF,8EC
09282:  MOVLB  8
09284:  MOVF   xEC,W
09286:  SUBLW  02
09288:  BNZ   92D4
0928A:  MOVF   xED,F
0928C:  BNZ   92D4
....................       { 
....................          e_port[motor] = e_target_port[motor]; 
0928E:  BCF    FD8.0
09290:  MOVLB  7
09292:  RLCF   x40,W
09294:  CLRF   03
09296:  ADDLW  C3
09298:  MOVWF  01
0929A:  MOVLW  07
0929C:  ADDWFC 03,F
0929E:  MOVLB  8
092A0:  MOVFF  03,8ED
092A4:  BCF    FD8.0
092A6:  MOVLB  7
092A8:  RLCF   x40,W
092AA:  CLRF   03
092AC:  ADDLW  C7
092AE:  MOVWF  FE9
092B0:  MOVLW  07
092B2:  ADDWFC 03,W
092B4:  MOVWF  FEA
092B6:  MOVFF  FEC,03
092BA:  MOVF   FED,F
092BC:  MOVFF  FEF,8EE
092C0:  MOVLB  8
092C2:  MOVFF  8ED,FEA
092C6:  MOVFF  01,FE9
092CA:  MOVFF  03,FEC
092CE:  MOVF   FED,F
092D0:  MOVFF  8EE,FEF
....................       } 
....................       // write to memory 
....................       if(e_mode[motor]==2 || e_mode[motor]==3) 
092D4:  BCF    FD8.0
092D6:  MOVLB  7
092D8:  RLCF   x40,W
092DA:  CLRF   03
092DC:  ADDLW  66
092DE:  MOVWF  FE9
092E0:  MOVLW  07
092E2:  ADDWFC 03,W
092E4:  MOVWF  FEA
092E6:  MOVFF  FEC,8ED
092EA:  MOVF   FED,F
092EC:  MOVFF  FEF,8EC
092F0:  MOVLB  8
092F2:  MOVF   xEC,W
092F4:  SUBLW  02
092F6:  BNZ   92FC
092F8:  MOVF   xED,F
092FA:  BZ    9324
092FC:  BCF    FD8.0
092FE:  MOVLB  7
09300:  RLCF   x40,W
09302:  CLRF   03
09304:  ADDLW  66
09306:  MOVWF  FE9
09308:  MOVLW  07
0930A:  ADDWFC 03,W
0930C:  MOVWF  FEA
0930E:  MOVFF  FEC,8ED
09312:  MOVF   FED,F
09314:  MOVFF  FEF,8EC
09318:  MOVLB  8
0931A:  MOVF   xEC,W
0931C:  SUBLW  03
0931E:  BNZ   9388
09320:  MOVF   xED,F
09322:  BNZ   9388
....................       { 
....................          switch(motor) 
09324:  MOVLB  7
09326:  MOVF   x40,W
09328:  XORLW  00
0932A:  MOVLB  0
0932C:  BZ    9334
0932E:  XORLW  01
09330:  BZ    935E
09332:  BRA    9386
....................          { 
....................             case 0 : write16(ADDR_E1_POS, e_pos[0]); 
09334:  MOVLW  7E
09336:  MOVLB  8
09338:  MOVWF  xEE
0933A:  MOVFF  7C0,8F0
0933E:  MOVFF  7BF,8EF
09342:  MOVLB  0
09344:  CALL   4FC8
....................                      write16(ADDR_E1_PORT,e_port[0]); 
09348:  MOVLW  AA
0934A:  MOVLB  8
0934C:  MOVWF  xEE
0934E:  MOVFF  7C4,8F0
09352:  MOVFF  7C3,8EF
09356:  MOVLB  0
09358:  CALL   4FC8
....................                break; 
0935C:  BRA    9386
....................             case 1 : write16(ADDR_E2_POS, e_pos[1]); 
0935E:  MOVLW  80
09360:  MOVLB  8
09362:  MOVWF  xEE
09364:  MOVFF  7C2,8F0
09368:  MOVFF  7C1,8EF
0936C:  MOVLB  0
0936E:  CALL   4FC8
....................                      write16(ADDR_E2_PORT,e_port[1]); 
09372:  MOVLW  AC
09374:  MOVLB  8
09376:  MOVWF  xEE
09378:  MOVFF  7C6,8F0
0937C:  MOVFF  7C5,8EF
09380:  MOVLB  0
09382:  CALL   4FC8
....................                break;             
09386:  MOVLB  8
....................          } 
....................       } 
....................    } 
09388:  BRA    9432
....................    else 
....................    { 
....................       m_error[motor]=TRUE; 
0938A:  BCF    FD8.0
0938C:  MOVLB  7
0938E:  RLCF   x40,W
09390:  CLRF   03
09392:  ADDLW  96
09394:  MOVWF  FE9
09396:  MOVLW  07
09398:  ADDWFC 03,W
0939A:  MOVWF  FEA
0939C:  CLRF   FEC
0939E:  MOVF   FED,F
093A0:  MOVLW  01
093A2:  MOVWF  FEF
....................       e_pos[motor] = 0; 
093A4:  BCF    FD8.0
093A6:  RLCF   x40,W
093A8:  CLRF   03
093AA:  ADDLW  BF
093AC:  MOVWF  FE9
093AE:  MOVLW  07
093B0:  ADDWFC 03,W
093B2:  MOVWF  FEA
093B4:  CLRF   FEC
093B6:  MOVF   FED,F
093B8:  CLRF   FEF
....................       e_port[motor] = 0; 
093BA:  BCF    FD8.0
093BC:  RLCF   x40,W
093BE:  CLRF   03
093C0:  ADDLW  C3
093C2:  MOVWF  FE9
093C4:  MOVLW  07
093C6:  ADDWFC 03,W
093C8:  MOVWF  FEA
093CA:  CLRF   FEC
093CC:  MOVF   FED,F
093CE:  CLRF   FEF
....................       switch(motor) 
093D0:  MOVF   x40,W
093D2:  XORLW  00
093D4:  MOVLB  0
093D6:  BZ    93DE
093D8:  XORLW  01
093DA:  BZ    9408
093DC:  BRA    9430
....................       { 
....................          case 0 : write16(ADDR_E1_POS, e_pos[0]); 
093DE:  MOVLW  7E
093E0:  MOVLB  8
093E2:  MOVWF  xEE
093E4:  MOVFF  7C0,8F0
093E8:  MOVFF  7BF,8EF
093EC:  MOVLB  0
093EE:  CALL   4FC8
....................                   write16(ADDR_E1_PORT,e_port[0]); 
093F2:  MOVLW  AA
093F4:  MOVLB  8
093F6:  MOVWF  xEE
093F8:  MOVFF  7C4,8F0
093FC:  MOVFF  7C3,8EF
09400:  MOVLB  0
09402:  CALL   4FC8
....................             break; 
09406:  BRA    9430
....................          case 1 : write16(ADDR_E2_POS, e_pos[1]); 
09408:  MOVLW  80
0940A:  MOVLB  8
0940C:  MOVWF  xEE
0940E:  MOVFF  7C2,8F0
09412:  MOVFF  7C1,8EF
09416:  MOVLB  0
09418:  CALL   4FC8
....................                   write16(ADDR_E2_PORT,e_port[1]); 
0941C:  MOVLW  AC
0941E:  MOVLB  8
09420:  MOVWF  xEE
09422:  MOVFF  7C6,8F0
09426:  MOVFF  7C5,8EF
0942A:  MOVLB  0
0942C:  CALL   4FC8
....................             break;             
09430:  MOVLB  8
....................       } 
....................    } 
....................     
....................    m_comp[motor]=TRUE; 
09432:  BCF    FD8.0
09434:  MOVLB  7
09436:  RLCF   x40,W
09438:  CLRF   03
0943A:  ADDLW  AF
0943C:  MOVWF  FE9
0943E:  MOVLW  07
09440:  ADDWFC 03,W
09442:  MOVWF  FEA
09444:  CLRF   FEC
09446:  MOVF   FED,F
09448:  MOVLW  01
0944A:  MOVWF  FEF
....................     
....................    switch (motor) 
0944C:  MOVF   x40,W
0944E:  XORLW  00
09450:  MOVLB  0
09452:  BZ    945A
09454:  XORLW  01
09456:  BZ    9482
09458:  BRA    94A8
....................    { 
....................       case 0 : write16(ADDR_M1_COMP,TRUE);  
0945A:  MOVLW  B2
0945C:  MOVLB  8
0945E:  MOVWF  xEE
09460:  CLRF   xF0
09462:  MOVLW  01
09464:  MOVWF  xEF
09466:  MOVLB  0
09468:  CALL   4FC8
....................                write16(ADDR_M1_LIN_POS, m_lin_pos[0]); 
0946C:  MOVLW  B6
0946E:  MOVLB  8
09470:  MOVWF  xEE
09472:  MOVFF  7B4,8F0
09476:  MOVFF  7B3,8EF
0947A:  MOVLB  0
0947C:  CALL   4FC8
....................          break; 
09480:  BRA    94A8
....................       case 1 : write16(ADDR_M2_COMP,TRUE); 
09482:  MOVLW  B4
09484:  MOVLB  8
09486:  MOVWF  xEE
09488:  CLRF   xF0
0948A:  MOVLW  01
0948C:  MOVWF  xEF
0948E:  MOVLB  0
09490:  CALL   4FC8
....................                write16(ADDR_M2_LIN_POS, m_lin_pos[1]); 
09494:  MOVLW  B8
09496:  MOVLB  8
09498:  MOVWF  xEE
0949A:  MOVFF  7B6,8F0
0949E:  MOVFF  7B5,8EF
094A2:  MOVLB  0
094A4:  CALL   4FC8
....................          break; 
....................    } 
....................     
....................    if (nv_report_mode==4) 
094A8:  MOVF   1F,W
094AA:  SUBLW  04
094AC:  BNZ   9552
094AE:  MOVF   20,F
094B0:  BNZ   9552
....................    { 
....................       if(motor==1) 
094B2:  MOVLB  7
094B4:  DECFSZ x40,W
094B6:  BRA    9554
....................       { 
....................          fprintf(COM_A, "@LPC,%Lu,%Ld\r\n", m_comp[motor],m_lin_pos[motor]); 
094B8:  BCF    FD8.0
094BA:  RLCF   x40,W
094BC:  CLRF   03
094BE:  ADDLW  AF
094C0:  MOVWF  FE9
094C2:  MOVLW  07
094C4:  ADDWFC 03,W
094C6:  MOVWF  FEA
094C8:  MOVFF  FEC,8ED
094CC:  MOVF   FED,F
094CE:  MOVFF  FEF,8EC
094D2:  BCF    FD8.0
094D4:  RLCF   x40,W
094D6:  CLRF   03
094D8:  ADDLW  B3
094DA:  MOVWF  FE9
094DC:  MOVLW  07
094DE:  ADDWFC 03,W
094E0:  MOVWF  FEA
094E2:  MOVFF  FEC,8EF
094E6:  MOVF   FED,F
094E8:  MOVFF  FEF,8EE
094EC:  MOVLW  52
094EE:  MOVWF  FF6
094F0:  MOVLW  1A
094F2:  MOVWF  FF7
094F4:  MOVLW  00
094F6:  MOVWF  FF8
094F8:  CLRF   1B
094FA:  BTFSC  FF2.7
094FC:  BSF    1B.7
094FE:  BCF    FF2.7
09500:  MOVLW  05
09502:  MOVLB  A
09504:  MOVWF  x40
09506:  MOVLB  0
09508:  CALL   1018
0950C:  BTFSC  1B.7
0950E:  BSF    FF2.7
09510:  MOVLW  10
09512:  MOVWF  FE9
09514:  CLRF   1B
09516:  BTFSC  FF2.7
09518:  BSF    1B.7
0951A:  BCF    FF2.7
0951C:  MOVFF  8ED,A41
09520:  MOVFF  8EC,A40
09524:  CALL   119A
09528:  BTFSC  1B.7
0952A:  BSF    FF2.7
0952C:  MOVLW  2C
0952E:  BTFSS  F9E.4
09530:  BRA    952E
09532:  MOVWF  FAD
09534:  MOVLW  10
09536:  MOVWF  FE9
09538:  MOVFF  8EF,8F1
0953C:  MOVFF  8EE,8F0
09540:  RCALL  8FD8
09542:  MOVLW  0D
09544:  BTFSS  F9E.4
09546:  BRA    9544
09548:  MOVWF  FAD
0954A:  MOVLW  0A
0954C:  BTFSS  F9E.4
0954E:  BRA    954C
09550:  MOVWF  FAD
09552:  MOVLB  7
....................       } 
....................    } 
09554:  MOVLB  0
09556:  RETURN 0
.................... } 
....................  
.................... int32 end_move(int32 steps, int16 e_port_dist) 
.................... { 
....................    int32 m_edge_pnt; 
....................    signed int32 m_pul; 
....................    signed int32 m_pll;     // motor pulse upper limit & lower limit 
....................     
....................    // hi-res quad 
....................    if (e_type[motor]==1) terminate(1); 
*
09684:  BCF    FD8.0
09686:  MOVLB  7
09688:  RLCF   x40,W
0968A:  CLRF   03
0968C:  ADDLW  6A
0968E:  MOVWF  FE9
09690:  MOVLW  07
09692:  ADDWFC 03,W
09694:  MOVWF  FEA
09696:  MOVFF  FEC,8EC
0969A:  MOVF   FED,F
0969C:  MOVFF  FEF,8EB
096A0:  MOVLB  8
096A2:  DECFSZ xEB,W
096A4:  BRA    96B4
096A6:  MOVF   xEC,F
096A8:  BNZ   96B4
096AA:  MOVLW  01
096AC:  MOVWF  xEB
096AE:  MOVLB  0
096B0:  RCALL  90C4
096B2:  MOVLB  8
....................    // slotted disk 
....................    if (e_type[motor]==2) { 
096B4:  BCF    FD8.0
096B6:  MOVLB  7
096B8:  RLCF   x40,W
096BA:  CLRF   03
096BC:  ADDLW  6A
096BE:  MOVWF  FE9
096C0:  MOVLW  07
096C2:  ADDWFC 03,W
096C4:  MOVWF  FEA
096C6:  MOVFF  FEC,8EC
096CA:  MOVF   FED,F
096CC:  MOVFF  FEF,8EB
096D0:  MOVLB  8
096D2:  MOVF   xEB,W
096D4:  SUBLW  02
096D6:  BTFSS  FD8.2
096D8:  BRA    9CE2
096DA:  MOVF   xEC,F
096DC:  BTFSS  FD8.2
096DE:  BRA    9CE2
....................       if (e_mode[motor]==2){ 
096E0:  BCF    FD8.0
096E2:  MOVLB  7
096E4:  RLCF   x40,W
096E6:  CLRF   03
096E8:  ADDLW  66
096EA:  MOVWF  FE9
096EC:  MOVLW  07
096EE:  ADDWFC 03,W
096F0:  MOVWF  FEA
096F2:  MOVFF  FEC,8EC
096F6:  MOVF   FED,F
096F8:  MOVFF  FEF,8EB
096FC:  MOVLB  8
096FE:  MOVF   xEB,W
09700:  SUBLW  02
09702:  BTFSS  FD8.2
09704:  BRA    9C5E
09706:  MOVF   xEC,F
09708:  BTFSS  FD8.2
0970A:  BRA    9C5E
....................          if(nv_product==ECO || nv_product==WMS2){ 
0970C:  MOVF   2F,F
0970E:  BNZ   9714
09710:  MOVF   30,F
09712:  BZ    9722
09714:  MOVF   2F,W
09716:  SUBLW  03
09718:  BTFSS  FD8.2
0971A:  BRA    9866
0971C:  MOVF   30,F
0971E:  BTFSS  FD8.2
09720:  BRA    9866
....................             m_pul = ((m_ppp[motor]*steps)+(m_ppp[motor]/2)); 
09722:  BCF    FD8.0
09724:  MOVLB  7
09726:  RLCF   x40,W
09728:  CLRF   03
0972A:  ADDLW  AB
0972C:  MOVWF  FE9
0972E:  MOVLW  07
09730:  ADDWFC 03,W
09732:  MOVWF  FEA
09734:  MOVFF  FEC,9F7
09738:  MOVF   FED,F
0973A:  MOVFF  FEF,9F6
0973E:  MOVFF  FEA,8EE
09742:  MOVFF  FE9,8ED
09746:  MOVLB  9
09748:  CLRF   xF9
0974A:  CLRF   xF8
0974C:  MOVFF  8DC,9FD
09750:  MOVFF  8DB,9FC
09754:  MOVFF  8DA,9FB
09758:  MOVFF  8D9,9FA
0975C:  MOVLB  0
0975E:  CALL   47E4
09762:  MOVFF  8EE,FEA
09766:  MOVFF  8ED,FE9
0976A:  MOVFF  03,8EE
0976E:  MOVFF  02,8ED
09772:  MOVFF  01,8EC
09776:  MOVFF  00,8EB
0977A:  BCF    FD8.0
0977C:  MOVLB  7
0977E:  RLCF   x40,W
09780:  CLRF   03
09782:  ADDLW  AB
09784:  MOVWF  FE9
09786:  MOVLW  07
09788:  ADDWFC 03,W
0978A:  MOVWF  FEA
0978C:  MOVFF  FEC,8F0
09790:  MOVF   FED,F
09792:  MOVFF  FEF,8EF
09796:  BCF    FD8.0
09798:  MOVLB  8
0979A:  RRCF   xF0,W
0979C:  MOVWF  03
0979E:  RRCF   xEF,W
097A0:  MOVWF  02
097A2:  ADDWF  00,W
097A4:  MOVWF  00
097A6:  MOVF   03,W
097A8:  ADDWFC 01,W
097AA:  MOVWF  01
097AC:  MOVLW  00
097AE:  ADDWFC xED,W
097B0:  MOVWF  02
097B2:  MOVLW  00
097B4:  ADDWFC xEE,W
097B6:  MOVWF  xE6
097B8:  MOVFF  02,8E5
097BC:  MOVFF  01,8E4
097C0:  MOVFF  00,8E3
....................             m_pll = ((m_ppp[motor]*steps)-(m_ppp[motor]/2)); 
097C4:  BCF    FD8.0
097C6:  MOVLB  7
097C8:  RLCF   x40,W
097CA:  CLRF   03
097CC:  ADDLW  AB
097CE:  MOVWF  FE9
097D0:  MOVLW  07
097D2:  ADDWFC 03,W
097D4:  MOVWF  FEA
097D6:  MOVFF  FEC,9F7
097DA:  MOVF   FED,F
097DC:  MOVFF  FEF,9F6
097E0:  MOVFF  FEA,8EE
097E4:  MOVFF  FE9,8ED
097E8:  MOVLB  9
097EA:  CLRF   xF9
097EC:  CLRF   xF8
097EE:  MOVFF  8DC,9FD
097F2:  MOVFF  8DB,9FC
097F6:  MOVFF  8DA,9FB
097FA:  MOVFF  8D9,9FA
097FE:  MOVLB  0
09800:  CALL   47E4
09804:  MOVFF  8EE,FEA
09808:  MOVFF  8ED,FE9
0980C:  MOVFF  03,8EE
09810:  MOVFF  02,8ED
09814:  MOVFF  01,8EC
09818:  MOVFF  00,8EB
0981C:  BCF    FD8.0
0981E:  MOVLB  7
09820:  RLCF   x40,W
09822:  CLRF   03
09824:  ADDLW  AB
09826:  MOVWF  FE9
09828:  MOVLW  07
0982A:  ADDWFC 03,W
0982C:  MOVWF  FEA
0982E:  MOVFF  FEC,8F0
09832:  MOVF   FED,F
09834:  MOVFF  FEF,8EF
09838:  BCF    FD8.0
0983A:  MOVLB  8
0983C:  RRCF   xF0,W
0983E:  MOVWF  03
09840:  RRCF   xEF,W
09842:  MOVWF  02
09844:  SUBWF  00,W
09846:  MOVWF  00
09848:  MOVF   03,W
0984A:  SUBWFB 01,W
0984C:  MOVWF  01
0984E:  MOVLW  00
09850:  SUBWFB xED,W
09852:  MOVWF  02
09854:  MOVLW  00
09856:  SUBWFB xEE,W
09858:  MOVWF  xEA
0985A:  MOVFF  02,8E9
0985E:  MOVFF  01,8E8
09862:  MOVFF  00,8E7
....................          } 
....................          if (nv_product==WMS4){ 
09866:  DECFSZ 2F,W
09868:  BRA    9A80
0986A:  MOVF   30,F
0986C:  BTFSS  FD8.2
0986E:  BRA    9A80
....................             if (end_even_port==FALSE){ 
09870:  MOVLB  2
09872:  MOVF   xDB,F
09874:  BNZ   996A
....................                m_pul = ((m_ppp[motor]*e_port_dist)+(m_ppp[motor]/2)); 
09876:  BCF    FD8.0
09878:  MOVLB  7
0987A:  RLCF   x40,W
0987C:  CLRF   03
0987E:  ADDLW  AB
09880:  MOVWF  FE9
09882:  MOVLW  07
09884:  ADDWFC 03,W
09886:  MOVWF  FEA
09888:  MOVFF  FEC,A11
0988C:  MOVF   FED,F
0988E:  MOVFF  FEF,A10
09892:  MOVFF  8DE,A13
09896:  MOVFF  8DD,A12
0989A:  MOVLB  0
0989C:  CALL   5C8C
098A0:  MOVFF  02,8EC
098A4:  MOVFF  01,8EB
098A8:  BCF    FD8.0
098AA:  MOVLB  7
098AC:  RLCF   x40,W
098AE:  CLRF   03
098B0:  ADDLW  AB
098B2:  MOVWF  FE9
098B4:  MOVLW  07
098B6:  ADDWFC 03,W
098B8:  MOVWF  FEA
098BA:  MOVFF  FEC,8EE
098BE:  MOVF   FED,F
098C0:  MOVFF  FEF,8ED
098C4:  BCF    FD8.0
098C6:  MOVLB  8
098C8:  RRCF   xEE,W
098CA:  MOVWF  03
098CC:  RRCF   xED,W
098CE:  MOVWF  02
098D0:  ADDWF  01,W
098D2:  MOVWF  01
098D4:  MOVF   xEC,W
098D6:  ADDWFC 03,F
098D8:  MOVFF  01,8E3
098DC:  MOVFF  03,8E4
098E0:  CLRF   02
098E2:  CLRF   03
098E4:  MOVFF  03,8E6
098E8:  MOVFF  02,8E5
....................                m_pll = ((m_ppp[motor]*e_port_dist)-(m_ppp[motor]/2));    
098EC:  BCF    FD8.0
098EE:  MOVLB  7
098F0:  RLCF   x40,W
098F2:  CLRF   03
098F4:  ADDLW  AB
098F6:  MOVWF  FE9
098F8:  MOVLW  07
098FA:  ADDWFC 03,W
098FC:  MOVWF  FEA
098FE:  MOVFF  FEC,A11
09902:  MOVF   FED,F
09904:  MOVFF  FEF,A10
09908:  MOVFF  8DE,A13
0990C:  MOVFF  8DD,A12
09910:  MOVLB  0
09912:  CALL   5C8C
09916:  MOVFF  02,8EC
0991A:  MOVFF  01,8EB
0991E:  BCF    FD8.0
09920:  MOVLB  7
09922:  RLCF   x40,W
09924:  CLRF   03
09926:  ADDLW  AB
09928:  MOVWF  FE9
0992A:  MOVLW  07
0992C:  ADDWFC 03,W
0992E:  MOVWF  FEA
09930:  MOVFF  FEC,8EE
09934:  MOVF   FED,F
09936:  MOVFF  FEF,8ED
0993A:  BCF    FD8.0
0993C:  MOVLB  8
0993E:  RRCF   xEE,W
09940:  MOVWF  03
09942:  RRCF   xED,W
09944:  MOVWF  02
09946:  SUBWF  01,W
09948:  MOVWF  00
0994A:  MOVF   03,W
0994C:  SUBWFB xEC,W
0994E:  MOVWF  03
09950:  MOVF   00,W
09952:  MOVFF  03,8E8
09956:  CLRF   02
09958:  CLRF   03
0995A:  MOVFF  03,8EA
0995E:  MOVFF  02,8E9
09962:  MOVFF  00,8E7
....................             } 
09966:  BRA    9A80
09968:  MOVLB  2
....................             else if (end_even_port==TRUE){ 
0996A:  DECFSZ xDB,W
0996C:  BRA    9A82
....................                m_pul = ((m_ppp[motor]*(e_port_dist-1))+(m_ppp[motor]/2)); 
0996E:  BCF    FD8.0
09970:  MOVLB  7
09972:  RLCF   x40,W
09974:  CLRF   03
09976:  ADDLW  AB
09978:  MOVWF  FE9
0997A:  MOVLW  07
0997C:  ADDWFC 03,W
0997E:  MOVWF  FEA
09980:  MOVFF  FEC,A11
09984:  MOVF   FED,F
09986:  MOVFF  FEF,A10
0998A:  MOVLW  01
0998C:  MOVLB  8
0998E:  SUBWF  xDD,W
09990:  MOVWF  00
09992:  MOVLW  00
09994:  SUBWFB xDE,W
09996:  MOVWF  03
09998:  MOVFF  00,8ED
0999C:  MOVWF  xEE
0999E:  MOVFF  FE8,A13
099A2:  MOVFF  00,A12
099A6:  MOVLB  0
099A8:  CALL   5C8C
099AC:  MOVFF  02,8EC
099B0:  MOVFF  01,8EB
099B4:  BCF    FD8.0
099B6:  MOVLB  7
099B8:  RLCF   x40,W
099BA:  CLRF   03
099BC:  ADDLW  AB
099BE:  MOVWF  FE9
099C0:  MOVLW  07
099C2:  ADDWFC 03,W
099C4:  MOVWF  FEA
099C6:  MOVFF  FEC,8EE
099CA:  MOVF   FED,F
099CC:  MOVFF  FEF,8ED
099D0:  BCF    FD8.0
099D2:  MOVLB  8
099D4:  RRCF   xEE,W
099D6:  MOVWF  03
099D8:  RRCF   xED,W
099DA:  MOVWF  02
099DC:  ADDWF  01,W
099DE:  MOVWF  01
099E0:  MOVF   xEC,W
099E2:  ADDWFC 03,F
099E4:  MOVFF  01,8E3
099E8:  MOVFF  03,8E4
099EC:  CLRF   02
099EE:  CLRF   03
099F0:  MOVFF  03,8E6
099F4:  MOVFF  02,8E5
....................                m_pll = (m_ppp[motor]*(e_port_dist-1)); 
099F8:  BCF    FD8.0
099FA:  MOVLB  7
099FC:  RLCF   x40,W
099FE:  CLRF   03
09A00:  ADDLW  AB
09A02:  MOVWF  FE9
09A04:  MOVLW  07
09A06:  ADDWFC 03,W
09A08:  MOVWF  FEA
09A0A:  MOVFF  FEC,A11
09A0E:  MOVF   FED,F
09A10:  MOVFF  FEF,A10
09A14:  MOVLW  01
09A16:  MOVLB  8
09A18:  SUBWF  xDD,W
09A1A:  MOVWF  00
09A1C:  MOVLW  00
09A1E:  SUBWFB xDE,W
09A20:  MOVWF  03
09A22:  MOVFF  00,8ED
09A26:  MOVWF  xEE
09A28:  MOVFF  FE8,A13
09A2C:  MOVFF  00,A12
09A30:  MOVLB  0
09A32:  CALL   5C8C
09A36:  MOVFF  02,03
09A3A:  MOVFF  01,8E7
09A3E:  MOVFF  02,8E8
09A42:  CLRF   02
09A44:  CLRF   03
09A46:  MOVFF  03,8EA
09A4A:  MOVFF  02,8E9
....................                m_pll = m_pll -(m_ppp[motor]/2); 
09A4E:  BCF    FD8.0
09A50:  MOVLB  7
09A52:  RLCF   x40,W
09A54:  CLRF   03
09A56:  ADDLW  AB
09A58:  MOVWF  FE9
09A5A:  MOVLW  07
09A5C:  ADDWFC 03,W
09A5E:  MOVWF  FEA
09A60:  MOVFF  FEC,8EC
09A64:  MOVF   FED,F
09A66:  MOVFF  FEF,8EB
09A6A:  BCF    FD8.0
09A6C:  MOVLB  8
09A6E:  RRCF   xEC,W
09A70:  MOVWF  03
09A72:  RRCF   xEB,W
09A74:  SUBWF  xE7,F
09A76:  MOVF   03,W
09A78:  SUBWFB xE8,F
09A7A:  MOVLW  00
09A7C:  SUBWFB xE9,F
09A7E:  SUBWFB xEA,F
09A80:  MOVLB  2
....................             } 
....................          } 
....................          if (m_step_cnt[motor] > m_pul || m_step_cnt[motor] < m_pll){ 
09A82:  MOVLB  7
09A84:  MOVF   x40,W
09A86:  MULLW  04
09A88:  MOVF   FF3,W
09A8A:  CLRF   03
09A8C:  ADDLW  A2
09A8E:  MOVWF  FE9
09A90:  MOVLW  07
09A92:  ADDWFC 03,W
09A94:  MOVWF  FEA
09A96:  MOVFF  FEF,8EB
09A9A:  MOVFF  FEC,8EC
09A9E:  MOVFF  FEC,8ED
09AA2:  MOVFF  FEC,8EE
09AA6:  MOVLB  8
09AA8:  BTFSC  xE6.7
09AAA:  BRA    9B1A
09AAC:  MOVF   xE6,W
09AAE:  SUBWF  xEE,W
09AB0:  BNC   9ACA
09AB2:  BNZ   9B1A
09AB4:  MOVF   xE5,W
09AB6:  SUBWF  xED,W
09AB8:  BNC   9ACA
09ABA:  BNZ   9B1A
09ABC:  MOVF   xE4,W
09ABE:  SUBWF  xEC,W
09AC0:  BNC   9ACA
09AC2:  BNZ   9B1A
09AC4:  MOVF   xEB,W
09AC6:  SUBWF  xE3,W
09AC8:  BNC   9B1A
09ACA:  MOVLB  7
09ACC:  MOVF   x40,W
09ACE:  MULLW  04
09AD0:  MOVF   FF3,W
09AD2:  CLRF   03
09AD4:  ADDLW  A2
09AD6:  MOVWF  FE9
09AD8:  MOVLW  07
09ADA:  ADDWFC 03,W
09ADC:  MOVWF  FEA
09ADE:  MOVFF  FEF,8EB
09AE2:  MOVFF  FEC,8EC
09AE6:  MOVFF  FEC,8ED
09AEA:  MOVFF  FEC,8EE
09AEE:  MOVLB  8
09AF0:  BTFSC  xEA.7
09AF2:  BRA    9C5E
09AF4:  MOVF   xEE,W
09AF6:  SUBWF  xEA,W
09AF8:  BTFSS  FD8.0
09AFA:  BRA    9C5E
09AFC:  BNZ   9B1A
09AFE:  MOVF   xED,W
09B00:  SUBWF  xE9,W
09B02:  BTFSS  FD8.0
09B04:  BRA    9C5E
09B06:  BNZ   9B1A
09B08:  MOVF   xEC,W
09B0A:  SUBWF  xE8,W
09B0C:  BTFSS  FD8.0
09B0E:  BRA    9C5E
09B10:  BNZ   9B1A
09B12:  MOVF   xE7,W
09B14:  SUBWF  xEB,W
09B16:  BTFSC  FD8.0
09B18:  BRA    9C5E
....................             fprintf(COM_A, "@MME,%u,%Ld,%Lu,%Lu,%Ld,%Ld\r\n",motor+1,steps,m_ppp[motor],m_step_cnt[motor],m_pul,m_pll); 
09B1A:  MOVLW  01
09B1C:  MOVLB  7
09B1E:  ADDWF  x40,W
09B20:  MOVLB  8
09B22:  MOVWF  xEB
09B24:  BCF    FD8.0
09B26:  MOVLB  7
09B28:  RLCF   x40,W
09B2A:  CLRF   03
09B2C:  ADDLW  AB
09B2E:  MOVWF  FE9
09B30:  MOVLW  07
09B32:  ADDWFC 03,W
09B34:  MOVWF  FEA
09B36:  MOVFF  FEC,8ED
09B3A:  MOVF   FED,F
09B3C:  MOVFF  FEF,8EC
09B40:  MOVF   x40,W
09B42:  MULLW  04
09B44:  MOVF   FF3,W
09B46:  CLRF   03
09B48:  ADDLW  A2
09B4A:  MOVWF  FE9
09B4C:  MOVLW  07
09B4E:  ADDWFC 03,W
09B50:  MOVWF  FEA
09B52:  MOVFF  FEF,8EE
09B56:  MOVFF  FEC,8EF
09B5A:  MOVFF  FEC,8F0
09B5E:  MOVFF  FEC,8F1
09B62:  MOVLW  62
09B64:  MOVWF  FF6
09B66:  MOVLW  1A
09B68:  MOVWF  FF7
09B6A:  MOVLW  00
09B6C:  MOVWF  FF8
09B6E:  CLRF   1B
09B70:  BTFSC  FF2.7
09B72:  BSF    1B.7
09B74:  BCF    FF2.7
09B76:  MOVLW  05
09B78:  MOVLB  A
09B7A:  MOVWF  x40
09B7C:  MOVLB  0
09B7E:  CALL   1018
09B82:  BTFSC  1B.7
09B84:  BSF    FF2.7
09B86:  CLRF   1B
09B88:  BTFSC  FF2.7
09B8A:  BSF    1B.7
09B8C:  BCF    FF2.7
09B8E:  MOVFF  8EB,A40
09B92:  MOVLW  1B
09B94:  MOVLB  A
09B96:  MOVWF  x41
09B98:  MOVLB  0
09B9A:  CALL   0F9A
09B9E:  BTFSC  1B.7
09BA0:  BSF    FF2.7
09BA2:  MOVLW  2C
09BA4:  BTFSS  F9E.4
09BA6:  BRA    9BA4
09BA8:  MOVWF  FAD
09BAA:  MOVLW  41
09BAC:  MOVWF  FE9
09BAE:  MOVFF  8DC,8F5
09BB2:  MOVFF  8DB,8F4
09BB6:  MOVFF  8DA,8F3
09BBA:  MOVFF  8D9,8F2
09BBE:  RCALL  9558
09BC0:  MOVLW  2C
09BC2:  BTFSS  F9E.4
09BC4:  BRA    9BC2
09BC6:  MOVWF  FAD
09BC8:  MOVLW  10
09BCA:  MOVWF  FE9
09BCC:  CLRF   1B
09BCE:  BTFSC  FF2.7
09BD0:  BSF    1B.7
09BD2:  BCF    FF2.7
09BD4:  MOVFF  8ED,A41
09BD8:  MOVFF  8EC,A40
09BDC:  CALL   119A
09BE0:  BTFSC  1B.7
09BE2:  BSF    FF2.7
09BE4:  MOVLW  2C
09BE6:  BTFSS  F9E.4
09BE8:  BRA    9BE6
09BEA:  MOVWF  FAD
09BEC:  MOVLW  41
09BEE:  MOVWF  FE9
09BF0:  CLRF   1B
09BF2:  BTFSC  FF2.7
09BF4:  BSF    1B.7
09BF6:  BCF    FF2.7
09BF8:  MOVFF  8F1,A43
09BFC:  MOVFF  8F0,A42
09C00:  MOVFF  8EF,A41
09C04:  MOVFF  8EE,A40
09C08:  CALL   10DE
09C0C:  BTFSC  1B.7
09C0E:  BSF    FF2.7
09C10:  MOVLW  2C
09C12:  BTFSS  F9E.4
09C14:  BRA    9C12
09C16:  MOVWF  FAD
09C18:  MOVLW  41
09C1A:  MOVWF  FE9
09C1C:  MOVFF  8E6,8F5
09C20:  MOVFF  8E5,8F4
09C24:  MOVFF  8E4,8F3
09C28:  MOVFF  8E3,8F2
09C2C:  RCALL  9558
09C2E:  MOVLW  2C
09C30:  BTFSS  F9E.4
09C32:  BRA    9C30
09C34:  MOVWF  FAD
09C36:  MOVLW  41
09C38:  MOVWF  FE9
09C3A:  MOVFF  8EA,8F5
09C3E:  MOVFF  8E9,8F4
09C42:  MOVFF  8E8,8F3
09C46:  MOVFF  8E7,8F2
09C4A:  RCALL  9558
09C4C:  MOVLW  0D
09C4E:  BTFSS  F9E.4
09C50:  BRA    9C4E
09C52:  MOVWF  FAD
09C54:  MOVLW  0A
09C56:  BTFSS  F9E.4
09C58:  BRA    9C56
09C5A:  MOVWF  FAD
09C5C:  MOVLB  8
....................             //align(0); 
....................          } 
....................       } 
....................       e_mode_rst[motor]=e_mode[motor]; 
09C5E:  BCF    FD8.0
09C60:  MOVLB  7
09C62:  RLCF   x40,W
09C64:  CLRF   03
09C66:  ADDLW  9E
09C68:  MOVWF  01
09C6A:  MOVLW  07
09C6C:  ADDWFC 03,F
09C6E:  MOVLB  8
09C70:  MOVFF  03,8EC
09C74:  BCF    FD8.0
09C76:  MOVLB  7
09C78:  RLCF   x40,W
09C7A:  CLRF   03
09C7C:  ADDLW  66
09C7E:  MOVWF  FE9
09C80:  MOVLW  07
09C82:  ADDWFC 03,W
09C84:  MOVWF  FEA
09C86:  MOVFF  FEC,03
09C8A:  MOVF   FED,F
09C8C:  MOVFF  FEF,8ED
09C90:  MOVLB  8
09C92:  MOVFF  8EC,FEA
09C96:  MOVFF  01,FE9
09C9A:  MOVFF  03,FEC
09C9E:  MOVF   FED,F
09CA0:  MOVFF  8ED,FEF
....................       e_mode[motor]=4;                 // = run-on mode 
09CA4:  BCF    FD8.0
09CA6:  MOVLB  7
09CA8:  RLCF   x40,W
09CAA:  CLRF   03
09CAC:  ADDLW  66
09CAE:  MOVWF  FE9
09CB0:  MOVLW  07
09CB2:  ADDWFC 03,W
09CB4:  MOVWF  FEA
09CB6:  CLRF   FEC
09CB8:  MOVF   FED,F
09CBA:  MOVLW  04
09CBC:  MOVWF  FEF
....................       m_edge_pnt=m_step_cnt[motor]; 
09CBE:  MOVF   x40,W
09CC0:  MULLW  04
09CC2:  MOVF   FF3,W
09CC4:  CLRF   03
09CC6:  ADDLW  A2
09CC8:  MOVWF  FE9
09CCA:  MOVLW  07
09CCC:  ADDWFC 03,W
09CCE:  MOVWF  FEA
09CD0:  MOVFF  FEF,8DF
09CD4:  MOVFF  FEC,8E0
09CD8:  MOVFF  FEC,8E1
09CDC:  MOVFF  FEC,8E2
09CE0:  MOVLB  8
....................    } 
....................    return(m_edge_pnt); 
09CE2:  MOVFF  8DF,00
09CE6:  MOVFF  8E0,01
09CEA:  MOVFF  8E1,02
09CEE:  MOVFF  8E2,03
09CF2:  MOVLB  0
09CF4:  RETURN 0
.................... } 
....................  
.................... // used to determine start & end on slot or not-slot 
.................... int8 start_and_end_ports() 
.................... { 
.................... //   div_t idiv; 
....................  
....................  //  int8 port_port; 
....................    int8 evenOdd; 
....................  
....................    end_even_port = FALSE; 
*
08552:  MOVLB  2
08554:  CLRF   xDB
....................    start_even_port = FALSE; 
08556:  CLRF   xDA
....................  
....................    //char config_str1[30]; 
....................   // fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................   //       nv_macro_mode, nv_interval, nv_volume,evenOdd,e_port[0], 
....................   //       e_target_port[0],m_lin_pos[1]); 
....................  
....................    if((e_target_port[motor] % 2) == 0) 
08558:  BCF    FD8.0
0855A:  MOVLB  7
0855C:  RLCF   x40,W
0855E:  CLRF   03
08560:  ADDLW  C7
08562:  MOVWF  FE9
08564:  MOVLW  07
08566:  ADDWFC 03,W
08568:  MOVWF  FEA
0856A:  MOVFF  FEC,8D9
0856E:  MOVF   FED,F
08570:  MOVFF  FEF,8D8
08574:  MOVLW  01
08576:  MOVLB  8
08578:  ANDWF  xD8,F
0857A:  CLRF   xD9
0857C:  MOVF   xD8,F
0857E:  BNZ   858C
08580:  MOVF   xD9,F
08582:  BNZ   858C
....................    { 
....................       end_even_port = TRUE; 
08584:  MOVLW  01
08586:  MOVLB  2
08588:  MOVWF  xDB
0858A:  MOVLB  8
....................    } 
....................  
....................    if((e_port[motor] % 2) == 0) 
0858C:  BCF    FD8.0
0858E:  MOVLB  7
08590:  RLCF   x40,W
08592:  CLRF   03
08594:  ADDLW  C3
08596:  MOVWF  FE9
08598:  MOVLW  07
0859A:  ADDWFC 03,W
0859C:  MOVWF  FEA
0859E:  MOVFF  FEC,8D9
085A2:  MOVF   FED,F
085A4:  MOVFF  FEF,8D8
085A8:  MOVLW  01
085AA:  MOVLB  8
085AC:  ANDWF  xD8,F
085AE:  CLRF   xD9
085B0:  MOVF   xD8,F
085B2:  BNZ   85C0
085B4:  MOVF   xD9,F
085B6:  BNZ   85C0
....................    { 
....................       start_even_port = TRUE; 
085B8:  MOVLW  01
085BA:  MOVLB  2
085BC:  MOVWF  xDA
085BE:  MOVLB  8
....................    } 
....................  
....................    // test for ending on an even port 
....................  
....................    /*idiv=div(e_target_port[motor],2); 
....................    if (idiv.rem==0)end_even_port=TRUE; 
....................  
....................    // test for starting on an even port 
....................    idiv=div(e_port[motor],2); 
....................    if (idiv.rem==0)start_even_port=TRUE;*/ 
....................  
....................    if (FALSE == start_even_port) 
085C0:  MOVLB  2
085C2:  MOVF   xDA,F
085C4:  BNZ   85DA
....................    { 
....................       evenOdd = 0; 
085C6:  MOVLB  8
085C8:  CLRF   xD7
....................       if (TRUE == end_even_port) 
085CA:  MOVLB  2
085CC:  DECFSZ xDB,W
085CE:  BRA    85D8
....................       { 
....................          evenOdd = 1; 
085D0:  MOVLW  01
085D2:  MOVLB  8
085D4:  MOVWF  xD7
085D6:  MOVLB  2
....................       } 
....................    } 
085D8:  BRA    85EE
....................    else 
....................    { 
....................       evenOdd = 2; 
085DA:  MOVLW  02
085DC:  MOVLB  8
085DE:  MOVWF  xD7
....................       if (TRUE == end_even_port) 
085E0:  MOVLB  2
085E2:  DECFSZ xDB,W
085E4:  BRA    85EE
....................       { 
....................          evenOdd = 3; 
085E6:  MOVLW  03
085E8:  MOVLB  8
085EA:  MOVWF  xD7
085EC:  MOVLB  2
....................       } 
....................    } 
....................     
....................    //char config_str2[30]; 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, evenOdd,e_port[0], 
....................          //e_target_port[0],m_lin_pos[1]); 
....................     
....................     
....................    return(evenOdd); 
085EE:  MOVLB  8
085F0:  MOVFF  8D7,01
085F4:  MOVLB  0
085F6:  GOTO   A044 (RETURN)
.................... } 
....................  
.................... /* 
....................    move the selected motor by (e_mode) 
....................    0 - simple steps / no encoder 
....................    1 - encoder ticks on chA 
....................    2 - port to port using (dir_mode) where 0 = dir & 1 = shortest 
....................    3 - align to index 
....................    4 - run-on past disk slot edge 
....................    5 - back-lash 
....................    steps    - used as motor steps, encoder ticks, or ports 
....................    dir_mode - 0 = fixed direction (dir), 1 = shortest route 
.................... */ 
.................... void move_motor(int8 dir_mode, int8 dir, int32 m_steps, int8 int_mode) 
.................... { 
....................    int32 m_edge_pnt; 
....................    int16 m_slot_steps, m_extra; 
....................    int8 port_port; 
....................     
....................    m_way[motor] = dir; 
*
09D6C:  BCF    FD8.0
09D6E:  MOVLB  7
09D70:  RLCF   x40,W
09D72:  CLRF   03
09D74:  ADDLW  86
09D76:  MOVWF  FE9
09D78:  MOVLW  07
09D7A:  ADDWFC 03,W
09D7C:  MOVWF  FEA
09D7E:  CLRF   FEC
09D80:  MOVF   FED,F
09D82:  MOVFF  8C8,FEF
....................    m_step_cnt[motor] = 0; 
09D86:  MOVF   x40,W
09D88:  MULLW  04
09D8A:  MOVF   FF3,W
09D8C:  CLRF   03
09D8E:  ADDLW  A2
09D90:  MOVWF  FE9
09D92:  MOVLW  07
09D94:  ADDWFC 03,W
09D96:  MOVWF  FEA
09D98:  MOVF   FEE,F
09D9A:  MOVF   FEE,F
09D9C:  CLRF   FEC
09D9E:  MOVF   FED,F
09DA0:  CLRF   FEF
09DA2:  MOVF   FED,F
09DA4:  CLRF   FEF
09DA6:  MOVF   FED,F
09DA8:  CLRF   FEF
....................    m_extra = m_run[motor]; 
09DAA:  BCF    FD8.0
09DAC:  RLCF   x40,W
09DAE:  CLRF   03
09DB0:  ADDLW  6E
09DB2:  MOVWF  FE9
09DB4:  MOVLW  07
09DB6:  ADDWFC 03,W
09DB8:  MOVWF  FEA
09DBA:  MOVFF  FEC,8D5
09DBE:  MOVF   FED,F
09DC0:  MOVFF  FEF,8D4
....................    m_slot_steps = (m_spr[motor]/e_cpr[motor]); 
09DC4:  BCF    FD8.0
09DC6:  RLCF   x40,W
09DC8:  CLRF   03
09DCA:  ADDLW  76
09DCC:  MOVWF  FE9
09DCE:  MOVLW  07
09DD0:  ADDWFC 03,W
09DD2:  MOVWF  FEA
09DD4:  MOVFF  FEC,8DC
09DD8:  MOVF   FED,F
09DDA:  MOVFF  FEF,8DB
09DDE:  BCF    FD8.0
09DE0:  RLCF   x40,W
09DE2:  CLRF   03
09DE4:  ADDLW  5E
09DE6:  MOVWF  FE9
09DE8:  MOVLW  07
09DEA:  ADDWFC 03,W
09DEC:  MOVWF  FEA
09DEE:  MOVFF  FEC,03
09DF2:  MOVF   FED,F
09DF4:  MOVFF  FEF,8DD
09DF8:  MOVFF  03,8DA
09DFC:  MOVFF  03,8DE
09E00:  MOVLB  0
09E02:  CALL   2CC8
09E06:  MOVFF  02,8D3
09E0A:  MOVFF  01,8D2
....................     
....................    // if port-port mode and not prev aligned then fail 
....................    //if(((e_mode[motor]==2) && (e_port[motor]==0))== FALSE){ 
....................    if((e_mode[motor] != 2) || (e_port[motor]!= 0)) 
09E0E:  BCF    FD8.0
09E10:  MOVLB  7
09E12:  RLCF   x40,W
09E14:  CLRF   03
09E16:  ADDLW  66
09E18:  MOVWF  FE9
09E1A:  MOVLW  07
09E1C:  ADDWFC 03,W
09E1E:  MOVWF  FEA
09E20:  MOVFF  FEC,8D8
09E24:  MOVF   FED,F
09E26:  MOVFF  FEF,8D7
09E2A:  MOVLB  8
09E2C:  MOVF   xD7,W
09E2E:  SUBLW  02
09E30:  BNZ   9E60
09E32:  MOVF   xD8,F
09E34:  BNZ   9E60
09E36:  BCF    FD8.0
09E38:  MOVLB  7
09E3A:  RLCF   x40,W
09E3C:  CLRF   03
09E3E:  ADDLW  C3
09E40:  MOVWF  FE9
09E42:  MOVLW  07
09E44:  ADDWFC 03,W
09E46:  MOVWF  FEA
09E48:  MOVFF  FEC,8D8
09E4C:  MOVF   FED,F
09E4E:  MOVFF  FEF,8D7
09E52:  MOVLB  8
09E54:  MOVF   xD7,F
09E56:  BNZ   9E60
09E58:  MOVF   xD8,F
09E5A:  BTFSC  FD8.2
09E5C:  GOTO   A6FE
....................    { //changed from the previous line Fraser 7/7/14 
....................  
....................       // e_mode = 2 is disk slot mode 
....................       // 
....................       if(e_mode[motor] == 2) 
09E60:  BCF    FD8.0
09E62:  MOVLB  7
09E64:  RLCF   x40,W
09E66:  CLRF   03
09E68:  ADDLW  66
09E6A:  MOVWF  FE9
09E6C:  MOVLW  07
09E6E:  ADDWFC 03,W
09E70:  MOVWF  FEA
09E72:  MOVFF  FEC,8D8
09E76:  MOVF   FED,F
09E78:  MOVFF  FEF,8D7
09E7C:  MOVLB  8
09E7E:  MOVF   xD7,W
09E80:  SUBLW  02
09E82:  BTFSS  FD8.2
09E84:  BRA    A1DE
09E86:  MOVF   xD8,F
09E88:  BTFSS  FD8.2
09E8A:  BRA    A1DE
....................       {  // if mode 2 steps == "port to go to" 
....................          e_target_port[motor]=m_steps;   // e_target_port = port to goto 
09E8C:  BCF    FD8.0
09E8E:  MOVLB  7
09E90:  RLCF   x40,W
09E92:  CLRF   03
09E94:  ADDLW  C7
09E96:  MOVWF  FE9
09E98:  MOVLW  07
09E9A:  ADDWFC 03,W
09E9C:  MOVWF  FEA
09E9E:  MOVFF  8C9,FEF
09EA2:  MOVFF  8CA,FEC
....................          /* WMS has 48 ports and a 24 slot disk. Even ports are not on a slot. 
....................             The valve only travels CW. Routine accounts for going past slot 1 
....................             and if an extra half-slot of movement is needed for an even port. 
....................          */ 
....................          //*** Start - Aqua Monitor Code ***// 
....................          if (nv_product==WMS4) 
09EA6:  DECFSZ 2F,W
09EA8:  BRA    A15A
09EAA:  MOVF   30,F
09EAC:  BTFSS  FD8.2
09EAE:  BRA    A15A
....................          { 
....................             if (e_target_port[motor] > e_port[motor]) 
09EB0:  BCF    FD8.0
09EB2:  RLCF   x40,W
09EB4:  CLRF   03
09EB6:  ADDLW  C7
09EB8:  MOVWF  FE9
09EBA:  MOVLW  07
09EBC:  ADDWFC 03,W
09EBE:  MOVWF  FEA
09EC0:  MOVFF  FEC,8D8
09EC4:  MOVF   FED,F
09EC6:  MOVFF  FEF,8D7
09ECA:  BCF    FD8.0
09ECC:  RLCF   x40,W
09ECE:  CLRF   03
09ED0:  ADDLW  C3
09ED2:  MOVWF  FE9
09ED4:  MOVLW  07
09ED6:  ADDWFC 03,W
09ED8:  MOVWF  FEA
09EDA:  MOVFF  FEC,03
09EDE:  MOVF   FED,F
09EE0:  MOVFF  FEF,01
09EE4:  MOVF   03,W
09EE6:  MOVLB  8
09EE8:  SUBWF  xD8,W
09EEA:  BNC   9F86
09EEC:  BNZ   9EF4
09EEE:  MOVF   xD7,W
09EF0:  SUBWF  01,W
09EF2:  BC    9F86
....................             { 
....................                e_port_dist[motor]=e_target_port[motor] - e_port[motor]; 
09EF4:  BCF    FD8.0
09EF6:  MOVLB  7
09EF8:  RLCF   x40,W
09EFA:  CLRF   03
09EFC:  ADDLW  B7
09EFE:  MOVWF  01
09F00:  MOVLW  07
09F02:  ADDWFC 03,F
09F04:  MOVLB  8
09F06:  MOVFF  03,8D8
09F0A:  BCF    FD8.0
09F0C:  MOVLB  7
09F0E:  RLCF   x40,W
09F10:  CLRF   03
09F12:  ADDLW  C7
09F14:  MOVWF  FE9
09F16:  MOVLW  07
09F18:  ADDWFC 03,W
09F1A:  MOVWF  FEA
09F1C:  MOVFF  FEC,8DA
09F20:  MOVF   FED,F
09F22:  MOVFF  FEF,8D9
09F26:  BCF    FD8.0
09F28:  RLCF   x40,W
09F2A:  CLRF   03
09F2C:  ADDLW  C3
09F2E:  MOVWF  FE9
09F30:  MOVLW  07
09F32:  ADDWFC 03,W
09F34:  MOVWF  FEA
09F36:  MOVFF  FEC,03
09F3A:  MOVF   FED,F
09F3C:  MOVF   FEF,W
09F3E:  MOVLB  8
09F40:  SUBWF  xD9,W
09F42:  MOVWF  00
09F44:  MOVF   03,W
09F46:  SUBWFB xDA,W
09F48:  MOVFF  8D8,FEA
09F4C:  MOVFF  01,FE9
09F50:  MOVWF  FEC
09F52:  MOVF   FED,F
09F54:  MOVFF  00,FEF
....................                m_steps = e_port_dist[motor]/2; 
09F58:  BCF    FD8.0
09F5A:  MOVLB  7
09F5C:  RLCF   x40,W
09F5E:  CLRF   03
09F60:  ADDLW  B7
09F62:  MOVWF  FE9
09F64:  MOVLW  07
09F66:  ADDWFC 03,W
09F68:  MOVWF  FEA
09F6A:  MOVFF  FEC,8D8
09F6E:  MOVF   FED,F
09F70:  MOVFF  FEF,8D7
09F74:  BCF    FD8.0
09F76:  MOVLB  8
09F78:  CLRF   xCC
09F7A:  CLRF   xCB
09F7C:  RRCF   xD8,W
09F7E:  MOVWF  xCA
09F80:  RRCF   xD7,W
09F82:  MOVWF  xC9
....................             } 
09F84:  BRA    A03E
....................             else 
....................             { 
....................                e_port_dist[motor]=((e_ppr[motor]-e_port[motor]) + e_target_port[motor]); 
09F86:  BCF    FD8.0
09F88:  MOVLB  7
09F8A:  RLCF   x40,W
09F8C:  CLRF   03
09F8E:  ADDLW  B7
09F90:  MOVWF  01
09F92:  MOVLW  07
09F94:  ADDWFC 03,F
09F96:  MOVFF  01,8D7
09F9A:  MOVLB  8
09F9C:  MOVFF  03,8D8
09FA0:  BCF    FD8.0
09FA2:  MOVLB  7
09FA4:  RLCF   x40,W
09FA6:  CLRF   03
09FA8:  ADDLW  62
09FAA:  MOVWF  FE9
09FAC:  MOVLW  07
09FAE:  ADDWFC 03,W
09FB0:  MOVWF  FEA
09FB2:  MOVFF  FEC,8DA
09FB6:  MOVF   FED,F
09FB8:  MOVFF  FEF,8D9
09FBC:  BCF    FD8.0
09FBE:  RLCF   x40,W
09FC0:  CLRF   03
09FC2:  ADDLW  C3
09FC4:  MOVWF  FE9
09FC6:  MOVLW  07
09FC8:  ADDWFC 03,W
09FCA:  MOVWF  FEA
09FCC:  MOVFF  FEC,03
09FD0:  MOVF   FED,F
09FD2:  MOVF   FEF,W
09FD4:  MOVLB  8
09FD6:  SUBWF  xD9,F
09FD8:  MOVF   03,W
09FDA:  SUBWFB xDA,F
09FDC:  BCF    FD8.0
09FDE:  MOVLB  7
09FE0:  RLCF   x40,W
09FE2:  CLRF   03
09FE4:  ADDLW  C7
09FE6:  MOVWF  FE9
09FE8:  MOVLW  07
09FEA:  ADDWFC 03,W
09FEC:  MOVWF  FEA
09FEE:  MOVFF  FEC,03
09FF2:  MOVF   FED,F
09FF4:  MOVF   FEF,W
09FF6:  MOVLB  8
09FF8:  ADDWF  xD9,W
09FFA:  MOVWF  01
09FFC:  MOVF   xDA,W
09FFE:  ADDWFC 03,F
0A000:  MOVFF  8D8,FEA
0A004:  MOVFF  8D7,FE9
0A008:  MOVFF  03,FEC
0A00C:  MOVF   FED,F
0A00E:  MOVFF  01,FEF
....................                m_steps = e_port_dist[motor]/2; 
0A012:  BCF    FD8.0
0A014:  MOVLB  7
0A016:  RLCF   x40,W
0A018:  CLRF   03
0A01A:  ADDLW  B7
0A01C:  MOVWF  FE9
0A01E:  MOVLW  07
0A020:  ADDWFC 03,W
0A022:  MOVWF  FEA
0A024:  MOVFF  FEC,8D8
0A028:  MOVF   FED,F
0A02A:  MOVFF  FEF,8D7
0A02E:  BCF    FD8.0
0A030:  MOVLB  8
0A032:  CLRF   xCC
0A034:  CLRF   xCB
0A036:  RRCF   xD8,W
0A038:  MOVWF  xCA
0A03A:  RRCF   xD7,W
0A03C:  MOVWF  xC9
....................             } 
....................              
....................             // determine start/end = slot/not slot 
....................             port_port = start_and_end_ports(); 
0A03E:  MOVLB  0
0A040:  GOTO   8552
0A044:  MOVFF  01,8D6
....................  
....................             // set new case for port 2 
....................             if((e_target_port[motor]==2) && (e_port[motor] == 1)) 
0A048:  BCF    FD8.0
0A04A:  MOVLB  7
0A04C:  RLCF   x40,W
0A04E:  CLRF   03
0A050:  ADDLW  C7
0A052:  MOVWF  FE9
0A054:  MOVLW  07
0A056:  ADDWFC 03,W
0A058:  MOVWF  FEA
0A05A:  MOVFF  FEC,8D8
0A05E:  MOVF   FED,F
0A060:  MOVFF  FEF,8D7
0A064:  MOVLB  8
0A066:  MOVF   xD7,W
0A068:  SUBLW  02
0A06A:  BNZ   A09A
0A06C:  MOVF   xD8,F
0A06E:  BNZ   A09A
0A070:  BCF    FD8.0
0A072:  MOVLB  7
0A074:  RLCF   x40,W
0A076:  CLRF   03
0A078:  ADDLW  C3
0A07A:  MOVWF  FE9
0A07C:  MOVLW  07
0A07E:  ADDWFC 03,W
0A080:  MOVWF  FEA
0A082:  MOVFF  FEC,8D8
0A086:  MOVF   FED,F
0A088:  MOVFF  FEF,8D7
0A08C:  MOVLB  8
0A08E:  DECFSZ xD7,W
0A090:  BRA    A09A
0A092:  MOVF   xD8,F
0A094:  BNZ   A09A
....................             { 
....................                port_port=4; 
0A096:  MOVLW  04
0A098:  MOVWF  xD6
....................             } 
....................              
....................             switch(port_port){ 
0A09A:  MOVF   xD6,W
0A09C:  ADDLW  FB
0A09E:  BC    A156
0A0A0:  ADDLW  05
0A0A2:  MOVLB  0
0A0A4:  GOTO   A74C
....................                case 0 : m_extra=m_run[motor];      // odd-odd  
0A0A8:  BCF    FD8.0
0A0AA:  MOVLB  7
0A0AC:  RLCF   x40,W
0A0AE:  CLRF   03
0A0B0:  ADDLW  6E
0A0B2:  MOVWF  FE9
0A0B4:  MOVLW  07
0A0B6:  ADDWFC 03,W
0A0B8:  MOVWF  FEA
0A0BA:  MOVFF  FEC,8D5
0A0BE:  MOVF   FED,F
0A0C0:  MOVFF  FEF,8D4
....................                   break; 
0A0C4:  MOVLB  8
0A0C6:  BRA    A156
....................                case 1 : m_extra=m_slot_steps + evn_so[motor];  //odd-even 
0A0C8:  BCF    FD8.0
0A0CA:  MOVLB  7
0A0CC:  RLCF   x40,W
0A0CE:  CLRF   03
0A0D0:  ADDLW  7E
0A0D2:  MOVWF  FE9
0A0D4:  MOVLW  07
0A0D6:  ADDWFC 03,W
0A0D8:  MOVWF  FEA
0A0DA:  MOVFF  FEC,03
0A0DE:  MOVF   FED,F
0A0E0:  MOVF   FEF,W
0A0E2:  MOVLB  8
0A0E4:  ADDWF  xD2,W
0A0E6:  MOVWF  xD4
0A0E8:  MOVF   03,W
0A0EA:  ADDWFC xD3,W
0A0EC:  MOVWF  xD5
....................                         //fprintf(COM_A, "%Lu\r\n",m_extra); 
....................                   break; 
0A0EE:  BRA    A156
....................                case 2 : m_extra=m_run[motor];      // even-odd 
0A0F0:  BCF    FD8.0
0A0F2:  MOVLB  7
0A0F4:  RLCF   x40,W
0A0F6:  CLRF   03
0A0F8:  ADDLW  6E
0A0FA:  MOVWF  FE9
0A0FC:  MOVLW  07
0A0FE:  ADDWFC 03,W
0A100:  MOVWF  FEA
0A102:  MOVFF  FEC,8D5
0A106:  MOVF   FED,F
0A108:  MOVFF  FEF,8D4
....................                         ++m_steps; 
0A10C:  MOVLW  01
0A10E:  MOVLB  8
0A110:  ADDWF  xC9,F
0A112:  BTFSC  FD8.0
0A114:  INCF   xCA,F
0A116:  BTFSC  FD8.2
0A118:  INCF   xCB,F
0A11A:  BTFSC  FD8.2
0A11C:  INCF   xCC,F
....................                   break; 
0A11E:  BRA    A156
....................                case 3 : m_extra=m_slot_steps + evn_so[motor];      // even-even 
0A120:  BCF    FD8.0
0A122:  MOVLB  7
0A124:  RLCF   x40,W
0A126:  CLRF   03
0A128:  ADDLW  7E
0A12A:  MOVWF  FE9
0A12C:  MOVLW  07
0A12E:  ADDWFC 03,W
0A130:  MOVWF  FEA
0A132:  MOVFF  FEC,03
0A136:  MOVF   FED,F
0A138:  MOVF   FEF,W
0A13A:  MOVLB  8
0A13C:  ADDWF  xD2,W
0A13E:  MOVWF  xD4
0A140:  MOVF   03,W
0A142:  ADDWFC xD3,W
0A144:  MOVWF  xD5
....................  
....................                   break; 
0A146:  BRA    A156
....................                case 4 : m_extra=m_slot_steps;      // special case for 1 to 2 
0A148:  MOVFF  8D3,8D5
0A14C:  MOVFF  8D2,8D4
....................                   break;     
0A150:  MOVLB  8
0A152:  BRA    A156
0A154:  MOVLB  8
....................             } 
....................          } 
0A156:  BRA    A182
0A158:  MOVLB  7
....................          //*** End - Aqua Monitor Code ***// 
....................          else 
....................          { 
....................             m_steps = abs_enc_pos(m_steps);   // calc ports (=steps) to move (cast to int32) 
0A15A:  MOVFF  8CC,8DA
0A15E:  MOVFF  8CB,8D9
0A162:  MOVFF  8CA,8D8
0A166:  MOVFF  8C9,8D7
0A16A:  MOVLB  0
0A16C:  GOTO   85FA
0A170:  MOVFF  03,8CC
0A174:  MOVFF  02,8CB
0A178:  MOVFF  01,8CA
0A17C:  MOVFF  00,8C9
0A180:  MOVLB  8
....................          } 
....................  
....................          // m_steps == steps of motor, encoder or slots 
....................          if (dir_mode == 1) 
0A182:  DECFSZ xC7,W
0A184:  BRA    A1AC
....................          { 
....................             m_steps = rel_enc_pos(m_steps);  // cast to int32 
0A186:  MOVFF  8CA,8D8
0A18A:  MOVFF  8C9,8D7
0A18E:  MOVFF  8CA,8DA
0A192:  MOVFF  8C9,8D9
0A196:  MOVLB  0
0A198:  GOTO   880C
0A19C:  MOVLB  8
0A19E:  CLRF   xCC
0A1A0:  CLRF   xCB
0A1A2:  MOVFF  02,8CA
0A1A6:  MOVFF  01,8C9
....................          } 
0A1AA:  BRA    A1DE
....................          else 
....................          { 
....................             if (nv_product == WMS2) 
0A1AC:  MOVF   2F,W
0A1AE:  SUBLW  03
0A1B0:  BNZ   A1DE
0A1B2:  MOVF   30,F
0A1B4:  BNZ   A1DE
....................             { 
....................                m_steps = (m_steps - e_pos[motor]); 
0A1B6:  BCF    FD8.0
0A1B8:  MOVLB  7
0A1BA:  RLCF   x40,W
0A1BC:  CLRF   03
0A1BE:  ADDLW  BF
0A1C0:  MOVWF  FE9
0A1C2:  MOVLW  07
0A1C4:  ADDWFC 03,W
0A1C6:  MOVWF  FEA
0A1C8:  MOVFF  FEC,03
0A1CC:  MOVF   FED,F
0A1CE:  MOVF   FEF,W
0A1D0:  MOVLB  8
0A1D2:  SUBWF  xC9,F
0A1D4:  MOVF   03,W
0A1D6:  SUBWFB xCA,F
0A1D8:  MOVLW  00
0A1DA:  SUBWFB xCB,F
0A1DC:  SUBWFB xCC,F
....................             } 
....................          } 
....................       } 
....................  
....................       start_motor(int_mode); // incorrect comment - This call will determine back-lash 
0A1DE:  MOVFF  8CD,8D7
0A1E2:  MOVLB  0
0A1E4:  GOTO   8ED6
....................        
....................       //timeout could be set here!!! 
....................       while (m_running[motor]) 
0A1E8:  BCF    FD8.0
0A1EA:  MOVLB  7
0A1EC:  RLCF   x40,W
0A1EE:  CLRF   03
0A1F0:  ADDLW  92
0A1F2:  MOVWF  FE9
0A1F4:  MOVLW  07
0A1F6:  ADDWFC 03,W
0A1F8:  MOVWF  FEA
0A1FA:  MOVF   FEF,F
0A1FC:  BNZ   A204
0A1FE:  MOVF   FEC,F
0A200:  BTFSC  FD8.2
0A202:  BRA    A6FA
....................       { 
....................          switch(e_mode[motor]) 
0A204:  BCF    FD8.0
0A206:  RLCF   x40,W
0A208:  CLRF   03
0A20A:  ADDLW  66
0A20C:  MOVWF  FE9
0A20E:  MOVLW  07
0A210:  ADDWFC 03,W
0A212:  MOVWF  FEA
0A214:  MOVF   FEF,W
0A216:  MOVWF  00
0A218:  MOVF   FEE,F
0A21A:  MOVF   FED,W
0A21C:  MOVWF  03
0A21E:  MOVF   03,W
0A220:  BNZ   A22A
0A222:  MOVF   00,F
0A224:  MOVLB  0
0A226:  BZ    A278
0A228:  MOVLB  7
0A22A:  MOVF   03,W
0A22C:  BNZ   A238
0A22E:  MOVLW  01
0A230:  SUBWF  00,W
0A232:  MOVLB  0
0A234:  BZ    A2CE
0A236:  MOVLB  7
0A238:  MOVF   03,W
0A23A:  BNZ   A246
0A23C:  MOVLW  02
0A23E:  SUBWF  00,W
0A240:  MOVLB  0
0A242:  BZ    A2CE
0A244:  MOVLB  7
0A246:  MOVF   03,W
0A248:  BNZ   A256
0A24A:  MOVLW  03
0A24C:  SUBWF  00,W
0A24E:  MOVLB  0
0A250:  BTFSC  FD8.2
0A252:  BRA    A39C
0A254:  MOVLB  7
0A256:  MOVF   03,W
0A258:  BNZ   A266
0A25A:  MOVLW  04
0A25C:  SUBWF  00,W
0A25E:  MOVLB  0
0A260:  BTFSC  FD8.2
0A262:  BRA    A4EC
0A264:  MOVLB  7
0A266:  MOVF   03,W
0A268:  BNZ   A276
0A26A:  MOVLW  05
0A26C:  SUBWF  00,W
0A26E:  MOVLB  0
0A270:  BTFSC  FD8.2
0A272:  BRA    A63C
0A274:  MOVLB  7
0A276:  BRA    A6F4
....................          { 
....................             // motor steps 
....................             case 0 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_steps) 
0A278:  MOVLB  7
0A27A:  MOVF   x40,W
0A27C:  MULLW  04
0A27E:  MOVF   FF3,W
0A280:  CLRF   03
0A282:  ADDLW  A2
0A284:  MOVWF  FE9
0A286:  MOVLW  07
0A288:  ADDWFC 03,W
0A28A:  MOVWF  FEA
0A28C:  MOVFF  FEF,8D7
0A290:  MOVFF  FEC,8D8
0A294:  MOVFF  FEC,8D9
0A298:  MOVFF  FEC,8DA
0A29C:  MOVLB  8
0A29E:  MOVF   xCC,W
0A2A0:  SUBWF  xDA,W
0A2A2:  BNC   A2C8
0A2A4:  BNZ   A2BC
0A2A6:  MOVF   xCB,W
0A2A8:  SUBWF  xD9,W
0A2AA:  BNC   A2C8
0A2AC:  BNZ   A2BC
0A2AE:  MOVF   xCA,W
0A2B0:  SUBWF  xD8,W
0A2B2:  BNC   A2C8
0A2B4:  BNZ   A2BC
0A2B6:  MOVF   xC9,W
0A2B8:  SUBWF  xD7,W
0A2BA:  BNC   A2C8
....................                { 
....................                   terminate(1); 
0A2BC:  MOVLW  01
0A2BE:  MOVWF  xEB
0A2C0:  MOVLB  0
0A2C2:  CALL   90C4
0A2C6:  MOVLB  8
....................                } 
....................                break; 
0A2C8:  MOVLB  7
0A2CA:  BRA    A6F4
0A2CC:  MOVLB  0
....................             } 
....................             // encoder ticks                                   signal an error 
....................             case 1: 
....................             case 2: 
....................             { 
....................                if (m_gb_cnt[motor] >= m_gb_err[motor]) 
0A2CE:  BCF    FD8.0
0A2D0:  MOVLB  7
0A2D2:  RLCF   x40,W
0A2D4:  CLRF   03
0A2D6:  ADDLW  9A
0A2D8:  MOVWF  FE9
0A2DA:  MOVLW  07
0A2DC:  ADDWFC 03,W
0A2DE:  MOVWF  FEA
0A2E0:  MOVFF  FEC,8D8
0A2E4:  MOVF   FED,F
0A2E6:  MOVFF  FEF,8D7
0A2EA:  BCF    FD8.0
0A2EC:  RLCF   x40,W
0A2EE:  CLRF   03
0A2F0:  ADDLW  5A
0A2F2:  MOVWF  FE9
0A2F4:  MOVLW  07
0A2F6:  ADDWFC 03,W
0A2F8:  MOVWF  FEA
0A2FA:  MOVFF  FEC,03
0A2FE:  MOVF   FED,F
0A300:  MOVFF  FEF,01
0A304:  MOVF   03,W
0A306:  MOVLB  8
0A308:  SUBWF  xD8,W
0A30A:  BNC   A31E
0A30C:  BNZ   A314
0A30E:  MOVF   01,W
0A310:  SUBWF  xD7,W
0A312:  BNC   A31E
....................                { 
....................                   terminate(0); 
0A314:  CLRF   xEB
0A316:  MOVLB  0
0A318:  CALL   90C4
0A31C:  MOVLB  8
....................                } 
....................  
....................                if (e_cha_cnt[motor] >= m_steps) 
0A31E:  BCF    FD8.0
0A320:  MOVLB  7
0A322:  RLCF   x40,W
0A324:  CLRF   03
0A326:  ADDLW  BB
0A328:  MOVWF  FE9
0A32A:  MOVLW  07
0A32C:  ADDWFC 03,W
0A32E:  MOVWF  FEA
0A330:  MOVFF  FEC,8D8
0A334:  MOVF   FED,F
0A336:  MOVFF  FEF,8D7
0A33A:  MOVLB  8
0A33C:  MOVF   xCC,F
0A33E:  BNZ   A396
0A340:  MOVF   xCB,F
0A342:  BNZ   A396
0A344:  MOVF   xCA,W
0A346:  SUBWF  xD8,W
0A348:  BNC   A396
0A34A:  BNZ   A352
0A34C:  MOVF   xC9,W
0A34E:  SUBWF  xD7,W
0A350:  BNC   A396
....................                { 
....................                   m_edge_pnt = end_move(m_steps, e_port_dist[motor]); 
0A352:  BCF    FD8.0
0A354:  MOVLB  7
0A356:  RLCF   x40,W
0A358:  CLRF   03
0A35A:  ADDLW  B7
0A35C:  MOVWF  FE9
0A35E:  MOVLW  07
0A360:  ADDWFC 03,W
0A362:  MOVWF  FEA
0A364:  MOVFF  FEC,8DE
0A368:  MOVF   FED,F
0A36A:  MOVFF  FEF,8DD
0A36E:  MOVFF  8CC,8DC
0A372:  MOVFF  8CB,8DB
0A376:  MOVFF  8CA,8DA
0A37A:  MOVFF  8C9,8D9
0A37E:  MOVLB  0
0A380:  CALL   9684
0A384:  MOVFF  03,8D1
0A388:  MOVFF  02,8D0
0A38C:  MOVFF  01,8CF
0A390:  MOVFF  00,8CE
0A394:  MOVLB  8
....................                } 
....................                break; 
0A396:  MOVLB  7
0A398:  BRA    A6F4
0A39A:  MOVLB  0
....................             } 
....................             // index                                           signal an error 
....................             case 3: 
....................             { 
....................                if (e_cha_cnt[motor]  >= m_steps) 
0A39C:  BCF    FD8.0
0A39E:  MOVLB  7
0A3A0:  RLCF   x40,W
0A3A2:  CLRF   03
0A3A4:  ADDLW  BB
0A3A6:  MOVWF  FE9
0A3A8:  MOVLW  07
0A3AA:  ADDWFC 03,W
0A3AC:  MOVWF  FEA
0A3AE:  MOVFF  FEC,8D8
0A3B2:  MOVF   FED,F
0A3B4:  MOVFF  FEF,8D7
0A3B8:  MOVLB  8
0A3BA:  MOVF   xCC,F
0A3BC:  BNZ   A3DA
0A3BE:  MOVF   xCB,F
0A3C0:  BNZ   A3DA
0A3C2:  MOVF   xCA,W
0A3C4:  SUBWF  xD8,W
0A3C6:  BNC   A3DA
0A3C8:  BNZ   A3D0
0A3CA:  MOVF   xC9,W
0A3CC:  SUBWF  xD7,W
0A3CE:  BNC   A3DA
....................                { 
....................                   terminate(0); 
0A3D0:  CLRF   xEB
0A3D2:  MOVLB  0
0A3D4:  CALL   90C4
0A3D8:  MOVLB  8
....................                } 
....................  
....................                if (e_index[motor] == 0) 
0A3DA:  BCF    FD8.0
0A3DC:  MOVLB  7
0A3DE:  RLCF   x40,W
0A3E0:  CLRF   03
0A3E2:  ADDLW  7A
0A3E4:  MOVWF  FE9
0A3E6:  MOVLW  07
0A3E8:  ADDWFC 03,W
0A3EA:  MOVWF  FEA
0A3EC:  MOVFF  FEC,8D8
0A3F0:  MOVF   FED,F
0A3F2:  MOVFF  FEF,8D7
0A3F6:  MOVLB  8
0A3F8:  MOVF   xD7,F
0A3FA:  BNZ   A460
0A3FC:  MOVF   xD8,F
0A3FE:  BNZ   A460
....................                { 
....................                   if (e_ch_n[motor]==0) 
0A400:  CLRF   03
0A402:  MOVLB  7
0A404:  MOVF   x40,W
0A406:  ADDLW  CB
0A408:  MOVWF  FE9
0A40A:  MOVLW  07
0A40C:  ADDWFC 03,W
0A40E:  MOVWF  FEA
0A410:  MOVF   FEF,F
0A412:  BNZ   A45E
....................                   { 
....................                      wrt_m_error(); 
0A414:  MOVLB  0
0A416:  CALL   8F74
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A41A:  BCF    FD8.0
0A41C:  MOVLB  7
0A41E:  RLCF   x40,W
0A420:  CLRF   03
0A422:  ADDLW  B7
0A424:  MOVWF  FE9
0A426:  MOVLW  07
0A428:  ADDWFC 03,W
0A42A:  MOVWF  FEA
0A42C:  MOVFF  FEC,8DE
0A430:  MOVF   FED,F
0A432:  MOVFF  FEF,8DD
0A436:  MOVFF  8CC,8DC
0A43A:  MOVFF  8CB,8DB
0A43E:  MOVFF  8CA,8DA
0A442:  MOVFF  8C9,8D9
0A446:  MOVLB  0
0A448:  CALL   9684
0A44C:  MOVFF  03,8D1
0A450:  MOVFF  02,8D0
0A454:  MOVFF  01,8CF
0A458:  MOVFF  00,8CE
0A45C:  MOVLB  7
0A45E:  MOVLB  8
....................                   } 
....................                } 
....................  
....................                if (e_index[motor]==1) 
0A460:  BCF    FD8.0
0A462:  MOVLB  7
0A464:  RLCF   x40,W
0A466:  CLRF   03
0A468:  ADDLW  7A
0A46A:  MOVWF  FE9
0A46C:  MOVLW  07
0A46E:  ADDWFC 03,W
0A470:  MOVWF  FEA
0A472:  MOVFF  FEC,8D8
0A476:  MOVF   FED,F
0A478:  MOVFF  FEF,8D7
0A47C:  MOVLB  8
0A47E:  DECFSZ xD7,W
0A480:  BRA    A4E6
0A482:  MOVF   xD8,F
0A484:  BNZ   A4E6
....................                { 
....................                   if (e_ch_n[motor]==1) 
0A486:  CLRF   03
0A488:  MOVLB  7
0A48A:  MOVF   x40,W
0A48C:  ADDLW  CB
0A48E:  MOVWF  FE9
0A490:  MOVLW  07
0A492:  ADDWFC 03,W
0A494:  MOVWF  FEA
0A496:  DECFSZ FEF,W
0A498:  BRA    A4E4
....................                   { 
....................                      wrt_m_error(); 
0A49A:  MOVLB  0
0A49C:  CALL   8F74
....................                      m_edge_pnt=end_move(m_steps, e_port_dist[motor]); 
0A4A0:  BCF    FD8.0
0A4A2:  MOVLB  7
0A4A4:  RLCF   x40,W
0A4A6:  CLRF   03
0A4A8:  ADDLW  B7
0A4AA:  MOVWF  FE9
0A4AC:  MOVLW  07
0A4AE:  ADDWFC 03,W
0A4B0:  MOVWF  FEA
0A4B2:  MOVFF  FEC,8DE
0A4B6:  MOVF   FED,F
0A4B8:  MOVFF  FEF,8DD
0A4BC:  MOVFF  8CC,8DC
0A4C0:  MOVFF  8CB,8DB
0A4C4:  MOVFF  8CA,8DA
0A4C8:  MOVFF  8C9,8D9
0A4CC:  MOVLB  0
0A4CE:  CALL   9684
0A4D2:  MOVFF  03,8D1
0A4D6:  MOVFF  02,8D0
0A4DA:  MOVFF  01,8CF
0A4DE:  MOVFF  00,8CE
0A4E2:  MOVLB  7
0A4E4:  MOVLB  8
....................                   } 
....................                } 
....................                break;  
0A4E6:  MOVLB  7
0A4E8:  BRA    A6F4
0A4EA:  MOVLB  0
....................             } 
....................             // run-on (past disk slot edge) 
....................             case 4: 
....................             { 
....................                if ((m_step_cnt[motor]-m_edge_pnt) >= m_extra) 
0A4EC:  MOVLB  7
0A4EE:  MOVF   x40,W
0A4F0:  MULLW  04
0A4F2:  MOVF   FF3,W
0A4F4:  CLRF   03
0A4F6:  ADDLW  A2
0A4F8:  MOVWF  FE9
0A4FA:  MOVLW  07
0A4FC:  ADDWFC 03,W
0A4FE:  MOVWF  FEA
0A500:  MOVFF  FEF,8D7
0A504:  MOVFF  FEC,8D8
0A508:  MOVFF  FEC,8D9
0A50C:  MOVFF  FEC,8DA
0A510:  MOVLB  8
0A512:  MOVF   xCE,W
0A514:  SUBWF  xD7,F
0A516:  MOVF   xCF,W
0A518:  SUBWFB xD8,F
0A51A:  MOVF   xD0,W
0A51C:  SUBWFB xD9,F
0A51E:  MOVF   xD1,W
0A520:  SUBWFB xDA,F
0A522:  BNZ   A53A
0A524:  MOVF   xD9,F
0A526:  BNZ   A53A
0A528:  MOVF   xD5,W
0A52A:  SUBWF  xD8,W
0A52C:  BTFSS  FD8.0
0A52E:  BRA    A636
0A530:  BNZ   A53A
0A532:  MOVF   xD4,W
0A534:  SUBWF  xD7,W
0A536:  BTFSS  FD8.0
0A538:  BRA    A636
....................                { 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A53A:  BCF    FD8.0
0A53C:  MOVLB  7
0A53E:  RLCF   x40,W
0A540:  CLRF   03
0A542:  ADDLW  66
0A544:  MOVWF  01
0A546:  MOVLW  07
0A548:  ADDWFC 03,F
0A54A:  MOVLB  8
0A54C:  MOVFF  03,8D8
0A550:  BCF    FD8.0
0A552:  MOVLB  7
0A554:  RLCF   x40,W
0A556:  CLRF   03
0A558:  ADDLW  9E
0A55A:  MOVWF  FE9
0A55C:  MOVLW  07
0A55E:  ADDWFC 03,W
0A560:  MOVWF  FEA
0A562:  MOVFF  FEC,03
0A566:  MOVF   FED,F
0A568:  MOVFF  FEF,8D9
0A56C:  MOVLB  8
0A56E:  MOVFF  8D8,FEA
0A572:  MOVFF  01,FE9
0A576:  MOVFF  03,FEC
0A57A:  MOVF   FED,F
0A57C:  MOVFF  8D9,FEF
....................                   fprintf(COM_A, "VALVE STOP %Lu,%Lu\r\n", 
....................                           m_step_cnt[motor],m_edge_pnt);  // NFI why this fixes random mover error to even ports?delay? 
0A580:  MOVLB  7
0A582:  MOVF   x40,W
0A584:  MULLW  04
0A586:  MOVF   FF3,W
0A588:  CLRF   03
0A58A:  ADDLW  A2
0A58C:  MOVWF  FE9
0A58E:  MOVLW  07
0A590:  ADDWFC 03,W
0A592:  MOVWF  FEA
0A594:  MOVFF  FEF,8D7
0A598:  MOVFF  FEC,8D8
0A59C:  MOVFF  FEC,8D9
0A5A0:  MOVFF  FEC,8DA
0A5A4:  MOVLW  80
0A5A6:  MOVWF  FF6
0A5A8:  MOVLW  1A
0A5AA:  MOVWF  FF7
0A5AC:  MOVLW  00
0A5AE:  MOVWF  FF8
0A5B0:  CLRF   1B
0A5B2:  BTFSC  FF2.7
0A5B4:  BSF    1B.7
0A5B6:  BCF    FF2.7
0A5B8:  MOVLW  0B
0A5BA:  MOVLB  A
0A5BC:  MOVWF  x40
0A5BE:  MOVLB  0
0A5C0:  CALL   1018
0A5C4:  BTFSC  1B.7
0A5C6:  BSF    FF2.7
0A5C8:  MOVLW  41
0A5CA:  MOVWF  FE9
0A5CC:  CLRF   1B
0A5CE:  BTFSC  FF2.7
0A5D0:  BSF    1B.7
0A5D2:  BCF    FF2.7
0A5D4:  MOVFF  8DA,A43
0A5D8:  MOVFF  8D9,A42
0A5DC:  MOVFF  8D8,A41
0A5E0:  MOVFF  8D7,A40
0A5E4:  CALL   10DE
0A5E8:  BTFSC  1B.7
0A5EA:  BSF    FF2.7
0A5EC:  MOVLW  2C
0A5EE:  BTFSS  F9E.4
0A5F0:  BRA    A5EE
0A5F2:  MOVWF  FAD
0A5F4:  MOVLW  41
0A5F6:  MOVWF  FE9
0A5F8:  CLRF   1B
0A5FA:  BTFSC  FF2.7
0A5FC:  BSF    1B.7
0A5FE:  BCF    FF2.7
0A600:  MOVFF  8D1,A43
0A604:  MOVFF  8D0,A42
0A608:  MOVFF  8CF,A41
0A60C:  MOVFF  8CE,A40
0A610:  CALL   10DE
0A614:  BTFSC  1B.7
0A616:  BSF    FF2.7
0A618:  MOVLW  0D
0A61A:  BTFSS  F9E.4
0A61C:  BRA    A61A
0A61E:  MOVWF  FAD
0A620:  MOVLW  0A
0A622:  BTFSS  F9E.4
0A624:  BRA    A622
0A626:  MOVWF  FAD
....................                   terminate(1); 
0A628:  MOVLW  01
0A62A:  MOVLB  8
0A62C:  MOVWF  xEB
0A62E:  MOVLB  0
0A630:  CALL   90C4
0A634:  MOVLB  8
....................                } 
....................                break; 
0A636:  MOVLB  7
0A638:  BRA    A6F4
0A63A:  MOVLB  0
....................             } 
....................             // run-on (back-lash) 
....................                      // if motor step count >= backlash setting 
....................             case 5 : 
....................             { 
....................                if (m_step_cnt[motor] >= m_bklsh[motor]) 
0A63C:  MOVLB  7
0A63E:  MOVF   x40,W
0A640:  MULLW  04
0A642:  MOVF   FF3,W
0A644:  CLRF   03
0A646:  ADDLW  A2
0A648:  MOVWF  FE9
0A64A:  MOVLW  07
0A64C:  ADDWFC 03,W
0A64E:  MOVWF  FEA
0A650:  MOVFF  FEF,8D7
0A654:  MOVFF  FEC,8D8
0A658:  MOVFF  FEC,8D9
0A65C:  MOVFF  FEC,8DA
0A660:  BCF    FD8.0
0A662:  RLCF   x40,W
0A664:  CLRF   03
0A666:  ADDLW  72
0A668:  MOVWF  FE9
0A66A:  MOVLW  07
0A66C:  ADDWFC 03,W
0A66E:  MOVWF  FEA
0A670:  MOVFF  FEC,03
0A674:  MOVF   FED,F
0A676:  MOVFF  FEF,01
0A67A:  MOVLB  8
0A67C:  MOVF   xDA,F
0A67E:  BNZ   A692
0A680:  MOVF   xD9,F
0A682:  BNZ   A692
0A684:  MOVF   03,W
0A686:  SUBWF  xD8,W
0A688:  BNC   A6F2
0A68A:  BNZ   A692
0A68C:  MOVF   01,W
0A68E:  SUBWF  xD7,W
0A690:  BNC   A6F2
....................                { 
....................                   // reset e_mode to saved e_mode 
....................                   e_mode[motor]=e_mode_rst[motor]; 
0A692:  BCF    FD8.0
0A694:  MOVLB  7
0A696:  RLCF   x40,W
0A698:  CLRF   03
0A69A:  ADDLW  66
0A69C:  MOVWF  01
0A69E:  MOVLW  07
0A6A0:  ADDWFC 03,F
0A6A2:  MOVLB  8
0A6A4:  MOVFF  03,8D8
0A6A8:  BCF    FD8.0
0A6AA:  MOVLB  7
0A6AC:  RLCF   x40,W
0A6AE:  CLRF   03
0A6B0:  ADDLW  9E
0A6B2:  MOVWF  FE9
0A6B4:  MOVLW  07
0A6B6:  ADDWFC 03,W
0A6B8:  MOVWF  FEA
0A6BA:  MOVFF  FEC,03
0A6BE:  MOVF   FED,F
0A6C0:  MOVFF  FEF,8D9
0A6C4:  MOVLB  8
0A6C6:  MOVFF  8D8,FEA
0A6CA:  MOVFF  01,FE9
0A6CE:  MOVFF  03,FEC
0A6D2:  MOVF   FED,F
0A6D4:  MOVFF  8D9,FEF
....................                   // reset chA counter to 0 
....................                   e_cha_cnt[motor] = 0; 
0A6D8:  BCF    FD8.0
0A6DA:  MOVLB  7
0A6DC:  RLCF   x40,W
0A6DE:  CLRF   03
0A6E0:  ADDLW  BB
0A6E2:  MOVWF  FE9
0A6E4:  MOVLW  07
0A6E6:  ADDWFC 03,W
0A6E8:  MOVWF  FEA
0A6EA:  CLRF   FEC
0A6EC:  MOVF   FED,F
0A6EE:  CLRF   FEF
0A6F0:  MOVLB  8
....................                } 
....................                break; 
0A6F2:  MOVLB  7
....................             } 
....................          } 
0A6F4:  MOVLB  0
0A6F6:  BRA    A1E8
0A6F8:  MOVLB  7
....................       } 
....................    } 
0A6FA:  BRA    A718
0A6FC:  MOVLB  8
....................    else m_error[motor]=TRUE; 
0A6FE:  BCF    FD8.0
0A700:  MOVLB  7
0A702:  RLCF   x40,W
0A704:  CLRF   03
0A706:  ADDLW  96
0A708:  MOVWF  FE9
0A70A:  MOVLW  07
0A70C:  ADDWFC 03,W
0A70E:  MOVWF  FEA
0A710:  CLRF   FEC
0A712:  MOVF   FED,F
0A714:  MOVLW  01
0A716:  MOVWF  FEF
....................     
....................    if(m_error[motor]==TRUE) { 
0A718:  BCF    FD8.0
0A71A:  RLCF   x40,W
0A71C:  CLRF   03
0A71E:  ADDLW  96
0A720:  MOVWF  FE9
0A722:  MOVLW  07
0A724:  ADDWFC 03,W
0A726:  MOVWF  FEA
0A728:  MOVFF  FEC,8D8
0A72C:  MOVF   FED,F
0A72E:  MOVFF  FEF,8D7
0A732:  MOVLB  8
0A734:  DECFSZ xD7,W
0A736:  BRA    A748
0A738:  MOVF   xD8,F
0A73A:  BNZ   A748
....................       wrt_m_error(); 
0A73C:  MOVLB  0
0A73E:  CALL   8F74
....................       msg_mer(); 
0A742:  CALL   9CF6
0A746:  MOVLB  8
....................    } 
0A748:  MOVLB  0
0A74A:  RETURN 0
....................    //taken out 17:51:00 07/08/2014 
....................    //fprintf(COM_A, "%Lu,%Lu,%Lu,%u,%Lu,%Lu,%Ld\r\n", 
....................          //nv_macro_mode, nv_interval, nv_volume, port_port,e_port[0], 
....................          //e_target_port[0],m_slot_steps); 
.................... } 
....................  
.................... /* where: dir_mode = 0, movement follows dir variable 
....................                    = 1, movement is shortest distance 
.................... */ 
.................... void command_move(int8 dir_mode, int8 dir, int8 int_mode) 
.................... { 
....................    if(arg > 0 && arg < 65536) 
*
17092:  MOVF   48,F
17094:  BNZ   170A2
17096:  MOVF   49,F
17098:  BNZ   170A2
1709A:  MOVF   4A,F
1709C:  BNZ   170A2
1709E:  MOVF   4B,F
170A0:  BZ    170CE
170A2:  MOVF   4B,F
170A4:  BNZ   170CE
170A6:  MOVF   4A,W
170A8:  SUBLW  00
170AA:  BNC   170CE
....................    { 
....................       move_motor(dir_mode, dir, arg, int_mode); 
170AC:  MOVFF  885,8C7
170B0:  MOVFF  886,8C8
170B4:  MOVFF  4B,8CC
170B8:  MOVFF  4A,8CB
170BC:  MOVFF  49,8CA
170C0:  MOVFF  48,8C9
170C4:  MOVFF  887,8CD
170C8:  CALL   9D6C
....................    } 
170CC:  BRA    1714A
....................    else if(arg==0) 
170CE:  MOVF   48,F
170D0:  BNZ   17146
170D2:  MOVF   49,F
170D4:  BNZ   17146
170D6:  MOVF   4A,F
170D8:  BNZ   17146
170DA:  MOVF   4B,F
170DC:  BNZ   17146
....................    { 
....................       m_lin_pos[motor]=0; 
170DE:  BCF    FD8.0
170E0:  MOVLB  7
170E2:  RLCF   x40,W
170E4:  CLRF   03
170E6:  ADDLW  B3
170E8:  MOVWF  FE9
170EA:  MOVLW  07
170EC:  ADDWFC 03,W
170EE:  MOVWF  FEA
170F0:  CLRF   FEC
170F2:  MOVF   FED,F
170F4:  CLRF   FEF
....................       switch (motor){ 
170F6:  MOVF   x40,W
170F8:  XORLW  00
170FA:  MOVLB  0
170FC:  BZ    17104
170FE:  XORLW  01
17100:  BZ    17116
17102:  BRA    17126
....................          case 0 : write16(ADDR_M1_LIN_POS,0);  
17104:  MOVLW  B6
17106:  MOVLB  8
17108:  MOVWF  xEE
1710A:  CLRF   xF0
1710C:  CLRF   xEF
1710E:  MOVLB  0
17110:  CALL   4FC8
....................             break; 
17114:  BRA    17126
....................          case 1 : write16(ADDR_M2_LIN_POS,0); 
17116:  MOVLW  B8
17118:  MOVLB  8
1711A:  MOVWF  xEE
1711C:  CLRF   xF0
1711E:  CLRF   xEF
17120:  MOVLB  0
17122:  CALL   4FC8
....................             break; 
....................       }  
....................       m_error[motor]=0; 
17126:  BCF    FD8.0
17128:  MOVLB  7
1712A:  RLCF   x40,W
1712C:  CLRF   03
1712E:  ADDLW  96
17130:  MOVWF  FE9
17132:  MOVLW  07
17134:  ADDWFC 03,W
17136:  MOVWF  FEA
17138:  CLRF   FEC
1713A:  MOVF   FED,F
1713C:  CLRF   FEF
....................       wrt_m_error(); 
1713E:  MOVLB  0
17140:  CALL   8F74
....................    } 
17144:  BRA    1714A
....................    else cmd_arg(); 
17146:  CALL   B2F2
1714A:  RETURN 0
.................... } 
....................  
.................... void poll_enc() 
.................... { 
....................    int8 chanI, chanA; 
....................  
....................    enc_pwr(ON); 
*
18B42:  MOVLW  01
18B44:  MOVLB  8
18B46:  MOVWF  xEC
18B48:  MOVLB  0
18B4A:  CALL   89C4
....................  
....................    while(TRUE) 
....................    { 
....................       delay_ms(250); 
18B4E:  MOVLW  FA
18B50:  MOVLB  9
18B52:  MOVWF  xEC
18B54:  MOVLB  0
18B56:  CALL   2904
....................       switch(motor) 
18B5A:  MOVLB  7
18B5C:  MOVF   x40,W
18B5E:  XORLW  00
18B60:  MOVLB  0
18B62:  BZ    18B6A
18B64:  XORLW  01
18B66:  BZ    18B7C
18B68:  BRA    18B8C
....................       { 
....................          case 0: 
....................          { 
....................             chanI = input(ENC1_IND); 
18B6A:  MOVLB  8
18B6C:  CLRF   x85
18B6E:  BTFSC  F81.4
18B70:  INCF   x85,F
....................             chanA = input(ENC1_PHA); 
18B72:  CLRF   x86
18B74:  BTFSC  F81.1
18B76:  INCF   x86,F
....................             break; 
18B78:  MOVLB  0
18B7A:  BRA    18B8C
....................          } 
....................          case 1 : 
....................          { 
....................             chanI = input(ENC2_IND); 
18B7C:  MOVLB  8
18B7E:  CLRF   x85
18B80:  BTFSC  F81.5
18B82:  INCF   x85,F
....................             chanA = input(ENC2_PHA); 
18B84:  CLRF   x86
18B86:  BTFSC  F81.2
18B88:  INCF   x86,F
....................             break; 
18B8A:  MOVLB  0
....................          } 
....................       } 
....................  
....................       fprintf(COM_A, "ind:%u / pha:%u\r\n", chanI, chanA); 
18B8C:  MOVLW  96
18B8E:  MOVWF  FF6
18B90:  MOVLW  1A
18B92:  MOVWF  FF7
18B94:  MOVLW  00
18B96:  MOVWF  FF8
18B98:  CLRF   1B
18B9A:  BTFSC  FF2.7
18B9C:  BSF    1B.7
18B9E:  BCF    FF2.7
18BA0:  MOVLW  04
18BA2:  MOVLB  A
18BA4:  MOVWF  x40
18BA6:  MOVLB  0
18BA8:  CALL   1018
18BAC:  BTFSC  1B.7
18BAE:  BSF    FF2.7
18BB0:  CLRF   1B
18BB2:  BTFSC  FF2.7
18BB4:  BSF    1B.7
18BB6:  BCF    FF2.7
18BB8:  MOVFF  885,A40
18BBC:  MOVLW  1B
18BBE:  MOVLB  A
18BC0:  MOVWF  x41
18BC2:  MOVLB  0
18BC4:  CALL   0F9A
18BC8:  BTFSC  1B.7
18BCA:  BSF    FF2.7
18BCC:  MOVLW  9C
18BCE:  MOVWF  FF6
18BD0:  MOVLW  1A
18BD2:  MOVWF  FF7
18BD4:  MOVLW  00
18BD6:  MOVWF  FF8
18BD8:  CLRF   1B
18BDA:  BTFSC  FF2.7
18BDC:  BSF    1B.7
18BDE:  BCF    FF2.7
18BE0:  MOVLW  07
18BE2:  MOVLB  A
18BE4:  MOVWF  x40
18BE6:  MOVLB  0
18BE8:  CALL   1018
18BEC:  BTFSC  1B.7
18BEE:  BSF    FF2.7
18BF0:  CLRF   1B
18BF2:  BTFSC  FF2.7
18BF4:  BSF    1B.7
18BF6:  BCF    FF2.7
18BF8:  MOVFF  886,A40
18BFC:  MOVLW  1B
18BFE:  MOVLB  A
18C00:  MOVWF  x41
18C02:  MOVLB  0
18C04:  CALL   0F9A
18C08:  BTFSC  1B.7
18C0A:  BSF    FF2.7
18C0C:  MOVLW  0D
18C0E:  BTFSS  F9E.4
18C10:  BRA    18C0E
18C12:  MOVWF  FAD
18C14:  MOVLW  0A
18C16:  BTFSS  F9E.4
18C18:  BRA    18C16
18C1A:  MOVWF  FAD
....................       if (kbhit(COM_A)) 
18C1C:  BTFSS  F9E.5
18C1E:  BRA    18C2C
....................       { 
....................          if (ESCAPE == getc(COM_A)) 
18C20:  CALL   0E2C
18C24:  MOVF   01,W
18C26:  SUBLW  1B
18C28:  BNZ   18C2C
....................          { 
....................             break; 
18C2A:  BRA    18C2E
....................          } 
....................       } 
18C2C:  BRA    18B4E
....................    } 
....................  
....................    delay_ms(100); 
18C2E:  MOVLW  64
18C30:  MOVLB  9
18C32:  MOVWF  xEC
18C34:  MOVLB  0
18C36:  CALL   2904
....................    enc_pwr(OFF); 
18C3A:  MOVLB  8
18C3C:  CLRF   xEC
18C3E:  MOVLB  0
18C40:  CALL   89C4
18C44:  GOTO   18C60 (RETURN)
.................... } 
....................  
.................... //************************************* 
....................  
.................... void align(int8 dir) 
.................... { 
....................    int16 steps; 
....................    int16 e_mode_reset; 
....................  
....................    e_mode_reset = e_mode[motor];               // save current e_mode 
*
0A8A8:  BCF    FD8.0
0A8AA:  MOVLB  7
0A8AC:  RLCF   x40,W
0A8AE:  CLRF   03
0A8B0:  ADDLW  66
0A8B2:  MOVWF  FE9
0A8B4:  MOVLW  07
0A8B6:  ADDWFC 03,W
0A8B8:  MOVWF  FEA
0A8BA:  MOVFF  FEC,8C6
0A8BE:  MOVF   FED,F
0A8C0:  MOVFF  FEF,8C5
....................  
....................    // move off - possibly already aligned 
....................    steps = m_spr[motor]/e_ppr[motor]; 
0A8C4:  BCF    FD8.0
0A8C6:  RLCF   x40,W
0A8C8:  CLRF   03
0A8CA:  ADDLW  76
0A8CC:  MOVWF  FE9
0A8CE:  MOVLW  07
0A8D0:  ADDWFC 03,W
0A8D2:  MOVWF  FEA
0A8D4:  MOVFF  FEC,8DC
0A8D8:  MOVF   FED,F
0A8DA:  MOVFF  FEF,8DB
0A8DE:  BCF    FD8.0
0A8E0:  RLCF   x40,W
0A8E2:  CLRF   03
0A8E4:  ADDLW  62
0A8E6:  MOVWF  FE9
0A8E8:  MOVLW  07
0A8EA:  ADDWFC 03,W
0A8EC:  MOVWF  FEA
0A8EE:  MOVFF  FEC,03
0A8F2:  MOVF   FED,F
0A8F4:  MOVFF  FEF,8DD
0A8F8:  MOVFF  03,8CA
0A8FC:  MOVFF  03,8DE
0A900:  MOVLB  0
0A902:  CALL   2CC8
0A906:  MOVFF  02,8C4
0A90A:  MOVFF  01,8C3
....................    e_mode[motor] = 0;                          // motor steps 
0A90E:  BCF    FD8.0
0A910:  MOVLB  7
0A912:  RLCF   x40,W
0A914:  CLRF   03
0A916:  ADDLW  66
0A918:  MOVWF  FE9
0A91A:  MOVLW  07
0A91C:  ADDWFC 03,W
0A91E:  MOVWF  FEA
0A920:  CLRF   FEC
0A922:  MOVF   FED,F
0A924:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal  
0A926:  MOVLB  8
0A928:  CLRF   xC7
0A92A:  MOVFF  8C2,8C8
0A92E:  CLRF   xCC
0A930:  CLRF   xCB
0A932:  MOVFF  8C4,8CA
0A936:  MOVFF  8C3,8C9
0A93A:  MOVLW  01
0A93C:  MOVWF  xCD
0A93E:  MOVLB  0
0A940:  CALL   9D6C
....................    // move-off terminates and switches off enc 
....................  
....................    // turn enc back on a poll (initial reading) 
....................    enc_pwr(ON); 
0A944:  MOVLW  01
0A946:  MOVLB  8
0A948:  MOVWF  xEC
0A94A:  MOVLB  0
0A94C:  CALL   89C4
....................    delay_ms(100); 
0A950:  MOVLW  64
0A952:  MOVLB  9
0A954:  MOVWF  xEC
0A956:  MOVLB  0
0A958:  CALL   2904
....................    poll_index(); 
0A95C:  BRA    A776
....................  
....................    steps = (e_cpr[motor]+2);                   // set steps = 1 rev + 2 ports 
0A95E:  BCF    FD8.0
0A960:  MOVLB  7
0A962:  RLCF   x40,W
0A964:  CLRF   03
0A966:  ADDLW  5E
0A968:  MOVWF  FE9
0A96A:  MOVLW  07
0A96C:  ADDWFC 03,W
0A96E:  MOVWF  FEA
0A970:  MOVFF  FEC,8C8
0A974:  MOVF   FED,F
0A976:  MOVFF  FEF,8C7
0A97A:  MOVLW  02
0A97C:  MOVLB  8
0A97E:  ADDWF  xC7,W
0A980:  MOVWF  xC3
0A982:  MOVLW  00
0A984:  ADDWFC xC8,W
0A986:  MOVWF  xC4
....................    e_mode[motor] = 3; 
0A988:  BCF    FD8.0
0A98A:  MOVLB  7
0A98C:  RLCF   x40,W
0A98E:  CLRF   03
0A990:  ADDLW  66
0A992:  MOVWF  FE9
0A994:  MOVLW  07
0A996:  ADDWFC 03,W
0A998:  MOVWF  FEA
0A99A:  CLRF   FEC
0A99C:  MOVF   FED,F
0A99E:  MOVLW  03
0A9A0:  MOVWF  FEF
....................    move_motor(0, dir, steps, 1); 
0A9A2:  MOVLB  8
0A9A4:  CLRF   xC7
0A9A6:  MOVFF  8C2,8C8
0A9AA:  CLRF   xCC
0A9AC:  CLRF   xCB
0A9AE:  MOVFF  8C4,8CA
0A9B2:  MOVFF  8C3,8C9
0A9B6:  MOVLW  01
0A9B8:  MOVWF  xCD
0A9BA:  MOVLB  0
0A9BC:  CALL   9D6C
....................  
....................    // move additional motor steps for alignment offset 
....................    steps = align_os[0]; 
0A9C0:  MOVFF  783,8C4
0A9C4:  MOVFF  782,8C3
....................    e_mode[motor] = 0;                          // motor steps 
0A9C8:  BCF    FD8.0
0A9CA:  MOVLB  7
0A9CC:  RLCF   x40,W
0A9CE:  CLRF   03
0A9D0:  ADDLW  66
0A9D2:  MOVWF  FE9
0A9D4:  MOVLW  07
0A9D6:  ADDWFC 03,W
0A9D8:  MOVWF  FEA
0A9DA:  CLRF   FEC
0A9DC:  MOVF   FED,F
0A9DE:  CLRF   FEF
....................    move_motor(0, dir, steps, 1);             // last var = int_mode, 1 = normal 
0A9E0:  MOVLB  8
0A9E2:  CLRF   xC7
0A9E4:  MOVFF  8C2,8C8
0A9E8:  CLRF   xCC
0A9EA:  CLRF   xCB
0A9EC:  MOVFF  8C4,8CA
0A9F0:  MOVFF  8C3,8C9
0A9F4:  MOVLW  01
0A9F6:  MOVWF  xCD
0A9F8:  MOVLB  0
0A9FA:  CALL   9D6C
....................  
....................    e_pos[motor] = 0; 
0A9FE:  BCF    FD8.0
0AA00:  MOVLB  7
0AA02:  RLCF   x40,W
0AA04:  CLRF   03
0AA06:  ADDLW  BF
0AA08:  MOVWF  FE9
0AA0A:  MOVLW  07
0AA0C:  ADDWFC 03,W
0AA0E:  MOVWF  FEA
0AA10:  CLRF   FEC
0AA12:  MOVF   FED,F
0AA14:  CLRF   FEF
....................    e_port[motor] = 1; 
0AA16:  BCF    FD8.0
0AA18:  RLCF   x40,W
0AA1A:  CLRF   03
0AA1C:  ADDLW  C3
0AA1E:  MOVWF  FE9
0AA20:  MOVLW  07
0AA22:  ADDWFC 03,W
0AA24:  MOVWF  FEA
0AA26:  CLRF   FEC
0AA28:  MOVF   FED,F
0AA2A:  MOVLW  01
0AA2C:  MOVWF  FEF
....................  
....................    e_mode[motor] = e_mode_reset; 
0AA2E:  BCF    FD8.0
0AA30:  RLCF   x40,W
0AA32:  CLRF   03
0AA34:  ADDLW  66
0AA36:  MOVWF  FE9
0AA38:  MOVLW  07
0AA3A:  ADDWFC 03,W
0AA3C:  MOVWF  FEA
0AA3E:  MOVFF  8C6,FEC
0AA42:  MOVF   FED,F
0AA44:  MOVFF  8C5,FEF
0AA48:  MOVLB  0
0AA4A:  RETURN 0
.................... } 
....................  
.................... void cal_disk(int8 dir) 
.................... { 
....................    int16 steps; 
....................  
....................    steps=(e_cpr[motor]+2);   // set steps = 1 rev + 1 port 
*
0E0A8:  BCF    FD8.0
0E0AA:  MOVLB  7
0E0AC:  RLCF   x40,W
0E0AE:  CLRF   03
0E0B0:  ADDLW  5E
0E0B2:  MOVWF  FE9
0E0B4:  MOVLW  07
0E0B6:  ADDWFC 03,W
0E0B8:  MOVWF  FEA
0E0BA:  MOVFF  FEC,889
0E0BE:  MOVF   FED,F
0E0C0:  MOVFF  FEF,888
0E0C4:  MOVLW  02
0E0C6:  MOVLB  8
0E0C8:  ADDWF  x88,W
0E0CA:  MOVWF  x86
0E0CC:  MOVLW  00
0E0CE:  ADDWFC x89,W
0E0D0:  MOVWF  x87
....................  
....................    // move_motor(int8 dir_mode, int8 dir, int32 steps, int8 int_mode) 
....................    move_motor(0, dir, steps, 2);    // last var = int_mode, 2 = signal all edges 
0E0D2:  CLRF   xC7
0E0D4:  MOVFF  885,8C8
0E0D8:  CLRF   xCC
0E0DA:  CLRF   xCB
0E0DC:  MOVFF  887,8CA
0E0E0:  MOVFF  886,8C9
0E0E4:  MOVLW  02
0E0E6:  MOVWF  xCD
0E0E8:  MOVLB  0
0E0EA:  CALL   9D6C
0E0EE:  GOTO   E16E (RETURN)
.................... } 
....................  
.................... void recovery() 
.................... { 
....................    if(nv_product!=AWS) 
*
0AA4C:  MOVF   2F,W
0AA4E:  SUBLW  02
0AA50:  BNZ   AA56
0AA52:  MOVF   30,F
0AA54:  BZ    AABE
....................    { 
....................       //setup_timer_0(RTCC_INTERNAL|RTCC_8_BIT|RTCC_DIV_256); 
....................       //set up valve timeout variable 
....................       /*ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
....................       enable_interrupts(INT_EXT); 
....................  
....................       start_heartbeat(); 
....................  
....................       enable_interrupts(GLOBAL); 
....................       busy_set();*/ 
....................       valve_align_timeout = 0; 
0AA56:  CLRF   3A
0AA58:  CLRF   39
....................       fprintf(COM_A, "@REC - homing syringe and aligning valve to port 1\r\n"); 
0AA5A:  MOVLW  A8
0AA5C:  MOVWF  FF6
0AA5E:  MOVLW  1A
0AA60:  MOVWF  FF7
0AA62:  MOVLW  00
0AA64:  MOVWF  FF8
0AA66:  CLRF   1B
0AA68:  BTFSC  FF2.7
0AA6A:  BSF    1B.7
0AA6C:  BCF    FF2.7
0AA6E:  CALL   0E42
0AA72:  BTFSC  1B.7
0AA74:  BSF    FF2.7
....................       motor=0; 
0AA76:  MOVLB  7
0AA78:  CLRF   x40
....................       align(0); 
0AA7A:  MOVLB  8
0AA7C:  CLRF   xC2
0AA7E:  MOVLB  0
0AA80:  RCALL  A8A8
....................       //move_motor(1,0,2,1);  commented out to leave valve at port 1 after receovery 
....................       motor=1; 
0AA82:  MOVLW  01
0AA84:  MOVLB  7
0AA86:  MOVWF  x40
....................       move_motor(0,0,22000,1); 
0AA88:  MOVLB  8
0AA8A:  CLRF   xC7
0AA8C:  CLRF   xC8
0AA8E:  CLRF   xCC
0AA90:  CLRF   xCB
0AA92:  MOVLW  55
0AA94:  MOVWF  xCA
0AA96:  MOVLW  F0
0AA98:  MOVWF  xC9
0AA9A:  MOVLW  01
0AA9C:  MOVWF  xCD
0AA9E:  MOVLB  0
0AAA0:  CALL   9D6C
....................        
....................       m_lin_pos[1]=0; 
0AAA4:  MOVLB  7
0AAA6:  CLRF   xB6
0AAA8:  CLRF   xB5
....................       write16(ADDR_M2_LIN_POS,0); 
0AAAA:  MOVLW  B8
0AAAC:  MOVLB  8
0AAAE:  MOVWF  xEE
0AAB0:  CLRF   xF0
0AAB2:  CLRF   xEF
0AAB4:  MOVLB  0
0AAB6:  CALL   4FC8
....................       valve_align_timeout = -1; 
0AABA:  SETF   3A
0AABC:  SETF   39
....................    } 
0AABE:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "h-bridge.c" 
.................... // *** SWITCHING VALVE MOTOR *** // 
....................  
.................... void HB_all_OFF(){ 
....................   output_bit(HB_IN1,OFF);           
*
0C1F6:  BCF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0C1F8:  BCF    F8E.5
....................   output_bit(HB_EN, OFF);            
0C1FA:  BCF    F8E.3
....................   delay_ms(20); 
0C1FC:  MOVLW  14
0C1FE:  MOVLB  9
0C200:  MOVWF  xEC
0C202:  MOVLB  0
0C204:  CALL   2904
....................   output_bit(VMOT,  OFF); 
0C208:  BCF    F8E.1
....................   output_bit(VHBRDG,OFF); 
0C20A:  BCF    F8E.2
0C20C:  GOTO   C262 (RETURN)
.................... } 
....................  
.................... void HB_m1_ON(){ 
....................   output_bit(VHBRDG,ON); 
0C210:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0C212:  BSF    F8E.1
....................   delay_ms(50); 
0C214:  MOVLW  32
0C216:  MOVLB  9
0C218:  MOVWF  xEC
0C21A:  MOVLB  0
0C21C:  CALL   2904
....................   output_bit(HB_IN1,ON);           
0C220:  BSF    F8E.4
....................   output_bit(HB_IN2,OFF); 
0C222:  BCF    F8E.5
....................   output_bit(HB_EN, ON);            
0C224:  BSF    F8E.3
0C226:  GOTO   C262 (RETURN)
.................... } 
....................  
.................... void HB_m2_ON(){ 
....................   output_bit(VHBRDG,ON); 
0C22A:  BSF    F8E.2
....................   output_bit(VMOT,  ON); 
0C22C:  BSF    F8E.1
....................   delay_ms(50); 
0C22E:  MOVLW  32
0C230:  MOVLB  9
0C232:  MOVWF  xEC
0C234:  MOVLB  0
0C236:  CALL   2904
....................   output_bit(HB_IN1,OFF);           
0C23A:  BCF    F8E.4
....................   output_bit(HB_IN2,ON); 
0C23C:  BSF    F8E.5
....................   output_bit(HB_EN, ON);   
0C23E:  BSF    F8E.3
0C240:  GOTO   C262 (RETURN)
.................... } 
....................  
.................... void h_bridge(int8 hb_cmd) 
.................... { 
....................    switch (hb_cmd){ 
0C244:  MOVLB  8
0C246:  MOVF   xB5,W
0C248:  XORLW  00
0C24A:  MOVLB  0
0C24C:  BZ    C258
0C24E:  XORLW  01
0C250:  BZ    C25C
0C252:  XORLW  03
0C254:  BZ    C260
0C256:  BRA    C262
....................       case 0:  HB_all_OFF(); 
0C258:  BRA    C1F6
....................          break; 
0C25A:  BRA    C262
....................       case 1:  HB_m1_ON(); 
0C25C:  BRA    C210
....................          break; 
0C25E:  BRA    C262
....................       case 2:  HB_m2_ON(); 
0C260:  BRA    C22A
....................          break; 
....................    } 
0C262:  RETURN 0
.................... } 
....................  
....................  
.................... #include "sleep.c" 
.................... int8 wakeup_char_is_D = 0; 
....................  
.................... serial_wakeup_reason_t serial_wakeup() 
*
15D8A:  MOVLB  8
15D8C:  CLRF   x89
15D8E:  CLRF   x8A
15D90:  CLRF   x8B
.................... { 
....................    int8 count = 0; 
....................    int8 serChar = 0; 
....................    serial_wakeup_reason_t wakeUpReason = WAKE_UP_NONE; 
....................  
....................    // after serial wakeup gets next three chars or times-out 
....................    // ... after three loops (~9 seconds). If chars are crap 
....................    // ... wake-up is not good 
....................    while (TRUE) 
....................    { 
....................       serChar = timed_getc_A(); 
15D92:  MOVLB  0
15D94:  BRA    15D20
15D96:  MOVFF  01,88A
....................       if (serChar) 
15D9A:  MOVLB  8
15D9C:  MOVF   x8A,F
15D9E:  BZ    15DC8
....................       { 
....................          if (DOLLAR_SIGN == serChar) 
15DA0:  MOVF   x8A,W
15DA2:  SUBLW  24
15DA4:  BNZ   15DAE
....................          { 
....................             wakeUpReason = WAKE_UP_GOOD; 
15DA6:  MOVLW  02
15DA8:  MOVWF  x8B
....................             break; 
15DAA:  BRA    15DD4
....................          }else if (serChar == 'D'){ 
15DAC:  BRA    15DC8
15DAE:  MOVF   x8A,W
15DB0:  SUBLW  44
15DB2:  BNZ   15DC4
....................             wakeup_char_is_D = 1; 
15DB4:  MOVLW  01
15DB6:  MOVLB  7
15DB8:  MOVWF  xCD
....................             wakeUpReason = WAKE_UP_GOOD; 
15DBA:  MOVLW  02
15DBC:  MOVLB  8
15DBE:  MOVWF  x8B
....................             break; 
15DC0:  BRA    15DD4
....................          }else 
15DC2:  BRA    15DC8
....................          { 
....................             wakeUpReason = WAKE_UP_FALSE; 
15DC4:  MOVLW  01
15DC6:  MOVWF  x8B
....................          } 
....................       } 
....................  
....................       if (++count > 2) 
15DC8:  INCF   x89,F
15DCA:  MOVF   x89,W
15DCC:  SUBLW  02
15DCE:  BC    15DD2
....................       { 
....................          break; 
15DD0:  BRA    15DD4
....................       } 
15DD2:  BRA    15D92
....................    } 
....................  
....................    return (wakeUpReason); 
15DD4:  MOVFF  88B,01
15DD8:  MOVLB  0
15DDA:  GOTO   15DEE (RETURN)
.................... } 
....................  
.................... // Set-up USART interrupt 
.................... /* The various register bits accessed here are detailed in the 
....................    PIC18F8722 datasheet. 
.................... */ 
.................... void set_usart_int() 
.................... { 
....................    clear_interrupt(INT_RDA);     // Serial 
*
15CB8:  MOVF   FAE,W
....................    sleep_mode = TRUE;            // Code var for USART int fired/not fired 
15CBA:  BSF    4D.1
....................    bit_clear(RCON,IPEN);         // Disable priority on interrupts 
15CBC:  BCF    FD0.7
....................    bit_clear(PIR1,RC1IF);        // Clear USART Receive Interrupt Flag bit 
15CBE:  BCF    F9E.5
....................    //      var,bit = addr,bit 
....................    bit_set(PIE1,RC1IE);          // Set USART Receive Interrupt Enable bit 
15CC0:  BSF    F9D.5
....................    bit_set(BAUDCON1,WUE);        // USART1 wake-up enable 
15CC2:  BSF    F65.1
....................    bit_set(INTCON,PEIE);         // Set Peripheral Interrupt Enable bit 
15CC4:  BSF    FF2.6
15CC6:  GOTO   15CD2 (RETURN)
....................    //bit_set(INTCON,GIE);        // Set Global Interrupt Enable bit 
.................... } 
....................  
.................... void initilizeSleepState() 
.................... { 
....................    disable_interrupts (INT_EXT); 
15CCA:  BCF    FF2.4
....................    clear_interrupt(INT_EXT);        // RTC 
15CCC:  BCF    FF2.1
....................    rtc_alarm = FALSE; 
15CCE:  BCF    4D.0
....................    set_usart_int(); 
15CD0:  BRA    15CB8
....................    kill_wd(); 
15CD2:  CALL   30EA
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
15CD6:  BSF    FF2.4
....................    sleep();  
15CD8:  MOVFF  FD3,00
15CDC:  BCF    FD1.7
15CDE:  BCF    FD3.7
15CE0:  SLEEP 
15CE2:  MOVFF  00,FD3
....................    delay_cycles(1); 
15CE6:  NOP   
15CE8:  RETURN 0
.................... } 
....................  
....................  
.................... int1 wakeup() 
*
15DDE:  MOVLB  8
15DE0:  CLRF   x88
.................... { 
....................    serial_wakeup_reason_t serWakeupReason = WAKE_UP_NONE; 
....................    blip(); 
15DE2:  MOVLB  0
15DE4:  RCALL  15CEA
....................  
....................    if (TRUE != rtc_alarm) 
15DE6:  BTFSC  4D.0
15DE8:  BRA    15EB8
....................    { 
....................       // serial interrupt detected a char 
....................       // flash LED 
....................       blip(); 
15DEA:  RCALL  15CEA
....................       // if serial wake-up is good 
....................       serWakeupReason = serial_wakeup(); 
15DEC:  BRA    15D8A
15DEE:  MOVFF  01,888
....................       if (WAKE_UP_GOOD == serWakeupReason) 
15DF2:  MOVLB  8
15DF4:  MOVF   x88,W
15DF6:  SUBLW  02
15DF8:  BNZ   15EB0
....................       { 
....................          sleep_mode = FALSE; 
15DFA:  BCF    4D.1
....................          start_heartbeat(); 
15DFC:  MOVLB  0
15DFE:  CALL   28F4
....................          init_hardware(); 
15E02:  CALL   292E
....................          init_rtc();                      // This is the FAT RTC 
15E06:  CALL   34FC
....................          sd_status = init_sdcard(); 
15E0A:  CALL   502E
15E0E:  MOVFF  01,2DC
....................          bit_set(INTCON,PEIE);            // Set Peripheral Interrupt Enable bit 
15E12:  BSF    FF2.6
....................          sprintf(event_str, ",serial wake-up,SD initialized\r\n"); 
15E14:  MOVLW  01
15E16:  MOVWF  1E
15E18:  MOVLW  A7
15E1A:  MOVWF  1D
15E1C:  MOVLW  DE
15E1E:  MOVWF  FF6
15E20:  MOVLW  1A
15E22:  MOVWF  FF7
15E24:  MOVLW  00
15E26:  MOVWF  FF8
15E28:  CALL   50B2
....................          record_event(); 
15E2C:  CALL   84CE
....................          nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
15E30:  CLRF   32
15E32:  MOVLW  01
15E34:  MOVWF  31
....................          write8(ADDR_CMD_MODE, nv_cmd_mode); 
15E36:  MOVLW  02
15E38:  MOVLB  8
15E3A:  MOVWF  x89
15E3C:  MOVFF  31,88A
15E40:  MOVLB  0
15E42:  CALL   3406
....................          // fputs("Just set nv_cmd_mode =TRUE/r/n", COM_A); 
....................          //Dump new data on being woken up with a D 
....................          if (wakeup_char_is_D){ 
15E46:  MOVLB  7
15E48:  MOVF   xCD,F
15E4A:  BZ    15E6E
....................             file_list(file_ptr_rel_new); 
15E4C:  MOVLW  03
15E4E:  MOVLB  8
15E50:  MOVWF  x8A
15E52:  MOVLW  07
15E54:  MOVWF  x89
15E56:  MOVLB  0
15E58:  CALL   BB18
....................             f_unlink(file_ptr_rel_new); 
15E5C:  MOVLW  03
15E5E:  MOVLB  8
15E60:  MOVWF  x8A
15E62:  MOVLW  07
15E64:  MOVWF  x89
15E66:  MOVLB  0
15E68:  CALL   BC92
15E6C:  MOVLB  7
....................          } 
....................          if(sd_status>0) 
15E6E:  MOVLB  2
15E70:  MOVF   xDC,F
15E72:  BZ    15E7C
....................          { 
....................             msg_card_fail(); 
15E74:  MOVLB  0
15E76:  CALL   5074
15E7A:  MOVLB  2
....................          } 
....................  
....................           
....................          if (!wakeup_char_is_D){ 
15E7C:  MOVLB  7
15E7E:  MOVF   xCD,F
15E80:  BNZ   15EA6
....................             fprintf(COM_A, "@RST\r\n"); 
15E82:  MOVLW  00
15E84:  MOVWF  FF6
15E86:  MOVLW  1B
15E88:  MOVWF  FF7
15E8A:  MOVLW  00
15E8C:  MOVWF  FF8
15E8E:  CLRF   1B
15E90:  BTFSC  FF2.7
15E92:  BSF    1B.7
15E94:  BCF    FF2.7
15E96:  MOVLB  0
15E98:  CALL   0E42
15E9C:  BTFSC  1B.7
15E9E:  BSF    FF2.7
....................             reset_cpu(); 
15EA0:  RESET
....................          }else{ 
15EA2:  BRA    15EAC
15EA4:  MOVLB  7
....................            //go back to sleep 
....................             wakeup_char_is_D = 0; 
15EA6:  CLRF   xCD
....................             //fprintf(COM_A,"\r\n@SLEEP"); 
....................             //delay_ms(5); 
....................             initilizeSleepState(); 
15EA8:  MOVLB  0
15EAA:  RCALL  15CCA
....................          } 
....................       } 
15EAC:  BRA    15EB8
15EAE:  MOVLB  8
....................       else 
....................       { 
....................          if (WAKE_UP_FALSE == serWakeupReason) 
15EB0:  DECFSZ x88,W
15EB2:  BRA    15EBA
....................          { 
....................              
....................             initilizeSleepState(); 
15EB4:  MOVLB  0
15EB6:  RCALL  15CCA
15EB8:  MOVLB  8
....................          } 
....................       } 
....................    } 
....................     
....................    return (rtc_alarm); 
15EBA:  MOVLW  00
15EBC:  BTFSC  4D.0
15EBE:  MOVLW  01
15EC0:  MOVWF  01
15EC2:  MOVLB  0
15EC4:  GOTO   15ECE (RETURN)
.................... } 
....................  
....................  
.................... void go_to_sleep() 
.................... { 
....................    shutdown(); 
15EC8:  RCALL  15C4E
....................    initilizeSleepState(); 
15ECA:  RCALL  15CCA
....................  
....................    while (TRUE) 
....................    { 
....................       if (TRUE == wakeup()) 
15ECC:  BRA    15DDE
15ECE:  DECFSZ 01,W
15ED0:  BRA    15ED6
....................       { 
....................          rtc_alarm = FALSE; 
15ED2:  BCF    4D.0
....................          break; 
15ED4:  BRA    15EDC
....................       } 
....................  
....................       blip(); 
15ED6:  RCALL  15CEA
....................       blip(); 
15ED8:  RCALL  15CEA
15EDA:  BRA    15ECC
....................    } 
15EDC:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... #include "reset.c" 
.................... void reset_event() 
.................... { 
....................    switch ( restart_cause() ) 
*
0ABBA:  MOVF   FD0,W
0ABBC:  ANDLW  0F
0ABBE:  BTFSS  FD0.4
0ABC0:  MOVLW  00
0ABC2:  BSF    FD0.0
0ABC4:  BSF    FD0.1
0ABC6:  BSF    FD0.4
0ABC8:  BSF    FD8.3
0ABCA:  BSF    FD8.4
0ABCC:  ADDLW  F0
0ABCE:  BTFSC  FD8.0
0ABD0:  BRA    ADDC
0ABD2:  ADDLW  10
0ABD4:  GOTO   ADE0
....................    { 
....................       case WDT_TIMEOUT: 
....................       { 
....................          printf("@WDT\r\n"); 
0ABD8:  MOVLW  08
0ABDA:  MOVWF  FF6
0ABDC:  MOVLW  1B
0ABDE:  MOVWF  FF7
0ABE0:  MOVLW  00
0ABE2:  MOVWF  FF8
0ABE4:  CLRF   1B
0ABE6:  BTFSC  FF2.7
0ABE8:  BSF    1B.7
0ABEA:  BCF    FF2.7
0ABEC:  CALL   0E42
0ABF0:  BTFSC  1B.7
0ABF2:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD time-out\r\n"); 
0ABF4:  MOVLW  01
0ABF6:  MOVWF  1E
0ABF8:  MOVLW  A7
0ABFA:  MOVWF  1D
0ABFC:  MOVLW  10
0ABFE:  MOVWF  FF6
0AC00:  MOVLW  1B
0AC02:  MOVWF  FF7
0AC04:  MOVLW  00
0AC06:  MOVWF  FF8
0AC08:  CALL   50B2
....................          record_event(); 
0AC0C:  CALL   84CE
....................          recovery(); 
0AC10:  RCALL  AA4C
....................          break; 
0AC12:  BRA    ADDC
....................       } 
....................       case WDT_FROM_SLEEP: 
....................       { 
....................          printf("@WDS\r\n"); 
0AC14:  MOVLW  2E
0AC16:  MOVWF  FF6
0AC18:  MOVLW  1B
0AC1A:  MOVWF  FF7
0AC1C:  MOVLW  00
0AC1E:  MOVWF  FF8
0AC20:  CLRF   1B
0AC22:  BTFSC  FF2.7
0AC24:  BSF    1B.7
0AC26:  BCF    FF2.7
0AC28:  CALL   0E42
0AC2C:  BTFSC  1B.7
0AC2E:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,WD from sleep\r\n"); 
0AC30:  MOVLW  01
0AC32:  MOVWF  1E
0AC34:  MOVLW  A7
0AC36:  MOVWF  1D
0AC38:  MOVLW  36
0AC3A:  MOVWF  FF6
0AC3C:  MOVLW  1B
0AC3E:  MOVWF  FF7
0AC40:  MOVLW  00
0AC42:  MOVWF  FF8
0AC44:  CALL   50B2
....................          record_event(); 
0AC48:  CALL   84CE
....................          recovery(); 
0AC4C:  RCALL  AA4C
....................          break; 
0AC4E:  BRA    ADDC
....................       }       
....................       case NORMAL_POWER_UP: 
....................       { 
....................          printf("@NPU\r\n"); 
0AC50:  MOVLW  56
0AC52:  MOVWF  FF6
0AC54:  MOVLW  1B
0AC56:  MOVWF  FF7
0AC58:  MOVLW  00
0AC5A:  MOVWF  FF8
0AC5C:  CLRF   1B
0AC5E:  BTFSC  FF2.7
0AC60:  BSF    1B.7
0AC62:  BCF    FF2.7
0AC64:  CALL   0E42
0AC68:  BTFSC  1B.7
0AC6A:  BSF    FF2.7
....................          sprintf(event_str, ",id#[%Lu],power applied,SD initialized\r\n", nv_serial); 
0AC6C:  MOVLW  01
0AC6E:  MOVWF  1E
0AC70:  MOVLW  A7
0AC72:  MOVWF  1D
0AC74:  MOVLW  5E
0AC76:  MOVWF  FF6
0AC78:  MOVLW  1B
0AC7A:  MOVWF  FF7
0AC7C:  MOVLW  00
0AC7E:  MOVWF  FF8
0AC80:  MOVLW  05
0AC82:  MOVLB  8
0AC84:  MOVWF  xEB
0AC86:  MOVLB  0
0AC88:  RCALL  AAC0
0AC8A:  MOVLW  10
0AC8C:  MOVWF  FE9
0AC8E:  MOVFF  26,8F7
0AC92:  MOVFF  25,8F6
0AC96:  RCALL  AAF2
0AC98:  MOVLW  66
0AC9A:  MOVWF  FF6
0AC9C:  MOVLW  1B
0AC9E:  MOVWF  FF7
0ACA0:  MOVLW  00
0ACA2:  MOVWF  FF8
0ACA4:  MOVLW  20
0ACA6:  MOVLB  8
0ACA8:  MOVWF  xEB
0ACAA:  MOVLB  0
0ACAC:  RCALL  AAC0
....................          record_event(); 
0ACAE:  CALL   84CE
....................          break; 
0ACB2:  BRA    ADDC
....................       } 
....................       case RESET_INSTRUCTION: 
....................       { 
....................          printf("@RST\r\n"); 
0ACB4:  MOVLW  88
0ACB6:  MOVWF  FF6
0ACB8:  MOVLW  1B
0ACBA:  MOVWF  FF7
0ACBC:  MOVLW  00
0ACBE:  MOVWF  FF8
0ACC0:  CLRF   1B
0ACC2:  BTFSC  FF2.7
0ACC4:  BSF    1B.7
0ACC6:  BCF    FF2.7
0ACC8:  CALL   0E42
0ACCC:  BTFSC  1B.7
0ACCE:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,reset instruction\r\n"); 
0ACD0:  MOVLW  01
0ACD2:  MOVWF  1E
0ACD4:  MOVLW  A7
0ACD6:  MOVWF  1D
0ACD8:  MOVLW  90
0ACDA:  MOVWF  FF6
0ACDC:  MOVLW  1B
0ACDE:  MOVWF  FF7
0ACE0:  MOVLW  00
0ACE2:  MOVWF  FF8
0ACE4:  CALL   50B2
....................          record_event(); 
0ACE8:  CALL   84CE
....................          break; 
0ACEC:  BRA    ADDC
....................       } 
....................       case BROWNOUT_RESTART: 
....................       { 
....................          printf("@BOR\r\n"); 
0ACEE:  MOVLW  B4
0ACF0:  MOVWF  FF6
0ACF2:  MOVLW  1B
0ACF4:  MOVWF  FF7
0ACF6:  MOVLW  00
0ACF8:  MOVWF  FF8
0ACFA:  CLRF   1B
0ACFC:  BTFSC  FF2.7
0ACFE:  BSF    1B.7
0AD00:  BCF    FF2.7
0AD02:  CALL   0E42
0AD06:  BTFSC  1B.7
0AD08:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,brown-out\r\n"); 
0AD0A:  MOVLW  01
0AD0C:  MOVWF  1E
0AD0E:  MOVLW  A7
0AD10:  MOVWF  1D
0AD12:  MOVLW  BC
0AD14:  MOVWF  FF6
0AD16:  MOVLW  1B
0AD18:  MOVWF  FF7
0AD1A:  MOVLW  00
0AD1C:  MOVWF  FF8
0AD1E:  CALL   50B2
....................          record_event(); 
0AD22:  CALL   84CE
....................          recovery(); 
0AD26:  RCALL  AA4C
....................          break; 
0AD28:  BRA    ADDC
....................       }  
....................       case MCLR_FROM_SLEEP: 
....................       { 
....................          printf("@MRS\r\n"); 
0AD2A:  MOVLW  D8
0AD2C:  MOVWF  FF6
0AD2E:  MOVLW  1B
0AD30:  MOVWF  FF7
0AD32:  MOVLW  00
0AD34:  MOVWF  FF8
0AD36:  CLRF   1B
0AD38:  BTFSC  FF2.7
0AD3A:  BSF    1B.7
0AD3C:  BCF    FF2.7
0AD3E:  CALL   0E42
0AD42:  BTFSC  1B.7
0AD44:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR from sleep\r\n"); 
0AD46:  MOVLW  01
0AD48:  MOVWF  1E
0AD4A:  MOVLW  A7
0AD4C:  MOVWF  1D
0AD4E:  MOVLW  E0
0AD50:  MOVWF  FF6
0AD52:  MOVLW  1B
0AD54:  MOVWF  FF7
0AD56:  MOVLW  00
0AD58:  MOVWF  FF8
0AD5A:  CALL   50B2
....................          record_event(); 
0AD5E:  CALL   84CE
....................          output_bit(RTC_CS, ENABLE); 
0AD62:  BCF    F91.0
....................          spi_write(0x89); 
0AD64:  MOVF   FC9,W
0AD66:  MOVLW  89
0AD68:  MOVWF  FC9
0AD6A:  RRCF   FC7,W
0AD6C:  BNC   AD6A
....................          spi_write(0b11111111); 
0AD6E:  MOVF   FC9,W
0AD70:  SETF   FC9
0AD72:  RRCF   FC7,W
0AD74:  BNC   AD72
....................          spi_read(0x00); 
0AD76:  MOVF   FC9,W
0AD78:  CLRF   FC9
0AD7A:  RRCF   FC7,W
0AD7C:  BNC   AD7A
....................          output_bit(RTC_CS, DISABLE); 
0AD7E:  BSF    F91.0
....................          recovery(); 
0AD80:  RCALL  AA4C
....................          break; 
0AD82:  BRA    ADDC
....................       }    
....................       case MCLR_FROM_RUN: 
....................       { 
....................          printf("@MRR\r\n"); 
0AD84:  MOVLW  02
0AD86:  MOVWF  FF6
0AD88:  MOVLW  1C
0AD8A:  MOVWF  FF7
0AD8C:  MOVLW  00
0AD8E:  MOVWF  FF8
0AD90:  CLRF   1B
0AD92:  BTFSC  FF2.7
0AD94:  BSF    1B.7
0AD96:  BCF    FF2.7
0AD98:  CALL   0E42
0AD9C:  BTFSC  1B.7
0AD9E:  BSF    FF2.7
....................          sprintf(event_str, ",restart cause,MCLR when running\r\n"); 
0ADA0:  MOVLW  01
0ADA2:  MOVWF  1E
0ADA4:  MOVLW  A7
0ADA6:  MOVWF  1D
0ADA8:  MOVLW  0A
0ADAA:  MOVWF  FF6
0ADAC:  MOVLW  1C
0ADAE:  MOVWF  FF7
0ADB0:  MOVLW  00
0ADB2:  MOVWF  FF8
0ADB4:  CALL   50B2
....................          record_event(); 
0ADB8:  CALL   84CE
....................          output_bit(RTC_CS, ENABLE); 
0ADBC:  BCF    F91.0
....................          spi_write(0x89); 
0ADBE:  MOVF   FC9,W
0ADC0:  MOVLW  89
0ADC2:  MOVWF  FC9
0ADC4:  RRCF   FC7,W
0ADC6:  BNC   ADC4
....................          spi_write(0b11111111); 
0ADC8:  MOVF   FC9,W
0ADCA:  SETF   FC9
0ADCC:  RRCF   FC7,W
0ADCE:  BNC   ADCC
....................          spi_read(0x00); 
0ADD0:  MOVF   FC9,W
0ADD2:  CLRF   FC9
0ADD4:  RRCF   FC7,W
0ADD6:  BNC   ADD4
....................          output_bit(RTC_CS, DISABLE); 
0ADD8:  BSF    F91.0
....................          recovery(); 
0ADDA:  RCALL  AA4C
....................          break; 
....................       }         
....................    } 
0ADDC:  GOTO   1B814 (RETURN)
.................... } 
....................  
.................... #include "memory.c" 
.................... /* 
....................  
.................... EEPROM   = 25LC512 
.................... CAPACITY = 512k bits / 8 = 64k bytes 
....................            64K = 65535 = 0xFFFF 
....................  
.................... MEMORY MAP 
....................  
.................... 0x0000 - 0x00FF: RESERVED 
.................... 0x0000 - 0x02FF: RESERVED 
.................... 0x0300 - 0xCEFF: MACROS 
.................... 0xCF00 - 0xFFFF: DATA BUFFER 
....................  
.................... STORAGE SPACE: 
....................  
.................... MACROS 
.................... CMD  = int8 
.................... ARG  = int16 
.................... LINE = CMD + ARG(MSB) + ARG(LSB) = 3 bytes 
.................... 1,024 command lines per macro 
.................... 3,072 bytes per macro (3072 = 0xC00) 
....................  
.................... DATA 
.................... Aprox 512kb or ~0x80000 total memory on current eeprom -Fraser 
.................... 6,272 16-bit words / numbers 
....................  
.................... */ 
....................  
.................... // == 0x0300 - 0xCEFF 
.................... #define MACROM  0x0300      
.................... // Channel 1 
.................... #define MACRO1  0x0F00 
.................... #define MACRO2  0x1B00 
.................... #define MACRO3  0x2700 
.................... #define MACRO4  0x3300 
.................... // Channel 2 
.................... #define MACRO5  0x3F00 
.................... #define MACRO6  0x4B00 
.................... #define MACRO7  0x5700 
.................... #define MACRO8  0x6300    
.................... // Channel 3 
.................... #define MACRO9  0x6F00 
.................... #define MACRO10  0x7B00    
.................... #define MACRO11  0x8700 
.................... #define MACRO12  0x9300      
.................... // Channel 4 
.................... #define MACRO13  0x9F00 
.................... #define MACRO14  0xAB00    
.................... #define MACRO15  0xB700    
.................... #define MACRO16  0xC300  
.................... #define MACRO17  0x3B148 //0x324A8 Changed by fraser 6/23/17 
.................... #define MACRO18  0x3D470 //0x330A8        --//-- 
.................... #define MACRO19  0x3F798 //0x33CA8        --//-- 
.................... #define MACRO20  0x41AC0 //0x348A8        --//-- 
.................... // End at CEFF 
....................  
.................... // == 0xCF00 - 0xFFFF 
.................... //#define DATMEM  0xCF00 
.................... #define STRM 0xCF00 
.................... #define STR1 0xF228 
.................... #define STR2 0x11550 
.................... #define STR3 0x13878  
.................... #define STR4 0x15BA0 
.................... #define STR5 0x17EC8 
.................... #define STR6 0x1A1F0 
.................... #define STR7 0x1C518 
.................... #define STR8 0x1E840 
.................... #define STR9 0x20B68 
.................... #define STR10 0x22E90 
.................... #define STR11 0x251B8 
.................... #define STR12 0x274E0 
.................... #define STR13 0x29808 
.................... #define STR14 0x2BB30 
.................... #define STR15 0x2DE58 
.................... #define STR16 0x30180 
.................... #define STR17 0x324A8 
.................... #define STR18 0x347D0 
.................... #define STR19 0x36AF8 
.................... #define STR20 0x38E20 
....................  
.................... #include "init_vars.c" 
.................... void init_nv_vars() 
.................... { 
....................    nv_product = read16(ADDR_PRODUCT); 
*
02AAC:  MOVLW  1E
02AAE:  MOVLB  8
02AB0:  MOVWF  x97
02AB2:  MOVLB  0
02AB4:  RCALL  29BE
02AB6:  MOVFF  02,30
02ABA:  MOVFF  01,2F
....................     
....................    nv_report_mode = read16(ADDR_REPORT_MODE); 
02ABE:  MOVLW  1C
02AC0:  MOVLB  8
02AC2:  MOVWF  x97
02AC4:  MOVLB  0
02AC6:  RCALL  29BE
02AC8:  MOVFF  02,20
02ACC:  MOVFF  01,1F
....................    nv_sample = read16(ADDR_SAMPLE); 
02AD0:  MOVLW  16
02AD2:  MOVLB  8
02AD4:  MOVWF  x97
02AD6:  MOVLB  0
02AD8:  RCALL  29BE
02ADA:  MOVFF  02,22
02ADE:  MOVFF  01,21
....................    nv_interval = read16(ADDR_INTERVAL); 
02AE2:  MOVLW  14
02AE4:  MOVLB  8
02AE6:  MOVWF  x97
02AE8:  MOVLB  0
02AEA:  RCALL  29BE
02AEC:  MOVFF  02,24
02AF0:  MOVFF  01,23
....................    nv_serial = read16(ADDR_SERIALNO); 
02AF4:  MOVLB  8
02AF6:  CLRF   x97
02AF8:  MOVLB  0
02AFA:  RCALL  29BE
02AFC:  MOVFF  02,26
02B00:  MOVFF  01,25
....................    nv_max_samples = read16(ADDR_MAX_SAMPLES); 
02B04:  MOVLW  18
02B06:  MOVLB  8
02B08:  MOVWF  x97
02B0A:  MOVLB  0
02B0C:  RCALL  29BE
02B0E:  MOVFF  02,28
02B12:  MOVFF  01,27
....................     
....................    nv_cmd_mode = read8(ADDR_CMD_MODE); 
02B16:  MOVLW  02
02B18:  MOVLB  8
02B1A:  MOVWF  xB7
02B1C:  MOVLB  0
02B1E:  RCALL  2A18
02B20:  CLRF   32
02B22:  MOVFF  01,31
....................    MaxSamples = read8(ADDR_MaxSamples); 
02B26:  MOVLW  28
02B28:  MOVLB  8
02B2A:  MOVWF  xB7
02B2C:  MOVLB  0
02B2E:  RCALL  2A18
02B30:  CLRF   34
02B32:  MOVFF  01,33
....................    nv_elapsed = read16(ADDR_ELAPSED); 
02B36:  MOVLW  12
02B38:  MOVLB  8
02B3A:  MOVWF  x97
02B3C:  MOVLB  0
02B3E:  RCALL  29BE
02B40:  MOVFF  02,36
02B44:  MOVFF  01,35
....................     
....................    nv_macro_step = read16(ADDR_MACRO_STEP); 
02B48:  MOVLW  3A
02B4A:  MOVLB  8
02B4C:  MOVWF  x97
02B4E:  MOVLB  0
02B50:  RCALL  29BE
02B52:  MOVFF  02,38
02B56:  MOVFF  01,37
....................    nv_com_err = read16(ADDR_COM_ERR); 
02B5A:  MOVLW  3C
02B5C:  MOVLB  8
02B5E:  MOVWF  x97
02B60:  MOVLB  0
02B62:  RCALL  29BE
02B64:  MOVFF  02,3E
02B68:  MOVFF  01,3D
....................     
....................    nv_sd_status = read16(ADDR_SD_STATUS); 
02B6C:  MOVLW  3E
02B6E:  MOVLB  8
02B70:  MOVWF  x97
02B72:  MOVLB  0
02B74:  RCALL  29BE
02B76:  MOVFF  02,40
02B7A:  MOVFF  01,3F
....................     
....................    nv_d1_temp = read16(ADDR_D1_TEMP); 
02B7E:  MOVLW  40
02B80:  MOVLB  8
02B82:  MOVWF  x97
02B84:  MOVLB  0
02B86:  RCALL  29BE
02B88:  MOVFF  02,42
02B8C:  MOVFF  01,41
....................    nv_d2_temp = read16(ADDR_D2_TEMP); 
02B90:  MOVLW  42
02B92:  MOVLB  8
02B94:  MOVWF  x97
02B96:  MOVLB  0
02B98:  RCALL  29BE
02B9A:  MOVFF  02,44
02B9E:  MOVFF  01,43
....................     
....................    RTC_Al_Yr_Reg = read8(ADDR_ALARM_YR);  
02BA2:  MOVLW  04
02BA4:  MOVLB  8
02BA6:  MOVWF  xB7
02BA8:  MOVLB  0
02BAA:  RCALL  2A18
02BAC:  MOVFF  01,72D
....................     
....................    NO3_slope = read_float(ADDR_CAL_M1); 
02BB0:  MOVLB  8
02BB2:  CLRF   x86
02BB4:  MOVLW  44
02BB6:  MOVWF  x85
02BB8:  MOVLB  0
02BBA:  RCALL  2A3E
02BBC:  MOVFF  03,3F8
02BC0:  MOVFF  02,3F7
02BC4:  MOVFF  01,3F6
02BC8:  MOVFF  00,3F5
....................    NO3_inter = read_float(ADDR_CAL_C1); 
02BCC:  MOVLB  8
02BCE:  CLRF   x86
02BD0:  MOVLW  48
02BD2:  MOVWF  x85
02BD4:  MOVLB  0
02BD6:  RCALL  2A3E
02BD8:  MOVFF  03,3FC
02BDC:  MOVFF  02,3FB
02BE0:  MOVFF  01,3FA
02BE4:  MOVFF  00,3F9
....................    PO4_slope = read_float(ADDR_CAL_M2); 
02BE8:  MOVLB  8
02BEA:  CLRF   x86
02BEC:  MOVLW  4C
02BEE:  MOVWF  x85
02BF0:  MOVLB  0
02BF2:  RCALL  2A3E
02BF4:  MOVFF  03,400
02BF8:  MOVFF  02,3FF
02BFC:  MOVFF  01,3FE
02C00:  MOVFF  00,3FD
....................    PO4_inter = read_float(ADDR_CAL_C2); 
02C04:  MOVLB  8
02C06:  CLRF   x86
02C08:  MOVLW  52
02C0A:  MOVWF  x85
02C0C:  MOVLB  0
02C0E:  RCALL  2A3E
02C10:  MOVFF  03,404
02C14:  MOVFF  02,403
02C18:  MOVFF  01,402
02C1C:  MOVFF  00,401
....................    NH4_slope = read_float(ADDR_CAL_M3); 
02C20:  MOVLB  8
02C22:  CLRF   x86
02C24:  MOVLW  56
02C26:  MOVWF  x85
02C28:  MOVLB  0
02C2A:  RCALL  2A3E
02C2C:  MOVFF  03,408
02C30:  MOVFF  02,407
02C34:  MOVFF  01,406
02C38:  MOVFF  00,405
....................    NH4_inter = read_float(ADDR_CAL_C3); 
02C3C:  MOVLB  8
02C3E:  CLRF   x86
02C40:  MOVLW  5A
02C42:  MOVWF  x85
02C44:  MOVLB  0
02C46:  RCALL  2A3E
02C48:  MOVFF  03,40C
02C4C:  MOVFF  02,40B
02C50:  MOVFF  01,40A
02C54:  MOVFF  00,409
....................    SiO_slope = read_float(ADDR_CAL_M4); 
02C58:  MOVLB  8
02C5A:  CLRF   x86
02C5C:  MOVLW  5E
02C5E:  MOVWF  x85
02C60:  MOVLB  0
02C62:  RCALL  2A3E
02C64:  MOVFF  03,410
02C68:  MOVFF  02,40F
02C6C:  MOVFF  01,40E
02C70:  MOVFF  00,40D
....................    SiO_inter = read_float(ADDR_CAL_C4);   
02C74:  MOVLB  8
02C76:  CLRF   x86
02C78:  MOVLW  62
02C7A:  MOVWF  x85
02C7C:  MOVLB  0
02C7E:  RCALL  2A3E
02C80:  MOVFF  03,414
02C84:  MOVFF  02,413
02C88:  MOVFF  01,412
02C8C:  MOVFF  00,411
....................     
....................    nv_macro_mode = read16(ADDR_MACRO_MODE); 
02C90:  MOVLW  20
02C92:  MOVLB  8
02C94:  MOVWF  x97
02C96:  MOVLB  0
02C98:  RCALL  29BE
02C9A:  MOVFF  02,2A
02C9E:  MOVFF  01,29
....................    nv_volume = read16(ADDR_VOLUME); 
02CA2:  MOVLW  22
02CA4:  MOVLB  8
02CA6:  MOVWF  x97
02CA8:  MOVLB  0
02CAA:  RCALL  29BE
02CAC:  MOVFF  02,2C
02CB0:  MOVFF  01,2B
....................    nv_port = read16(ADDR_PORT); 
02CB4:  MOVLW  24
02CB6:  MOVLB  8
02CB8:  MOVWF  x97
02CBA:  MOVLB  0
02CBC:  RCALL  29BE
02CBE:  MOVFF  02,2E
02CC2:  MOVFF  01,2D
02CC6:  RETURN 0
....................     
....................    //nv_det_type = read16(ADDR_DET_TYPE);//removed by Fraser 7/13/15 
.................... } 
....................  
.................... void reset_nv_vars() 
.................... { 
....................    write16(ADDR_REPORT_MODE,0); 
*
0DEA0:  MOVLW  1C
0DEA2:  MOVLB  8
0DEA4:  MOVWF  xEE
0DEA6:  CLRF   xF0
0DEA8:  CLRF   xEF
0DEAA:  MOVLB  0
0DEAC:  CALL   4FC8
....................    write16(ADDR_SAMPLE,0); 
0DEB0:  MOVLW  16
0DEB2:  MOVLB  8
0DEB4:  MOVWF  xEE
0DEB6:  CLRF   xF0
0DEB8:  CLRF   xEF
0DEBA:  MOVLB  0
0DEBC:  CALL   4FC8
....................    write16(ADDR_INTERVAL,60); 
0DEC0:  MOVLW  14
0DEC2:  MOVLB  8
0DEC4:  MOVWF  xEE
0DEC6:  CLRF   xF0
0DEC8:  MOVLW  3C
0DECA:  MOVWF  xEF
0DECC:  MOVLB  0
0DECE:  CALL   4FC8
....................    write16(ADDR_SERIALNO,9999); 
0DED2:  MOVLB  8
0DED4:  CLRF   xEE
0DED6:  MOVLW  27
0DED8:  MOVWF  xF0
0DEDA:  MOVLW  0F
0DEDC:  MOVWF  xEF
0DEDE:  MOVLB  0
0DEE0:  CALL   4FC8
....................    write16(ADDR_MAX_SAMPLES,3360); 
0DEE4:  MOVLW  18
0DEE6:  MOVLB  8
0DEE8:  MOVWF  xEE
0DEEA:  MOVLW  0D
0DEEC:  MOVWF  xF0
0DEEE:  MOVLW  20
0DEF0:  MOVWF  xEF
0DEF2:  MOVLB  0
0DEF4:  CALL   4FC8
....................     
....................    write8(ADDR_CMD_MODE,TRUE); 
0DEF8:  MOVLW  02
0DEFA:  MOVLB  8
0DEFC:  MOVWF  x89
0DEFE:  MOVLW  01
0DF00:  MOVWF  x8A
0DF02:  MOVLB  0
0DF04:  CALL   3406
....................    write16(ADDR_MACRO_STEP, 0); 
0DF08:  MOVLW  3A
0DF0A:  MOVLB  8
0DF0C:  MOVWF  xEE
0DF0E:  CLRF   xF0
0DF10:  CLRF   xEF
0DF12:  MOVLB  0
0DF14:  CALL   4FC8
....................    write16(ADDR_COM_ERR,3); 
0DF18:  MOVLW  3C
0DF1A:  MOVLB  8
0DF1C:  MOVWF  xEE
0DF1E:  CLRF   xF0
0DF20:  MOVLW  03
0DF22:  MOVWF  xEF
0DF24:  MOVLB  0
0DF26:  CALL   4FC8
....................     
....................    write8(ADDR_ALARM_YR,10);  
0DF2A:  MOVLW  04
0DF2C:  MOVLB  8
0DF2E:  MOVWF  x89
0DF30:  MOVLW  0A
0DF32:  MOVWF  x8A
0DF34:  MOVLB  0
0DF36:  CALL   3406
....................     
....................    write_float(ADDR_CAL_M1,1); 
0DF3A:  MOVLB  8
0DF3C:  CLRF   x86
0DF3E:  MOVLW  44
0DF40:  MOVWF  x85
0DF42:  CLRF   x8A
0DF44:  CLRF   x89
0DF46:  CLRF   x88
0DF48:  MOVLW  7F
0DF4A:  MOVWF  x87
0DF4C:  MOVLB  0
0DF4E:  CALL   CD40
....................    write_float(ADDR_CAL_C1,0); 
0DF52:  MOVLB  8
0DF54:  CLRF   x86
0DF56:  MOVLW  48
0DF58:  MOVWF  x85
0DF5A:  CLRF   x8A
0DF5C:  CLRF   x89
0DF5E:  CLRF   x88
0DF60:  CLRF   x87
0DF62:  MOVLB  0
0DF64:  CALL   CD40
....................    write_float(ADDR_CAL_M2,1); 
0DF68:  MOVLB  8
0DF6A:  CLRF   x86
0DF6C:  MOVLW  4C
0DF6E:  MOVWF  x85
0DF70:  CLRF   x8A
0DF72:  CLRF   x89
0DF74:  CLRF   x88
0DF76:  MOVLW  7F
0DF78:  MOVWF  x87
0DF7A:  MOVLB  0
0DF7C:  CALL   CD40
....................    write_float(ADDR_CAL_C2,0); 
0DF80:  MOVLB  8
0DF82:  CLRF   x86
0DF84:  MOVLW  52
0DF86:  MOVWF  x85
0DF88:  CLRF   x8A
0DF8A:  CLRF   x89
0DF8C:  CLRF   x88
0DF8E:  CLRF   x87
0DF90:  MOVLB  0
0DF92:  CALL   CD40
....................    write_float(ADDR_CAL_M3,1); 
0DF96:  MOVLB  8
0DF98:  CLRF   x86
0DF9A:  MOVLW  56
0DF9C:  MOVWF  x85
0DF9E:  CLRF   x8A
0DFA0:  CLRF   x89
0DFA2:  CLRF   x88
0DFA4:  MOVLW  7F
0DFA6:  MOVWF  x87
0DFA8:  MOVLB  0
0DFAA:  CALL   CD40
....................    write_float(ADDR_CAL_C3,0); 
0DFAE:  MOVLB  8
0DFB0:  CLRF   x86
0DFB2:  MOVLW  5A
0DFB4:  MOVWF  x85
0DFB6:  CLRF   x8A
0DFB8:  CLRF   x89
0DFBA:  CLRF   x88
0DFBC:  CLRF   x87
0DFBE:  MOVLB  0
0DFC0:  CALL   CD40
....................    write_float(ADDR_CAL_M4,1); 
0DFC4:  MOVLB  8
0DFC6:  CLRF   x86
0DFC8:  MOVLW  5E
0DFCA:  MOVWF  x85
0DFCC:  CLRF   x8A
0DFCE:  CLRF   x89
0DFD0:  CLRF   x88
0DFD2:  MOVLW  7F
0DFD4:  MOVWF  x87
0DFD6:  MOVLB  0
0DFD8:  CALL   CD40
....................    write_float(ADDR_CAL_C4,0);  
0DFDC:  MOVLB  8
0DFDE:  CLRF   x86
0DFE0:  MOVLW  62
0DFE2:  MOVWF  x85
0DFE4:  CLRF   x8A
0DFE6:  CLRF   x89
0DFE8:  CLRF   x88
0DFEA:  CLRF   x87
0DFEC:  MOVLB  0
0DFEE:  CALL   CD40
....................     
....................    write16(ADDR_D1_TEMP,20000); 
0DFF2:  MOVLW  40
0DFF4:  MOVLB  8
0DFF6:  MOVWF  xEE
0DFF8:  MOVLW  4E
0DFFA:  MOVWF  xF0
0DFFC:  MOVLW  20
0DFFE:  MOVWF  xEF
0E000:  MOVLB  0
0E002:  CALL   4FC8
....................    write16(ADDR_D2_TEMP,20000); 
0E006:  MOVLW  42
0E008:  MOVLB  8
0E00A:  MOVWF  xEE
0E00C:  MOVLW  4E
0E00E:  MOVWF  xF0
0E010:  MOVLW  20
0E012:  MOVWF  xEF
0E014:  MOVLB  0
0E016:  CALL   4FC8
....................     
....................    write16(ADDR_MACRO_MODE,0); 
0E01A:  MOVLW  20
0E01C:  MOVLB  8
0E01E:  MOVWF  xEE
0E020:  CLRF   xF0
0E022:  CLRF   xEF
0E024:  MOVLB  0
0E026:  CALL   4FC8
....................    write16(ADDR_VOLUME,22500);  
0E02A:  MOVLW  22
0E02C:  MOVLB  8
0E02E:  MOVWF  xEE
0E030:  MOVLW  57
0E032:  MOVWF  xF0
0E034:  MOVLW  E4
0E036:  MOVWF  xEF
0E038:  MOVLB  0
0E03A:  CALL   4FC8
....................    if(nv_product!=AWS) write16(ADDR_PORT,2); 
0E03E:  MOVF   2F,W
0E040:  SUBLW  02
0E042:  BNZ   E048
0E044:  MOVF   30,F
0E046:  BZ    E05C
0E048:  MOVLW  24
0E04A:  MOVLB  8
0E04C:  MOVWF  xEE
0E04E:  CLRF   xF0
0E050:  MOVLW  02
0E052:  MOVWF  xEF
0E054:  MOVLB  0
0E056:  CALL   4FC8
0E05A:  BRA    E06E
....................    else write16(ADDR_PORT,1); 
0E05C:  MOVLW  24
0E05E:  MOVLB  8
0E060:  MOVWF  xEE
0E062:  CLRF   xF0
0E064:  MOVLW  01
0E066:  MOVWF  xEF
0E068:  MOVLB  0
0E06A:  CALL   4FC8
....................     
....................    write16(ADDR_DET_TYPE,1); 
0E06E:  MOVLW  26
0E070:  MOVLB  8
0E072:  MOVWF  xEE
0E074:  CLRF   xF0
0E076:  MOVLW  01
0E078:  MOVWF  xEF
0E07A:  MOVLB  0
0E07C:  CALL   4FC8
....................     
....................    init_nv_vars(); 
0E080:  CALL   2AAC
0E084:  GOTO   E09E (RETURN)
.................... } 
....................  
....................  
.................... #include "detector.c" 
....................  
.................... void clear_slave_reply() 
.................... { 
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
*
127E2:  MOVLW  02
127E4:  MOVWF  FEA
127E6:  MOVLW  47
127E8:  MOVWF  FE9
127EA:  CLRF   00
127EC:  CLRF   02
127EE:  MOVLW  51
127F0:  MOVWF  01
127F2:  CALL   351A
127F6:  RETURN 0
.................... } 
....................  
.................... void clear_flag_str() 
.................... { 
....................    memset (&flag_str[0], 0x00, 20); //blank it 
*
0F910:  MOVLW  03
0F912:  MOVWF  FEA
0F914:  MOVLW  25
0F916:  MOVWF  FE9
0F918:  CLRF   00
0F91A:  CLRF   02
0F91C:  MOVLW  14
0F91E:  MOVWF  01
0F920:  CALL   351A
0F924:  GOTO   F944 (RETURN)
.................... } 
....................  
.................... int8 parse_string() 
.................... { 
....................    int8 c, n; 
....................    c=0; 
*
13318:  MOVLB  8
1331A:  CLRF   xD4
....................  
....................    memset (&sub_string[0], 0x00, 20); //blank it 
1331C:  CLRF   FEA
1331E:  MOVLW  52
13320:  MOVWF  FE9
13322:  CLRF   00
13324:  CLRF   02
13326:  MOVLW  14
13328:  MOVWF  01
1332A:  MOVLB  0
1332C:  CALL   351A
....................  
....................    for(n=0; n<20; n++) { 
13330:  MOVLB  8
13332:  CLRF   xD5
13334:  MOVF   xD5,W
13336:  SUBLW  13
13338:  BNC   1337E
....................         c = data_buffer[string_pos];  
1333A:  CLRF   03
1333C:  MOVLB  2
1333E:  MOVF   x98,W
13340:  ADDLW  67
13342:  MOVWF  FE9
13344:  MOVLW  00
13346:  ADDWFC 03,W
13348:  MOVWF  FEA
1334A:  MOVFF  FEF,8D4
....................         ++string_pos; 
1334E:  INCF   x98,F
....................         if (c == '\0') return(1); // found end 
13350:  MOVLB  8
13352:  MOVF   xD4,F
13354:  BNZ   1335C
13356:  MOVLW  01
13358:  MOVWF  01
1335A:  BRA    13382
....................         if (c == ',')  return(0); // found seperator  
1335C:  MOVF   xD4,W
1335E:  SUBLW  2C
13360:  BNZ   13368
13362:  MOVLW  00
13364:  MOVWF  01
13366:  BRA    13382
....................         sub_string[n] = c; 
13368:  CLRF   03
1336A:  MOVF   xD5,W
1336C:  ADDLW  52
1336E:  MOVWF  FE9
13370:  MOVLW  00
13372:  ADDWFC 03,W
13374:  MOVWF  FEA
13376:  MOVFF  8D4,FEF
1337A:  INCF   xD5,F
1337C:  BRA    13334
....................    } 
....................     
....................    return(2); // failed = bad string 
1337E:  MOVLW  02
13380:  MOVWF  01
13382:  MOVLB  0
13384:  GOTO   136AE (RETURN)
.................... } 
....................   
.................... void load_parsed_data(int16 result) 
.................... { 
....................    switch (chem){ 
*
135C2:  MOVLW  2E
135C4:  MOVWF  FF6
135C6:  MOVLW  1C
135C8:  MOVWF  FF7
135CA:  MOVLW  00
135CC:  MOVWF  FF8
135CE:  MOVLW  03
135D0:  MOVWF  FEA
135D2:  MOVLW  3D
135D4:  MOVWF  FE9
135D6:  CALL   FE56
135DA:  MOVF   01,W
135DC:  BZ    135F0
135DE:  XORLW  01
135E0:  BZ    13610
135E2:  XORLW  03
135E4:  BZ    13630
135E6:  XORLW  01
135E8:  BZ    13650
135EA:  XORLW  07
135EC:  BZ    13670
135EE:  BRA    1368E
....................       case "NO3" : NO3_array[read_i] = result; 
135F0:  BCF    FD8.0
135F2:  MOVLB  3
135F4:  RLCF   x4A,W
135F6:  CLRF   03
135F8:  ADDLW  4B
135FA:  MOVWF  FE9
135FC:  MOVLW  03
135FE:  ADDWFC 03,W
13600:  MOVWF  FEA
13602:  MOVFF  8D5,FEC
13606:  MOVF   FED,F
13608:  MOVFF  8D4,FEF
....................          break; 
1360C:  MOVLB  0
1360E:  BRA    1368E
....................       case "NO2" : NO2_array[read_i] = result; 
13610:  BCF    FD8.0
13612:  MOVLB  3
13614:  RLCF   x4A,W
13616:  CLRF   03
13618:  ADDLW  5D
1361A:  MOVWF  FE9
1361C:  MOVLW  03
1361E:  ADDWFC 03,W
13620:  MOVWF  FEA
13622:  MOVFF  8D5,FEC
13626:  MOVF   FED,F
13628:  MOVFF  8D4,FEF
....................          break;    
1362C:  MOVLB  0
1362E:  BRA    1368E
....................       case "PO4" : PO4_array[read_i] = result; 
13630:  BCF    FD8.0
13632:  MOVLB  3
13634:  RLCF   x4A,W
13636:  CLRF   03
13638:  ADDLW  6F
1363A:  MOVWF  FE9
1363C:  MOVLW  03
1363E:  ADDWFC 03,W
13640:  MOVWF  FEA
13642:  MOVFF  8D5,FEC
13646:  MOVF   FED,F
13648:  MOVFF  8D4,FEF
....................          break; 
1364C:  MOVLB  0
1364E:  BRA    1368E
....................       case "NH4" : NH4_array[read_i] = result; 
13650:  BCF    FD8.0
13652:  MOVLB  3
13654:  RLCF   x4A,W
13656:  CLRF   03
13658:  ADDLW  81
1365A:  MOVWF  FE9
1365C:  MOVLW  03
1365E:  ADDWFC 03,W
13660:  MOVWF  FEA
13662:  MOVFF  8D5,FEC
13666:  MOVF   FED,F
13668:  MOVFF  8D4,FEF
....................          break; 
1366C:  MOVLB  0
1366E:  BRA    1368E
....................       case "SiO" : SiO_array[read_i] = result; 
13670:  BCF    FD8.0
13672:  MOVLB  3
13674:  RLCF   x4A,W
13676:  CLRF   03
13678:  ADDLW  93
1367A:  MOVWF  FE9
1367C:  MOVLW  03
1367E:  ADDWFC 03,W
13680:  MOVWF  FEA
13682:  MOVFF  8D5,FEC
13686:  MOVF   FED,F
13688:  MOVFF  8D4,FEF
....................          break; 
1368C:  MOVLB  0
....................    } 
1368E:  GOTO   13706 (RETURN)
.................... } 
....................  
.................... int16 parse_data() 
13692:  MOVLB  8
13694:  CLRF   xCF
13696:  CLRF   xCE
13698:  CLRF   xD1
1369A:  CLRF   xD0
.................... { 
....................    int16 result = 0; 
....................    int16 temp   = 0; 
....................    int8 n, parsed; 
....................     
....................    string_pos = 0; 
1369C:  MOVLB  2
1369E:  CLRF   x98
....................     
....................    for (n=0; n<11; ++n){ 
136A0:  MOVLB  8
136A2:  CLRF   xD2
136A4:  MOVF   xD2,W
136A6:  SUBLW  0A
136A8:  BNC   136FA
....................       parsed = parse_string(); 
136AA:  MOVLB  0
136AC:  BRA    13318
136AE:  MOVFF  01,8D3
....................       if (parsed == 2) return(0); 
136B2:  MOVLB  8
136B4:  MOVF   xD3,W
136B6:  SUBLW  02
136B8:  BNZ   136C2
136BA:  MOVLW  00
136BC:  MOVWF  01
136BE:  MOVWF  02
136C0:  BRA    13710
....................       if (n==8) result = atol(sub_string); 
136C2:  MOVF   xD2,W
136C4:  SUBLW  08
136C6:  BNZ   136DC
136C8:  CLRF   xD5
136CA:  MOVLW  52
136CC:  MOVWF  xD4
136CE:  MOVLB  0
136D0:  RCALL  133DE
136D2:  MOVFF  02,8CF
136D6:  MOVFF  01,8CE
136DA:  MOVLB  8
....................       if (n==10)  temp = atol(sub_string); 
136DC:  MOVF   xD2,W
136DE:  SUBLW  0A
136E0:  BNZ   136F6
136E2:  CLRF   xD5
136E4:  MOVLW  52
136E6:  MOVWF  xD4
136E8:  MOVLB  0
136EA:  RCALL  133DE
136EC:  MOVFF  02,8D1
136F0:  MOVFF  01,8D0
136F4:  MOVLB  8
136F6:  INCF   xD2,F
136F8:  BRA    136A4
....................    } 
....................    load_parsed_data(result); 
136FA:  MOVFF  8CF,8D5
136FE:  MOVFF  8CE,8D4
13702:  MOVLB  0
13704:  BRA    135C2
....................    return (temp); 
13706:  MOVLB  8
13708:  MOVFF  8D0,01
1370C:  MOVFF  8D1,02
13710:  MOVLB  0
13712:  RETURN 0
.................... } 
....................  
.................... // *** get data functions *** // 
....................  
.................... void clear_data_buffer() 
.................... { 
....................    memset (&data_buffer[0], 0x00, BUFFER_LEN);  //blank it 
*
0D51C:  CLRF   FEA
0D51E:  MOVLW  67
0D520:  MOVWF  FE9
0D522:  CLRF   00
0D524:  CLRF   02
0D526:  MOVLW  A0
0D528:  MOVWF  01
0D52A:  CALL   351A
0D52E:  RETURN 0
.................... } 
....................  
.................... int16 decode_flag() 
.................... { 
....................  
....................    int16 wave_l; 
....................    char temp_str[7]; 
....................  
....................    strcopy(chem,"XXX"); 
*
0F928:  MOVLW  03
0F92A:  MOVWF  FEA
0F92C:  MOVLW  3D
0F92E:  MOVWF  FE9
0F930:  MOVLW  00
0F932:  CALL   02E4
0F936:  TBLRD*-
0F938:  TBLRD*+
0F93A:  MOVF   FF5,W
0F93C:  MOVWF  FEE
0F93E:  IORLW  00
0F940:  BNZ   F938
....................  
....................    clear_flag_str(); 
0F942:  BRA    F910
....................  
....................    sprintf(temp_str,"%Lu",macro_flag);    
0F944:  MOVLW  08
0F946:  MOVWF  1E
0F948:  MOVLW  ED
0F94A:  MOVWF  1D
0F94C:  MOVLW  10
0F94E:  MOVWF  FE9
0F950:  MOVFF  324,8F7
0F954:  MOVFF  323,8F6
0F958:  CALL   AAF2
....................  
....................    if (macro_flag < 100) { 
0F95C:  MOVLB  3
0F95E:  MOVF   x24,F
0F960:  BNZ   F97A
0F962:  MOVF   x23,W
0F964:  SUBLW  63
0F966:  BNC   F97A
....................       temp_str[3] = '\0'; 
0F968:  MOVLB  8
0F96A:  CLRF   xF0
....................       temp_str[2] = temp_str[1]; 
0F96C:  MOVFF  8EE,8EF
....................       temp_str[1] = temp_str[0]; 
0F970:  MOVFF  8ED,8EE
....................       temp_str[0] = '0'; 
0F974:  MOVLW  30
0F976:  MOVWF  xED
0F978:  MOVLB  3
....................    } 
....................  
....................    switch (temp_str[0]){ 
0F97A:  MOVLB  8
0F97C:  MOVF   xED,W
0F97E:  XORLW  30
0F980:  MOVLB  0
0F982:  BZ    F9A6
0F984:  XORLW  01
0F986:  BZ    F9CC
0F988:  XORLW  03
0F98A:  BZ    F9F2
0F98C:  XORLW  01
0F98E:  BZ    FA18
0F990:  XORLW  07
0F992:  BZ    FA3E
0F994:  XORLW  01
0F996:  BZ    FA64
0F998:  XORLW  03
0F99A:  BTFSC  FD8.2
0F99C:  BRA    FA8A
0F99E:  XORLW  01
0F9A0:  BTFSC  FD8.2
0F9A2:  BRA    FAB0
0F9A4:  BRA    FAD8
....................       case '0' : strcopy(chem,"NO3"); 
0F9A6:  MOVLW  03
0F9A8:  MOVWF  FEA
0F9AA:  MOVLW  3D
0F9AC:  MOVWF  FE9
0F9AE:  MOVLW  00
0F9B0:  CALL   02FC
0F9B4:  TBLRD*-
0F9B6:  TBLRD*+
0F9B8:  MOVF   FF5,W
0F9BA:  MOVWF  FEE
0F9BC:  IORLW  00
0F9BE:  BNZ   F9B6
....................                  wave_l=543; 
0F9C0:  MOVLW  02
0F9C2:  MOVLB  8
0F9C4:  MOVWF  xEC
0F9C6:  MOVLW  1F
0F9C8:  MOVWF  xEB
....................          break; 
0F9CA:  BRA    FAFC
....................       case '1' : strcopy(chem,"PO4"); 
0F9CC:  MOVLW  03
0F9CE:  MOVWF  FEA
0F9D0:  MOVLW  3D
0F9D2:  MOVWF  FE9
0F9D4:  MOVLW  00
0F9D6:  CALL   0314
0F9DA:  TBLRD*-
0F9DC:  TBLRD*+
0F9DE:  MOVF   FF5,W
0F9E0:  MOVWF  FEE
0F9E2:  IORLW  00
0F9E4:  BNZ   F9DC
....................                  wave_l=880;       
0F9E6:  MOVLW  03
0F9E8:  MOVLB  8
0F9EA:  MOVWF  xEC
0F9EC:  MOVLW  70
0F9EE:  MOVWF  xEB
....................          break; 
0F9F0:  BRA    FAFC
....................       case '2' : strcopy(chem,"NH4"); 
0F9F2:  MOVLW  03
0F9F4:  MOVWF  FEA
0F9F6:  MOVLW  3D
0F9F8:  MOVWF  FE9
0F9FA:  MOVLW  00
0F9FC:  CALL   032C
0FA00:  TBLRD*-
0FA02:  TBLRD*+
0FA04:  MOVF   FF5,W
0FA06:  MOVWF  FEE
0FA08:  IORLW  00
0FA0A:  BNZ   FA02
....................                  wave_l=660;       
0FA0C:  MOVLW  02
0FA0E:  MOVLB  8
0FA10:  MOVWF  xEC
0FA12:  MOVLW  94
0FA14:  MOVWF  xEB
....................          break; 
0FA16:  BRA    FAFC
....................       case '3' : strcopy(chem,"SiO"); 
0FA18:  MOVLW  03
0FA1A:  MOVWF  FEA
0FA1C:  MOVLW  3D
0FA1E:  MOVWF  FE9
0FA20:  MOVLW  00
0FA22:  CALL   0344
0FA26:  TBLRD*-
0FA28:  TBLRD*+
0FA2A:  MOVF   FF5,W
0FA2C:  MOVWF  FEE
0FA2E:  IORLW  00
0FA30:  BNZ   FA28
....................                  wave_l=810;       
0FA32:  MOVLW  03
0FA34:  MOVLB  8
0FA36:  MOVWF  xEC
0FA38:  MOVLW  2A
0FA3A:  MOVWF  xEB
....................          break; 
0FA3C:  BRA    FAFC
....................       case '4' : strcopy(chem,"Ure"); 
0FA3E:  MOVLW  03
0FA40:  MOVWF  FEA
0FA42:  MOVLW  3D
0FA44:  MOVWF  FE9
0FA46:  MOVLW  00
0FA48:  CALL   035C
0FA4C:  TBLRD*-
0FA4E:  TBLRD*+
0FA50:  MOVF   FF5,W
0FA52:  MOVWF  FEE
0FA54:  IORLW  00
0FA56:  BNZ   FA4E
....................                  wave_l=525;       
0FA58:  MOVLW  02
0FA5A:  MOVLB  8
0FA5C:  MOVWF  xEC
0FA5E:  MOVLW  0D
0FA60:  MOVWF  xEB
....................          break; 
0FA62:  BRA    FAFC
....................       case '5' : strcopy(chem,"NO2"); 
0FA64:  MOVLW  03
0FA66:  MOVWF  FEA
0FA68:  MOVLW  3D
0FA6A:  MOVWF  FE9
0FA6C:  MOVLW  00
0FA6E:  CALL   0374
0FA72:  TBLRD*-
0FA74:  TBLRD*+
0FA76:  MOVF   FF5,W
0FA78:  MOVWF  FEE
0FA7A:  IORLW  00
0FA7C:  BNZ   FA74
....................                  wave_l=543;       
0FA7E:  MOVLW  02
0FA80:  MOVLB  8
0FA82:  MOVWF  xEC
0FA84:  MOVLW  1F
0FA86:  MOVWF  xEB
....................          break; 
0FA88:  BRA    FAFC
....................       case '6' : strcopy(chem,"Fe_"); 
0FA8A:  MOVLW  03
0FA8C:  MOVWF  FEA
0FA8E:  MOVLW  3D
0FA90:  MOVWF  FE9
0FA92:  MOVLW  00
0FA94:  CALL   038C
0FA98:  TBLRD*-
0FA9A:  TBLRD*+
0FA9C:  MOVF   FF5,W
0FA9E:  MOVWF  FEE
0FAA0:  IORLW  00
0FAA2:  BNZ   FA9A
....................                  wave_l=543;       
0FAA4:  MOVLW  02
0FAA6:  MOVLB  8
0FAA8:  MOVWF  xEC
0FAAA:  MOVLW  1F
0FAAC:  MOVWF  xEB
....................          break; 
0FAAE:  BRA    FAFC
....................       case '7' : strcopy(chem,"Cl_"); 
0FAB0:  MOVLW  03
0FAB2:  MOVWF  FEA
0FAB4:  MOVLW  3D
0FAB6:  MOVWF  FE9
0FAB8:  MOVLW  00
0FABA:  CALL   03A4
0FABE:  TBLRD*-
0FAC0:  TBLRD*+
0FAC2:  MOVF   FF5,W
0FAC4:  MOVWF  FEE
0FAC6:  IORLW  00
0FAC8:  BNZ   FAC0
....................                  wave_l=560;       
0FACA:  MOVLW  02
0FACC:  MOVLB  8
0FACE:  MOVWF  xEC
0FAD0:  MOVLW  30
0FAD2:  MOVWF  xEB
....................          break; 
0FAD4:  BRA    FAFC
0FAD6:  MOVLB  0
....................       default  : strcopy(chem,"XXX"); 
0FAD8:  MOVLW  03
0FADA:  MOVWF  FEA
0FADC:  MOVLW  3D
0FADE:  MOVWF  FE9
0FAE0:  MOVLW  00
0FAE2:  CALL   02E4
0FAE6:  TBLRD*-
0FAE8:  TBLRD*+
0FAEA:  MOVF   FF5,W
0FAEC:  MOVWF  FEE
0FAEE:  IORLW  00
0FAF0:  BNZ   FAE8
....................                  wave_l=999;       
0FAF2:  MOVLW  03
0FAF4:  MOVLB  8
0FAF6:  MOVWF  xEC
0FAF8:  MOVLW  E7
0FAFA:  MOVWF  xEB
....................          break; 
....................    } 
....................    switch (temp_str[1]){ 
0FAFC:  MOVF   xEE,W
0FAFE:  XORLW  31
0FB00:  MOVLB  0
0FB02:  BZ    FB22
0FB04:  XORLW  03
0FB06:  BZ    FB3E
0FB08:  XORLW  01
0FB0A:  BZ    FB5A
0FB0C:  XORLW  07
0FB0E:  BZ    FB76
0FB10:  XORLW  01
0FB12:  BZ    FB92
0FB14:  XORLW  03
0FB16:  BZ    FBAE
0FB18:  XORLW  01
0FB1A:  BZ    FBCA
0FB1C:  XORLW  0F
0FB1E:  BZ    FBE6
0FB20:  BRA    FC02
....................       case '1' : strcopy(anal,"Smp"); 
0FB22:  MOVLW  03
0FB24:  MOVWF  FEA
0FB26:  MOVLW  42
0FB28:  MOVWF  FE9
0FB2A:  MOVLW  00
0FB2C:  CALL   03BC
0FB30:  TBLRD*-
0FB32:  TBLRD*+
0FB34:  MOVF   FF5,W
0FB36:  MOVWF  FEE
0FB38:  IORLW  00
0FB3A:  BNZ   FB32
....................          break; 
0FB3C:  BRA    FC1C
....................       case '2' : strcopy(anal,"Std"); 
0FB3E:  MOVLW  03
0FB40:  MOVWF  FEA
0FB42:  MOVLW  42
0FB44:  MOVWF  FE9
0FB46:  MOVLW  00
0FB48:  CALL   03D4
0FB4C:  TBLRD*-
0FB4E:  TBLRD*+
0FB50:  MOVF   FF5,W
0FB52:  MOVWF  FEE
0FB54:  IORLW  00
0FB56:  BNZ   FB4E
....................          break; 
0FB58:  BRA    FC1C
....................       case '3' : strcopy(anal,"Cmb"); 
0FB5A:  MOVLW  03
0FB5C:  MOVWF  FEA
0FB5E:  MOVLW  42
0FB60:  MOVWF  FE9
0FB62:  MOVLW  00
0FB64:  CALL   03EC
0FB68:  TBLRD*-
0FB6A:  TBLRD*+
0FB6C:  MOVF   FF5,W
0FB6E:  MOVWF  FEE
0FB70:  IORLW  00
0FB72:  BNZ   FB6A
....................          break; 
0FB74:  BRA    FC1C
....................       case '4' : strcopy(anal,"Tst"); 
0FB76:  MOVLW  03
0FB78:  MOVWF  FEA
0FB7A:  MOVLW  42
0FB7C:  MOVWF  FE9
0FB7E:  MOVLW  00
0FB80:  CALL   0404
0FB84:  TBLRD*-
0FB86:  TBLRD*+
0FB88:  MOVF   FF5,W
0FB8A:  MOVWF  FEE
0FB8C:  IORLW  00
0FB8E:  BNZ   FB86
....................          break; 
0FB90:  BRA    FC1C
....................       case '5' : strcopy(anal,"Rbl"); 
0FB92:  MOVLW  03
0FB94:  MOVWF  FEA
0FB96:  MOVLW  42
0FB98:  MOVWF  FE9
0FB9A:  MOVLW  00
0FB9C:  CALL   041C
0FBA0:  TBLRD*-
0FBA2:  TBLRD*+
0FBA4:  MOVF   FF5,W
0FBA6:  MOVWF  FEE
0FBA8:  IORLW  00
0FBAA:  BNZ   FBA2
....................          break; 
0FBAC:  BRA    FC1C
....................       case '6' : strcopy(anal,"Cal"); 
0FBAE:  MOVLW  03
0FBB0:  MOVWF  FEA
0FBB2:  MOVLW  42
0FBB4:  MOVWF  FE9
0FBB6:  MOVLW  00
0FBB8:  CALL   0434
0FBBC:  TBLRD*-
0FBBE:  TBLRD*+
0FBC0:  MOVF   FF5,W
0FBC2:  MOVWF  FEE
0FBC4:  IORLW  00
0FBC6:  BNZ   FBBE
....................          break; 
0FBC8:  BRA    FC1C
....................       case '7' : strcopy(anal,"Fls"); 
0FBCA:  MOVLW  03
0FBCC:  MOVWF  FEA
0FBCE:  MOVLW  42
0FBD0:  MOVWF  FE9
0FBD2:  MOVLW  00
0FBD4:  CALL   044C
0FBD8:  TBLRD*-
0FBDA:  TBLRD*+
0FBDC:  MOVF   FF5,W
0FBDE:  MOVWF  FEE
0FBE0:  IORLW  00
0FBE2:  BNZ   FBDA
....................          break; 
0FBE4:  BRA    FC1C
....................       case '8' : strcopy(anal,"Utl"); 
0FBE6:  MOVLW  03
0FBE8:  MOVWF  FEA
0FBEA:  MOVLW  42
0FBEC:  MOVWF  FE9
0FBEE:  MOVLW  00
0FBF0:  CALL   0464
0FBF4:  TBLRD*-
0FBF6:  TBLRD*+
0FBF8:  MOVF   FF5,W
0FBFA:  MOVWF  FEE
0FBFC:  IORLW  00
0FBFE:  BNZ   FBF6
....................          break;     
0FC00:  BRA    FC1C
....................       default  : strcopy(anal,"XXX"); 
0FC02:  MOVLW  03
0FC04:  MOVWF  FEA
0FC06:  MOVLW  42
0FC08:  MOVWF  FE9
0FC0A:  MOVLW  00
0FC0C:  CALL   02E4
0FC10:  TBLRD*-
0FC12:  TBLRD*+
0FC14:  MOVF   FF5,W
0FC16:  MOVWF  FEE
0FC18:  IORLW  00
0FC1A:  BNZ   FC12
....................          break;          
....................    } 
....................    switch (temp_str[2]){ 
0FC1C:  MOVLB  8
0FC1E:  MOVF   xEF,W
0FC20:  XORLW  31
0FC22:  MOVLB  0
0FC24:  BZ    FC4E
0FC26:  XORLW  03
0FC28:  BZ    FC6E
0FC2A:  XORLW  01
0FC2C:  BZ    FC90
0FC2E:  XORLW  07
0FC30:  BZ    FCB2
0FC32:  XORLW  01
0FC34:  BZ    FCD4
0FC36:  XORLW  03
0FC38:  BZ    FCF6
0FC3A:  XORLW  01
0FC3C:  BTFSC  FD8.2
0FC3E:  BRA    FD18
0FC40:  XORLW  0F
0FC42:  BTFSC  FD8.2
0FC44:  BRA    FD3A
0FC46:  XORLW  01
0FC48:  BTFSC  FD8.2
0FC4A:  BRA    FD5C
0FC4C:  BRA    FD80
....................       case '1' : strcopy(read_t,"I0s"); 
0FC4E:  MOVLW  03
0FC50:  MOVWF  FEA
0FC52:  MOVLW  46
0FC54:  MOVWF  FE9
0FC56:  MOVLW  00
0FC58:  CALL   047C
0FC5C:  TBLRD*-
0FC5E:  TBLRD*+
0FC60:  MOVF   FF5,W
0FC62:  MOVWF  FEE
0FC64:  IORLW  00
0FC66:  BNZ   FC5E
....................                  read_i = 0; 
0FC68:  MOVLB  3
0FC6A:  CLRF   x4A
....................          break; 
0FC6C:  BRA    FD9E
....................       case '2' : strcopy(read_t,"I1s"); 
0FC6E:  MOVLW  03
0FC70:  MOVWF  FEA
0FC72:  MOVLW  46
0FC74:  MOVWF  FE9
0FC76:  MOVLW  00
0FC78:  CALL   0494
0FC7C:  TBLRD*-
0FC7E:  TBLRD*+
0FC80:  MOVF   FF5,W
0FC82:  MOVWF  FEE
0FC84:  IORLW  00
0FC86:  BNZ   FC7E
....................                  read_i = 1;       
0FC88:  MOVLW  01
0FC8A:  MOVLB  3
0FC8C:  MOVWF  x4A
....................          break; 
0FC8E:  BRA    FD9E
....................       case '3' : strcopy(read_t,"I0t"); 
0FC90:  MOVLW  03
0FC92:  MOVWF  FEA
0FC94:  MOVLW  46
0FC96:  MOVWF  FE9
0FC98:  MOVLW  00
0FC9A:  CALL   04AC
0FC9E:  TBLRD*-
0FCA0:  TBLRD*+
0FCA2:  MOVF   FF5,W
0FCA4:  MOVWF  FEE
0FCA6:  IORLW  00
0FCA8:  BNZ   FCA0
....................                  read_i = 2;       
0FCAA:  MOVLW  02
0FCAC:  MOVLB  3
0FCAE:  MOVWF  x4A
....................          break; 
0FCB0:  BRA    FD9E
....................       case '4' : strcopy(read_t,"I1t"); 
0FCB2:  MOVLW  03
0FCB4:  MOVWF  FEA
0FCB6:  MOVLW  46
0FCB8:  MOVWF  FE9
0FCBA:  MOVLW  00
0FCBC:  CALL   04C4
0FCC0:  TBLRD*-
0FCC2:  TBLRD*+
0FCC4:  MOVF   FF5,W
0FCC6:  MOVWF  FEE
0FCC8:  IORLW  00
0FCCA:  BNZ   FCC2
....................                  read_i = 3;       
0FCCC:  MOVLW  03
0FCCE:  MOVLB  3
0FCD0:  MOVWF  x4A
....................          break; 
0FCD2:  BRA    FD9E
....................       case '5' : strcopy(read_t,"I0r"); 
0FCD4:  MOVLW  03
0FCD6:  MOVWF  FEA
0FCD8:  MOVLW  46
0FCDA:  MOVWF  FE9
0FCDC:  MOVLW  00
0FCDE:  CALL   04DC
0FCE2:  TBLRD*-
0FCE4:  TBLRD*+
0FCE6:  MOVF   FF5,W
0FCE8:  MOVWF  FEE
0FCEA:  IORLW  00
0FCEC:  BNZ   FCE4
....................                  read_i = 4;       
0FCEE:  MOVLW  04
0FCF0:  MOVLB  3
0FCF2:  MOVWF  x4A
....................          break; 
0FCF4:  BRA    FD9E
....................       case '6' : strcopy(read_t,"I1r"); 
0FCF6:  MOVLW  03
0FCF8:  MOVWF  FEA
0FCFA:  MOVLW  46
0FCFC:  MOVWF  FE9
0FCFE:  MOVLW  00
0FD00:  CALL   04F4
0FD04:  TBLRD*-
0FD06:  TBLRD*+
0FD08:  MOVF   FF5,W
0FD0A:  MOVWF  FEE
0FD0C:  IORLW  00
0FD0E:  BNZ   FD06
....................                  read_i = 5;       
0FD10:  MOVLW  05
0FD12:  MOVLB  3
0FD14:  MOVWF  x4A
....................          break; 
0FD16:  BRA    FD9E
....................       case '7' : strcopy(read_t,"I0u"); 
0FD18:  MOVLW  03
0FD1A:  MOVWF  FEA
0FD1C:  MOVLW  46
0FD1E:  MOVWF  FE9
0FD20:  MOVLW  00
0FD22:  CALL   050C
0FD26:  TBLRD*-
0FD28:  TBLRD*+
0FD2A:  MOVF   FF5,W
0FD2C:  MOVWF  FEE
0FD2E:  IORLW  00
0FD30:  BNZ   FD28
....................                  read_i = 6;       
0FD32:  MOVLW  06
0FD34:  MOVLB  3
0FD36:  MOVWF  x4A
....................          break; 
0FD38:  BRA    FD9E
....................       case '8' : strcopy(read_t,"I1u"); 
0FD3A:  MOVLW  03
0FD3C:  MOVWF  FEA
0FD3E:  MOVLW  46
0FD40:  MOVWF  FE9
0FD42:  MOVLW  00
0FD44:  CALL   0524
0FD48:  TBLRD*-
0FD4A:  TBLRD*+
0FD4C:  MOVF   FF5,W
0FD4E:  MOVWF  FEE
0FD50:  IORLW  00
0FD52:  BNZ   FD4A
....................                  read_i = 7;       
0FD54:  MOVLW  07
0FD56:  MOVLB  3
0FD58:  MOVWF  x4A
....................          break; 
0FD5A:  BRA    FD9E
....................       case '9' : strcopy(read_t,"Chk"); 
0FD5C:  MOVLW  03
0FD5E:  MOVWF  FEA
0FD60:  MOVLW  46
0FD62:  MOVWF  FE9
0FD64:  MOVLW  00
0FD66:  CALL   053C
0FD6A:  TBLRD*-
0FD6C:  TBLRD*+
0FD6E:  MOVF   FF5,W
0FD70:  MOVWF  FEE
0FD72:  IORLW  00
0FD74:  BNZ   FD6C
....................                  read_i = 8;       
0FD76:  MOVLW  08
0FD78:  MOVLB  3
0FD7A:  MOVWF  x4A
....................          break;        
0FD7C:  BRA    FD9E
0FD7E:  MOVLB  0
....................       default  : strcopy(read_t,"XX"); 
0FD80:  MOVLW  03
0FD82:  MOVWF  FEA
0FD84:  MOVLW  46
0FD86:  MOVWF  FE9
0FD88:  MOVLW  00
0FD8A:  CALL   0554
0FD8E:  TBLRD*-
0FD90:  TBLRD*+
0FD92:  MOVF   FF5,W
0FD94:  MOVWF  FEE
0FD96:  IORLW  00
0FD98:  BNZ   FD90
....................                  read_i = 0;       
0FD9A:  MOVLB  3
0FD9C:  CLRF   x4A
....................          break;          
....................    } 
....................     
....................    strcat(flag_str, chem); 
0FD9E:  MOVLW  03
0FDA0:  MOVLB  8
0FDA2:  MOVWF  xF9
0FDA4:  MOVLW  25
0FDA6:  MOVWF  xF8
0FDA8:  MOVLW  03
0FDAA:  MOVWF  xFB
0FDAC:  MOVLW  3D
0FDAE:  MOVWF  xFA
0FDB0:  MOVLB  0
0FDB2:  CALL   54D2
....................    strcat(flag_str, (char *)","); 
0FDB6:  MOVLW  2C
0FDB8:  MOVLB  8
0FDBA:  MOVWF  xF4
0FDBC:  CLRF   xF5
0FDBE:  MOVLW  03
0FDC0:  MOVWF  xF9
0FDC2:  MOVLW  25
0FDC4:  MOVWF  xF8
0FDC6:  MOVLW  08
0FDC8:  MOVWF  xFB
0FDCA:  MOVLW  F4
0FDCC:  MOVWF  xFA
0FDCE:  MOVLB  0
0FDD0:  CALL   54D2
....................    strcat(flag_str, anal); 
0FDD4:  MOVLW  03
0FDD6:  MOVLB  8
0FDD8:  MOVWF  xF9
0FDDA:  MOVLW  25
0FDDC:  MOVWF  xF8
0FDDE:  MOVLW  03
0FDE0:  MOVWF  xFB
0FDE2:  MOVLW  42
0FDE4:  MOVWF  xFA
0FDE6:  MOVLB  0
0FDE8:  CALL   54D2
....................    strcat(flag_str, (char *)","); 
0FDEC:  MOVLW  2C
0FDEE:  MOVLB  8
0FDF0:  MOVWF  xF4
0FDF2:  CLRF   xF5
0FDF4:  MOVLW  03
0FDF6:  MOVWF  xF9
0FDF8:  MOVLW  25
0FDFA:  MOVWF  xF8
0FDFC:  MOVLW  08
0FDFE:  MOVWF  xFB
0FE00:  MOVLW  F4
0FE02:  MOVWF  xFA
0FE04:  MOVLB  0
0FE06:  CALL   54D2
....................    strcat(flag_str, read_t);   
0FE0A:  MOVLW  03
0FE0C:  MOVLB  8
0FE0E:  MOVWF  xF9
0FE10:  MOVLW  25
0FE12:  MOVWF  xF8
0FE14:  MOVLW  03
0FE16:  MOVWF  xFB
0FE18:  MOVLW  46
0FE1A:  MOVWF  xFA
0FE1C:  MOVLB  0
0FE1E:  CALL   54D2
....................     
....................    return wave_l; 
0FE22:  MOVLB  8
0FE24:  MOVFF  8EB,01
0FE28:  MOVFF  8EC,02
0FE2C:  MOVLB  0
0FE2E:  RETURN 0
.................... } 
....................  
.................... void det_cmd() 
.................... { 
....................    if (cmd=='K') detector_ch = arg; 
*
0F3F6:  MOVF   47,W
0F3F8:  SUBLW  4B
0F3FA:  BTFSC  FD8.2
0F3FC:  MOVFF  48,2D6
....................    if (cmd=='L') detector_li = arg; 
0F400:  MOVF   47,W
0F402:  SUBLW  4C
0F404:  BNZ   F40E
0F406:  MOVFF  49,2D8
0F40A:  MOVFF  48,2D7
....................   // if (cmd=='l') detector_li = arg;  // VK - not sure what to set detector_li to here 
....................  
....................    // sends a detector command (e.g. set LED) 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@DET[/%u][%c]ARG[%Lu]\r\n", detector, cmd, arg); 
0F40E:  MOVF   1F,W
0F410:  SUBLW  04
0F412:  BNZ   F4DC
0F414:  MOVF   20,F
0F416:  BNZ   F4DC
0F418:  MOVLW  44
0F41A:  MOVWF  FF6
0F41C:  MOVLW  1C
0F41E:  MOVWF  FF7
0F420:  MOVLW  00
0F422:  MOVWF  FF8
0F424:  CLRF   1B
0F426:  BTFSC  FF2.7
0F428:  BSF    1B.7
0F42A:  BCF    FF2.7
0F42C:  MOVLW  06
0F42E:  MOVLB  A
0F430:  MOVWF  x40
0F432:  MOVLB  0
0F434:  CALL   1018
0F438:  BTFSC  1B.7
0F43A:  BSF    FF2.7
0F43C:  CLRF   1B
0F43E:  BTFSC  FF2.7
0F440:  BSF    1B.7
0F442:  BCF    FF2.7
0F444:  MOVFF  2D5,A40
0F448:  MOVLW  1B
0F44A:  MOVLB  A
0F44C:  MOVWF  x41
0F44E:  MOVLB  0
0F450:  CALL   0F9A
0F454:  BTFSC  1B.7
0F456:  BSF    FF2.7
0F458:  MOVLW  5D
0F45A:  BTFSS  F9E.4
0F45C:  BRA    F45A
0F45E:  MOVWF  FAD
0F460:  MOVLW  5B
0F462:  BTFSS  F9E.4
0F464:  BRA    F462
0F466:  MOVWF  FAD
0F468:  MOVF   47,W
0F46A:  BTFSS  F9E.4
0F46C:  BRA    F46A
0F46E:  MOVWF  FAD
0F470:  MOVLW  50
0F472:  MOVWF  FF6
0F474:  MOVLW  1C
0F476:  MOVWF  FF7
0F478:  MOVLW  00
0F47A:  MOVWF  FF8
0F47C:  CLRF   1B
0F47E:  BTFSC  FF2.7
0F480:  BSF    1B.7
0F482:  BCF    FF2.7
0F484:  MOVLW  05
0F486:  MOVLB  A
0F488:  MOVWF  x40
0F48A:  MOVLB  0
0F48C:  CALL   1018
0F490:  BTFSC  1B.7
0F492:  BSF    FF2.7
0F494:  MOVLW  41
0F496:  MOVWF  FE9
0F498:  CLRF   1B
0F49A:  BTFSC  FF2.7
0F49C:  BSF    1B.7
0F49E:  BCF    FF2.7
0F4A0:  MOVFF  4B,A43
0F4A4:  MOVFF  4A,A42
0F4A8:  MOVFF  49,A41
0F4AC:  MOVFF  48,A40
0F4B0:  CALL   10DE
0F4B4:  BTFSC  1B.7
0F4B6:  BSF    FF2.7
0F4B8:  MOVLW  58
0F4BA:  MOVWF  FF6
0F4BC:  MOVLW  1C
0F4BE:  MOVWF  FF7
0F4C0:  MOVLW  00
0F4C2:  MOVWF  FF8
0F4C4:  CLRF   1B
0F4C6:  BTFSC  FF2.7
0F4C8:  BSF    1B.7
0F4CA:  BCF    FF2.7
0F4CC:  MOVLW  03
0F4CE:  MOVLB  A
0F4D0:  MOVWF  x40
0F4D2:  MOVLB  0
0F4D4:  CALL   1018
0F4D8:  BTFSC  1B.7
0F4DA:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0F4DC:  CALL   DA6C
....................       fprintf(COM_B, "/%u%c%Lu\r\n",detector, cmd, arg); 
0F4E0:  MOVLW  2F
0F4E2:  BTFSS  FA4.4
0F4E4:  BRA    F4E2
0F4E6:  MOVLB  F
0F4E8:  MOVWF  x1C
0F4EA:  MOVFF  2D5,8F3
0F4EE:  MOVLW  1B
0F4F0:  MOVLB  8
0F4F2:  MOVWF  xF4
0F4F4:  MOVLB  0
0F4F6:  CALL   DAB4
0F4FA:  MOVF   47,W
0F4FC:  BTFSS  FA4.4
0F4FE:  BRA    F4FC
0F500:  MOVLB  F
0F502:  MOVWF  x1C
0F504:  MOVLW  41
0F506:  MOVWF  FE9
0F508:  MOVFF  4B,8F6
0F50C:  MOVFF  4A,8F5
0F510:  MOVFF  49,8F4
0F514:  MOVFF  48,8F3
0F518:  MOVLB  0
0F51A:  BRA    F316
0F51C:  MOVLW  0D
0F51E:  BTFSS  FA4.4
0F520:  BRA    F51E
0F522:  MOVLB  F
0F524:  MOVWF  x1C
0F526:  MOVLW  0A
0F528:  BTFSS  FA4.4
0F52A:  BRA    F528
0F52C:  MOVWF  x1C
....................    multidrop_off(); 
0F52E:  MOVLB  0
0F530:  CALL   DB58
0F534:  RETURN 0
.................... } 
....................  
.................... rcvd_data_type_t get_slave_data() 
*
12E38:  MOVLB  8
12E3A:  CLRF   xEC
12E3C:  BCF    xED.0
12E3E:  CLRF   xEE
12E40:  CLRF   xF2
12E42:  CLRF   xF1
12E44:  CLRF   xF0
12E46:  CLRF   xEF
.................... { 
....................    int8 c, index = 0; 
....................    int1 startCharacterRcvd = FALSE; 
....................    rcvd_data_type_t rcvDataType = NO_DATA; 
....................    int32 tenMicroSecDelayCounter = 0; 
....................  
....................    memset (&slave_reply[0], 0x00, SLAVE_REPLY_CHARS); //blank it 
12E48:  MOVLW  02
12E4A:  MOVWF  FEA
12E4C:  MOVLW  47
12E4E:  MOVWF  FE9
12E50:  CLRF   00
12E52:  CLRF   02
12E54:  MOVLW  51
12E56:  MOVWF  01
12E58:  MOVLB  0
12E5A:  CALL   351A
....................  
....................    det_cmd(); 
12E5E:  CALL   F3F6
....................  
....................    // restarts WD and disables timer interrupts 
....................    // ... 4 seconds to complete code before restart or WD will bark 
....................    // ... stops led blinking (caused by timer interrupts) 
....................    suspend_heartbeat(); 
12E62:  CALL   5548
....................  
....................    // while record==FALSE or TRUE or buffer NOT full 
....................    // END occurs when a CR is received 
....................    // OUT occurs for a time-out 
....................    while (rcvDataType != DATA_COMPLETE && rcvDataType != RCV_TIMEOUT && index < SLAVE_REPLY_CHARS) 
12E66:  MOVLB  8
12E68:  MOVF   xEE,W
12E6A:  SUBLW  02
12E6C:  BZ    12F00
12E6E:  MOVF   xEE,W
12E70:  SUBLW  03
12E72:  BZ    12F00
12E74:  MOVF   xEC,W
12E76:  SUBLW  50
12E78:  BNC   12F00
....................    { 
....................       // is data received? 
....................       if (kbhit(COM_B)) 
12E7A:  BTFSS  FA4.5
12E7C:  BRA    12EB4
....................       { 
....................          c = fgetc(COM_B);          // Yes, read it 
12E7E:  MOVLB  0
12E80:  RCALL  12E1E
12E82:  MOVFF  01,8EB
....................  
....................          if(startCharacterRcvd) 
12E86:  MOVLB  8
12E88:  BTFSS  xED.0
12E8A:  BRA    12EAC
....................          {  // Store data only if the "start sentinel" has been received 
....................             slave_reply[index++] = c; 
12E8C:  MOVF   xEC,W
12E8E:  INCF   xEC,F
12E90:  CLRF   03
12E92:  ADDLW  47
12E94:  MOVWF  FE9
12E96:  MOVLW  02
12E98:  ADDWFC 03,W
12E9A:  MOVWF  FEA
12E9C:  MOVFF  8EB,FEF
....................             if (CARRIAGE_RET == c) 
12EA0:  MOVF   xEB,W
12EA2:  SUBLW  0D
12EA4:  BNZ   12EAA
....................             { 
....................                rcvDataType = DATA_COMPLETE; 
12EA6:  MOVLW  02
12EA8:  MOVWF  xEE
....................             } 
....................          } 
12EAA:  BRA    12EB4
....................          else 
....................          { 
....................             if (AT_SIGN == c) 
12EAC:  MOVF   xEB,W
12EAE:  SUBLW  40
12EB0:  BNZ   12EB4
....................             { 
....................                startCharacterRcvd = TRUE; 
12EB2:  BSF    xED.0
....................             } 
....................          } 
....................       } 
....................  
....................       delay_us(10); 
12EB4:  MOVLW  35
12EB6:  MOVWF  00
12EB8:  DECFSZ 00,F
12EBA:  BRA    12EB8
....................       if (tenMicroSecDelayCounter++ > 500000) 
12EBC:  MOVFF  8F2,8F6
12EC0:  MOVFF  8F1,8F5
12EC4:  MOVFF  8F0,8F4
12EC8:  MOVFF  8EF,8F3
12ECC:  MOVLW  01
12ECE:  ADDWF  xEF,F
12ED0:  BTFSC  FD8.0
12ED2:  INCF   xF0,F
12ED4:  BTFSC  FD8.2
12ED6:  INCF   xF1,F
12ED8:  BTFSC  FD8.2
12EDA:  INCF   xF2,F
12EDC:  MOVF   xF6,F
12EDE:  BNZ   12EFA
12EE0:  MOVF   xF5,W
12EE2:  SUBLW  06
12EE4:  BC    12EFE
12EE6:  XORLW  FF
12EE8:  BNZ   12EFA
12EEA:  MOVF   xF4,W
12EEC:  SUBLW  A0
12EEE:  BC    12EFE
12EF0:  XORLW  FF
12EF2:  BNZ   12EFA
12EF4:  MOVF   xF3,W
12EF6:  SUBLW  20
12EF8:  BC    12EFE
....................       { 
....................          rcvDataType = RCV_TIMEOUT;  // usec = tenMicroSecDelayCounter*delay_us(10) = 5,000,000 = 3 sec 
12EFA:  MOVLW  03
12EFC:  MOVWF  xEE
....................       } 
12EFE:  BRA    12E68
....................    } 
....................  
....................    if (SLAVE_REPLY_CHARS <= index ) 
12F00:  MOVF   xEC,W
12F02:  SUBLW  50
12F04:  BC    12F16
....................    { 
....................       if ( (RCV_TIMEOUT != rcvDataType) && (DATA_COMPLETE != rcvDataType) ) 
12F06:  MOVF   xEE,W
12F08:  SUBLW  03
12F0A:  BZ    12F16
12F0C:  MOVF   xEE,W
12F0E:  SUBLW  02
12F10:  BZ    12F16
....................       { 
....................          rcvDataType = SOME_DATA; 
12F12:  MOVLW  01
12F14:  MOVWF  xEE
....................       } 
....................    } 
....................  
....................    restart_heartbeat(); 
12F16:  MOVLB  0
12F18:  CALL   5568
....................    
....................    // FALSE 0 = start condition 
....................    // TRUE  1 = '@' received 
....................    // END   2 = CR received 
....................    // OUT   3 = time-out 
....................    return(rcvDataType); 
12F1C:  MOVLB  8
12F1E:  MOVFF  8EE,01
12F22:  MOVLB  0
12F24:  GOTO   1309C (RETURN)
.................... } 
....................  
.................... void display_rec(int8 store, int8 display) 
.................... { 
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
*
0FF5E:  MOVF   1F,F
0FF60:  BNZ   FF80
0FF62:  MOVF   20,F
0FF64:  BNZ   FF80
0FF66:  MOVLB  8
0FF68:  DECFSZ xEC,W
0FF6A:  BRA    FF6E
0FF6C:  BRA    FF72
0FF6E:  MOVLB  0
0FF70:  BRA    FF80
0FF72:  CLRF   FEA
0FF74:  MOVLW  67
0FF76:  MOVWF  FE9
0FF78:  MOVLB  0
0FF7A:  CALL   798A
0FF7E:  BRA    FF94
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
0FF80:  MOVF   20,F
0FF82:  BNZ   FF8A
0FF84:  MOVF   1F,W
0FF86:  SUBLW  03
0FF88:  BC    FF94
0FF8A:  CLRF   FEA
0FF8C:  MOVLW  67
0FF8E:  MOVWF  FE9
0FF90:  CALL   798A
....................  
....................    if (store==TRUE && sd_status==0) { 
0FF94:  MOVLB  8
0FF96:  DECFSZ xEB,W
0FF98:  BRA    FFF8
0FF9A:  MOVLB  2
0FF9C:  MOVF   xDC,F
0FF9E:  BTFSC  FD8.2
0FFA0:  BRA    FFA6
0FFA2:  MOVLB  8
0FFA4:  BRA    FFF8
....................        
....................       buffer_select = 0; 
0FFA6:  MOVLB  0
0FFA8:  CLRF   x66
....................       
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FFAA:  MOVLB  8
0FFAC:  CLRF   xED
0FFAE:  MOVLB  0
0FFB0:  CALL   557A
....................          append_data(file_ptr_raw_all); 
0FFB4:  MOVLW  02
0FFB6:  MOVLB  8
0FFB8:  MOVWF  xEE
0FFBA:  MOVLW  DD
0FFBC:  MOVWF  xED
0FFBE:  MOVLB  0
0FFC0:  CALL   82EC
....................       heartbeat(TRUE); 
0FFC4:  MOVLW  01
0FFC6:  MOVLB  8
0FFC8:  MOVWF  xED
0FFCA:  MOVLB  0
0FFCC:  CALL   557A
....................        
....................       heartbeat(FALSE); // restarts WD & stops timer = 4 seconds to complete 
0FFD0:  MOVLB  8
0FFD2:  CLRF   xED
0FFD4:  MOVLB  0
0FFD6:  CALL   557A
....................          append_data(file_ptr_raw_new); 
0FFDA:  MOVLW  02
0FFDC:  MOVLB  8
0FFDE:  MOVWF  xEE
0FFE0:  MOVLW  EB
0FFE2:  MOVWF  xED
0FFE4:  MOVLB  0
0FFE6:  CALL   82EC
....................       heartbeat(TRUE); 
0FFEA:  MOVLW  01
0FFEC:  MOVLB  8
0FFEE:  MOVWF  xED
0FFF0:  MOVLB  0
0FFF2:  CALL   557A
0FFF6:  MOVLB  8
....................    } 
0FFF8:  MOVLB  0
0FFFA:  RETURN 0
.................... } 
....................  
.................... int16 det_read(int8 store, int8 display) 
*
12F34:  CLRF   xE5
.................... { 
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................     
....................    #define SHT 4 
....................    #define LNG 5 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
12F28:  MOVLW  0D
12F2A:  MOVLB  8
12F2C:  MOVWF  xCE
12F2E:  MOVLW  0A
12F30:  MOVWF  xCF
12F32:  CLRF   xD0
....................    char err_msg[ERR_MSG_LENGTH]; 
.................... //!   char timeout[4] = {'T','-','O','\0'}; 
.................... //!   char at_rx[4] = {'@','R','x','\0'}; 
.................... //!   char nil_rx[4] = {'N','I','L','\0'}; 
....................  
....................    rcvd_data_type_t rcvdData = NO_DATA; 
....................    int8  i, rec_len,flag_mod; 
....................  
....................    clear_slave_reply(); 
12F36:  MOVLB  0
12F38:  RCALL  127E2
....................    clear_data_buffer(); 
12F3A:  CALL   D51C
....................    memset (&err_msg[0], 0x00, ERR_MSG_LENGTH);  //blank it 
12F3E:  MOVLW  08
12F40:  MOVWF  FEA
12F42:  MOVLW  D1
12F44:  MOVWF  FE9
12F46:  CLRF   00
12F48:  CLRF   02
12F4A:  MOVLW  14
12F4C:  MOVWF  01
12F4E:  CALL   351A
....................    memset (&event_str[0], 0x00, BUFFER_LEN);    //blank it 
12F52:  MOVLW  01
12F54:  MOVWF  FEA
12F56:  MOVLW  A7
12F58:  MOVWF  FE9
12F5A:  CLRF   00
12F5C:  CLRF   02
12F5E:  MOVLW  A0
12F60:  MOVWF  01
12F62:  CALL   351A
....................  
....................    time_stamp(); 
12F66:  CALL   540E
....................    strcpy(data_buffer, time_stmp_str); 
12F6A:  CLRF   FEA
12F6C:  MOVLW  67
12F6E:  MOVWF  FE9
12F70:  MOVLW  02
12F72:  MOVWF  FE2
12F74:  MOVLW  99
12F76:  MOVWF  FE1
12F78:  MOVF   FE7,F
12F7A:  MOVFF  FE6,FEE
12F7E:  BNZ   12F78
....................    strcat(data_buffer, (char *)","); 
12F80:  MOVLW  2C
12F82:  MOVLB  8
12F84:  MOVWF  xE9
12F86:  CLRF   xEA
12F88:  CLRF   xF9
12F8A:  MOVLW  67
12F8C:  MOVWF  xF8
12F8E:  MOVLW  08
12F90:  MOVWF  xFB
12F92:  MOVLW  E9
12F94:  MOVWF  xFA
12F96:  MOVLB  0
12F98:  CALL   54D2
....................  
....................    flag_mod=fmod(macro_flag,10); 
12F9C:  MOVFF  324,918
12FA0:  MOVFF  323,917
12FA4:  CALL   C8EA
12FA8:  MOVFF  03,8EE
12FAC:  MOVFF  02,8ED
12FB0:  MOVFF  01,8EC
12FB4:  MOVFF  00,8EB
12FB8:  MOVFF  03,8F2
12FBC:  MOVFF  02,8F1
12FC0:  MOVFF  01,8F0
12FC4:  MOVFF  00,8EF
12FC8:  MOVLB  8
12FCA:  CLRF   xF6
12FCC:  CLRF   xF5
12FCE:  MOVLW  20
12FD0:  MOVWF  xF4
12FD2:  MOVLW  82
12FD4:  MOVWF  xF3
12FD6:  MOVLB  0
12FD8:  BRA    12BDE
12FDA:  MOVFF  03,916
12FDE:  MOVFF  02,915
12FE2:  MOVFF  01,914
12FE6:  MOVFF  00,913
12FEA:  RCALL  127F8
12FEC:  MOVFF  01,8E8
....................   // fprintf(COM_A, "Flag Mod=%u\r\n",flag_mod); // just a print for testing 
....................  
....................    if (flag_mod==1 || flag_mod==3) 
12FF0:  MOVLB  8
12FF2:  DECFSZ xE8,W
12FF4:  BRA    12FF8
12FF6:  BRA    12FFE
12FF8:  MOVF   xE8,W
12FFA:  SUBLW  03
12FFC:  BNZ   1301C
....................    { 
....................       clear_proc_time_stmp_str(); 
12FFE:  MOVLB  0
13000:  BRA    12D46
....................       strcopy(proc_time_stmp_str,time_stmp_str); 
13002:  MOVLW  02
13004:  MOVWF  FEA
13006:  MOVLW  B7
13008:  MOVWF  FE9
1300A:  MOVLW  02
1300C:  MOVWF  FE2
1300E:  MOVLW  99
13010:  MOVWF  FE1
13012:  MOVF   FE7,F
13014:  MOVFF  FE6,FEE
13018:  BNZ   13012
1301A:  MOVLB  8
....................    } 
....................  
....................    decode_flag();    
1301C:  MOVLB  0
1301E:  CALL   F928
....................    strncat(data_buffer, flag_str, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13022:  MOVLB  8
13024:  CLRF   xEC
13026:  MOVLW  67
13028:  MOVWF  xEB
1302A:  MOVLB  0
1302C:  RCALL  12D5E
1302E:  MOVFF  02,03
13032:  MOVF   01,W
13034:  XORLW  FF
13036:  ADDLW  A1
13038:  MOVLB  8
1303A:  MOVWF  xEB
1303C:  MOVLW  00
1303E:  SUBFWB 02,W
13040:  MOVWF  xEC
13042:  MOVLW  01
13044:  SUBWF  xEB,F
13046:  MOVLW  00
13048:  SUBWFB xEC,F
1304A:  CLRF   xEE
1304C:  MOVLW  67
1304E:  MOVWF  xED
13050:  MOVLW  03
13052:  MOVWF  xF0
13054:  MOVLW  25
13056:  MOVWF  xEF
13058:  MOVFF  8EC,8F2
1305C:  MOVFF  8EB,8F1
13060:  MOVLB  0
13062:  RCALL  12D9A
....................    strcat(data_buffer, (char *)","); 
13064:  MOVLW  2C
13066:  MOVLB  8
13068:  MOVWF  xE9
1306A:  CLRF   xEA
1306C:  CLRF   xF9
1306E:  MOVLW  67
13070:  MOVWF  xF8
13072:  MOVLW  08
13074:  MOVWF  xFB
13076:  MOVLW  E9
13078:  MOVWF  xFA
1307A:  MOVLB  0
1307C:  CALL   54D2
....................     
....................    cmd = 'S'; 
13080:  MOVLW  53
13082:  MOVWF  47
....................    arg = 1; 
13084:  CLRF   4B
13086:  CLRF   4A
13088:  CLRF   49
1308A:  MOVLW  01
1308C:  MOVWF  48
....................  
....................    for(i = 0; i < 6; i++) 
1308E:  MOVLB  8
13090:  CLRF   xE6
13092:  MOVF   xE6,W
13094:  SUBLW  05
13096:  BNC   130AE
....................    { 
....................       rcvdData = get_slave_data(); 
13098:  MOVLB  0
1309A:  BRA    12E38
1309C:  MOVFF  01,8E5
....................       if (DATA_COMPLETE == rcvdData) 
130A0:  MOVLB  8
130A2:  MOVF   xE5,W
130A4:  SUBLW  02
130A6:  BNZ   130AA
....................       { 
....................          break; 
130A8:  BRA    130AE
....................       } 
130AA:  INCF   xE6,F
130AC:  BRA    13092
....................    } 
....................  
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
130AE:  CLRF   xEC
130B0:  MOVLW  67
130B2:  MOVWF  xEB
130B4:  MOVLB  0
130B6:  RCALL  12D5E
130B8:  MOVFF  02,03
130BC:  MOVF   01,W
130BE:  XORLW  FF
130C0:  ADDLW  A1
130C2:  MOVLB  8
130C4:  MOVWF  xEB
130C6:  MOVLW  00
130C8:  SUBFWB 02,W
130CA:  MOVWF  xEC
130CC:  MOVLW  01
130CE:  SUBWF  xEB,F
130D0:  MOVLW  00
130D2:  SUBWFB xEC,F
130D4:  CLRF   xEE
130D6:  MOVLW  67
130D8:  MOVWF  xED
130DA:  MOVLW  02
130DC:  MOVWF  xF0
130DE:  MOVLW  47
130E0:  MOVWF  xEF
130E2:  MOVFF  8EC,8F2
130E6:  MOVFF  8EB,8F1
130EA:  MOVLB  0
130EC:  RCALL  12D9A
....................  
....................    // if record either NIL or @ received, test the length 
....................    rec_len = strlen(slave_reply); 
130EE:  MOVLW  02
130F0:  MOVLB  8
130F2:  MOVWF  xEC
130F4:  MOVLW  47
130F6:  MOVWF  xEB
130F8:  MOVLB  0
130FA:  RCALL  12D5E
130FC:  MOVFF  01,8E7
....................    if (rec_len > 0 && rec_len < 12) 
13100:  MOVLB  8
13102:  MOVF   xE7,F
13104:  BZ    13112
13106:  MOVF   xE7,W
13108:  SUBLW  0B
1310A:  BNC   13112
....................    { 
....................       rcvdData = SHORT_DATA; 
1310C:  MOVLW  04
1310E:  MOVWF  xE5
....................    } 
13110:  BRA    1311C
....................    else 
....................    { 
....................       if (rec_len > 30) 
13112:  MOVF   xE7,W
13114:  SUBLW  1E
13116:  BC    1311C
....................       { 
....................          rcvdData = LONG_DATA; 
13118:  MOVLW  05
1311A:  MOVWF  xE5
....................       } 
....................    } 
....................  
....................    switch(rcvdData) 
1311C:  MOVLW  02
1311E:  SUBWF  xE5,W
13120:  ADDLW  FC
13122:  BC    1318E
13124:  ADDLW  04
13126:  MOVLB  0
13128:  GOTO   132F0
....................    { 
....................       case DATA_COMPLETE: 
....................       { 
....................          // do nothing 
....................          break; 
1312C:  MOVLB  8
1312E:  BRA    1318E
13130:  MOVLB  0
....................       } 
....................       case RCV_TIMEOUT: 
....................       { 
....................          sprintf(err_msg, " time-out"); 
13132:  MOVLW  08
13134:  MOVWF  1E
13136:  MOVLW  D1
13138:  MOVWF  1D
1313A:  MOVLW  5C
1313C:  MOVWF  FF6
1313E:  MOVLW  1C
13140:  MOVWF  FF7
13142:  MOVLW  00
13144:  MOVWF  FF8
13146:  CALL   50B2
....................          break; 
1314A:  MOVLB  8
1314C:  BRA    1318E
1314E:  MOVLB  0
....................       } 
....................       case SHORT_DATA: 
....................       { 
....................          sprintf(err_msg, " data too short"); 
13150:  MOVLW  08
13152:  MOVWF  1E
13154:  MOVLW  D1
13156:  MOVWF  1D
13158:  MOVLW  66
1315A:  MOVWF  FF6
1315C:  MOVLW  1C
1315E:  MOVWF  FF7
13160:  MOVLW  00
13162:  MOVWF  FF8
13164:  CALL   50B2
....................          break; 
13168:  MOVLB  8
1316A:  BRA    1318E
1316C:  MOVLB  0
....................       } 
....................       case LONG_DATA: 
....................       { 
....................          sprintf(err_msg, " data too long"); 
1316E:  MOVLW  08
13170:  MOVWF  1E
13172:  MOVLW  D1
13174:  MOVWF  1D
13176:  MOVLW  76
13178:  MOVWF  FF6
1317A:  MOVLW  1C
1317C:  MOVWF  FF7
1317E:  MOVLW  00
13180:  MOVWF  FF8
13182:  CALL   50B2
....................          break; 
13186:  MOVLB  8
13188:  BRA    1318E
1318A:  MOVLB  0
1318C:  MOVLB  8
....................       } 
....................    } 
....................  
....................    strncat(data_buffer, err_msg, (BUFFER_LEN - strlen(data_buffer) - 1)); 
1318E:  CLRF   xEC
13190:  MOVLW  67
13192:  MOVWF  xEB
13194:  MOVLB  0
13196:  RCALL  12D5E
13198:  MOVFF  02,03
1319C:  MOVF   01,W
1319E:  XORLW  FF
131A0:  ADDLW  A1
131A2:  MOVLB  8
131A4:  MOVWF  xEB
131A6:  MOVLW  00
131A8:  SUBFWB 02,W
131AA:  MOVWF  xEC
131AC:  MOVLW  01
131AE:  SUBWF  xEB,F
131B0:  MOVLW  00
131B2:  SUBWFB xEC,F
131B4:  CLRF   xEE
131B6:  MOVLW  67
131B8:  MOVWF  xED
131BA:  MOVLW  08
131BC:  MOVWF  xF0
131BE:  MOVLW  D1
131C0:  MOVWF  xEF
131C2:  MOVFF  8EC,8F2
131C6:  MOVFF  8EB,8F1
131CA:  MOVLB  0
131CC:  RCALL  12D9A
....................    strncat(data_buffer, endofline, (BUFFER_LEN - strlen(data_buffer) - 1)); 
131CE:  MOVLB  8
131D0:  CLRF   xEC
131D2:  MOVLW  67
131D4:  MOVWF  xEB
131D6:  MOVLB  0
131D8:  RCALL  12D5E
131DA:  MOVFF  02,03
131DE:  MOVF   01,W
131E0:  XORLW  FF
131E2:  ADDLW  A1
131E4:  MOVLB  8
131E6:  MOVWF  xEB
131E8:  MOVLW  00
131EA:  SUBFWB 02,W
131EC:  MOVWF  xEC
131EE:  MOVLW  01
131F0:  SUBWF  xEB,F
131F2:  MOVLW  00
131F4:  SUBWFB xEC,F
131F6:  CLRF   xEE
131F8:  MOVLW  67
131FA:  MOVWF  xED
131FC:  MOVLW  08
131FE:  MOVWF  xF0
13200:  MOVLW  CE
13202:  MOVWF  xEF
13204:  MOVFF  8EC,8F2
13208:  MOVFF  8EB,8F1
1320C:  MOVLB  0
1320E:  RCALL  12D9A
....................  
....................    if(DATA_COMPLETE != rcvdData) 
13210:  MOVLB  8
13212:  MOVF   xE5,W
13214:  SUBLW  02
13216:  BZ    132D2
....................    {    //housekeeping 
....................       time_stamp(); 
13218:  MOVLB  0
1321A:  CALL   540E
....................       sprintf(event_str, ",detector[%s],len[%u]", err_msg, rec_len); 
1321E:  MOVLW  01
13220:  MOVWF  1E
13222:  MOVLW  A7
13224:  MOVWF  1D
13226:  MOVLW  86
13228:  MOVWF  FF6
1322A:  MOVLW  1C
1322C:  MOVWF  FF7
1322E:  MOVLW  00
13230:  MOVWF  FF8
13232:  MOVLW  0A
13234:  MOVLB  8
13236:  MOVWF  xEB
13238:  MOVLB  0
1323A:  CALL   AAC0
1323E:  MOVFF  1E,FEA
13242:  MOVFF  1D,FE9
13246:  CLRF   FEF
13248:  MOVLW  08
1324A:  MOVWF  FEA
1324C:  MOVLW  D1
1324E:  MOVWF  FE9
13250:  CALL   FE30
13254:  MOVLW  92
13256:  MOVWF  FF6
13258:  MOVLW  1C
1325A:  MOVWF  FF7
1325C:  MOVLW  00
1325E:  MOVWF  FF8
13260:  MOVLW  06
13262:  MOVLB  8
13264:  MOVWF  xEB
13266:  MOVLB  0
13268:  CALL   AAC0
1326C:  MOVFF  8E7,8ED
13270:  MOVLW  1B
13272:  MOVLB  8
13274:  MOVWF  xEE
13276:  MOVLB  0
13278:  CALL   5274
1327C:  MOVLW  5D
1327E:  MOVLB  8
13280:  MOVWF  xFF
13282:  MOVLB  0
13284:  CALL   5092
....................       strncat(event_str, data_buffer, (BUFFER_LEN - strlen(event_str) - 1)); 
13288:  MOVLW  01
1328A:  MOVLB  8
1328C:  MOVWF  xEC
1328E:  MOVLW  A7
13290:  MOVWF  xEB
13292:  MOVLB  0
13294:  RCALL  12D5E
13296:  MOVFF  02,03
1329A:  MOVF   01,W
1329C:  XORLW  FF
1329E:  ADDLW  A1
132A0:  MOVLB  8
132A2:  MOVWF  xEB
132A4:  MOVLW  00
132A6:  SUBFWB 02,W
132A8:  MOVWF  xEC
132AA:  MOVLW  01
132AC:  SUBWF  xEB,F
132AE:  MOVLW  00
132B0:  SUBWFB xEC,F
132B2:  MOVLW  01
132B4:  MOVWF  xEE
132B6:  MOVLW  A7
132B8:  MOVWF  xED
132BA:  CLRF   xF0
132BC:  MOVLW  67
132BE:  MOVWF  xEF
132C0:  MOVFF  8EC,8F2
132C4:  MOVFF  8EB,8F1
132C8:  MOVLB  0
132CA:  RCALL  12D9A
....................       record_event(); 
132CC:  CALL   84CE
132D0:  MOVLB  8
....................    } 
....................  
....................    display_rec(store, display); 
132D2:  MOVFF  8CC,8EB
132D6:  MOVFF  8CD,8EC
132DA:  MOVLB  0
132DC:  CALL   FF5E
....................  
....................    return (rcvdData); 
132E0:  CLRF   03
132E2:  MOVLB  8
132E4:  MOVFF  8E5,01
132E8:  MOVFF  03,02
132EC:  MOVLB  0
132EE:  RETURN 0
.................... } 
....................  
.................... void get_det_read(int8 store, int8 display) 
.................... { 
....................    int8 index; 
....................  
....................    for(index = 0; index < 3; ++index) 
*
13714:  MOVLB  8
13716:  CLRF   xC4
13718:  MOVF   xC4,W
1371A:  SUBLW  02
1371C:  BTFSS  FD8.0
1371E:  BRA    13834
....................    { 
....................       if (DATA_COMPLETE == det_read(store, display)) 
13720:  MOVFF  8C2,8CC
13724:  MOVFF  8C3,8CD
13728:  MOVLB  0
1372A:  CALL   12F28
1372E:  MOVFF  02,03
13732:  MOVF   01,W
13734:  SUBLW  02
13736:  BNZ   13744
13738:  MOVF   03,F
1373A:  BNZ   13744
....................       { 
....................          break; 
1373C:  MOVLB  8
1373E:  BRA    13834
....................       } 
13740:  BRA    13830
13742:  MOVLB  0
....................       else 
....................       { 
....................          fprintf(COM_A, "@RTY,%u\r\n", (index+1)); 
13744:  MOVLW  01
13746:  MOVLB  8
13748:  ADDWF  xC4,W
1374A:  MOVWF  xC5
1374C:  MOVLW  9C
1374E:  MOVWF  FF6
13750:  MOVLW  1C
13752:  MOVWF  FF7
13754:  MOVLW  00
13756:  MOVWF  FF8
13758:  CLRF   1B
1375A:  BTFSC  FF2.7
1375C:  BSF    1B.7
1375E:  BCF    FF2.7
13760:  MOVLW  05
13762:  MOVLB  A
13764:  MOVWF  x40
13766:  MOVLB  0
13768:  CALL   1018
1376C:  BTFSC  1B.7
1376E:  BSF    FF2.7
13770:  CLRF   1B
13772:  BTFSC  FF2.7
13774:  BSF    1B.7
13776:  BCF    FF2.7
13778:  MOVFF  8C5,A40
1377C:  MOVLW  1B
1377E:  MOVLB  A
13780:  MOVWF  x41
13782:  MOVLB  0
13784:  CALL   0F9A
13788:  BTFSC  1B.7
1378A:  BSF    FF2.7
1378C:  MOVLW  0D
1378E:  BTFSS  F9E.4
13790:  BRA    1378E
13792:  MOVWF  FAD
13794:  MOVLW  0A
13796:  BTFSS  F9E.4
13798:  BRA    13796
1379A:  MOVWF  FAD
....................          output_bit(VDET,OFF); 
1379C:  BCF    F90.7
....................          delay_ms(1000); 
1379E:  MOVLW  04
137A0:  MOVLB  8
137A2:  MOVWF  xC5
137A4:  MOVLW  FA
137A6:  MOVLB  9
137A8:  MOVWF  xEC
137AA:  MOVLB  0
137AC:  CALL   2904
137B0:  MOVLB  8
137B2:  DECFSZ xC5,F
137B4:  BRA    137A4
....................          output_bit(VDET,ON); 
137B6:  BSF    F90.7
....................          delay_ms(1000); 
137B8:  MOVLW  04
137BA:  MOVWF  xC5
137BC:  MOVLW  FA
137BE:  MOVLB  9
137C0:  MOVWF  xEC
137C2:  MOVLB  0
137C4:  CALL   2904
137C8:  MOVLB  8
137CA:  DECFSZ xC5,F
137CC:  BRA    137BC
....................          if (LightTargetFlag==0) 
137CE:  MOVLB  2
137D0:  MOVF   xD9,F
137D2:  BNZ   1381A
....................          { 
....................           cmd='K'; 
137D4:  MOVLW  4B
137D6:  MOVWF  47
....................           arg=detector_ch; 
137D8:  CLRF   4B
137DA:  CLRF   4A
137DC:  CLRF   49
137DE:  MOVFF  2D6,48
....................           det_cmd(); 
137E2:  MOVLB  0
137E4:  CALL   F3F6
....................           delay_ms(1000); 
137E8:  MOVLW  04
137EA:  MOVLB  8
137EC:  MOVWF  xC5
137EE:  MOVLW  FA
137F0:  MOVLB  9
137F2:  MOVWF  xEC
137F4:  MOVLB  0
137F6:  CALL   2904
137FA:  MOVLB  8
137FC:  DECFSZ xC5,F
137FE:  BRA    137EE
....................           cmd='L'; 
13800:  MOVLW  4C
13802:  MOVWF  47
....................           arg=detector_li; 
13804:  CLRF   4B
13806:  CLRF   4A
13808:  MOVFF  2D8,49
1380C:  MOVFF  2D7,48
....................           det_cmd(); 
13810:  MOVLB  0
13812:  CALL   F3F6
....................          }  
13816:  BRA    1382E
13818:  MOVLB  2
....................          else 
....................          { 
....................           cmd='l'; 
1381A:  MOVLW  6C
1381C:  MOVWF  47
....................           arg=1; 
1381E:  CLRF   4B
13820:  CLRF   4A
13822:  CLRF   49
13824:  MOVLW  01
13826:  MOVWF  48
....................           det_cmd(); 
13828:  MOVLB  0
1382A:  CALL   F3F6
1382E:  MOVLB  8
....................          }  
....................       } 
13830:  INCF   xC4,F
13832:  BRA    13718
....................    } 
....................  
....................    parse_data(); 
13834:  MOVLB  0
13836:  RCALL  13692
....................    data_available = TRUE; 
13838:  MOVLW  01
1383A:  MOVLB  3
1383C:  MOVWF  x3B
....................    macro_flag = 900; 
1383E:  MOVLW  03
13840:  MOVWF  x24
13842:  MOVLW  84
13844:  MOVWF  x23
....................  
....................    return; 
13846:  MOVLB  0
13848:  RETURN 0
.................... } 
....................  
.................... int16 parse_temp() 
*
13BB4:  MOVLB  8
13BB6:  CLRF   xCD
13BB8:  CLRF   xCC
.................... { 
....................    int16 temp = 0; 
....................  
....................    temp = parse_data(); 
13BBA:  MOVLB  0
13BBC:  RCALL  13692
13BBE:  MOVFF  02,8CD
13BC2:  MOVFF  01,8CC
....................    return (temp); 
13BC6:  MOVLB  8
13BC8:  MOVFF  8CC,01
13BCC:  MOVFF  8CD,02
13BD0:  MOVLB  0
13BD2:  GOTO   13CE4 (RETURN)
.................... } 
....................  
.................... void det_temp() 
13BD6:  MOVLB  8
13BD8:  CLRF   xC9
13BDA:  CLRF   xC8
.................... { 
....................    int8 store,display; 
....................    int16 n,t; 
....................    int16 current_temp = 0; 
....................    int16 target_temp; 
....................     
....................    switch (detector) 
13BDC:  MOVLB  2
13BDE:  MOVF   xD5,W
13BE0:  XORLW  01
13BE2:  MOVLB  0
13BE4:  BZ    13BEC
13BE6:  XORLW  03
13BE8:  BZ    13BF6
13BEA:  BRA    13C00
....................    { 
....................       case 1 : target_temp = nv_d1_temp; 
13BEC:  MOVFF  42,8CB
13BF0:  MOVFF  41,8CA
....................          break; 
13BF4:  BRA    13C0C
....................       case 2 : target_temp = nv_d2_temp; 
13BF6:  MOVFF  44,8CB
13BFA:  MOVFF  43,8CA
....................          break; 
13BFE:  BRA    13C0C
....................       default : target_temp = 20000; 
13C00:  MOVLW  4E
13C02:  MOVLB  8
13C04:  MOVWF  xCB
13C06:  MOVLW  20
13C08:  MOVWF  xCA
....................          break; 
13C0A:  MOVLB  0
....................    } 
....................  
....................    t = 60;         // 5 mins = 300 sec >> delay = 300 / 5 = 60 
13C0C:  MOVLB  8
13C0E:  CLRF   xC7
13C10:  MOVLW  3C
13C12:  MOVWF  xC6
....................    n = 0; 
13C14:  CLRF   xC5
13C16:  CLRF   xC4
....................    store=FALSE; 
13C18:  CLRF   xC2
....................    display=FALSE; 
13C1A:  CLRF   xC3
....................  
....................    time_stamp(); 
13C1C:  MOVLB  0
13C1E:  CALL   540E
....................    sprintf(event_str, ",start heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n", target_temp,current_temp,n); 
13C22:  MOVLW  01
13C24:  MOVWF  1E
13C26:  MOVLW  A7
13C28:  MOVWF  1D
13C2A:  MOVLW  A6
13C2C:  MOVWF  FF6
13C2E:  MOVLW  1C
13C30:  MOVWF  FF7
13C32:  MOVLW  00
13C34:  MOVWF  FF8
13C36:  MOVLW  16
13C38:  MOVLB  8
13C3A:  MOVWF  xEB
13C3C:  MOVLB  0
13C3E:  CALL   AAC0
13C42:  MOVLW  10
13C44:  MOVWF  FE9
13C46:  MOVFF  8CB,8F7
13C4A:  MOVFF  8CA,8F6
13C4E:  CALL   AAF2
13C52:  MOVLW  BF
13C54:  MOVWF  FF6
13C56:  MOVLW  1C
13C58:  MOVWF  FF7
13C5A:  MOVLW  00
13C5C:  MOVWF  FF8
13C5E:  MOVLW  09
13C60:  MOVLB  8
13C62:  MOVWF  xEB
13C64:  MOVLB  0
13C66:  CALL   AAC0
13C6A:  MOVLW  10
13C6C:  MOVWF  FE9
13C6E:  MOVFF  8C9,8F7
13C72:  MOVFF  8C8,8F6
13C76:  CALL   AAF2
13C7A:  MOVLW  CB
13C7C:  MOVWF  FF6
13C7E:  MOVLW  1C
13C80:  MOVWF  FF7
13C82:  MOVLW  00
13C84:  MOVWF  FF8
13C86:  MOVLW  0B
13C88:  MOVLB  8
13C8A:  MOVWF  xEB
13C8C:  MOVLB  0
13C8E:  CALL   AAC0
13C92:  MOVLW  10
13C94:  MOVWF  FE9
13C96:  MOVFF  8C5,8F7
13C9A:  MOVFF  8C4,8F6
13C9E:  CALL   AAF2
13CA2:  MOVLW  D9
13CA4:  MOVWF  FF6
13CA6:  MOVLW  1C
13CA8:  MOVWF  FF7
13CAA:  MOVLW  00
13CAC:  MOVWF  FF8
13CAE:  MOVLW  03
13CB0:  MOVLB  8
13CB2:  MOVWF  xEB
13CB4:  MOVLB  0
13CB6:  CALL   AAC0
....................    record_event(); 
13CBA:  CALL   84CE
....................  
....................    for (n=1; n<t; ++n) 
13CBE:  MOVLB  8
13CC0:  CLRF   xC5
13CC2:  MOVLW  01
13CC4:  MOVWF  xC4
13CC6:  MOVF   xC5,W
13CC8:  SUBWF  xC7,W
13CCA:  BNC   13D26
13CCC:  BNZ   13CD4
13CCE:  MOVF   xC6,W
13CD0:  SUBWF  xC4,W
13CD2:  BC    13D26
....................    { 
....................       det_read(store, display);           // detector read ~ 2.5 sec 
13CD4:  MOVFF  8C2,8CC
13CD8:  MOVFF  8C3,8CD
13CDC:  MOVLB  0
13CDE:  CALL   12F28
....................       current_temp=parse_temp(); 
13CE2:  BRA    13BB4
13CE4:  MOVFF  02,8C9
13CE8:  MOVFF  01,8C8
....................       if (current_temp >= target_temp || current_temp == 0) break;  // 0=fail (no detector) 
13CEC:  MOVLB  8
13CEE:  MOVF   xCB,W
13CF0:  SUBWF  xC9,W
13CF2:  BNC   13CFC
13CF4:  BNZ   13D04
13CF6:  MOVF   xCA,W
13CF8:  SUBWF  xC8,W
13CFA:  BC    13D04
13CFC:  MOVF   xC8,F
13CFE:  BNZ   13D08
13D00:  MOVF   xC9,F
13D02:  BNZ   13D08
13D04:  BRA    13D26
13D06:  BRA    13D1E
....................       else delay_ms(2500);                               // completes the 5.0 loop 
13D08:  MOVLW  0A
13D0A:  MOVWF  xCC
13D0C:  MOVLW  FA
13D0E:  MOVLB  9
13D10:  MOVWF  xEC
13D12:  MOVLB  0
13D14:  CALL   2904
13D18:  MOVLB  8
13D1A:  DECFSZ xCC,F
13D1C:  BRA    13D0C
13D1E:  INCF   xC4,F
13D20:  BTFSC  FD8.2
13D22:  INCF   xC5,F
13D24:  BRA    13CC6
....................    } 
....................     
....................    sprintf(event_str, ",end heating,target[%Lu],actual[%Lu],readings[%Lu]\r\n",  
....................                            target_temp,current_temp,n); 
13D26:  MOVLW  01
13D28:  MOVWF  1E
13D2A:  MOVLW  A7
13D2C:  MOVWF  1D
13D2E:  MOVLW  DE
13D30:  MOVWF  FF6
13D32:  MOVLW  1C
13D34:  MOVWF  FF7
13D36:  MOVLW  00
13D38:  MOVWF  FF8
13D3A:  MOVLW  14
13D3C:  MOVWF  xEB
13D3E:  MOVLB  0
13D40:  CALL   AAC0
13D44:  MOVLW  10
13D46:  MOVWF  FE9
13D48:  MOVFF  8CB,8F7
13D4C:  MOVFF  8CA,8F6
13D50:  CALL   AAF2
13D54:  MOVLW  F5
13D56:  MOVWF  FF6
13D58:  MOVLW  1C
13D5A:  MOVWF  FF7
13D5C:  MOVLW  00
13D5E:  MOVWF  FF8
13D60:  MOVLW  09
13D62:  MOVLB  8
13D64:  MOVWF  xEB
13D66:  MOVLB  0
13D68:  CALL   AAC0
13D6C:  MOVLW  10
13D6E:  MOVWF  FE9
13D70:  MOVFF  8C9,8F7
13D74:  MOVFF  8C8,8F6
13D78:  CALL   AAF2
13D7C:  MOVLW  01
13D7E:  MOVWF  FF6
13D80:  MOVLW  1D
13D82:  MOVWF  FF7
13D84:  MOVLW  00
13D86:  MOVWF  FF8
13D88:  MOVLW  0B
13D8A:  MOVLB  8
13D8C:  MOVWF  xEB
13D8E:  MOVLB  0
13D90:  CALL   AAC0
13D94:  MOVLW  10
13D96:  MOVWF  FE9
13D98:  MOVFF  8C5,8F7
13D9C:  MOVFF  8C4,8F6
13DA0:  CALL   AAF2
13DA4:  MOVLW  0F
13DA6:  MOVWF  FF6
13DA8:  MOVLW  1D
13DAA:  MOVWF  FF7
13DAC:  MOVLW  00
13DAE:  MOVWF  FF8
13DB0:  MOVLW  03
13DB2:  MOVLB  8
13DB4:  MOVWF  xEB
13DB6:  MOVLB  0
13DB8:  CALL   AAC0
....................    record_event();    
13DBC:  CALL   84CE
13DC0:  RETURN 0
.................... } 
....................  
.................... int16 temp_probe() 
.................... { 
....................    int8 i; 
....................    int16 temp; 
....................    int32 result,reading; 
....................     
....................    result=0; 
*
1388C:  MOVLB  8
1388E:  CLRF   xD5
13890:  CLRF   xD4
13892:  CLRF   xD3
13894:  CLRF   xD2
....................    set_adc_channel(1,VSS); 
13896:  MOVLW  04
13898:  MOVWF  01
1389A:  MOVF   FC2,W
1389C:  ANDLW  83
1389E:  IORWF  01,W
138A0:  MOVWF  FC2
138A2:  MOVLW  00
138A4:  MOVWF  01
138A6:  MOVF   FC1,W
138A8:  ANDLW  F8
138AA:  IORWF  01,W
138AC:  MOVWF  FC1
....................     
....................    output_bit(PIN_D0, 1); 
138AE:  BSF    F8C.0
....................     
....................    for(i=1;i<51;++i){ 
138B0:  MOVLW  01
138B2:  MOVWF  xCF
138B4:  MOVF   xCF,W
138B6:  SUBLW  32
138B8:  BNC   138DE
....................       reading=read_adc(); 
138BA:  BSF    FC2.1
138BC:  BTFSC  FC2.1
138BE:  BRA    138BC
138C0:  MOVFF  FC3,8D6
138C4:  MOVFF  FC4,8D7
138C8:  CLRF   xD8
138CA:  CLRF   xD9
....................       delay_ms(5); 
138CC:  MOVLW  05
138CE:  MOVLB  9
138D0:  MOVWF  xEC
138D2:  MOVLB  0
138D4:  CALL   2904
138D8:  MOVLB  8
138DA:  INCF   xCF,F
138DC:  BRA    138B4
....................    } 
....................     
....................    for(i=1;i<101;++i){ 
138DE:  MOVLW  01
138E0:  MOVWF  xCF
138E2:  MOVF   xCF,W
138E4:  SUBLW  64
138E6:  BNC   13994
....................       reading=read_adc(); 
138E8:  BSF    FC2.1
138EA:  BTFSC  FC2.1
138EC:  BRA    138EA
138EE:  MOVFF  FC3,8D6
138F2:  MOVFF  FC4,8D7
138F6:  CLRF   xD8
138F8:  CLRF   xD9
....................       result=(((result*(i-1))+reading)/i); 
138FA:  MOVLW  01
138FC:  SUBWF  xCF,W
138FE:  MOVWF  xDA
13900:  MOVFF  8D5,9F9
13904:  MOVFF  8D4,9F8
13908:  MOVFF  8D3,9F7
1390C:  MOVFF  8D2,9F6
13910:  MOVLB  9
13912:  CLRF   xFD
13914:  CLRF   xFC
13916:  CLRF   xFB
13918:  MOVWF  xFA
1391A:  MOVLB  0
1391C:  CALL   47E4
13920:  MOVFF  03,8DD
13924:  MOVFF  02,8DC
13928:  MOVFF  01,8DB
1392C:  MOVFF  00,8DA
13930:  MOVLB  8
13932:  MOVF   xD6,W
13934:  ADDWF  xDA,F
13936:  MOVF   xD7,W
13938:  ADDWFC xDB,F
1393A:  MOVF   xD8,W
1393C:  ADDWFC xDC,F
1393E:  MOVF   xD9,W
13940:  ADDWFC xDD,F
13942:  BCF    FD8.1
13944:  CLRF   1B
13946:  BTFSC  FF2.7
13948:  BSF    1B.7
1394A:  BCF    FF2.7
1394C:  MOVFF  8DD,A4F
13950:  MOVFF  8DC,A4E
13954:  MOVFF  8DB,A4D
13958:  MOVFF  8DA,A4C
1395C:  MOVLB  A
1395E:  CLRF   x53
13960:  CLRF   x52
13962:  CLRF   x51
13964:  MOVFF  8CF,A50
13968:  MOVLB  0
1396A:  CALL   104A
1396E:  BTFSC  1B.7
13970:  BSF    FF2.7
13972:  MOVFF  03,8D5
13976:  MOVFF  02,8D4
1397A:  MOVFF  01,8D3
1397E:  MOVFF  00,8D2
....................       delay_ms(5); 
13982:  MOVLW  05
13984:  MOVLB  9
13986:  MOVWF  xEC
13988:  MOVLB  0
1398A:  CALL   2904
1398E:  MOVLB  8
13990:  INCF   xCF,F
13992:  BRA    138E2
....................    }    
....................     
....................    output_bit(PIN_D0, 0); 
13994:  BCF    F8C.0
....................  
....................    temp=((result*4133)/100)-20513; 
13996:  MOVFF  8D5,9F9
1399A:  MOVFF  8D4,9F8
1399E:  MOVFF  8D3,9F7
139A2:  MOVFF  8D2,9F6
139A6:  MOVLB  9
139A8:  CLRF   xFD
139AA:  CLRF   xFC
139AC:  MOVLW  10
139AE:  MOVWF  xFB
139B0:  MOVLW  25
139B2:  MOVWF  xFA
139B4:  MOVLB  0
139B6:  CALL   47E4
139BA:  MOVFF  03,8DD
139BE:  MOVFF  02,8DC
139C2:  MOVFF  01,8DB
139C6:  MOVFF  00,8DA
139CA:  BCF    FD8.1
139CC:  CLRF   1B
139CE:  BTFSC  FF2.7
139D0:  BSF    1B.7
139D2:  BCF    FF2.7
139D4:  MOVFF  03,A4F
139D8:  MOVFF  02,A4E
139DC:  MOVFF  01,A4D
139E0:  MOVFF  00,A4C
139E4:  MOVLB  A
139E6:  CLRF   x53
139E8:  CLRF   x52
139EA:  CLRF   x51
139EC:  MOVLW  64
139EE:  MOVWF  x50
139F0:  MOVLB  0
139F2:  CALL   104A
139F6:  BTFSC  1B.7
139F8:  BSF    FF2.7
139FA:  MOVLW  21
139FC:  MOVLB  8
139FE:  SUBWF  00,W
13A00:  MOVWF  xD0
13A02:  MOVLW  50
13A04:  SUBWFB 01,W
13A06:  MOVWF  xD1
....................     
....................    //printf("%Ld,%Ld,%Lu\r\n",reading,result,temp); 
....................  
....................    return(temp); 
13A08:  MOVFF  8D0,01
13A0C:  MOVFF  8D1,02
13A10:  MOVLB  0
13A12:  GOTO   13A78 (RETURN)
.................... } 
....................  
.................... int16 probe_read(int8 store, int8 display){ 
*
13A22:  CLRF   xC8
13A24:  CLRF   xC7
....................  
....................    // get detector reading and write to a file on the SD card 
....................    // the string to be stored is compiled into "data_buffer" 
....................    // first the data_buffer is cleared 
....................    // then time_stamp_str, flags, results & end-of-line are concatenated 
....................    // append_data writes "data_buffer" to the file "all" and "new" files 
....................  
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
*
13A16:  MOVLW  0D
13A18:  MOVLB  8
13A1A:  MOVWF  xC4
13A1C:  MOVLW  0A
13A1E:  MOVWF  xC5
13A20:  CLRF   xC6
....................    int16 temp = 0; 
....................  
....................    clear_slave_reply(); 
*
13A26:  MOVLB  0
13A28:  CALL   127E2
....................    clear_data_buffer(); 
13A2C:  CALL   D51C
....................  
....................    time_stamp(); 
13A30:  CALL   540E
....................    strcpy(data_buffer, time_stmp_str); 
13A34:  CLRF   FEA
13A36:  MOVLW  67
13A38:  MOVWF  FE9
13A3A:  MOVLW  02
13A3C:  MOVWF  FE2
13A3E:  MOVLW  99
13A40:  MOVWF  FE1
13A42:  MOVF   FE7,F
13A44:  MOVFF  FE6,FEE
13A48:  BNZ   13A42
....................    strcat(data_buffer, (char *)",Tmp,"); 
13A4A:  MOVLW  2C
13A4C:  MOVLB  8
13A4E:  MOVWF  xC9
13A50:  MOVLW  54
13A52:  MOVWF  xCA
13A54:  MOVLW  6D
13A56:  MOVWF  xCB
13A58:  MOVLW  70
13A5A:  MOVWF  xCC
13A5C:  MOVLW  2C
13A5E:  MOVWF  xCD
13A60:  CLRF   xCE
13A62:  CLRF   xF9
13A64:  MOVLW  67
13A66:  MOVWF  xF8
13A68:  MOVLW  08
13A6A:  MOVWF  xFB
13A6C:  MOVLW  C9
13A6E:  MOVWF  xFA
13A70:  MOVLB  0
13A72:  CALL   54D2
....................  
....................    //*** READ TEMP PROBE ***// 
....................    temp=temp_probe(); 
13A76:  BRA    1388C
13A78:  MOVFF  02,8C8
13A7C:  MOVFF  01,8C7
....................    //*** PUT INTO slave_reply ***// 
....................    //itoa(temp,10,slave_reply); 
....................    sprintf (slave_reply, "%05.3w",temp); 
13A80:  MOVLW  02
13A82:  MOVWF  1E
13A84:  MOVLW  47
13A86:  MOVWF  1D
13A88:  MOVLW  45
13A8A:  MOVWF  FE9
13A8C:  MOVLB  8
13A8E:  CLRF   xF0
13A90:  CLRF   xEF
13A92:  MOVFF  8C8,8EE
13A96:  MOVFF  8C7,8ED
13A9A:  MOVLW  03
13A9C:  MOVWF  xF1
13A9E:  MOVLB  0
13AA0:  CALL   530E
....................  
....................    strcat(slave_reply, endofline); 
13AA4:  MOVLW  02
13AA6:  MOVLB  8
13AA8:  MOVWF  xF9
13AAA:  MOVLW  47
13AAC:  MOVWF  xF8
13AAE:  MOVLW  08
13AB0:  MOVWF  xFB
13AB2:  MOVLW  C4
13AB4:  MOVWF  xFA
13AB6:  MOVLB  0
13AB8:  CALL   54D2
....................    strncat(data_buffer, slave_reply, (BUFFER_LEN - strlen(data_buffer) - 1)); 
13ABC:  MOVLB  8
13ABE:  CLRF   xEC
13AC0:  MOVLW  67
13AC2:  MOVWF  xEB
13AC4:  MOVLB  0
13AC6:  CALL   12D5E
13ACA:  MOVFF  02,03
13ACE:  MOVF   01,W
13AD0:  XORLW  FF
13AD2:  ADDLW  A1
13AD4:  MOVLB  8
13AD6:  MOVWF  xCF
13AD8:  MOVLW  00
13ADA:  SUBFWB 02,W
13ADC:  MOVWF  xD0
13ADE:  MOVLW  01
13AE0:  SUBWF  xCF,F
13AE2:  MOVLW  00
13AE4:  SUBWFB xD0,F
13AE6:  CLRF   xEE
13AE8:  MOVLW  67
13AEA:  MOVWF  xED
13AEC:  MOVLW  02
13AEE:  MOVWF  xF0
13AF0:  MOVLW  47
13AF2:  MOVWF  xEF
13AF4:  MOVFF  8D0,8F2
13AF8:  MOVFF  8CF,8F1
13AFC:  MOVLB  0
13AFE:  CALL   12D9A
....................  
....................    if (nv_report_mode == 0 && display == TRUE) fprintf(COM_A, "%s", data_buffer); 
13B02:  MOVF   1F,F
13B04:  BNZ   13B24
13B06:  MOVF   20,F
13B08:  BNZ   13B24
13B0A:  MOVLB  8
13B0C:  DECFSZ xC3,W
13B0E:  BRA    13B12
13B10:  BRA    13B16
13B12:  MOVLB  0
13B14:  BRA    13B24
13B16:  CLRF   FEA
13B18:  MOVLW  67
13B1A:  MOVWF  FE9
13B1C:  MOVLB  0
13B1E:  CALL   798A
13B22:  BRA    13B38
....................    else if (nv_report_mode >= 4) fprintf(COM_A, "%s", data_buffer); 
13B24:  MOVF   20,F
13B26:  BNZ   13B2E
13B28:  MOVF   1F,W
13B2A:  SUBLW  03
13B2C:  BC    13B38
13B2E:  CLRF   FEA
13B30:  MOVLW  67
13B32:  MOVWF  FE9
13B34:  CALL   798A
....................  
....................    if (store == TRUE && sd_status==0) { 
13B38:  MOVLB  8
13B3A:  DECFSZ xC2,W
13B3C:  BRA    13B9C
13B3E:  MOVLB  2
13B40:  MOVF   xDC,F
13B42:  BTFSC  FD8.2
13B44:  BRA    13B4A
13B46:  MOVLB  8
13B48:  BRA    13B9C
....................       buffer_select = 0; 
13B4A:  MOVLB  0
13B4C:  CLRF   x66
....................       
....................       heartbeat(FALSE); 
13B4E:  MOVLB  8
13B50:  CLRF   xED
13B52:  MOVLB  0
13B54:  CALL   557A
....................          append_data(file_ptr_raw_all); 
13B58:  MOVLW  02
13B5A:  MOVLB  8
13B5C:  MOVWF  xEE
13B5E:  MOVLW  DD
13B60:  MOVWF  xED
13B62:  MOVLB  0
13B64:  CALL   82EC
....................       heartbeat(TRUE); 
13B68:  MOVLW  01
13B6A:  MOVLB  8
13B6C:  MOVWF  xED
13B6E:  MOVLB  0
13B70:  CALL   557A
....................        
....................       heartbeat(FALSE); 
13B74:  MOVLB  8
13B76:  CLRF   xED
13B78:  MOVLB  0
13B7A:  CALL   557A
....................          append_data(file_ptr_raw_new); 
13B7E:  MOVLW  02
13B80:  MOVLB  8
13B82:  MOVWF  xEE
13B84:  MOVLW  EB
13B86:  MOVWF  xED
13B88:  MOVLB  0
13B8A:  CALL   82EC
....................       heartbeat(TRUE); 
13B8E:  MOVLW  01
13B90:  MOVLB  8
13B92:  MOVWF  xED
13B94:  MOVLB  0
13B96:  CALL   557A
13B9A:  MOVLB  8
....................    } 
....................     
....................    macro_flag = 900; 
13B9C:  MOVLW  03
13B9E:  MOVLB  3
13BA0:  MOVWF  x24
13BA2:  MOVLW  84
13BA4:  MOVWF  x23
....................     
....................    return (temp); 
13BA6:  MOVLB  8
13BA8:  MOVFF  8C7,01
13BAC:  MOVFF  8C8,02
13BB0:  MOVLB  0
13BB2:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "colorimeter.c" 
.................... void set_heaters(int8 set) 
.................... { 
....................    switch(set){ 
*
126F4:  MOVLB  8
126F6:  MOVF   xC5,W
126F8:  ADDLW  FC
126FA:  BC    12738
126FC:  ADDLW  04
126FE:  MOVLB  0
12700:  GOTO   12740
....................       case 0 :  
....................             output_bit(HSW1, OFF); 
12704:  BCF    F8C.0
....................             output_bit(HSW2, OFF); 
12706:  BCF    F8C.1
....................          break; 
12708:  MOVLB  8
1270A:  BRA    12738
....................       case 1 :  
....................             output_bit(HSW1, ON); 
1270C:  BSF    F8C.0
....................          break; 
1270E:  MOVLB  8
12710:  BRA    12738
....................       case 2 :  
....................             output_bit(HSW2, ON); 
12712:  BSF    F8C.1
....................          break;  
12714:  MOVLB  8
12716:  BRA    12738
....................       case 3 :  
....................             output_bit(HSW1, ON); 
12718:  BSF    F8C.0
....................             delay_ms(500); 
1271A:  MOVLW  02
1271C:  MOVLB  8
1271E:  MOVWF  xC6
12720:  MOVLW  FA
12722:  MOVLB  9
12724:  MOVWF  xEC
12726:  MOVLB  0
12728:  CALL   2904
1272C:  MOVLB  8
1272E:  DECFSZ xC6,F
12730:  BRA    12720
....................             output_bit(HSW2, ON); 
12732:  BSF    F8C.1
....................          break;             
12734:  BRA    12738
12736:  MOVLB  8
....................    } 
....................    heater_stat=set; 
12738:  MOVFF  8C5,4B5
1273C:  MOVLB  0
1273E:  RETURN 0
.................... } 
....................  
.................... void LED_SAR(int16 intensity) 
.................... { 
....................    // ADC1 = PD1 (color) 
....................    // ADC2 = PD2 (source) 
....................    // ADC3 = TEMP 
....................    // ADC4 = ILED 
....................     
....................    int8 i; 
....................    int16 LED_level, LED_level_change, output, temp; 
....................     
....................    LED_level=2048; 
*
0F81E:  MOVLW  08
0F820:  MOVLB  8
0F822:  MOVWF  xCC
0F824:  CLRF   xCB
....................    LED_level_change=2048; 
0F826:  MOVWF  xCE
0F828:  CLRF   xCD
....................     
....................    for (i=0; i<12; i++){ 
0F82A:  CLRF   xCA
0F82C:  MOVF   xCA,W
0F82E:  SUBLW  0B
0F830:  BNC   F8A8
....................       DAC_set(1,LED_level); 
0F832:  MOVLW  01
0F834:  MOVWF  xD3
0F836:  MOVFF  8CC,8D5
0F83A:  MOVFF  8CB,8D4
0F83E:  MOVLB  0
0F840:  RCALL  F56C
....................       LED_level_change = LED_level_change/2; 
0F842:  BCF    FD8.0
0F844:  MOVLB  8
0F846:  RRCF   xCE,F
0F848:  RRCF   xCD,F
....................       ADC_average(200); 
0F84A:  CLRF   xD4
0F84C:  MOVLW  C8
0F84E:  MOVWF  xD3
0F850:  MOVLB  0
0F852:  RCALL  F614
....................       output = ADC_val[2]; 
0F854:  MOVFF  4AA,8D0
0F858:  MOVFF  4A9,8CF
....................       temp = ADC_val[3]; 
0F85C:  MOVFF  4AC,8D2
0F860:  MOVFF  4AB,8D1
....................       //fprintf(COM_A, "%6Lu %6Lu %6Lu %6Lu %6Lu\r\n", intensity,output,LED_level,LED_level_change,temp); 
....................       if(output>intensity) { 
0F864:  MOVLB  8
0F866:  MOVF   xC9,W
0F868:  SUBWF  xD0,W
0F86A:  BNC   F87E
0F86C:  BNZ   F874
0F86E:  MOVF   xCF,W
0F870:  SUBWF  xC8,W
0F872:  BC    F87E
....................          LED_level=LED_level-LED_level_change; 
0F874:  MOVF   xCD,W
0F876:  SUBWF  xCB,F
0F878:  MOVF   xCE,W
0F87A:  SUBWFB xCC,F
....................       } 
0F87C:  BRA    F8A4
....................       else if(output<intensity){ 
0F87E:  MOVF   xD0,W
0F880:  SUBWF  xC9,W
0F882:  BNC   F896
0F884:  BNZ   F88C
0F886:  MOVF   xC8,W
0F888:  SUBWF  xCF,W
0F88A:  BC    F896
....................          LED_level=LED_level+LED_level_change; 
0F88C:  MOVF   xCD,W
0F88E:  ADDWF  xCB,F
0F890:  MOVF   xCE,W
0F892:  ADDWFC xCC,F
....................       } 
0F894:  BRA    F8A4
....................       else if(output==intensity) break; 
0F896:  MOVF   xC8,W
0F898:  SUBWF  xCF,W
0F89A:  BNZ   F8A4
0F89C:  MOVF   xC9,W
0F89E:  SUBWF  xD0,W
0F8A0:  BTFSC  FD8.2
0F8A2:  BRA    F8A8
0F8A4:  INCF   xCA,F
0F8A6:  BRA    F82C
....................    } 
....................     
....................    DAC_set(1,LED_level);    
0F8A8:  MOVLW  01
0F8AA:  MOVWF  xD3
0F8AC:  MOVFF  8CC,8D5
0F8B0:  MOVFF  8CB,8D4
0F8B4:  MOVLB  0
0F8B6:  RCALL  F56C
0F8B8:  RETURN 0
.................... } 
....................  
.................... int8 set_LED(int16 intensity) 
0F8BA:  MOVLW  01
0F8BC:  MOVLB  8
0F8BE:  MOVWF  xC7
.................... { 
....................    int8 valid=TRUE; 
....................     
....................   if(intensity > 0 && intensity < 4096) LED_SAR(intensity); 
0F8C0:  MOVF   xC5,F
0F8C2:  BNZ   F8C8
0F8C4:  MOVF   xC6,F
0F8C6:  BZ    F8DC
0F8C8:  MOVF   xC6,W
0F8CA:  SUBLW  0F
0F8CC:  BNC   F8DC
0F8CE:  MOVFF  8C6,8C9
0F8D2:  MOVFF  8C5,8C8
0F8D6:  MOVLB  0
0F8D8:  RCALL  F81E
0F8DA:  MOVLB  8
....................   if(intensity == 0) { 
0F8DC:  MOVF   xC5,F
0F8DE:  BNZ   F902
0F8E0:  MOVF   xC6,F
0F8E2:  BNZ   F902
....................       DAC_set(1, 0); 
0F8E4:  MOVLW  01
0F8E6:  MOVWF  xD3
0F8E8:  CLRF   xD5
0F8EA:  CLRF   xD4
0F8EC:  MOVLB  0
0F8EE:  RCALL  F56C
....................       DAC_set(2, 0); 
0F8F0:  MOVLW  02
0F8F2:  MOVLB  8
0F8F4:  MOVWF  xD3
0F8F6:  CLRF   xD5
0F8F8:  CLRF   xD4
0F8FA:  MOVLB  0
0F8FC:  RCALL  F56C
....................    } 
0F8FE:  BRA    F906
0F900:  MOVLB  8
....................    else valid=FALSE; 
0F902:  CLRF   xC7
0F904:  MOVLB  0
....................    return(valid); 
0F906:  MOVLB  8
0F908:  MOVFF  8C7,01
0F90C:  MOVLB  0
0F90E:  RETURN 0
.................... } 
....................  
.................... void load_scanned_data() 
.................... { 
....................    switch (chem){ 
*
0FE90:  MOVLW  14
0FE92:  MOVWF  FF6
0FE94:  MOVLW  1D
0FE96:  MOVWF  FF7
0FE98:  MOVLW  00
0FE9A:  MOVWF  FF8
0FE9C:  MOVLW  03
0FE9E:  MOVWF  FEA
0FEA0:  MOVLW  3D
0FEA2:  MOVWF  FE9
0FEA4:  RCALL  FE56
0FEA6:  MOVF   01,W
0FEA8:  BZ    FEBC
0FEAA:  XORLW  01
0FEAC:  BZ    FEDC
0FEAE:  XORLW  03
0FEB0:  BZ    FEFC
0FEB2:  XORLW  01
0FEB4:  BZ    FF1C
0FEB6:  XORLW  07
0FEB8:  BZ    FF3C
0FEBA:  BRA    FF5A
....................       case "NO3" : NO3_array[read_i] = ADC_val[1]; 
0FEBC:  BCF    FD8.0
0FEBE:  MOVLB  3
0FEC0:  RLCF   x4A,W
0FEC2:  CLRF   03
0FEC4:  ADDLW  4B
0FEC6:  MOVWF  FE9
0FEC8:  MOVLW  03
0FECA:  ADDWFC 03,W
0FECC:  MOVWF  FEA
0FECE:  MOVFF  4A8,FEC
0FED2:  MOVF   FED,F
0FED4:  MOVFF  4A7,FEF
....................          break; 
0FED8:  MOVLB  0
0FEDA:  BRA    FF5A
....................       case "NO2" : NO2_array[read_i] = ADC_val[1]; 
0FEDC:  BCF    FD8.0
0FEDE:  MOVLB  3
0FEE0:  RLCF   x4A,W
0FEE2:  CLRF   03
0FEE4:  ADDLW  5D
0FEE6:  MOVWF  FE9
0FEE8:  MOVLW  03
0FEEA:  ADDWFC 03,W
0FEEC:  MOVWF  FEA
0FEEE:  MOVFF  4A8,FEC
0FEF2:  MOVF   FED,F
0FEF4:  MOVFF  4A7,FEF
....................          break;    
0FEF8:  MOVLB  0
0FEFA:  BRA    FF5A
....................       case "PO4" : PO4_array[read_i] = ADC_val[1]; 
0FEFC:  BCF    FD8.0
0FEFE:  MOVLB  3
0FF00:  RLCF   x4A,W
0FF02:  CLRF   03
0FF04:  ADDLW  6F
0FF06:  MOVWF  FE9
0FF08:  MOVLW  03
0FF0A:  ADDWFC 03,W
0FF0C:  MOVWF  FEA
0FF0E:  MOVFF  4A8,FEC
0FF12:  MOVF   FED,F
0FF14:  MOVFF  4A7,FEF
....................          break; 
0FF18:  MOVLB  0
0FF1A:  BRA    FF5A
....................       case "NH4" : NH4_array[read_i] = ADC_val[1]; 
0FF1C:  BCF    FD8.0
0FF1E:  MOVLB  3
0FF20:  RLCF   x4A,W
0FF22:  CLRF   03
0FF24:  ADDLW  81
0FF26:  MOVWF  FE9
0FF28:  MOVLW  03
0FF2A:  ADDWFC 03,W
0FF2C:  MOVWF  FEA
0FF2E:  MOVFF  4A8,FEC
0FF32:  MOVF   FED,F
0FF34:  MOVFF  4A7,FEF
....................          break; 
0FF38:  MOVLB  0
0FF3A:  BRA    FF5A
....................       case "SiO" : SiO_array[read_i] = ADC_val[1]; 
0FF3C:  BCF    FD8.0
0FF3E:  MOVLB  3
0FF40:  RLCF   x4A,W
0FF42:  CLRF   03
0FF44:  ADDLW  93
0FF46:  MOVWF  FE9
0FF48:  MOVLW  03
0FF4A:  ADDWFC 03,W
0FF4C:  MOVWF  FEA
0FF4E:  MOVFF  4A8,FEC
0FF52:  MOVF   FED,F
0FF54:  MOVFF  4A7,FEF
....................          break; 
0FF58:  MOVLB  0
....................    } 
0FF5A:  GOTO   10250 (RETURN)
.................... } 
....................  
.................... void read_colorimeter(int16 scans, int8 store, int8 display, int8 test) 
.................... { 
....................    int16 v_supply, wave_l; 
....................        
....................    ADC_average(scans); 
*
10000:  MOVFF  8C3,8D4
10004:  MOVFF  8C2,8D3
10008:  CALL   F614
....................     
....................    v_supply = read_supply(); 
1000C:  CALL   50F0
10010:  MOVFF  02,8C8
10014:  MOVFF  01,8C7
....................        
....................    RTC_reset_HT(); 
10018:  CALL   34A6
....................    RTC_read(); 
1001C:  CALL   3338
....................     
....................  //  if (macro_flag==011 || macro_flag==023 || macro_flag==111 || macro_flag==123 
....................  //     || macro_flag==211 || macro_flag==223 || macro_flag==311 || macro_flag==323 
....................   
....................    wave_l = decode_flag(); 
10020:  CALL   F928
10024:  MOVFF  02,8CA
10028:  MOVFF  01,8C9
....................     
....................    if(test==1)fprintf(COM_A,"%Lu,",ADC_val[2]); 
1002C:  MOVLB  8
1002E:  DECFSZ xC6,W
10030:  GOTO   1005E
10034:  MOVLW  10
10036:  MOVWF  FE9
10038:  CLRF   1B
1003A:  BTFSC  FF2.7
1003C:  BSF    1B.7
1003E:  BCF    FF2.7
10040:  MOVFF  4AA,A41
10044:  MOVFF  4A9,A40
10048:  MOVLB  0
1004A:  CALL   119A
1004E:  BTFSC  1B.7
10050:  BSF    FF2.7
10052:  MOVLW  2C
10054:  BTFSS  F9E.4
10056:  GOTO   10054
1005A:  MOVWF  FAD
1005C:  MOVLB  8
....................     
....................    sprintf(data_buffer,  
....................       "%02u/%02u/%02u %02u:%02u:%02u,%4.2w,%s,%s,%s,%Lu,%Lu,%u,%Lu,%Lu,%Lu\r\n", 
....................       RTC_Mon_Reg,RTC_DOM_Reg,RTC_Yr_Reg,RTC_Hr_Reg,RTC_Min_Reg,RTC_Sec_Reg, 
....................       v_supply,chem,anal,read_t,nv_serial,wave_l,heater_stat, 
....................       ADC_val[1],ADC_val[4],ADC_val[3]); 
1005E:  CLRF   1E
10060:  MOVLW  67
10062:  MOVWF  1D
10064:  MOVFF  72A,8ED
10068:  MOVLW  01
1006A:  MOVWF  xEE
1006C:  MOVLB  0
1006E:  CALL   5274
10072:  MOVLW  2F
10074:  MOVLB  8
10076:  MOVWF  xFF
10078:  MOVLB  0
1007A:  CALL   5092
1007E:  MOVFF  729,8ED
10082:  MOVLW  01
10084:  MOVLB  8
10086:  MOVWF  xEE
10088:  MOVLB  0
1008A:  CALL   5274
1008E:  MOVLW  2F
10090:  MOVLB  8
10092:  MOVWF  xFF
10094:  MOVLB  0
10096:  CALL   5092
1009A:  MOVFF  72B,8ED
1009E:  MOVLW  01
100A0:  MOVLB  8
100A2:  MOVWF  xEE
100A4:  MOVLB  0
100A6:  CALL   5274
100AA:  MOVLW  20
100AC:  MOVLB  8
100AE:  MOVWF  xFF
100B0:  MOVLB  0
100B2:  CALL   5092
100B6:  MOVFF  727,8ED
100BA:  MOVLW  01
100BC:  MOVLB  8
100BE:  MOVWF  xEE
100C0:  MOVLB  0
100C2:  CALL   5274
100C6:  MOVLW  3A
100C8:  MOVLB  8
100CA:  MOVWF  xFF
100CC:  MOVLB  0
100CE:  CALL   5092
100D2:  MOVFF  726,8ED
100D6:  MOVLW  01
100D8:  MOVLB  8
100DA:  MOVWF  xEE
100DC:  MOVLB  0
100DE:  CALL   5274
100E2:  MOVLW  3A
100E4:  MOVLB  8
100E6:  MOVWF  xFF
100E8:  MOVLB  0
100EA:  CALL   5092
100EE:  MOVFF  725,8ED
100F2:  MOVLW  01
100F4:  MOVLB  8
100F6:  MOVWF  xEE
100F8:  MOVLB  0
100FA:  CALL   5274
100FE:  MOVLW  2C
10100:  MOVLB  8
10102:  MOVWF  xFF
10104:  MOVLB  0
10106:  CALL   5092
1010A:  MOVLW  04
1010C:  MOVWF  FE9
1010E:  MOVLB  8
10110:  CLRF   xF0
10112:  CLRF   xEF
10114:  MOVFF  8C8,8EE
10118:  MOVFF  8C7,8ED
1011C:  MOVLW  02
1011E:  MOVWF  xF1
10120:  MOVLB  0
10122:  CALL   530E
10126:  MOVLW  2C
10128:  MOVLB  8
1012A:  MOVWF  xFF
1012C:  MOVLB  0
1012E:  CALL   5092
10132:  MOVFF  1E,FEA
10136:  MOVFF  1D,FE9
1013A:  CLRF   FEF
1013C:  MOVLW  03
1013E:  MOVWF  FEA
10140:  MOVLW  3D
10142:  MOVWF  FE9
10144:  CALL   FE30
10148:  MOVLW  2C
1014A:  MOVLB  8
1014C:  MOVWF  xFF
1014E:  MOVLB  0
10150:  CALL   5092
10154:  MOVFF  1E,FEA
10158:  MOVFF  1D,FE9
1015C:  CLRF   FEF
1015E:  MOVLW  03
10160:  MOVWF  FEA
10162:  MOVLW  42
10164:  MOVWF  FE9
10166:  CALL   FE30
1016A:  MOVLW  2C
1016C:  MOVLB  8
1016E:  MOVWF  xFF
10170:  MOVLB  0
10172:  CALL   5092
10176:  MOVFF  1E,FEA
1017A:  MOVFF  1D,FE9
1017E:  CLRF   FEF
10180:  MOVLW  03
10182:  MOVWF  FEA
10184:  MOVLW  46
10186:  MOVWF  FE9
10188:  CALL   FE30
1018C:  MOVLW  2C
1018E:  MOVLB  8
10190:  MOVWF  xFF
10192:  MOVLB  0
10194:  CALL   5092
10198:  MOVLW  10
1019A:  MOVWF  FE9
1019C:  MOVFF  26,8F7
101A0:  MOVFF  25,8F6
101A4:  CALL   AAF2
101A8:  MOVLW  2C
101AA:  MOVLB  8
101AC:  MOVWF  xFF
101AE:  MOVLB  0
101B0:  CALL   5092
101B4:  MOVLW  10
101B6:  MOVWF  FE9
101B8:  MOVFF  8CA,8F7
101BC:  MOVFF  8C9,8F6
101C0:  CALL   AAF2
101C4:  MOVLW  2C
101C6:  MOVLB  8
101C8:  MOVWF  xFF
101CA:  MOVLB  0
101CC:  CALL   5092
101D0:  MOVFF  4B5,8ED
101D4:  MOVLW  1B
101D6:  MOVLB  8
101D8:  MOVWF  xEE
101DA:  MOVLB  0
101DC:  CALL   5274
101E0:  MOVLW  2C
101E2:  MOVLB  8
101E4:  MOVWF  xFF
101E6:  MOVLB  0
101E8:  CALL   5092
101EC:  MOVLW  10
101EE:  MOVWF  FE9
101F0:  MOVFF  4A8,8F7
101F4:  MOVFF  4A7,8F6
101F8:  CALL   AAF2
101FC:  MOVLW  2C
101FE:  MOVLB  8
10200:  MOVWF  xFF
10202:  MOVLB  0
10204:  CALL   5092
10208:  MOVLW  10
1020A:  MOVWF  FE9
1020C:  MOVFF  4AE,8F7
10210:  MOVFF  4AD,8F6
10214:  CALL   AAF2
10218:  MOVLW  2C
1021A:  MOVLB  8
1021C:  MOVWF  xFF
1021E:  MOVLB  0
10220:  CALL   5092
10224:  MOVLW  10
10226:  MOVWF  FE9
10228:  MOVFF  4AC,8F7
1022C:  MOVFF  4AB,8F6
10230:  CALL   AAF2
10234:  MOVLW  0D
10236:  MOVLB  8
10238:  MOVWF  xFF
1023A:  MOVLB  0
1023C:  CALL   5092
10240:  MOVLW  0A
10242:  MOVLB  8
10244:  MOVWF  xFF
10246:  MOVLB  0
10248:  CALL   5092
....................  
....................    load_scanned_data();  
1024C:  GOTO   FE90
....................  
....................    display_rec(store, display); 
10250:  MOVFF  8C4,8EB
10254:  MOVFF  8C5,8EC
10258:  CALL   FF5E
....................     
....................    data_available = TRUE; 
1025C:  MOVLW  01
1025E:  MOVLB  3
10260:  MOVWF  x3B
....................    macro_flag = 900; 
10262:  MOVLW  03
10264:  MOVWF  x24
10266:  MOVLW  84
10268:  MOVWF  x23
1026A:  MOVLB  0
1026C:  RETURN 0
.................... } 
....................  
.................... void DAC_set_test(int16 channel) 
.................... { 
....................    int8 i; 
....................    int16 setting; 
....................     
....................    setting=0; 
1026E:  MOVLB  8
10270:  CLRF   x8B
10272:  CLRF   x8A
....................    channel=channel-20000; 
10274:  MOVLW  20
10276:  SUBWF  x87,F
10278:  MOVLW  4E
1027A:  SUBWFB x88,F
....................     
....................    for (i=0; i<9; i++){ 
1027C:  CLRF   x89
1027E:  MOVF   x89,W
10280:  SUBLW  08
10282:  BNC   10324
....................       DAC_set(channel, setting); 
10284:  MOVFF  887,8D3
10288:  MOVFF  88B,8D5
1028C:  MOVFF  88A,8D4
10290:  MOVLB  0
10292:  CALL   F56C
....................       fprintf(COM_A, "@DAC,%Lu,%Lu,", channel, setting); 
10296:  MOVLW  2A
10298:  MOVWF  FF6
1029A:  MOVLW  1D
1029C:  MOVWF  FF7
1029E:  MOVLW  00
102A0:  MOVWF  FF8
102A2:  CLRF   1B
102A4:  BTFSC  FF2.7
102A6:  BSF    1B.7
102A8:  BCF    FF2.7
102AA:  MOVLW  05
102AC:  MOVLB  A
102AE:  MOVWF  x40
102B0:  MOVLB  0
102B2:  CALL   1018
102B6:  BTFSC  1B.7
102B8:  BSF    FF2.7
102BA:  MOVLW  10
102BC:  MOVWF  FE9
102BE:  CLRF   1B
102C0:  BTFSC  FF2.7
102C2:  BSF    1B.7
102C4:  BCF    FF2.7
102C6:  MOVFF  888,A41
102CA:  MOVFF  887,A40
102CE:  CALL   119A
102D2:  BTFSC  1B.7
102D4:  BSF    FF2.7
102D6:  MOVLW  2C
102D8:  BTFSS  F9E.4
102DA:  BRA    102D8
102DC:  MOVWF  FAD
102DE:  MOVLW  10
102E0:  MOVWF  FE9
102E2:  CLRF   1B
102E4:  BTFSC  FF2.7
102E6:  BSF    1B.7
102E8:  BCF    FF2.7
102EA:  MOVFF  88B,A41
102EE:  MOVFF  88A,A40
102F2:  CALL   119A
102F6:  BTFSC  1B.7
102F8:  BSF    FF2.7
102FA:  MOVLW  2C
102FC:  BTFSS  F9E.4
102FE:  BRA    102FC
10300:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
10302:  MOVLB  8
10304:  CLRF   xC3
10306:  MOVLW  C8
10308:  MOVWF  xC2
1030A:  CLRF   xC4
1030C:  MOVLW  01
1030E:  MOVWF  xC5
10310:  MOVWF  xC6
10312:  MOVLB  0
10314:  RCALL  10000
....................       setting = setting+500; 
10316:  MOVLW  F4
10318:  MOVLB  8
1031A:  ADDWF  x8A,F
1031C:  MOVLW  01
1031E:  ADDWFC x8B,F
10320:  INCF   x89,F
10322:  BRA    1027E
....................    } 
10324:  MOVLB  0
10326:  GOTO   10482 (RETURN)
.................... } 
....................  
.................... void set_LED_test() 
.................... { 
....................    int8 i; 
....................    int16 intensity; 
....................     
....................    intensity=0; 
1032A:  MOVLB  8
1032C:  CLRF   x87
1032E:  CLRF   x86
....................     
....................    for (i=0; i<9; i++){ 
10330:  CLRF   x85
10332:  MOVF   x85,W
10334:  SUBLW  08
10336:  BNC   103B0
....................       LED_SAR(intensity); 
10338:  MOVFF  887,8C9
1033C:  MOVFF  886,8C8
10340:  MOVLB  0
10342:  CALL   F81E
....................       fprintf(COM_A, "@SAR,1,%Lu,", intensity); 
10346:  MOVLW  38
10348:  MOVWF  FF6
1034A:  MOVLW  1D
1034C:  MOVWF  FF7
1034E:  MOVLW  00
10350:  MOVWF  FF8
10352:  CLRF   1B
10354:  BTFSC  FF2.7
10356:  BSF    1B.7
10358:  BCF    FF2.7
1035A:  MOVLW  07
1035C:  MOVLB  A
1035E:  MOVWF  x40
10360:  MOVLB  0
10362:  CALL   1018
10366:  BTFSC  1B.7
10368:  BSF    FF2.7
1036A:  MOVLW  10
1036C:  MOVWF  FE9
1036E:  CLRF   1B
10370:  BTFSC  FF2.7
10372:  BSF    1B.7
10374:  BCF    FF2.7
10376:  MOVFF  887,A41
1037A:  MOVFF  886,A40
1037E:  CALL   119A
10382:  BTFSC  1B.7
10384:  BSF    FF2.7
10386:  MOVLW  2C
10388:  BTFSS  F9E.4
1038A:  BRA    10388
1038C:  MOVWF  FAD
....................       read_colorimeter(200,FALSE,TRUE,TRUE); 
1038E:  MOVLB  8
10390:  CLRF   xC3
10392:  MOVLW  C8
10394:  MOVWF  xC2
10396:  CLRF   xC4
10398:  MOVLW  01
1039A:  MOVWF  xC5
1039C:  MOVWF  xC6
1039E:  MOVLB  0
103A0:  RCALL  10000
....................       intensity = intensity+500; 
103A2:  MOVLW  F4
103A4:  MOVLB  8
103A6:  ADDWF  x86,F
103A8:  MOVLW  01
103AA:  ADDWFC x87,F
103AC:  INCF   x85,F
103AE:  BRA    10332
....................    } 
103B0:  MOVLB  0
103B2:  GOTO   10482 (RETURN)
.................... } 
....................  
....................  
....................  
.................... #include "aws.c" 
.................... void init_valve_status() 
.................... { 
....................    int v; 
....................     
....................    for(v=0; v<33; ++v) valve_status[v]=0; 
*
030AE:  MOVLB  8
030B0:  CLRF   xB6
030B2:  MOVF   xB6,W
030B4:  SUBLW  20
030B6:  BNC   30CC
030B8:  CLRF   03
030BA:  MOVF   xB6,W
030BC:  ADDLW  B7
030BE:  MOVWF  FE9
030C0:  MOVLW  04
030C2:  ADDWFC 03,W
030C4:  MOVWF  FEA
030C6:  CLRF   FEF
030C8:  INCF   xB6,F
030CA:  BRA    30B2
030CC:  MOVLB  0
030CE:  RETURN 0
.................... } 
....................  
.................... void init_aws() 
.................... { 
....................    if(nv_product==AWS)set_tris_h(0b00000000); 
030D0:  MOVF   2F,W
030D2:  SUBLW  02
030D4:  BNZ   30DE
030D6:  MOVF   30,F
030D8:  BNZ   30DE
030DA:  MOVLW  00
030DC:  MOVWF  F99
....................    init_valve_status(); 
030DE:  RCALL  30AE
....................    bus_pwr_status=0; 
030E0:  MOVLB  4
030E2:  CLRF   xB6
030E4:  MOVLB  0
030E6:  GOTO   1B770 (RETURN)
.................... } 
....................  
.................... void display_valve_status() 
.................... { 
....................    int8 v; 
....................     
....................    fprintf(COM_A, "@VAL "); 
*
0ED5A:  MOVLW  44
0ED5C:  MOVWF  FF6
0ED5E:  MOVLW  1D
0ED60:  MOVWF  FF7
0ED62:  MOVLW  00
0ED64:  MOVWF  FF8
0ED66:  CLRF   1B
0ED68:  BTFSC  FF2.7
0ED6A:  BSF    1B.7
0ED6C:  BCF    FF2.7
0ED6E:  CALL   0E42
0ED72:  BTFSC  1B.7
0ED74:  BSF    FF2.7
....................    for(v=1; v<9; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0ED76:  MOVLW  01
0ED78:  MOVLB  8
0ED7A:  MOVWF  xB6
0ED7C:  MOVF   xB6,W
0ED7E:  SUBLW  08
0ED80:  BNC   EDEA
0ED82:  CLRF   03
0ED84:  MOVF   xB6,W
0ED86:  ADDLW  B7
0ED88:  MOVWF  FE9
0ED8A:  MOVLW  04
0ED8C:  ADDWFC 03,W
0ED8E:  MOVWF  FEA
0ED90:  MOVFF  FEF,8B7
0ED94:  CLRF   1B
0ED96:  BTFSC  FF2.7
0ED98:  BSF    1B.7
0ED9A:  BCF    FF2.7
0ED9C:  MOVFF  8B6,A40
0EDA0:  MOVLW  01
0EDA2:  MOVLB  A
0EDA4:  MOVWF  x41
0EDA6:  MOVLB  0
0EDA8:  CALL   0F9A
0EDAC:  BTFSC  1B.7
0EDAE:  BSF    FF2.7
0EDB0:  MOVLW  5B
0EDB2:  BTFSS  F9E.4
0EDB4:  BRA    EDB2
0EDB6:  MOVWF  FAD
0EDB8:  CLRF   1B
0EDBA:  BTFSC  FF2.7
0EDBC:  BSF    1B.7
0EDBE:  BCF    FF2.7
0EDC0:  MOVFF  8B7,A40
0EDC4:  MOVLW  1B
0EDC6:  MOVLB  A
0EDC8:  MOVWF  x41
0EDCA:  MOVLB  0
0EDCC:  CALL   0F9A
0EDD0:  BTFSC  1B.7
0EDD2:  BSF    FF2.7
0EDD4:  MOVLW  5D
0EDD6:  BTFSS  F9E.4
0EDD8:  BRA    EDD6
0EDDA:  MOVWF  FAD
0EDDC:  MOVLW  20
0EDDE:  BTFSS  F9E.4
0EDE0:  BRA    EDDE
0EDE2:  MOVWF  FAD
0EDE4:  MOVLB  8
0EDE6:  INCF   xB6,F
0EDE8:  BRA    ED7C
....................    fprintf(COM_A, "\r\n"); 
0EDEA:  MOVLW  0D
0EDEC:  BTFSS  F9E.4
0EDEE:  BRA    EDEC
0EDF0:  MOVWF  FAD
0EDF2:  MOVLW  0A
0EDF4:  BTFSS  F9E.4
0EDF6:  BRA    EDF4
0EDF8:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EDFA:  MOVLW  4A
0EDFC:  MOVWF  FF6
0EDFE:  MOVLW  1D
0EE00:  MOVWF  FF7
0EE02:  MOVLW  00
0EE04:  MOVWF  FF8
0EE06:  CLRF   1B
0EE08:  BTFSC  FF2.7
0EE0A:  BSF    1B.7
0EE0C:  BCF    FF2.7
0EE0E:  MOVLB  0
0EE10:  CALL   0E42
0EE14:  BTFSC  1B.7
0EE16:  BSF    FF2.7
....................    for(v=9; v<17; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EE18:  MOVLW  09
0EE1A:  MOVLB  8
0EE1C:  MOVWF  xB6
0EE1E:  MOVF   xB6,W
0EE20:  SUBLW  10
0EE22:  BNC   EE8C
0EE24:  CLRF   03
0EE26:  MOVF   xB6,W
0EE28:  ADDLW  B7
0EE2A:  MOVWF  FE9
0EE2C:  MOVLW  04
0EE2E:  ADDWFC 03,W
0EE30:  MOVWF  FEA
0EE32:  MOVFF  FEF,8B7
0EE36:  CLRF   1B
0EE38:  BTFSC  FF2.7
0EE3A:  BSF    1B.7
0EE3C:  BCF    FF2.7
0EE3E:  MOVFF  8B6,A40
0EE42:  MOVLW  01
0EE44:  MOVLB  A
0EE46:  MOVWF  x41
0EE48:  MOVLB  0
0EE4A:  CALL   0F9A
0EE4E:  BTFSC  1B.7
0EE50:  BSF    FF2.7
0EE52:  MOVLW  5B
0EE54:  BTFSS  F9E.4
0EE56:  BRA    EE54
0EE58:  MOVWF  FAD
0EE5A:  CLRF   1B
0EE5C:  BTFSC  FF2.7
0EE5E:  BSF    1B.7
0EE60:  BCF    FF2.7
0EE62:  MOVFF  8B7,A40
0EE66:  MOVLW  1B
0EE68:  MOVLB  A
0EE6A:  MOVWF  x41
0EE6C:  MOVLB  0
0EE6E:  CALL   0F9A
0EE72:  BTFSC  1B.7
0EE74:  BSF    FF2.7
0EE76:  MOVLW  5D
0EE78:  BTFSS  F9E.4
0EE7A:  BRA    EE78
0EE7C:  MOVWF  FAD
0EE7E:  MOVLW  20
0EE80:  BTFSS  F9E.4
0EE82:  BRA    EE80
0EE84:  MOVWF  FAD
0EE86:  MOVLB  8
0EE88:  INCF   xB6,F
0EE8A:  BRA    EE1E
....................    fprintf(COM_A, "\r\n"); 
0EE8C:  MOVLW  0D
0EE8E:  BTFSS  F9E.4
0EE90:  BRA    EE8E
0EE92:  MOVWF  FAD
0EE94:  MOVLW  0A
0EE96:  BTFSS  F9E.4
0EE98:  BRA    EE96
0EE9A:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EE9C:  MOVLW  50
0EE9E:  MOVWF  FF6
0EEA0:  MOVLW  1D
0EEA2:  MOVWF  FF7
0EEA4:  MOVLW  00
0EEA6:  MOVWF  FF8
0EEA8:  CLRF   1B
0EEAA:  BTFSC  FF2.7
0EEAC:  BSF    1B.7
0EEAE:  BCF    FF2.7
0EEB0:  MOVLB  0
0EEB2:  CALL   0E42
0EEB6:  BTFSC  1B.7
0EEB8:  BSF    FF2.7
....................    for(v=17; v<25; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EEBA:  MOVLW  11
0EEBC:  MOVLB  8
0EEBE:  MOVWF  xB6
0EEC0:  MOVF   xB6,W
0EEC2:  SUBLW  18
0EEC4:  BNC   EF2E
0EEC6:  CLRF   03
0EEC8:  MOVF   xB6,W
0EECA:  ADDLW  B7
0EECC:  MOVWF  FE9
0EECE:  MOVLW  04
0EED0:  ADDWFC 03,W
0EED2:  MOVWF  FEA
0EED4:  MOVFF  FEF,8B7
0EED8:  CLRF   1B
0EEDA:  BTFSC  FF2.7
0EEDC:  BSF    1B.7
0EEDE:  BCF    FF2.7
0EEE0:  MOVFF  8B6,A40
0EEE4:  MOVLW  01
0EEE6:  MOVLB  A
0EEE8:  MOVWF  x41
0EEEA:  MOVLB  0
0EEEC:  CALL   0F9A
0EEF0:  BTFSC  1B.7
0EEF2:  BSF    FF2.7
0EEF4:  MOVLW  5B
0EEF6:  BTFSS  F9E.4
0EEF8:  BRA    EEF6
0EEFA:  MOVWF  FAD
0EEFC:  CLRF   1B
0EEFE:  BTFSC  FF2.7
0EF00:  BSF    1B.7
0EF02:  BCF    FF2.7
0EF04:  MOVFF  8B7,A40
0EF08:  MOVLW  1B
0EF0A:  MOVLB  A
0EF0C:  MOVWF  x41
0EF0E:  MOVLB  0
0EF10:  CALL   0F9A
0EF14:  BTFSC  1B.7
0EF16:  BSF    FF2.7
0EF18:  MOVLW  5D
0EF1A:  BTFSS  F9E.4
0EF1C:  BRA    EF1A
0EF1E:  MOVWF  FAD
0EF20:  MOVLW  20
0EF22:  BTFSS  F9E.4
0EF24:  BRA    EF22
0EF26:  MOVWF  FAD
0EF28:  MOVLB  8
0EF2A:  INCF   xB6,F
0EF2C:  BRA    EEC0
....................    fprintf(COM_A, "\r\n"); 
0EF2E:  MOVLW  0D
0EF30:  BTFSS  F9E.4
0EF32:  BRA    EF30
0EF34:  MOVWF  FAD
0EF36:  MOVLW  0A
0EF38:  BTFSS  F9E.4
0EF3A:  BRA    EF38
0EF3C:  MOVWF  FAD
....................     
....................    fprintf(COM_A, "@VAL "); 
0EF3E:  MOVLW  56
0EF40:  MOVWF  FF6
0EF42:  MOVLW  1D
0EF44:  MOVWF  FF7
0EF46:  MOVLW  00
0EF48:  MOVWF  FF8
0EF4A:  CLRF   1B
0EF4C:  BTFSC  FF2.7
0EF4E:  BSF    1B.7
0EF50:  BCF    FF2.7
0EF52:  MOVLB  0
0EF54:  CALL   0E42
0EF58:  BTFSC  1B.7
0EF5A:  BSF    FF2.7
....................    for(v=25; v<33; ++v) fprintf(COM_A, "%02u[%u] ",v,valve_status[v]); 
0EF5C:  MOVLW  19
0EF5E:  MOVLB  8
0EF60:  MOVWF  xB6
0EF62:  MOVF   xB6,W
0EF64:  SUBLW  20
0EF66:  BNC   EFD0
0EF68:  CLRF   03
0EF6A:  MOVF   xB6,W
0EF6C:  ADDLW  B7
0EF6E:  MOVWF  FE9
0EF70:  MOVLW  04
0EF72:  ADDWFC 03,W
0EF74:  MOVWF  FEA
0EF76:  MOVFF  FEF,8B7
0EF7A:  CLRF   1B
0EF7C:  BTFSC  FF2.7
0EF7E:  BSF    1B.7
0EF80:  BCF    FF2.7
0EF82:  MOVFF  8B6,A40
0EF86:  MOVLW  01
0EF88:  MOVLB  A
0EF8A:  MOVWF  x41
0EF8C:  MOVLB  0
0EF8E:  CALL   0F9A
0EF92:  BTFSC  1B.7
0EF94:  BSF    FF2.7
0EF96:  MOVLW  5B
0EF98:  BTFSS  F9E.4
0EF9A:  BRA    EF98
0EF9C:  MOVWF  FAD
0EF9E:  CLRF   1B
0EFA0:  BTFSC  FF2.7
0EFA2:  BSF    1B.7
0EFA4:  BCF    FF2.7
0EFA6:  MOVFF  8B7,A40
0EFAA:  MOVLW  1B
0EFAC:  MOVLB  A
0EFAE:  MOVWF  x41
0EFB0:  MOVLB  0
0EFB2:  CALL   0F9A
0EFB6:  BTFSC  1B.7
0EFB8:  BSF    FF2.7
0EFBA:  MOVLW  5D
0EFBC:  BTFSS  F9E.4
0EFBE:  BRA    EFBC
0EFC0:  MOVWF  FAD
0EFC2:  MOVLW  20
0EFC4:  BTFSS  F9E.4
0EFC6:  BRA    EFC4
0EFC8:  MOVWF  FAD
0EFCA:  MOVLB  8
0EFCC:  INCF   xB6,F
0EFCE:  BRA    EF62
....................    fprintf(COM_A, "\r\n");    
0EFD0:  MOVLW  0D
0EFD2:  BTFSS  F9E.4
0EFD4:  BRA    EFD2
0EFD6:  MOVWF  FAD
0EFD8:  MOVLW  0A
0EFDA:  BTFSS  F9E.4
0EFDC:  BRA    EFDA
0EFDE:  MOVWF  FAD
0EFE0:  MOVLB  0
0EFE2:  RETURN 0
.................... } 
....................  
.................... void sol_switch_cmd(int16 setting) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][s][%Lu]\r\n", setting); 
*
1449C:  MOVF   1F,W
1449E:  SUBLW  04
144A0:  BNZ   1450A
144A2:  MOVF   20,F
144A4:  BNZ   1450A
144A6:  MOVLW  5C
144A8:  MOVWF  FF6
144AA:  MOVLW  1D
144AC:  MOVWF  FF7
144AE:  MOVLW  00
144B0:  MOVWF  FF8
144B2:  CLRF   1B
144B4:  BTFSC  FF2.7
144B6:  BSF    1B.7
144B8:  BCF    FF2.7
144BA:  MOVLW  0C
144BC:  MOVLB  A
144BE:  MOVWF  x40
144C0:  MOVLB  0
144C2:  CALL   1018
144C6:  BTFSC  1B.7
144C8:  BSF    FF2.7
144CA:  MOVLW  10
144CC:  MOVWF  FE9
144CE:  CLRF   1B
144D0:  BTFSC  FF2.7
144D2:  BSF    1B.7
144D4:  BCF    FF2.7
144D6:  MOVFF  8B7,A41
144DA:  MOVFF  8B6,A40
144DE:  CALL   119A
144E2:  BTFSC  1B.7
144E4:  BSF    FF2.7
144E6:  MOVLW  6B
144E8:  MOVWF  FF6
144EA:  MOVLW  1D
144EC:  MOVWF  FF7
144EE:  MOVLW  00
144F0:  MOVWF  FF8
144F2:  CLRF   1B
144F4:  BTFSC  FF2.7
144F6:  BSF    1B.7
144F8:  BCF    FF2.7
144FA:  MOVLW  03
144FC:  MOVLB  A
144FE:  MOVWF  x40
14500:  MOVLB  0
14502:  CALL   1018
14506:  BTFSC  1B.7
14508:  BSF    FF2.7
....................  
....................    multidrop_on(); 
1450A:  CALL   DA6C
....................       fprintf(COM_B, "/1s%Lu\r",setting); 
1450E:  MOVLW  70
14510:  MOVWF  FF6
14512:  MOVLW  1D
14514:  MOVWF  FF7
14516:  MOVLW  00
14518:  MOVWF  FF8
1451A:  MOVLW  03
1451C:  MOVLB  8
1451E:  MOVWF  xB8
14520:  MOVLB  0
14522:  CALL   DA80
14526:  MOVLW  10
14528:  MOVWF  FE9
1452A:  MOVFF  8B7,8B9
1452E:  MOVFF  8B6,8B8
14532:  BRA    143E2
14534:  MOVLW  0D
14536:  BTFSS  FA4.4
14538:  BRA    14536
1453A:  MOVLB  F
1453C:  MOVWF  x1C
....................    multidrop_off(); 
1453E:  MOVLB  0
14540:  CALL   DB58
....................  
....................    delay_ms(100); 
14544:  MOVLW  64
14546:  MOVLB  9
14548:  MOVWF  xEC
1454A:  MOVLB  0
1454C:  CALL   2904
14550:  RETURN 0
.................... } 
....................  
.................... void sol_chip_cmd(int8 chip) 
.................... { 
....................    if (nv_report_mode == 4) fprintf(COM_A, "@SOL[/1][c][%u]\r\n", chip); 
*
0DBAA:  MOVF   1F,W
0DBAC:  SUBLW  04
0DBAE:  BNZ   DC18
0DBB0:  MOVF   20,F
0DBB2:  BNZ   DC18
0DBB4:  MOVLW  78
0DBB6:  MOVWF  FF6
0DBB8:  MOVLW  1D
0DBBA:  MOVWF  FF7
0DBBC:  MOVLW  00
0DBBE:  MOVWF  FF8
0DBC0:  CLRF   1B
0DBC2:  BTFSC  FF2.7
0DBC4:  BSF    1B.7
0DBC6:  BCF    FF2.7
0DBC8:  MOVLW  0C
0DBCA:  MOVLB  A
0DBCC:  MOVWF  x40
0DBCE:  MOVLB  0
0DBD0:  CALL   1018
0DBD4:  BTFSC  1B.7
0DBD6:  BSF    FF2.7
0DBD8:  CLRF   1B
0DBDA:  BTFSC  FF2.7
0DBDC:  BSF    1B.7
0DBDE:  BCF    FF2.7
0DBE0:  MOVFF  8B6,A40
0DBE4:  MOVLW  1B
0DBE6:  MOVLB  A
0DBE8:  MOVWF  x41
0DBEA:  MOVLB  0
0DBEC:  CALL   0F9A
0DBF0:  BTFSC  1B.7
0DBF2:  BSF    FF2.7
0DBF4:  MOVLW  86
0DBF6:  MOVWF  FF6
0DBF8:  MOVLW  1D
0DBFA:  MOVWF  FF7
0DBFC:  MOVLW  00
0DBFE:  MOVWF  FF8
0DC00:  CLRF   1B
0DC02:  BTFSC  FF2.7
0DC04:  BSF    1B.7
0DC06:  BCF    FF2.7
0DC08:  MOVLW  03
0DC0A:  MOVLB  A
0DC0C:  MOVWF  x40
0DC0E:  MOVLB  0
0DC10:  CALL   1018
0DC14:  BTFSC  1B.7
0DC16:  BSF    FF2.7
....................     
....................    multidrop_on(); 
0DC18:  RCALL  DA6C
....................       fprintf(COM_B, "/1c%u\r",chip); 
0DC1A:  MOVLW  8A
0DC1C:  MOVWF  FF6
0DC1E:  MOVLW  1D
0DC20:  MOVWF  FF7
0DC22:  MOVLW  00
0DC24:  MOVWF  FF8
0DC26:  MOVLW  03
0DC28:  MOVLB  8
0DC2A:  MOVWF  xB8
0DC2C:  MOVLB  0
0DC2E:  RCALL  DA80
0DC30:  MOVFF  8B6,8F3
0DC34:  MOVLW  1B
0DC36:  MOVLB  8
0DC38:  MOVWF  xF4
0DC3A:  MOVLB  0
0DC3C:  RCALL  DAB4
0DC3E:  MOVLW  0D
0DC40:  BTFSS  FA4.4
0DC42:  BRA    DC40
0DC44:  MOVLB  F
0DC46:  MOVWF  x1C
....................    multidrop_off(); 
0DC48:  MOVLB  0
0DC4A:  RCALL  DB58
....................    delay_ms(100); 
0DC4C:  MOVLW  64
0DC4E:  MOVLB  9
0DC50:  MOVWF  xEC
0DC52:  MOVLB  0
0DC54:  CALL   2904
....................  
....................    multidrop_on(); 
0DC58:  RCALL  DA6C
....................      fprintf(COM_B, "/1s256\r"); 
0DC5A:  MOVLW  92
0DC5C:  MOVWF  FF6
0DC5E:  MOVLW  1D
0DC60:  MOVWF  FF7
0DC62:  MOVLW  00
0DC64:  MOVWF  FF8
0DC66:  BRA    DB7A
....................    multidrop_off();  
0DC68:  RCALL  DB58
....................    delay_ms(100); 
0DC6A:  MOVLW  64
0DC6C:  MOVLB  9
0DC6E:  MOVWF  xEC
0DC70:  MOVLB  0
0DC72:  CALL   2904
0DC76:  RETURN 0
.................... } 
....................  
.................... void sol_switch(int8 valve) 
.................... { 
....................    switch(valve){ 
*
14552:  MOVLB  8
14554:  MOVF   xB5,W
14556:  ADDLW  DF
14558:  BTFSC  FD8.0
1455A:  BRA    14946
1455C:  ADDLW  21
1455E:  MOVLB  0
14560:  GOTO   14978
....................       case 0 : sol_chip_cmd(1); 
14564:  MOVLW  01
14566:  MOVLB  8
14568:  MOVWF  xB6
1456A:  MOVLB  0
1456C:  CALL   DBAA
....................                sol_switch_cmd(0); 
14570:  MOVLB  8
14572:  CLRF   xB7
14574:  CLRF   xB6
14576:  MOVLB  0
14578:  RCALL  1449C
....................                sol_chip_cmd(2); 
1457A:  MOVLW  02
1457C:  MOVLB  8
1457E:  MOVWF  xB6
14580:  MOVLB  0
14582:  CALL   DBAA
....................                sol_switch_cmd(0); 
14586:  MOVLB  8
14588:  CLRF   xB7
1458A:  CLRF   xB6
1458C:  MOVLB  0
1458E:  RCALL  1449C
....................                sol_chip_cmd(3); 
14590:  MOVLW  03
14592:  MOVLB  8
14594:  MOVWF  xB6
14596:  MOVLB  0
14598:  CALL   DBAA
....................                sol_switch_cmd(0); 
1459C:  MOVLB  8
1459E:  CLRF   xB7
145A0:  CLRF   xB6
145A2:  MOVLB  0
145A4:  RCALL  1449C
....................                sol_chip_cmd(4); 
145A6:  MOVLW  04
145A8:  MOVLB  8
145AA:  MOVWF  xB6
145AC:  MOVLB  0
145AE:  CALL   DBAA
....................                sol_switch_cmd(0); 
145B2:  MOVLB  8
145B4:  CLRF   xB7
145B6:  CLRF   xB6
145B8:  MOVLB  0
145BA:  RCALL  1449C
....................                init_valve_status(); 
145BC:  CALL   30AE
....................          break; 
145C0:  MOVLB  8
145C2:  BRA    14946
....................       // Bank 1 
....................       case 1 : sol_chip_cmd(1); 
145C4:  MOVLW  01
145C6:  MOVLB  8
145C8:  MOVWF  xB6
145CA:  MOVLB  0
145CC:  CALL   DBAA
....................                sol_switch_cmd(1); 
145D0:  MOVLB  8
145D2:  CLRF   xB7
145D4:  MOVLW  01
145D6:  MOVWF  xB6
145D8:  MOVLB  0
145DA:  RCALL  1449C
....................          break;     
145DC:  MOVLB  8
145DE:  BRA    14946
....................       case 2 : sol_chip_cmd(1); 
145E0:  MOVLW  01
145E2:  MOVLB  8
145E4:  MOVWF  xB6
145E6:  MOVLB  0
145E8:  CALL   DBAA
....................                sol_switch_cmd(2); 
145EC:  MOVLB  8
145EE:  CLRF   xB7
145F0:  MOVLW  02
145F2:  MOVWF  xB6
145F4:  MOVLB  0
145F6:  RCALL  1449C
....................          break;           
145F8:  MOVLB  8
145FA:  BRA    14946
....................       case 3 : sol_chip_cmd(1); 
145FC:  MOVLW  01
145FE:  MOVLB  8
14600:  MOVWF  xB6
14602:  MOVLB  0
14604:  CALL   DBAA
....................                sol_switch_cmd(4); 
14608:  MOVLB  8
1460A:  CLRF   xB7
1460C:  MOVLW  04
1460E:  MOVWF  xB6
14610:  MOVLB  0
14612:  RCALL  1449C
....................          break;  
14614:  MOVLB  8
14616:  BRA    14946
....................       case 4 : sol_chip_cmd(1); 
14618:  MOVLW  01
1461A:  MOVLB  8
1461C:  MOVWF  xB6
1461E:  MOVLB  0
14620:  CALL   DBAA
....................                sol_switch_cmd(8); 
14624:  MOVLB  8
14626:  CLRF   xB7
14628:  MOVLW  08
1462A:  MOVWF  xB6
1462C:  MOVLB  0
1462E:  RCALL  1449C
....................          break;  
14630:  MOVLB  8
14632:  BRA    14946
....................       case 5 : sol_chip_cmd(1); 
14634:  MOVLW  01
14636:  MOVLB  8
14638:  MOVWF  xB6
1463A:  MOVLB  0
1463C:  CALL   DBAA
....................                sol_switch_cmd(16); 
14640:  MOVLB  8
14642:  CLRF   xB7
14644:  MOVLW  10
14646:  MOVWF  xB6
14648:  MOVLB  0
1464A:  RCALL  1449C
....................          break;  
1464C:  MOVLB  8
1464E:  BRA    14946
....................       case 6 : sol_chip_cmd(1); 
14650:  MOVLW  01
14652:  MOVLB  8
14654:  MOVWF  xB6
14656:  MOVLB  0
14658:  CALL   DBAA
....................                sol_switch_cmd(32); 
1465C:  MOVLB  8
1465E:  CLRF   xB7
14660:  MOVLW  20
14662:  MOVWF  xB6
14664:  MOVLB  0
14666:  RCALL  1449C
....................          break;  
14668:  MOVLB  8
1466A:  BRA    14946
....................       case 7 : sol_chip_cmd(1); 
1466C:  MOVLW  01
1466E:  MOVLB  8
14670:  MOVWF  xB6
14672:  MOVLB  0
14674:  CALL   DBAA
....................                sol_switch_cmd(64); 
14678:  MOVLB  8
1467A:  CLRF   xB7
1467C:  MOVLW  40
1467E:  MOVWF  xB6
14680:  MOVLB  0
14682:  RCALL  1449C
....................          break;  
14684:  MOVLB  8
14686:  BRA    14946
....................       case 8 : sol_chip_cmd(1); 
14688:  MOVLW  01
1468A:  MOVLB  8
1468C:  MOVWF  xB6
1468E:  MOVLB  0
14690:  CALL   DBAA
....................                sol_switch_cmd(128); 
14694:  MOVLB  8
14696:  CLRF   xB7
14698:  MOVLW  80
1469A:  MOVWF  xB6
1469C:  MOVLB  0
1469E:  RCALL  1449C
....................          break;   
146A0:  MOVLB  8
146A2:  BRA    14946
....................       // Bank 2 
....................       case 9 : sol_chip_cmd(2); 
146A4:  MOVLW  02
146A6:  MOVLB  8
146A8:  MOVWF  xB6
146AA:  MOVLB  0
146AC:  CALL   DBAA
....................                sol_switch_cmd(1); 
146B0:  MOVLB  8
146B2:  CLRF   xB7
146B4:  MOVLW  01
146B6:  MOVWF  xB6
146B8:  MOVLB  0
146BA:  RCALL  1449C
....................          break;     
146BC:  MOVLB  8
146BE:  BRA    14946
....................       case 10 : sol_chip_cmd(2); 
146C0:  MOVLW  02
146C2:  MOVLB  8
146C4:  MOVWF  xB6
146C6:  MOVLB  0
146C8:  CALL   DBAA
....................                sol_switch_cmd(2); 
146CC:  MOVLB  8
146CE:  CLRF   xB7
146D0:  MOVLW  02
146D2:  MOVWF  xB6
146D4:  MOVLB  0
146D6:  RCALL  1449C
....................          break;           
146D8:  MOVLB  8
146DA:  BRA    14946
....................       case 11 : sol_chip_cmd(2); 
146DC:  MOVLW  02
146DE:  MOVLB  8
146E0:  MOVWF  xB6
146E2:  MOVLB  0
146E4:  CALL   DBAA
....................                sol_switch_cmd(4); 
146E8:  MOVLB  8
146EA:  CLRF   xB7
146EC:  MOVLW  04
146EE:  MOVWF  xB6
146F0:  MOVLB  0
146F2:  RCALL  1449C
....................          break;  
146F4:  MOVLB  8
146F6:  BRA    14946
....................       case 12 : sol_chip_cmd(2); 
146F8:  MOVLW  02
146FA:  MOVLB  8
146FC:  MOVWF  xB6
146FE:  MOVLB  0
14700:  CALL   DBAA
....................                sol_switch_cmd(8); 
14704:  MOVLB  8
14706:  CLRF   xB7
14708:  MOVLW  08
1470A:  MOVWF  xB6
1470C:  MOVLB  0
1470E:  RCALL  1449C
....................          break;  
14710:  MOVLB  8
14712:  BRA    14946
....................       case 13 : sol_chip_cmd(2); 
14714:  MOVLW  02
14716:  MOVLB  8
14718:  MOVWF  xB6
1471A:  MOVLB  0
1471C:  CALL   DBAA
....................                sol_switch_cmd(16); 
14720:  MOVLB  8
14722:  CLRF   xB7
14724:  MOVLW  10
14726:  MOVWF  xB6
14728:  MOVLB  0
1472A:  RCALL  1449C
....................          break;  
1472C:  MOVLB  8
1472E:  BRA    14946
....................       case 14 : sol_chip_cmd(2); 
14730:  MOVLW  02
14732:  MOVLB  8
14734:  MOVWF  xB6
14736:  MOVLB  0
14738:  CALL   DBAA
....................                sol_switch_cmd(32); 
1473C:  MOVLB  8
1473E:  CLRF   xB7
14740:  MOVLW  20
14742:  MOVWF  xB6
14744:  MOVLB  0
14746:  RCALL  1449C
....................          break;  
14748:  MOVLB  8
1474A:  BRA    14946
....................       case 15 : sol_chip_cmd(2); 
1474C:  MOVLW  02
1474E:  MOVLB  8
14750:  MOVWF  xB6
14752:  MOVLB  0
14754:  CALL   DBAA
....................                sol_switch_cmd(64); 
14758:  MOVLB  8
1475A:  CLRF   xB7
1475C:  MOVLW  40
1475E:  MOVWF  xB6
14760:  MOVLB  0
14762:  RCALL  1449C
....................          break;  
14764:  MOVLB  8
14766:  BRA    14946
....................       case 16 : sol_chip_cmd(2); 
14768:  MOVLW  02
1476A:  MOVLB  8
1476C:  MOVWF  xB6
1476E:  MOVLB  0
14770:  CALL   DBAA
....................                sol_switch_cmd(128); 
14774:  MOVLB  8
14776:  CLRF   xB7
14778:  MOVLW  80
1477A:  MOVWF  xB6
1477C:  MOVLB  0
1477E:  RCALL  1449C
....................          break;   
14780:  MOVLB  8
14782:  BRA    14946
....................       // Bank 3 
....................       case 17 : sol_chip_cmd(3); 
14784:  MOVLW  03
14786:  MOVLB  8
14788:  MOVWF  xB6
1478A:  MOVLB  0
1478C:  CALL   DBAA
....................                sol_switch_cmd(1); 
14790:  MOVLB  8
14792:  CLRF   xB7
14794:  MOVLW  01
14796:  MOVWF  xB6
14798:  MOVLB  0
1479A:  RCALL  1449C
....................          break;     
1479C:  MOVLB  8
1479E:  BRA    14946
....................       case 18 : sol_chip_cmd(3); 
147A0:  MOVLW  03
147A2:  MOVLB  8
147A4:  MOVWF  xB6
147A6:  MOVLB  0
147A8:  CALL   DBAA
....................                sol_switch_cmd(2); 
147AC:  MOVLB  8
147AE:  CLRF   xB7
147B0:  MOVLW  02
147B2:  MOVWF  xB6
147B4:  MOVLB  0
147B6:  RCALL  1449C
....................          break;           
147B8:  MOVLB  8
147BA:  BRA    14946
....................       case 19 : sol_chip_cmd(3); 
147BC:  MOVLW  03
147BE:  MOVLB  8
147C0:  MOVWF  xB6
147C2:  MOVLB  0
147C4:  CALL   DBAA
....................                sol_switch_cmd(4); 
147C8:  MOVLB  8
147CA:  CLRF   xB7
147CC:  MOVLW  04
147CE:  MOVWF  xB6
147D0:  MOVLB  0
147D2:  RCALL  1449C
....................          break;  
147D4:  MOVLB  8
147D6:  BRA    14946
....................       case 20 : sol_chip_cmd(3); 
147D8:  MOVLW  03
147DA:  MOVLB  8
147DC:  MOVWF  xB6
147DE:  MOVLB  0
147E0:  CALL   DBAA
....................                sol_switch_cmd(8); 
147E4:  MOVLB  8
147E6:  CLRF   xB7
147E8:  MOVLW  08
147EA:  MOVWF  xB6
147EC:  MOVLB  0
147EE:  RCALL  1449C
....................          break;  
147F0:  MOVLB  8
147F2:  BRA    14946
....................       case 21 : sol_chip_cmd(3); 
147F4:  MOVLW  03
147F6:  MOVLB  8
147F8:  MOVWF  xB6
147FA:  MOVLB  0
147FC:  CALL   DBAA
....................                sol_switch_cmd(16); 
14800:  MOVLB  8
14802:  CLRF   xB7
14804:  MOVLW  10
14806:  MOVWF  xB6
14808:  MOVLB  0
1480A:  RCALL  1449C
....................          break;  
1480C:  MOVLB  8
1480E:  BRA    14946
....................       case 22 : sol_chip_cmd(3); 
14810:  MOVLW  03
14812:  MOVLB  8
14814:  MOVWF  xB6
14816:  MOVLB  0
14818:  CALL   DBAA
....................                sol_switch_cmd(32); 
1481C:  MOVLB  8
1481E:  CLRF   xB7
14820:  MOVLW  20
14822:  MOVWF  xB6
14824:  MOVLB  0
14826:  RCALL  1449C
....................          break;  
14828:  MOVLB  8
1482A:  BRA    14946
....................       case 23 : sol_chip_cmd(3); 
1482C:  MOVLW  03
1482E:  MOVLB  8
14830:  MOVWF  xB6
14832:  MOVLB  0
14834:  CALL   DBAA
....................                sol_switch_cmd(64); 
14838:  MOVLB  8
1483A:  CLRF   xB7
1483C:  MOVLW  40
1483E:  MOVWF  xB6
14840:  MOVLB  0
14842:  RCALL  1449C
....................          break;  
14844:  MOVLB  8
14846:  BRA    14946
....................       case 24 : sol_chip_cmd(3); 
14848:  MOVLW  03
1484A:  MOVLB  8
1484C:  MOVWF  xB6
1484E:  MOVLB  0
14850:  CALL   DBAA
....................                sol_switch_cmd(128); 
14854:  MOVLB  8
14856:  CLRF   xB7
14858:  MOVLW  80
1485A:  MOVWF  xB6
1485C:  MOVLB  0
1485E:  RCALL  1449C
....................          break;      
14860:  MOVLB  8
14862:  BRA    14946
....................       // Bank 4 
....................       case 25 : sol_chip_cmd(4); 
14864:  MOVLW  04
14866:  MOVLB  8
14868:  MOVWF  xB6
1486A:  MOVLB  0
1486C:  CALL   DBAA
....................                sol_switch_cmd(1); 
14870:  MOVLB  8
14872:  CLRF   xB7
14874:  MOVLW  01
14876:  MOVWF  xB6
14878:  MOVLB  0
1487A:  RCALL  1449C
....................          break;     
1487C:  MOVLB  8
1487E:  BRA    14946
....................       case 26 : sol_chip_cmd(4); 
14880:  MOVLW  04
14882:  MOVLB  8
14884:  MOVWF  xB6
14886:  MOVLB  0
14888:  CALL   DBAA
....................                sol_switch_cmd(2); 
1488C:  MOVLB  8
1488E:  CLRF   xB7
14890:  MOVLW  02
14892:  MOVWF  xB6
14894:  MOVLB  0
14896:  RCALL  1449C
....................          break;           
14898:  MOVLB  8
1489A:  BRA    14946
....................       case 27 : sol_chip_cmd(4); 
1489C:  MOVLW  04
1489E:  MOVLB  8
148A0:  MOVWF  xB6
148A2:  MOVLB  0
148A4:  CALL   DBAA
....................                sol_switch_cmd(4); 
148A8:  MOVLB  8
148AA:  CLRF   xB7
148AC:  MOVLW  04
148AE:  MOVWF  xB6
148B0:  MOVLB  0
148B2:  RCALL  1449C
....................          break;  
148B4:  MOVLB  8
148B6:  BRA    14946
....................       case 28 : sol_chip_cmd(4); 
148B8:  MOVLW  04
148BA:  MOVLB  8
148BC:  MOVWF  xB6
148BE:  MOVLB  0
148C0:  CALL   DBAA
....................                sol_switch_cmd(8); 
148C4:  MOVLB  8
148C6:  CLRF   xB7
148C8:  MOVLW  08
148CA:  MOVWF  xB6
148CC:  MOVLB  0
148CE:  RCALL  1449C
....................          break;  
148D0:  MOVLB  8
148D2:  BRA    14946
....................       case 29 : sol_chip_cmd(4); 
148D4:  MOVLW  04
148D6:  MOVLB  8
148D8:  MOVWF  xB6
148DA:  MOVLB  0
148DC:  CALL   DBAA
....................                sol_switch_cmd(16); 
148E0:  MOVLB  8
148E2:  CLRF   xB7
148E4:  MOVLW  10
148E6:  MOVWF  xB6
148E8:  MOVLB  0
148EA:  RCALL  1449C
....................          break;  
148EC:  MOVLB  8
148EE:  BRA    14946
....................       case 30 : sol_chip_cmd(4); 
148F0:  MOVLW  04
148F2:  MOVLB  8
148F4:  MOVWF  xB6
148F6:  MOVLB  0
148F8:  CALL   DBAA
....................                sol_switch_cmd(32); 
148FC:  MOVLB  8
148FE:  CLRF   xB7
14900:  MOVLW  20
14902:  MOVWF  xB6
14904:  MOVLB  0
14906:  RCALL  1449C
....................          break;  
14908:  MOVLB  8
1490A:  BRA    14946
....................       case 31 : sol_chip_cmd(4); 
1490C:  MOVLW  04
1490E:  MOVLB  8
14910:  MOVWF  xB6
14912:  MOVLB  0
14914:  CALL   DBAA
....................                sol_switch_cmd(64); 
14918:  MOVLB  8
1491A:  CLRF   xB7
1491C:  MOVLW  40
1491E:  MOVWF  xB6
14920:  MOVLB  0
14922:  RCALL  1449C
....................          break;  
14924:  MOVLB  8
14926:  BRA    14946
....................       case 32 : sol_chip_cmd(4); 
14928:  MOVLW  04
1492A:  MOVLB  8
1492C:  MOVWF  xB6
1492E:  MOVLB  0
14930:  CALL   DBAA
....................                sol_switch_cmd(128); 
14934:  MOVLB  8
14936:  CLRF   xB7
14938:  MOVLW  80
1493A:  MOVWF  xB6
1493C:  MOVLB  0
1493E:  RCALL  1449C
....................          break; 
14940:  MOVLB  8
14942:  BRA    14946
14944:  MOVLB  8
....................    } 
....................    if(valve>0&&valve<33) valve_status[valve]=1;   
14946:  MOVF   xB5,F
14948:  BZ    14962
1494A:  MOVF   xB5,W
1494C:  SUBLW  20
1494E:  BNC   14962
14950:  CLRF   03
14952:  MOVF   xB5,W
14954:  ADDLW  B7
14956:  MOVWF  FE9
14958:  MOVLW  04
1495A:  ADDWFC 03,W
1495C:  MOVWF  FEA
1495E:  MOVLW  01
14960:  MOVWF  FEF
....................    if(nv_report_mode==4)display_valve_status(); 
14962:  MOVF   1F,W
14964:  SUBLW  04
14966:  BNZ   14974
14968:  MOVF   20,F
1496A:  BNZ   14974
1496C:  MOVLB  0
1496E:  CALL   ED5A
14972:  MOVLB  8
14974:  MOVLB  0
14976:  RETURN 0
....................     
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "data.c" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... char endofline[3] = {'\r' , '\n' , '\0'}; 
....................  
.................... void clear_data_arrays(){ 
....................  
....................    int8 i; 
....................    // raw data 
....................    for (i=0; i<8; ++i) NO3_array[i] = 0; 
*
104F0:  MOVLB  8
104F2:  CLRF   x9D
104F4:  MOVF   x9D,W
104F6:  SUBLW  07
104F8:  BNC   10514
104FA:  BCF    FD8.0
104FC:  RLCF   x9D,W
104FE:  CLRF   03
10500:  ADDLW  4B
10502:  MOVWF  FE9
10504:  MOVLW  03
10506:  ADDWFC 03,W
10508:  MOVWF  FEA
1050A:  CLRF   FEC
1050C:  MOVF   FED,F
1050E:  CLRF   FEF
10510:  INCF   x9D,F
10512:  BRA    104F4
....................    for (i=0; i<8; ++i) NO2_array[i] = 0; 
10514:  CLRF   x9D
10516:  MOVF   x9D,W
10518:  SUBLW  07
1051A:  BNC   10536
1051C:  BCF    FD8.0
1051E:  RLCF   x9D,W
10520:  CLRF   03
10522:  ADDLW  5D
10524:  MOVWF  FE9
10526:  MOVLW  03
10528:  ADDWFC 03,W
1052A:  MOVWF  FEA
1052C:  CLRF   FEC
1052E:  MOVF   FED,F
10530:  CLRF   FEF
10532:  INCF   x9D,F
10534:  BRA    10516
....................    for (i=0; i<8; ++i) PO4_array[i] = 0; 
10536:  CLRF   x9D
10538:  MOVF   x9D,W
1053A:  SUBLW  07
1053C:  BNC   10558
1053E:  BCF    FD8.0
10540:  RLCF   x9D,W
10542:  CLRF   03
10544:  ADDLW  6F
10546:  MOVWF  FE9
10548:  MOVLW  03
1054A:  ADDWFC 03,W
1054C:  MOVWF  FEA
1054E:  CLRF   FEC
10550:  MOVF   FED,F
10552:  CLRF   FEF
10554:  INCF   x9D,F
10556:  BRA    10538
....................    for (i=0; i<8; ++i) NH4_array[i] = 0; 
10558:  CLRF   x9D
1055A:  MOVF   x9D,W
1055C:  SUBLW  07
1055E:  BNC   1057A
10560:  BCF    FD8.0
10562:  RLCF   x9D,W
10564:  CLRF   03
10566:  ADDLW  81
10568:  MOVWF  FE9
1056A:  MOVLW  03
1056C:  ADDWFC 03,W
1056E:  MOVWF  FEA
10570:  CLRF   FEC
10572:  MOVF   FED,F
10574:  CLRF   FEF
10576:  INCF   x9D,F
10578:  BRA    1055A
....................    for (i=0; i<8; ++i) SiO_array[i] = 0; 
1057A:  CLRF   x9D
1057C:  MOVF   x9D,W
1057E:  SUBLW  07
10580:  BNC   1059C
10582:  BCF    FD8.0
10584:  RLCF   x9D,W
10586:  CLRF   03
10588:  ADDLW  93
1058A:  MOVWF  FE9
1058C:  MOVLW  03
1058E:  ADDWFC 03,W
10590:  MOVWF  FEA
10592:  CLRF   FEC
10594:  MOVF   FED,F
10596:  CLRF   FEF
10598:  INCF   x9D,F
1059A:  BRA    1057C
....................     
....................    memset (&abs_str[0], 0x00, 68);  //blank it 
1059C:  MOVLW  04
1059E:  MOVWF  FEA
105A0:  MOVLW  25
105A2:  MOVWF  FE9
105A4:  CLRF   00
105A6:  CLRF   02
105A8:  MOVLW  44
105AA:  MOVWF  01
105AC:  MOVLB  0
105AE:  CALL   351A
105B2:  GOTO   153B8 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO3(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO3_abs_array[i] = 0; 
*
10E3E:  MOVLB  8
10E40:  CLRF   xC2
10E42:  MOVF   xC2,W
10E44:  SUBLW  03
10E46:  BNC   10E66
10E48:  MOVF   xC2,W
10E4A:  MULLW  04
10E4C:  MOVF   FF3,W
10E4E:  CLRF   03
10E50:  ADDLW  A5
10E52:  MOVWF  FE9
10E54:  MOVLW  03
10E56:  ADDWFC 03,W
10E58:  MOVWF  FEA
10E5A:  CLRF   FEF
10E5C:  CLRF   FEC
10E5E:  CLRF   FEC
10E60:  CLRF   FEC
10E62:  INCF   xC2,F
10E64:  BRA    10E42
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO3_array[0] > 0 && NO3_array[1] > 0) { 
10E66:  MOVLB  3
10E68:  MOVF   x4B,F
10E6A:  BTFSS  FD8.2
10E6C:  BRA    10E72
10E6E:  MOVF   x4C,F
10E70:  BZ    10F0C
10E72:  MOVF   x4D,F
10E74:  BNZ   10E7A
10E76:  MOVF   x4E,F
10E78:  BZ    10F0C
....................       blank = NO3_array[0]; 
10E7A:  MOVFF  34C,918
10E7E:  MOVFF  34B,917
10E82:  MOVLB  0
10E84:  CALL   C8EA
10E88:  MOVFF  03,8C6
10E8C:  MOVFF  02,8C5
10E90:  MOVFF  01,8C4
10E94:  MOVFF  00,8C3
....................       react = NO3_array[1]; 
10E98:  MOVFF  34E,918
10E9C:  MOVFF  34D,917
10EA0:  CALL   C8EA
10EA4:  MOVFF  03,8CA
10EA8:  MOVFF  02,8C9
10EAC:  MOVFF  01,8C8
10EB0:  MOVFF  00,8C7
....................       ratio = blank / react; 
10EB4:  MOVFF  8C6,8FE
10EB8:  MOVFF  8C5,8FD
10EBC:  MOVFF  8C4,8FC
10EC0:  MOVFF  8C3,8FB
10EC4:  MOVFF  8CA,902
10EC8:  MOVFF  8C9,901
10ECC:  MOVFF  8C8,900
10ED0:  MOVFF  8C7,8FF
10ED4:  CALL   C920
10ED8:  MOVFF  03,8CE
10EDC:  MOVFF  02,8CD
10EE0:  MOVFF  01,8CC
10EE4:  MOVFF  00,8CB
....................       // As 
....................       NO3_abs_array[0] = log10(ratio); 
10EE8:  MOVFF  8CE,8D2
10EEC:  MOVFF  8CD,8D1
10EF0:  MOVFF  8CC,8D0
10EF4:  MOVFF  8CB,8CF
10EF8:  RCALL  10BBC
10EFA:  MOVFF  03,3A8
10EFE:  MOVFF  02,3A7
10F02:  MOVFF  01,3A6
10F06:  MOVFF  00,3A5
10F0A:  MOVLB  3
....................    } 
....................    if (NO3_array[2] > 0 && NO3_array[3] > 0) { 
10F0C:  MOVF   x4F,F
10F0E:  BNZ   10F14
10F10:  MOVF   x50,F
10F12:  BZ    10FAE
10F14:  MOVF   x51,F
10F16:  BNZ   10F1C
10F18:  MOVF   x52,F
10F1A:  BZ    10FAE
....................       blank = NO3_array[2]; 
10F1C:  MOVFF  350,918
10F20:  MOVFF  34F,917
10F24:  MOVLB  0
10F26:  CALL   C8EA
10F2A:  MOVFF  03,8C6
10F2E:  MOVFF  02,8C5
10F32:  MOVFF  01,8C4
10F36:  MOVFF  00,8C3
....................       react = NO3_array[3]; 
10F3A:  MOVFF  352,918
10F3E:  MOVFF  351,917
10F42:  CALL   C8EA
10F46:  MOVFF  03,8CA
10F4A:  MOVFF  02,8C9
10F4E:  MOVFF  01,8C8
10F52:  MOVFF  00,8C7
....................       ratio = blank / react;    
10F56:  MOVFF  8C6,8FE
10F5A:  MOVFF  8C5,8FD
10F5E:  MOVFF  8C4,8FC
10F62:  MOVFF  8C3,8FB
10F66:  MOVFF  8CA,902
10F6A:  MOVFF  8C9,901
10F6E:  MOVFF  8C8,900
10F72:  MOVFF  8C7,8FF
10F76:  CALL   C920
10F7A:  MOVFF  03,8CE
10F7E:  MOVFF  02,8CD
10F82:  MOVFF  01,8CC
10F86:  MOVFF  00,8CB
....................       // At 
....................       NO3_abs_array[1] = log10(ratio); 
10F8A:  MOVFF  8CE,8D2
10F8E:  MOVFF  8CD,8D1
10F92:  MOVFF  8CC,8D0
10F96:  MOVFF  8CB,8CF
10F9A:  RCALL  10BBC
10F9C:  MOVFF  03,3AC
10FA0:  MOVFF  02,3AB
10FA4:  MOVFF  01,3AA
10FA8:  MOVFF  00,3A9
10FAC:  MOVLB  3
....................    } 
....................    if (NO3_array[4] > 0 && NO3_array[5] > 0) { 
10FAE:  MOVF   x53,F
10FB0:  BNZ   10FB6
10FB2:  MOVF   x54,F
10FB4:  BZ    11050
10FB6:  MOVF   x55,F
10FB8:  BNZ   10FBE
10FBA:  MOVF   x56,F
10FBC:  BZ    11050
....................       blank = NO3_array[4]; 
10FBE:  MOVFF  354,918
10FC2:  MOVFF  353,917
10FC6:  MOVLB  0
10FC8:  CALL   C8EA
10FCC:  MOVFF  03,8C6
10FD0:  MOVFF  02,8C5
10FD4:  MOVFF  01,8C4
10FD8:  MOVFF  00,8C3
....................       react = NO3_array[5]; 
10FDC:  MOVFF  356,918
10FE0:  MOVFF  355,917
10FE4:  CALL   C8EA
10FE8:  MOVFF  03,8CA
10FEC:  MOVFF  02,8C9
10FF0:  MOVFF  01,8C8
10FF4:  MOVFF  00,8C7
....................       ratio = blank / react; 
10FF8:  MOVFF  8C6,8FE
10FFC:  MOVFF  8C5,8FD
11000:  MOVFF  8C4,8FC
11004:  MOVFF  8C3,8FB
11008:  MOVFF  8CA,902
1100C:  MOVFF  8C9,901
11010:  MOVFF  8C8,900
11014:  MOVFF  8C7,8FF
11018:  CALL   C920
1101C:  MOVFF  03,8CE
11020:  MOVFF  02,8CD
11024:  MOVFF  01,8CC
11028:  MOVFF  00,8CB
....................       // Ar 
....................       NO3_abs_array[2] = log10(ratio); 
1102C:  MOVFF  8CE,8D2
11030:  MOVFF  8CD,8D1
11034:  MOVFF  8CC,8D0
11038:  MOVFF  8CB,8CF
1103C:  RCALL  10BBC
1103E:  MOVFF  03,3B0
11042:  MOVFF  02,3AF
11046:  MOVFF  01,3AE
1104A:  MOVFF  00,3AD
1104E:  MOVLB  3
....................    } 
....................    if (NO3_array[6] > 0 && NO3_array[7] > 0) { 
11050:  MOVF   x57,F
11052:  BNZ   11058
11054:  MOVF   x58,F
11056:  BZ    110F2
11058:  MOVF   x59,F
1105A:  BNZ   11060
1105C:  MOVF   x5A,F
1105E:  BZ    110F2
....................       blank = NO3_array[6]; 
11060:  MOVFF  358,918
11064:  MOVFF  357,917
11068:  MOVLB  0
1106A:  CALL   C8EA
1106E:  MOVFF  03,8C6
11072:  MOVFF  02,8C5
11076:  MOVFF  01,8C4
1107A:  MOVFF  00,8C3
....................       react = NO3_array[7]; 
1107E:  MOVFF  35A,918
11082:  MOVFF  359,917
11086:  CALL   C8EA
1108A:  MOVFF  03,8CA
1108E:  MOVFF  02,8C9
11092:  MOVFF  01,8C8
11096:  MOVFF  00,8C7
....................       ratio = blank / react; 
1109A:  MOVFF  8C6,8FE
1109E:  MOVFF  8C5,8FD
110A2:  MOVFF  8C4,8FC
110A6:  MOVFF  8C3,8FB
110AA:  MOVFF  8CA,902
110AE:  MOVFF  8C9,901
110B2:  MOVFF  8C8,900
110B6:  MOVFF  8C7,8FF
110BA:  CALL   C920
110BE:  MOVFF  03,8CE
110C2:  MOVFF  02,8CD
110C6:  MOVFF  01,8CC
110CA:  MOVFF  00,8CB
....................       // Au 
....................       NO3_abs_array[3] = log10(ratio); 
110CE:  MOVFF  8CE,8D2
110D2:  MOVFF  8CD,8D1
110D6:  MOVFF  8CC,8D0
110DA:  MOVFF  8CB,8CF
110DE:  RCALL  10BBC
110E0:  MOVFF  03,3B4
110E4:  MOVFF  02,3B3
110E8:  MOVFF  01,3B2
110EC:  MOVFF  00,3B1
110F0:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO3_array[0],NO3_array[1],NO3_abs_array[0],NO3_array[2],NO3_array[3],NO3_abs_array[1],NO3_array[4],NO3_array[5],NO3_abs_array[2]); 
110F2:  MOVLW  04
110F4:  MOVWF  1E
110F6:  MOVLW  25
110F8:  MOVWF  1D
110FA:  MOVLW  9A
110FC:  MOVWF  FF6
110FE:  MOVLW  1D
11100:  MOVWF  FF7
11102:  MOVLW  00
11104:  MOVWF  FF8
11106:  MOVLW  06
11108:  MOVLB  8
1110A:  MOVWF  xEB
1110C:  MOVLB  0
1110E:  CALL   AAC0
11112:  MOVLW  10
11114:  MOVWF  FE9
11116:  MOVFF  34C,8F7
1111A:  MOVFF  34B,8F6
1111E:  CALL   AAF2
11122:  MOVLW  A3
11124:  MOVWF  FF6
11126:  MOVLW  1D
11128:  MOVWF  FF7
1112A:  MOVLW  00
1112C:  MOVWF  FF8
1112E:  MOVLW  07
11130:  MOVLB  8
11132:  MOVWF  xEB
11134:  MOVLB  0
11136:  CALL   AAC0
1113A:  MOVLW  10
1113C:  MOVWF  FE9
1113E:  MOVFF  34E,8F7
11142:  MOVFF  34D,8F6
11146:  CALL   AAF2
1114A:  MOVLW  AD
1114C:  MOVWF  FF6
1114E:  MOVLW  1D
11150:  MOVWF  FF7
11152:  MOVLW  00
11154:  MOVWF  FF8
11156:  MOVLW  09
11158:  MOVLB  8
1115A:  MOVWF  xEB
1115C:  MOVLB  0
1115E:  CALL   AAC0
11162:  MOVLW  89
11164:  MOVWF  FE9
11166:  MOVFF  3A8,8D2
1116A:  MOVFF  3A7,8D1
1116E:  MOVFF  3A6,8D0
11172:  MOVFF  3A5,8CF
11176:  MOVLW  04
11178:  MOVLB  8
1117A:  MOVWF  xD3
1117C:  MOVLB  0
1117E:  RCALL  10C28
11180:  MOVLW  BB
11182:  MOVWF  FF6
11184:  MOVLW  1D
11186:  MOVWF  FF7
11188:  MOVLW  00
1118A:  MOVWF  FF8
1118C:  MOVLW  07
1118E:  MOVLB  8
11190:  MOVWF  xEB
11192:  MOVLB  0
11194:  CALL   AAC0
11198:  MOVLW  10
1119A:  MOVWF  FE9
1119C:  MOVFF  350,8F7
111A0:  MOVFF  34F,8F6
111A4:  CALL   AAF2
111A8:  MOVLW  C5
111AA:  MOVWF  FF6
111AC:  MOVLW  1D
111AE:  MOVWF  FF7
111B0:  MOVLW  00
111B2:  MOVWF  FF8
111B4:  MOVLW  07
111B6:  MOVLB  8
111B8:  MOVWF  xEB
111BA:  MOVLB  0
111BC:  CALL   AAC0
111C0:  MOVLW  10
111C2:  MOVWF  FE9
111C4:  MOVFF  352,8F7
111C8:  MOVFF  351,8F6
111CC:  CALL   AAF2
111D0:  MOVLW  CF
111D2:  MOVWF  FF6
111D4:  MOVLW  1D
111D6:  MOVWF  FF7
111D8:  MOVLW  00
111DA:  MOVWF  FF8
111DC:  MOVLW  09
111DE:  MOVLB  8
111E0:  MOVWF  xEB
111E2:  MOVLB  0
111E4:  CALL   AAC0
111E8:  MOVLW  89
111EA:  MOVWF  FE9
111EC:  MOVFF  3AC,8D2
111F0:  MOVFF  3AB,8D1
111F4:  MOVFF  3AA,8D0
111F8:  MOVFF  3A9,8CF
111FC:  MOVLW  04
111FE:  MOVLB  8
11200:  MOVWF  xD3
11202:  MOVLB  0
11204:  RCALL  10C28
11206:  MOVLW  DD
11208:  MOVWF  FF6
1120A:  MOVLW  1D
1120C:  MOVWF  FF7
1120E:  MOVLW  00
11210:  MOVWF  FF8
11212:  MOVLW  07
11214:  MOVLB  8
11216:  MOVWF  xEB
11218:  MOVLB  0
1121A:  CALL   AAC0
1121E:  MOVLW  10
11220:  MOVWF  FE9
11222:  MOVFF  354,8F7
11226:  MOVFF  353,8F6
1122A:  CALL   AAF2
1122E:  MOVLW  E7
11230:  MOVWF  FF6
11232:  MOVLW  1D
11234:  MOVWF  FF7
11236:  MOVLW  00
11238:  MOVWF  FF8
1123A:  MOVLW  07
1123C:  MOVLB  8
1123E:  MOVWF  xEB
11240:  MOVLB  0
11242:  CALL   AAC0
11246:  MOVLW  10
11248:  MOVWF  FE9
1124A:  MOVFF  356,8F7
1124E:  MOVFF  355,8F6
11252:  CALL   AAF2
11256:  MOVLW  F1
11258:  MOVWF  FF6
1125A:  MOVLW  1D
1125C:  MOVWF  FF7
1125E:  MOVLW  00
11260:  MOVWF  FF8
11262:  MOVLW  09
11264:  MOVLB  8
11266:  MOVWF  xEB
11268:  MOVLB  0
1126A:  CALL   AAC0
1126E:  MOVLW  89
11270:  MOVWF  FE9
11272:  MOVFF  3B0,8D2
11276:  MOVFF  3AF,8D1
1127A:  MOVFF  3AE,8D0
1127E:  MOVFF  3AD,8CF
11282:  MOVLW  04
11284:  MOVLB  8
11286:  MOVWF  xD3
11288:  MOVLB  0
1128A:  RCALL  10C28
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO3,%s\r\n", abs_str);       
1128C:  MOVF   1F,W
1128E:  SUBLW  02
11290:  BNZ   11296
11292:  MOVF   20,F
11294:  BZ    112D6
11296:  MOVLW  00
11298:  MOVWF  FF6
1129A:  MOVLW  1E
1129C:  MOVWF  FF7
1129E:  MOVLW  00
112A0:  MOVWF  FF8
112A2:  CLRF   1B
112A4:  BTFSC  FF2.7
112A6:  BSF    1B.7
112A8:  BCF    FF2.7
112AA:  MOVLW  09
112AC:  MOVLB  A
112AE:  MOVWF  x40
112B0:  MOVLB  0
112B2:  CALL   1018
112B6:  BTFSC  1B.7
112B8:  BSF    FF2.7
112BA:  MOVLW  04
112BC:  MOVWF  FEA
112BE:  MOVLW  25
112C0:  MOVWF  FE9
112C2:  CALL   798A
112C6:  MOVLW  0D
112C8:  BTFSS  F9E.4
112CA:  BRA    112C8
112CC:  MOVWF  FAD
112CE:  MOVLW  0A
112D0:  BTFSS  F9E.4
112D2:  BRA    112D0
112D4:  MOVWF  FAD
112D6:  GOTO   125E2 (RETURN)
.................... } 
....................  
.................... void calc_abs_NO2(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................        
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NO2_abs_array[i] = 0; 
112DA:  MOVLB  8
112DC:  CLRF   xC2
112DE:  MOVF   xC2,W
112E0:  SUBLW  03
112E2:  BNC   11302
112E4:  MOVF   xC2,W
112E6:  MULLW  04
112E8:  MOVF   FF3,W
112EA:  CLRF   03
112EC:  ADDLW  B5
112EE:  MOVWF  FE9
112F0:  MOVLW  03
112F2:  ADDWFC 03,W
112F4:  MOVWF  FEA
112F6:  CLRF   FEF
112F8:  CLRF   FEC
112FA:  CLRF   FEC
112FC:  CLRF   FEC
112FE:  INCF   xC2,F
11300:  BRA    112DE
....................     
....................    // raw data array == Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // if (Br > 0 && Rr > 0 && Br > Rr) == if valid raw data update Abs 
....................    // Removing forcing abs to 0 if negative VK Sept. 24 2015 
....................    if (NO2_array[0] > 0 && NO2_array[1] > 0) { 
11302:  MOVLB  3
11304:  MOVF   x5D,F
11306:  BTFSS  FD8.2
11308:  BRA    1130E
1130A:  MOVF   x5E,F
1130C:  BZ    113A8
1130E:  MOVF   x5F,F
11310:  BNZ   11316
11312:  MOVF   x60,F
11314:  BZ    113A8
....................       blank = NO2_array[0]; 
11316:  MOVFF  35E,918
1131A:  MOVFF  35D,917
1131E:  MOVLB  0
11320:  CALL   C8EA
11324:  MOVFF  03,8C6
11328:  MOVFF  02,8C5
1132C:  MOVFF  01,8C4
11330:  MOVFF  00,8C3
....................       react = NO2_array[1]; 
11334:  MOVFF  360,918
11338:  MOVFF  35F,917
1133C:  CALL   C8EA
11340:  MOVFF  03,8CA
11344:  MOVFF  02,8C9
11348:  MOVFF  01,8C8
1134C:  MOVFF  00,8C7
....................       ratio = blank / react; 
11350:  MOVFF  8C6,8FE
11354:  MOVFF  8C5,8FD
11358:  MOVFF  8C4,8FC
1135C:  MOVFF  8C3,8FB
11360:  MOVFF  8CA,902
11364:  MOVFF  8C9,901
11368:  MOVFF  8C8,900
1136C:  MOVFF  8C7,8FF
11370:  CALL   C920
11374:  MOVFF  03,8CE
11378:  MOVFF  02,8CD
1137C:  MOVFF  01,8CC
11380:  MOVFF  00,8CB
....................       // As 
....................       NO2_abs_array[0] = log10(ratio); 
11384:  MOVFF  8CE,8D2
11388:  MOVFF  8CD,8D1
1138C:  MOVFF  8CC,8D0
11390:  MOVFF  8CB,8CF
11394:  RCALL  10BBC
11396:  MOVFF  03,3B8
1139A:  MOVFF  02,3B7
1139E:  MOVFF  01,3B6
113A2:  MOVFF  00,3B5
113A6:  MOVLB  3
....................    } 
....................    if (NO2_array[2] > 0 && NO2_array[3] > 0) { 
113A8:  MOVF   x61,F
113AA:  BNZ   113B0
113AC:  MOVF   x62,F
113AE:  BZ    1144C
113B0:  MOVF   x63,F
113B2:  BNZ   113B8
113B4:  MOVF   x64,F
113B6:  BZ    1144C
....................       blank = NO2_array[2]; 
113B8:  MOVFF  362,918
113BC:  MOVFF  361,917
113C0:  MOVLB  0
113C2:  CALL   C8EA
113C6:  MOVFF  03,8C6
113CA:  MOVFF  02,8C5
113CE:  MOVFF  01,8C4
113D2:  MOVFF  00,8C3
....................       react = NO2_array[3]; 
113D6:  MOVFF  364,918
113DA:  MOVFF  363,917
113DE:  CALL   C8EA
113E2:  MOVFF  03,8CA
113E6:  MOVFF  02,8C9
113EA:  MOVFF  01,8C8
113EE:  MOVFF  00,8C7
....................       ratio = blank / react;    
113F2:  MOVFF  8C6,8FE
113F6:  MOVFF  8C5,8FD
113FA:  MOVFF  8C4,8FC
113FE:  MOVFF  8C3,8FB
11402:  MOVFF  8CA,902
11406:  MOVFF  8C9,901
1140A:  MOVFF  8C8,900
1140E:  MOVFF  8C7,8FF
11412:  CALL   C920
11416:  MOVFF  03,8CE
1141A:  MOVFF  02,8CD
1141E:  MOVFF  01,8CC
11422:  MOVFF  00,8CB
....................       // At 
....................       NO2_abs_array[1] = log10(ratio); 
11426:  MOVFF  8CE,8D2
1142A:  MOVFF  8CD,8D1
1142E:  MOVFF  8CC,8D0
11432:  MOVFF  8CB,8CF
11436:  CALL   10BBC
1143A:  MOVFF  03,3BC
1143E:  MOVFF  02,3BB
11442:  MOVFF  01,3BA
11446:  MOVFF  00,3B9
1144A:  MOVLB  3
....................    } 
....................    if (NO2_array[4] > 0 && NO2_array[5] > 0) { 
1144C:  MOVF   x65,F
1144E:  BNZ   11454
11450:  MOVF   x66,F
11452:  BZ    114F0
11454:  MOVF   x67,F
11456:  BNZ   1145C
11458:  MOVF   x68,F
1145A:  BZ    114F0
....................       blank = NO2_array[4]; 
1145C:  MOVFF  366,918
11460:  MOVFF  365,917
11464:  MOVLB  0
11466:  CALL   C8EA
1146A:  MOVFF  03,8C6
1146E:  MOVFF  02,8C5
11472:  MOVFF  01,8C4
11476:  MOVFF  00,8C3
....................       react = NO2_array[5]; 
1147A:  MOVFF  368,918
1147E:  MOVFF  367,917
11482:  CALL   C8EA
11486:  MOVFF  03,8CA
1148A:  MOVFF  02,8C9
1148E:  MOVFF  01,8C8
11492:  MOVFF  00,8C7
....................       ratio = blank / react; 
11496:  MOVFF  8C6,8FE
1149A:  MOVFF  8C5,8FD
1149E:  MOVFF  8C4,8FC
114A2:  MOVFF  8C3,8FB
114A6:  MOVFF  8CA,902
114AA:  MOVFF  8C9,901
114AE:  MOVFF  8C8,900
114B2:  MOVFF  8C7,8FF
114B6:  CALL   C920
114BA:  MOVFF  03,8CE
114BE:  MOVFF  02,8CD
114C2:  MOVFF  01,8CC
114C6:  MOVFF  00,8CB
....................       // Ar 
....................       NO2_abs_array[2] = log10(ratio); 
114CA:  MOVFF  8CE,8D2
114CE:  MOVFF  8CD,8D1
114D2:  MOVFF  8CC,8D0
114D6:  MOVFF  8CB,8CF
114DA:  CALL   10BBC
114DE:  MOVFF  03,3C0
114E2:  MOVFF  02,3BF
114E6:  MOVFF  01,3BE
114EA:  MOVFF  00,3BD
114EE:  MOVLB  3
....................    } 
....................    if (NO2_array[6] > 0 && NO2_array[7] > 0) { 
114F0:  MOVF   x69,F
114F2:  BNZ   114F8
114F4:  MOVF   x6A,F
114F6:  BZ    11594
114F8:  MOVF   x6B,F
114FA:  BNZ   11500
114FC:  MOVF   x6C,F
114FE:  BZ    11594
....................       blank = NO2_array[6]; 
11500:  MOVFF  36A,918
11504:  MOVFF  369,917
11508:  MOVLB  0
1150A:  CALL   C8EA
1150E:  MOVFF  03,8C6
11512:  MOVFF  02,8C5
11516:  MOVFF  01,8C4
1151A:  MOVFF  00,8C3
....................       react = NO2_array[7]; 
1151E:  MOVFF  36C,918
11522:  MOVFF  36B,917
11526:  CALL   C8EA
1152A:  MOVFF  03,8CA
1152E:  MOVFF  02,8C9
11532:  MOVFF  01,8C8
11536:  MOVFF  00,8C7
....................       ratio = blank / react; 
1153A:  MOVFF  8C6,8FE
1153E:  MOVFF  8C5,8FD
11542:  MOVFF  8C4,8FC
11546:  MOVFF  8C3,8FB
1154A:  MOVFF  8CA,902
1154E:  MOVFF  8C9,901
11552:  MOVFF  8C8,900
11556:  MOVFF  8C7,8FF
1155A:  CALL   C920
1155E:  MOVFF  03,8CE
11562:  MOVFF  02,8CD
11566:  MOVFF  01,8CC
1156A:  MOVFF  00,8CB
....................       // Au 
....................       NO2_abs_array[3] = log10(ratio); 
1156E:  MOVFF  8CE,8D2
11572:  MOVFF  8CD,8D1
11576:  MOVFF  8CC,8D0
1157A:  MOVFF  8CB,8CF
1157E:  CALL   10BBC
11582:  MOVFF  03,3C4
11586:  MOVFF  02,3C3
1158A:  MOVFF  01,3C2
1158E:  MOVFF  00,3C1
11592:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NO2_array[0],NO2_array[1],NO2_abs_array[0],NO2_array[2],NO2_array[3],NO2_abs_array[1],NO2_array[4],NO2_array[5],NO2_abs_array[2]); 
11594:  MOVLW  04
11596:  MOVWF  1E
11598:  MOVLW  25
1159A:  MOVWF  1D
1159C:  MOVLW  0E
1159E:  MOVWF  FF6
115A0:  MOVLW  1E
115A2:  MOVWF  FF7
115A4:  MOVLW  00
115A6:  MOVWF  FF8
115A8:  MOVLW  06
115AA:  MOVLB  8
115AC:  MOVWF  xEB
115AE:  MOVLB  0
115B0:  CALL   AAC0
115B4:  MOVLW  10
115B6:  MOVWF  FE9
115B8:  MOVFF  35E,8F7
115BC:  MOVFF  35D,8F6
115C0:  CALL   AAF2
115C4:  MOVLW  17
115C6:  MOVWF  FF6
115C8:  MOVLW  1E
115CA:  MOVWF  FF7
115CC:  MOVLW  00
115CE:  MOVWF  FF8
115D0:  MOVLW  07
115D2:  MOVLB  8
115D4:  MOVWF  xEB
115D6:  MOVLB  0
115D8:  CALL   AAC0
115DC:  MOVLW  10
115DE:  MOVWF  FE9
115E0:  MOVFF  360,8F7
115E4:  MOVFF  35F,8F6
115E8:  CALL   AAF2
115EC:  MOVLW  21
115EE:  MOVWF  FF6
115F0:  MOVLW  1E
115F2:  MOVWF  FF7
115F4:  MOVLW  00
115F6:  MOVWF  FF8
115F8:  MOVLW  09
115FA:  MOVLB  8
115FC:  MOVWF  xEB
115FE:  MOVLB  0
11600:  CALL   AAC0
11604:  MOVLW  89
11606:  MOVWF  FE9
11608:  MOVFF  3B8,8D2
1160C:  MOVFF  3B7,8D1
11610:  MOVFF  3B6,8D0
11614:  MOVFF  3B5,8CF
11618:  MOVLW  04
1161A:  MOVLB  8
1161C:  MOVWF  xD3
1161E:  MOVLB  0
11620:  CALL   10C28
11624:  MOVLW  2F
11626:  MOVWF  FF6
11628:  MOVLW  1E
1162A:  MOVWF  FF7
1162C:  MOVLW  00
1162E:  MOVWF  FF8
11630:  MOVLW  07
11632:  MOVLB  8
11634:  MOVWF  xEB
11636:  MOVLB  0
11638:  CALL   AAC0
1163C:  MOVLW  10
1163E:  MOVWF  FE9
11640:  MOVFF  362,8F7
11644:  MOVFF  361,8F6
11648:  CALL   AAF2
1164C:  MOVLW  39
1164E:  MOVWF  FF6
11650:  MOVLW  1E
11652:  MOVWF  FF7
11654:  MOVLW  00
11656:  MOVWF  FF8
11658:  MOVLW  07
1165A:  MOVLB  8
1165C:  MOVWF  xEB
1165E:  MOVLB  0
11660:  CALL   AAC0
11664:  MOVLW  10
11666:  MOVWF  FE9
11668:  MOVFF  364,8F7
1166C:  MOVFF  363,8F6
11670:  CALL   AAF2
11674:  MOVLW  43
11676:  MOVWF  FF6
11678:  MOVLW  1E
1167A:  MOVWF  FF7
1167C:  MOVLW  00
1167E:  MOVWF  FF8
11680:  MOVLW  09
11682:  MOVLB  8
11684:  MOVWF  xEB
11686:  MOVLB  0
11688:  CALL   AAC0
1168C:  MOVLW  89
1168E:  MOVWF  FE9
11690:  MOVFF  3BC,8D2
11694:  MOVFF  3BB,8D1
11698:  MOVFF  3BA,8D0
1169C:  MOVFF  3B9,8CF
116A0:  MOVLW  04
116A2:  MOVLB  8
116A4:  MOVWF  xD3
116A6:  MOVLB  0
116A8:  CALL   10C28
116AC:  MOVLW  51
116AE:  MOVWF  FF6
116B0:  MOVLW  1E
116B2:  MOVWF  FF7
116B4:  MOVLW  00
116B6:  MOVWF  FF8
116B8:  MOVLW  07
116BA:  MOVLB  8
116BC:  MOVWF  xEB
116BE:  MOVLB  0
116C0:  CALL   AAC0
116C4:  MOVLW  10
116C6:  MOVWF  FE9
116C8:  MOVFF  366,8F7
116CC:  MOVFF  365,8F6
116D0:  CALL   AAF2
116D4:  MOVLW  5B
116D6:  MOVWF  FF6
116D8:  MOVLW  1E
116DA:  MOVWF  FF7
116DC:  MOVLW  00
116DE:  MOVWF  FF8
116E0:  MOVLW  07
116E2:  MOVLB  8
116E4:  MOVWF  xEB
116E6:  MOVLB  0
116E8:  CALL   AAC0
116EC:  MOVLW  10
116EE:  MOVWF  FE9
116F0:  MOVFF  368,8F7
116F4:  MOVFF  367,8F6
116F8:  CALL   AAF2
116FC:  MOVLW  65
116FE:  MOVWF  FF6
11700:  MOVLW  1E
11702:  MOVWF  FF7
11704:  MOVLW  00
11706:  MOVWF  FF8
11708:  MOVLW  09
1170A:  MOVLB  8
1170C:  MOVWF  xEB
1170E:  MOVLB  0
11710:  CALL   AAC0
11714:  MOVLW  89
11716:  MOVWF  FE9
11718:  MOVFF  3C0,8D2
1171C:  MOVFF  3BF,8D1
11720:  MOVFF  3BE,8D0
11724:  MOVFF  3BD,8CF
11728:  MOVLW  04
1172A:  MOVLB  8
1172C:  MOVWF  xD3
1172E:  MOVLB  0
11730:  CALL   10C28
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NO2,%s\r\n", abs_str);       
11734:  MOVF   1F,W
11736:  SUBLW  02
11738:  BNZ   1173E
1173A:  MOVF   20,F
1173C:  BZ    1177E
1173E:  MOVLW  74
11740:  MOVWF  FF6
11742:  MOVLW  1E
11744:  MOVWF  FF7
11746:  MOVLW  00
11748:  MOVWF  FF8
1174A:  CLRF   1B
1174C:  BTFSC  FF2.7
1174E:  BSF    1B.7
11750:  BCF    FF2.7
11752:  MOVLW  09
11754:  MOVLB  A
11756:  MOVWF  x40
11758:  MOVLB  0
1175A:  CALL   1018
1175E:  BTFSC  1B.7
11760:  BSF    FF2.7
11762:  MOVLW  04
11764:  MOVWF  FEA
11766:  MOVLW  25
11768:  MOVWF  FE9
1176A:  CALL   798A
1176E:  MOVLW  0D
11770:  BTFSS  F9E.4
11772:  BRA    11770
11774:  MOVWF  FAD
11776:  MOVLW  0A
11778:  BTFSS  F9E.4
1177A:  BRA    11778
1177C:  MOVWF  FAD
1177E:  GOTO   125E2 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void calc_abs_PO4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) PO4_abs_array[i] = 0; 
11782:  MOVLB  8
11784:  CLRF   xC2
11786:  MOVF   xC2,W
11788:  SUBLW  03
1178A:  BNC   117AA
1178C:  MOVF   xC2,W
1178E:  MULLW  04
11790:  MOVF   FF3,W
11792:  CLRF   03
11794:  ADDLW  C5
11796:  MOVWF  FE9
11798:  MOVLW  03
1179A:  ADDWFC 03,W
1179C:  MOVWF  FEA
1179E:  CLRF   FEF
117A0:  CLRF   FEC
117A2:  CLRF   FEC
117A4:  CLRF   FEC
117A6:  INCF   xC2,F
117A8:  BRA    11786
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (PO4_array[0] > 0 && PO4_array[1] > 0) { 
117AA:  MOVLB  3
117AC:  MOVF   x6F,F
117AE:  BTFSS  FD8.2
117B0:  BRA    117B6
117B2:  MOVF   x70,F
117B4:  BZ    11852
117B6:  MOVF   x71,F
117B8:  BNZ   117BE
117BA:  MOVF   x72,F
117BC:  BZ    11852
....................       blank = PO4_array[0]; 
117BE:  MOVFF  370,918
117C2:  MOVFF  36F,917
117C6:  MOVLB  0
117C8:  CALL   C8EA
117CC:  MOVFF  03,8C6
117D0:  MOVFF  02,8C5
117D4:  MOVFF  01,8C4
117D8:  MOVFF  00,8C3
....................       react = PO4_array[1]; 
117DC:  MOVFF  372,918
117E0:  MOVFF  371,917
117E4:  CALL   C8EA
117E8:  MOVFF  03,8CA
117EC:  MOVFF  02,8C9
117F0:  MOVFF  01,8C8
117F4:  MOVFF  00,8C7
....................       ratio = blank / react; 
117F8:  MOVFF  8C6,8FE
117FC:  MOVFF  8C5,8FD
11800:  MOVFF  8C4,8FC
11804:  MOVFF  8C3,8FB
11808:  MOVFF  8CA,902
1180C:  MOVFF  8C9,901
11810:  MOVFF  8C8,900
11814:  MOVFF  8C7,8FF
11818:  CALL   C920
1181C:  MOVFF  03,8CE
11820:  MOVFF  02,8CD
11824:  MOVFF  01,8CC
11828:  MOVFF  00,8CB
....................       PO4_abs_array[0] = log10(ratio); 
1182C:  MOVFF  8CE,8D2
11830:  MOVFF  8CD,8D1
11834:  MOVFF  8CC,8D0
11838:  MOVFF  8CB,8CF
1183C:  CALL   10BBC
11840:  MOVFF  03,3C8
11844:  MOVFF  02,3C7
11848:  MOVFF  01,3C6
1184C:  MOVFF  00,3C5
11850:  MOVLB  3
....................    } 
....................    if (PO4_array[2] > 0 && PO4_array[3] > 0) { 
11852:  MOVF   x73,F
11854:  BNZ   1185A
11856:  MOVF   x74,F
11858:  BZ    118F6
1185A:  MOVF   x75,F
1185C:  BNZ   11862
1185E:  MOVF   x76,F
11860:  BZ    118F6
....................       blank = PO4_array[2]; 
11862:  MOVFF  374,918
11866:  MOVFF  373,917
1186A:  MOVLB  0
1186C:  CALL   C8EA
11870:  MOVFF  03,8C6
11874:  MOVFF  02,8C5
11878:  MOVFF  01,8C4
1187C:  MOVFF  00,8C3
....................       react = PO4_array[3]; 
11880:  MOVFF  376,918
11884:  MOVFF  375,917
11888:  CALL   C8EA
1188C:  MOVFF  03,8CA
11890:  MOVFF  02,8C9
11894:  MOVFF  01,8C8
11898:  MOVFF  00,8C7
....................       ratio = blank / react;    
1189C:  MOVFF  8C6,8FE
118A0:  MOVFF  8C5,8FD
118A4:  MOVFF  8C4,8FC
118A8:  MOVFF  8C3,8FB
118AC:  MOVFF  8CA,902
118B0:  MOVFF  8C9,901
118B4:  MOVFF  8C8,900
118B8:  MOVFF  8C7,8FF
118BC:  CALL   C920
118C0:  MOVFF  03,8CE
118C4:  MOVFF  02,8CD
118C8:  MOVFF  01,8CC
118CC:  MOVFF  00,8CB
....................       PO4_abs_array[1] = log10(ratio); 
118D0:  MOVFF  8CE,8D2
118D4:  MOVFF  8CD,8D1
118D8:  MOVFF  8CC,8D0
118DC:  MOVFF  8CB,8CF
118E0:  CALL   10BBC
118E4:  MOVFF  03,3CC
118E8:  MOVFF  02,3CB
118EC:  MOVFF  01,3CA
118F0:  MOVFF  00,3C9
118F4:  MOVLB  3
....................    } 
....................    if (PO4_array[4] > 0 && PO4_array[5] > 0) { 
118F6:  MOVF   x77,F
118F8:  BNZ   118FE
118FA:  MOVF   x78,F
118FC:  BZ    1199A
118FE:  MOVF   x79,F
11900:  BNZ   11906
11902:  MOVF   x7A,F
11904:  BZ    1199A
....................       blank = PO4_array[4]; 
11906:  MOVFF  378,918
1190A:  MOVFF  377,917
1190E:  MOVLB  0
11910:  CALL   C8EA
11914:  MOVFF  03,8C6
11918:  MOVFF  02,8C5
1191C:  MOVFF  01,8C4
11920:  MOVFF  00,8C3
....................       react = PO4_array[5]; 
11924:  MOVFF  37A,918
11928:  MOVFF  379,917
1192C:  CALL   C8EA
11930:  MOVFF  03,8CA
11934:  MOVFF  02,8C9
11938:  MOVFF  01,8C8
1193C:  MOVFF  00,8C7
....................       ratio = blank / react; 
11940:  MOVFF  8C6,8FE
11944:  MOVFF  8C5,8FD
11948:  MOVFF  8C4,8FC
1194C:  MOVFF  8C3,8FB
11950:  MOVFF  8CA,902
11954:  MOVFF  8C9,901
11958:  MOVFF  8C8,900
1195C:  MOVFF  8C7,8FF
11960:  CALL   C920
11964:  MOVFF  03,8CE
11968:  MOVFF  02,8CD
1196C:  MOVFF  01,8CC
11970:  MOVFF  00,8CB
....................       PO4_abs_array[2] = log10(ratio); 
11974:  MOVFF  8CE,8D2
11978:  MOVFF  8CD,8D1
1197C:  MOVFF  8CC,8D0
11980:  MOVFF  8CB,8CF
11984:  CALL   10BBC
11988:  MOVFF  03,3D0
1198C:  MOVFF  02,3CF
11990:  MOVFF  01,3CE
11994:  MOVFF  00,3CD
11998:  MOVLB  3
....................    } 
....................    if (PO4_array[6] > 0 && PO4_array[7] > 0) { 
1199A:  MOVF   x7B,F
1199C:  BNZ   119A2
1199E:  MOVF   x7C,F
119A0:  BZ    11A3E
119A2:  MOVF   x7D,F
119A4:  BNZ   119AA
119A6:  MOVF   x7E,F
119A8:  BZ    11A3E
....................       blank = PO4_array[6]; 
119AA:  MOVFF  37C,918
119AE:  MOVFF  37B,917
119B2:  MOVLB  0
119B4:  CALL   C8EA
119B8:  MOVFF  03,8C6
119BC:  MOVFF  02,8C5
119C0:  MOVFF  01,8C4
119C4:  MOVFF  00,8C3
....................       react = PO4_array[7]; 
119C8:  MOVFF  37E,918
119CC:  MOVFF  37D,917
119D0:  CALL   C8EA
119D4:  MOVFF  03,8CA
119D8:  MOVFF  02,8C9
119DC:  MOVFF  01,8C8
119E0:  MOVFF  00,8C7
....................       ratio = blank / react; 
119E4:  MOVFF  8C6,8FE
119E8:  MOVFF  8C5,8FD
119EC:  MOVFF  8C4,8FC
119F0:  MOVFF  8C3,8FB
119F4:  MOVFF  8CA,902
119F8:  MOVFF  8C9,901
119FC:  MOVFF  8C8,900
11A00:  MOVFF  8C7,8FF
11A04:  CALL   C920
11A08:  MOVFF  03,8CE
11A0C:  MOVFF  02,8CD
11A10:  MOVFF  01,8CC
11A14:  MOVFF  00,8CB
....................       PO4_abs_array[3] = log10(ratio); 
11A18:  MOVFF  8CE,8D2
11A1C:  MOVFF  8CD,8D1
11A20:  MOVFF  8CC,8D0
11A24:  MOVFF  8CB,8CF
11A28:  CALL   10BBC
11A2C:  MOVFF  03,3D4
11A30:  MOVFF  02,3D3
11A34:  MOVFF  01,3D2
11A38:  MOVFF  00,3D1
11A3C:  MOVLB  3
....................    } 
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    PO4_array[0],PO4_array[1],PO4_abs_array[0],PO4_array[2],PO4_array[3],PO4_abs_array[1],PO4_array[4],PO4_array[5],PO4_abs_array[2]); 
11A3E:  MOVLW  04
11A40:  MOVWF  1E
11A42:  MOVLW  25
11A44:  MOVWF  1D
11A46:  MOVLW  82
11A48:  MOVWF  FF6
11A4A:  MOVLW  1E
11A4C:  MOVWF  FF7
11A4E:  MOVLW  00
11A50:  MOVWF  FF8
11A52:  MOVLW  06
11A54:  MOVLB  8
11A56:  MOVWF  xEB
11A58:  MOVLB  0
11A5A:  CALL   AAC0
11A5E:  MOVLW  10
11A60:  MOVWF  FE9
11A62:  MOVFF  370,8F7
11A66:  MOVFF  36F,8F6
11A6A:  CALL   AAF2
11A6E:  MOVLW  8B
11A70:  MOVWF  FF6
11A72:  MOVLW  1E
11A74:  MOVWF  FF7
11A76:  MOVLW  00
11A78:  MOVWF  FF8
11A7A:  MOVLW  07
11A7C:  MOVLB  8
11A7E:  MOVWF  xEB
11A80:  MOVLB  0
11A82:  CALL   AAC0
11A86:  MOVLW  10
11A88:  MOVWF  FE9
11A8A:  MOVFF  372,8F7
11A8E:  MOVFF  371,8F6
11A92:  CALL   AAF2
11A96:  MOVLW  95
11A98:  MOVWF  FF6
11A9A:  MOVLW  1E
11A9C:  MOVWF  FF7
11A9E:  MOVLW  00
11AA0:  MOVWF  FF8
11AA2:  MOVLW  09
11AA4:  MOVLB  8
11AA6:  MOVWF  xEB
11AA8:  MOVLB  0
11AAA:  CALL   AAC0
11AAE:  MOVLW  89
11AB0:  MOVWF  FE9
11AB2:  MOVFF  3C8,8D2
11AB6:  MOVFF  3C7,8D1
11ABA:  MOVFF  3C6,8D0
11ABE:  MOVFF  3C5,8CF
11AC2:  MOVLW  04
11AC4:  MOVLB  8
11AC6:  MOVWF  xD3
11AC8:  MOVLB  0
11ACA:  CALL   10C28
11ACE:  MOVLW  A3
11AD0:  MOVWF  FF6
11AD2:  MOVLW  1E
11AD4:  MOVWF  FF7
11AD6:  MOVLW  00
11AD8:  MOVWF  FF8
11ADA:  MOVLW  07
11ADC:  MOVLB  8
11ADE:  MOVWF  xEB
11AE0:  MOVLB  0
11AE2:  CALL   AAC0
11AE6:  MOVLW  10
11AE8:  MOVWF  FE9
11AEA:  MOVFF  374,8F7
11AEE:  MOVFF  373,8F6
11AF2:  CALL   AAF2
11AF6:  MOVLW  AD
11AF8:  MOVWF  FF6
11AFA:  MOVLW  1E
11AFC:  MOVWF  FF7
11AFE:  MOVLW  00
11B00:  MOVWF  FF8
11B02:  MOVLW  07
11B04:  MOVLB  8
11B06:  MOVWF  xEB
11B08:  MOVLB  0
11B0A:  CALL   AAC0
11B0E:  MOVLW  10
11B10:  MOVWF  FE9
11B12:  MOVFF  376,8F7
11B16:  MOVFF  375,8F6
11B1A:  CALL   AAF2
11B1E:  MOVLW  B7
11B20:  MOVWF  FF6
11B22:  MOVLW  1E
11B24:  MOVWF  FF7
11B26:  MOVLW  00
11B28:  MOVWF  FF8
11B2A:  MOVLW  09
11B2C:  MOVLB  8
11B2E:  MOVWF  xEB
11B30:  MOVLB  0
11B32:  CALL   AAC0
11B36:  MOVLW  89
11B38:  MOVWF  FE9
11B3A:  MOVFF  3CC,8D2
11B3E:  MOVFF  3CB,8D1
11B42:  MOVFF  3CA,8D0
11B46:  MOVFF  3C9,8CF
11B4A:  MOVLW  04
11B4C:  MOVLB  8
11B4E:  MOVWF  xD3
11B50:  MOVLB  0
11B52:  CALL   10C28
11B56:  MOVLW  C5
11B58:  MOVWF  FF6
11B5A:  MOVLW  1E
11B5C:  MOVWF  FF7
11B5E:  MOVLW  00
11B60:  MOVWF  FF8
11B62:  MOVLW  07
11B64:  MOVLB  8
11B66:  MOVWF  xEB
11B68:  MOVLB  0
11B6A:  CALL   AAC0
11B6E:  MOVLW  10
11B70:  MOVWF  FE9
11B72:  MOVFF  378,8F7
11B76:  MOVFF  377,8F6
11B7A:  CALL   AAF2
11B7E:  MOVLW  CF
11B80:  MOVWF  FF6
11B82:  MOVLW  1E
11B84:  MOVWF  FF7
11B86:  MOVLW  00
11B88:  MOVWF  FF8
11B8A:  MOVLW  07
11B8C:  MOVLB  8
11B8E:  MOVWF  xEB
11B90:  MOVLB  0
11B92:  CALL   AAC0
11B96:  MOVLW  10
11B98:  MOVWF  FE9
11B9A:  MOVFF  37A,8F7
11B9E:  MOVFF  379,8F6
11BA2:  CALL   AAF2
11BA6:  MOVLW  D9
11BA8:  MOVWF  FF6
11BAA:  MOVLW  1E
11BAC:  MOVWF  FF7
11BAE:  MOVLW  00
11BB0:  MOVWF  FF8
11BB2:  MOVLW  09
11BB4:  MOVLB  8
11BB6:  MOVWF  xEB
11BB8:  MOVLB  0
11BBA:  CALL   AAC0
11BBE:  MOVLW  89
11BC0:  MOVWF  FE9
11BC2:  MOVFF  3D0,8D2
11BC6:  MOVFF  3CF,8D1
11BCA:  MOVFF  3CE,8D0
11BCE:  MOVFF  3CD,8CF
11BD2:  MOVLW  04
11BD4:  MOVLB  8
11BD6:  MOVWF  xD3
11BD8:  MOVLB  0
11BDA:  CALL   10C28
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,PO4,%s\r\n", abs_str);     
11BDE:  MOVF   1F,W
11BE0:  SUBLW  02
11BE2:  BNZ   11BE8
11BE4:  MOVF   20,F
11BE6:  BZ    11C28
11BE8:  MOVLW  E8
11BEA:  MOVWF  FF6
11BEC:  MOVLW  1E
11BEE:  MOVWF  FF7
11BF0:  MOVLW  00
11BF2:  MOVWF  FF8
11BF4:  CLRF   1B
11BF6:  BTFSC  FF2.7
11BF8:  BSF    1B.7
11BFA:  BCF    FF2.7
11BFC:  MOVLW  09
11BFE:  MOVLB  A
11C00:  MOVWF  x40
11C02:  MOVLB  0
11C04:  CALL   1018
11C08:  BTFSC  1B.7
11C0A:  BSF    FF2.7
11C0C:  MOVLW  04
11C0E:  MOVWF  FEA
11C10:  MOVLW  25
11C12:  MOVWF  FE9
11C14:  CALL   798A
11C18:  MOVLW  0D
11C1A:  BTFSS  F9E.4
11C1C:  BRA    11C1A
11C1E:  MOVWF  FAD
11C20:  MOVLW  0A
11C22:  BTFSS  F9E.4
11C24:  BRA    11C22
11C26:  MOVWF  FAD
11C28:  GOTO   125E2 (RETURN)
....................     
....................    // Old code replaced 10/2015 
....................   // sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   PO4_abs_array[0],PO4_abs_array[1],PO4_abs_array[2],PO4_abs_array[3]); 
....................    //if (nv_report_mode != 2)  
....................   // fprintf(COM_A, "@ABS,PO4,%s\r\n", abs_str); 
.................... } 
....................  
.................... void calc_abs_NH4(){ 
....................  
....................    int8 i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) NH4_abs_array[i] = 0; 
11C2C:  MOVLB  8
11C2E:  CLRF   xC2
11C30:  MOVF   xC2,W
11C32:  SUBLW  03
11C34:  BNC   11C54
11C36:  MOVF   xC2,W
11C38:  MULLW  04
11C3A:  MOVF   FF3,W
11C3C:  CLRF   03
11C3E:  ADDLW  D5
11C40:  MOVWF  FE9
11C42:  MOVLW  03
11C44:  ADDWFC 03,W
11C46:  MOVWF  FEA
11C48:  CLRF   FEF
11C4A:  CLRF   FEC
11C4C:  CLRF   FEC
11C4E:  CLRF   FEC
11C50:  INCF   xC2,F
11C52:  BRA    11C30
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (NH4_array[0] > 0 && NH4_array[1] > 0) { 
11C54:  MOVLB  3
11C56:  MOVF   x81,F
11C58:  BTFSS  FD8.2
11C5A:  BRA    11C60
11C5C:  MOVF   x82,F
11C5E:  BZ    11CFC
11C60:  MOVF   x83,F
11C62:  BNZ   11C68
11C64:  MOVF   x84,F
11C66:  BZ    11CFC
....................       blank = NH4_array[0]; 
11C68:  MOVFF  382,918
11C6C:  MOVFF  381,917
11C70:  MOVLB  0
11C72:  CALL   C8EA
11C76:  MOVFF  03,8C6
11C7A:  MOVFF  02,8C5
11C7E:  MOVFF  01,8C4
11C82:  MOVFF  00,8C3
....................       react = NH4_array[1]; 
11C86:  MOVFF  384,918
11C8A:  MOVFF  383,917
11C8E:  CALL   C8EA
11C92:  MOVFF  03,8CA
11C96:  MOVFF  02,8C9
11C9A:  MOVFF  01,8C8
11C9E:  MOVFF  00,8C7
....................       ratio = blank / react; 
11CA2:  MOVFF  8C6,8FE
11CA6:  MOVFF  8C5,8FD
11CAA:  MOVFF  8C4,8FC
11CAE:  MOVFF  8C3,8FB
11CB2:  MOVFF  8CA,902
11CB6:  MOVFF  8C9,901
11CBA:  MOVFF  8C8,900
11CBE:  MOVFF  8C7,8FF
11CC2:  CALL   C920
11CC6:  MOVFF  03,8CE
11CCA:  MOVFF  02,8CD
11CCE:  MOVFF  01,8CC
11CD2:  MOVFF  00,8CB
....................       NH4_abs_array[0] = log10(ratio); 
11CD6:  MOVFF  8CE,8D2
11CDA:  MOVFF  8CD,8D1
11CDE:  MOVFF  8CC,8D0
11CE2:  MOVFF  8CB,8CF
11CE6:  CALL   10BBC
11CEA:  MOVFF  03,3D8
11CEE:  MOVFF  02,3D7
11CF2:  MOVFF  01,3D6
11CF6:  MOVFF  00,3D5
11CFA:  MOVLB  3
....................    } 
....................    if (NH4_array[2] > 0 && NH4_array[3] > 0) { 
11CFC:  MOVF   x85,F
11CFE:  BNZ   11D04
11D00:  MOVF   x86,F
11D02:  BZ    11DA0
11D04:  MOVF   x87,F
11D06:  BNZ   11D0C
11D08:  MOVF   x88,F
11D0A:  BZ    11DA0
....................       blank = NH4_array[2]; 
11D0C:  MOVFF  386,918
11D10:  MOVFF  385,917
11D14:  MOVLB  0
11D16:  CALL   C8EA
11D1A:  MOVFF  03,8C6
11D1E:  MOVFF  02,8C5
11D22:  MOVFF  01,8C4
11D26:  MOVFF  00,8C3
....................       react = NH4_array[3]; 
11D2A:  MOVFF  388,918
11D2E:  MOVFF  387,917
11D32:  CALL   C8EA
11D36:  MOVFF  03,8CA
11D3A:  MOVFF  02,8C9
11D3E:  MOVFF  01,8C8
11D42:  MOVFF  00,8C7
....................       ratio = blank / react;    
11D46:  MOVFF  8C6,8FE
11D4A:  MOVFF  8C5,8FD
11D4E:  MOVFF  8C4,8FC
11D52:  MOVFF  8C3,8FB
11D56:  MOVFF  8CA,902
11D5A:  MOVFF  8C9,901
11D5E:  MOVFF  8C8,900
11D62:  MOVFF  8C7,8FF
11D66:  CALL   C920
11D6A:  MOVFF  03,8CE
11D6E:  MOVFF  02,8CD
11D72:  MOVFF  01,8CC
11D76:  MOVFF  00,8CB
....................       NH4_abs_array[1] = log10(ratio); 
11D7A:  MOVFF  8CE,8D2
11D7E:  MOVFF  8CD,8D1
11D82:  MOVFF  8CC,8D0
11D86:  MOVFF  8CB,8CF
11D8A:  CALL   10BBC
11D8E:  MOVFF  03,3DC
11D92:  MOVFF  02,3DB
11D96:  MOVFF  01,3DA
11D9A:  MOVFF  00,3D9
11D9E:  MOVLB  3
....................    } 
....................    if (NH4_array[4] > 0 && NH4_array[5] > 0) { 
11DA0:  MOVF   x89,F
11DA2:  BNZ   11DA8
11DA4:  MOVF   x8A,F
11DA6:  BZ    11E44
11DA8:  MOVF   x8B,F
11DAA:  BNZ   11DB0
11DAC:  MOVF   x8C,F
11DAE:  BZ    11E44
....................       blank = NH4_array[4]; 
11DB0:  MOVFF  38A,918
11DB4:  MOVFF  389,917
11DB8:  MOVLB  0
11DBA:  CALL   C8EA
11DBE:  MOVFF  03,8C6
11DC2:  MOVFF  02,8C5
11DC6:  MOVFF  01,8C4
11DCA:  MOVFF  00,8C3
....................       react = NH4_array[5]; 
11DCE:  MOVFF  38C,918
11DD2:  MOVFF  38B,917
11DD6:  CALL   C8EA
11DDA:  MOVFF  03,8CA
11DDE:  MOVFF  02,8C9
11DE2:  MOVFF  01,8C8
11DE6:  MOVFF  00,8C7
....................       ratio = blank / react; 
11DEA:  MOVFF  8C6,8FE
11DEE:  MOVFF  8C5,8FD
11DF2:  MOVFF  8C4,8FC
11DF6:  MOVFF  8C3,8FB
11DFA:  MOVFF  8CA,902
11DFE:  MOVFF  8C9,901
11E02:  MOVFF  8C8,900
11E06:  MOVFF  8C7,8FF
11E0A:  CALL   C920
11E0E:  MOVFF  03,8CE
11E12:  MOVFF  02,8CD
11E16:  MOVFF  01,8CC
11E1A:  MOVFF  00,8CB
....................       NH4_abs_array[2] = log10(ratio); 
11E1E:  MOVFF  8CE,8D2
11E22:  MOVFF  8CD,8D1
11E26:  MOVFF  8CC,8D0
11E2A:  MOVFF  8CB,8CF
11E2E:  CALL   10BBC
11E32:  MOVFF  03,3E0
11E36:  MOVFF  02,3DF
11E3A:  MOVFF  01,3DE
11E3E:  MOVFF  00,3DD
11E42:  MOVLB  3
....................    } 
....................    if (NH4_array[6] > 0 && NH4_array[7] > 0) { 
11E44:  MOVF   x8D,F
11E46:  BNZ   11E4C
11E48:  MOVF   x8E,F
11E4A:  BZ    11EE8
11E4C:  MOVF   x8F,F
11E4E:  BNZ   11E54
11E50:  MOVF   x90,F
11E52:  BZ    11EE8
....................       blank = NH4_array[6]; 
11E54:  MOVFF  38E,918
11E58:  MOVFF  38D,917
11E5C:  MOVLB  0
11E5E:  CALL   C8EA
11E62:  MOVFF  03,8C6
11E66:  MOVFF  02,8C5
11E6A:  MOVFF  01,8C4
11E6E:  MOVFF  00,8C3
....................       react = NH4_array[7]; 
11E72:  MOVFF  390,918
11E76:  MOVFF  38F,917
11E7A:  CALL   C8EA
11E7E:  MOVFF  03,8CA
11E82:  MOVFF  02,8C9
11E86:  MOVFF  01,8C8
11E8A:  MOVFF  00,8C7
....................       ratio = blank / react; 
11E8E:  MOVFF  8C6,8FE
11E92:  MOVFF  8C5,8FD
11E96:  MOVFF  8C4,8FC
11E9A:  MOVFF  8C3,8FB
11E9E:  MOVFF  8CA,902
11EA2:  MOVFF  8C9,901
11EA6:  MOVFF  8C8,900
11EAA:  MOVFF  8C7,8FF
11EAE:  CALL   C920
11EB2:  MOVFF  03,8CE
11EB6:  MOVFF  02,8CD
11EBA:  MOVFF  01,8CC
11EBE:  MOVFF  00,8CB
....................       NH4_abs_array[3] = log10(ratio); 
11EC2:  MOVFF  8CE,8D2
11EC6:  MOVFF  8CD,8D1
11ECA:  MOVFF  8CC,8D0
11ECE:  MOVFF  8CB,8CF
11ED2:  CALL   10BBC
11ED6:  MOVFF  03,3E4
11EDA:  MOVFF  02,3E3
11EDE:  MOVFF  01,3E2
11EE2:  MOVFF  00,3E1
11EE6:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    NH4_array[0],NH4_array[1],NH4_abs_array[0],NH4_array[2],NH4_array[3],NH4_abs_array[1],NH4_array[4],NH4_array[5],NH4_abs_array[2]); 
11EE8:  MOVLW  04
11EEA:  MOVWF  1E
11EEC:  MOVLW  25
11EEE:  MOVWF  1D
11EF0:  MOVLW  F6
11EF2:  MOVWF  FF6
11EF4:  MOVLW  1E
11EF6:  MOVWF  FF7
11EF8:  MOVLW  00
11EFA:  MOVWF  FF8
11EFC:  MOVLW  06
11EFE:  MOVLB  8
11F00:  MOVWF  xEB
11F02:  MOVLB  0
11F04:  CALL   AAC0
11F08:  MOVLW  10
11F0A:  MOVWF  FE9
11F0C:  MOVFF  382,8F7
11F10:  MOVFF  381,8F6
11F14:  CALL   AAF2
11F18:  MOVLW  FF
11F1A:  MOVWF  FF6
11F1C:  MOVLW  1E
11F1E:  MOVWF  FF7
11F20:  MOVLW  00
11F22:  MOVWF  FF8
11F24:  MOVLW  07
11F26:  MOVLB  8
11F28:  MOVWF  xEB
11F2A:  MOVLB  0
11F2C:  CALL   AAC0
11F30:  MOVLW  10
11F32:  MOVWF  FE9
11F34:  MOVFF  384,8F7
11F38:  MOVFF  383,8F6
11F3C:  CALL   AAF2
11F40:  MOVLW  09
11F42:  MOVWF  FF6
11F44:  MOVLW  1F
11F46:  MOVWF  FF7
11F48:  MOVLW  00
11F4A:  MOVWF  FF8
11F4C:  MOVLW  09
11F4E:  MOVLB  8
11F50:  MOVWF  xEB
11F52:  MOVLB  0
11F54:  CALL   AAC0
11F58:  MOVLW  89
11F5A:  MOVWF  FE9
11F5C:  MOVFF  3D8,8D2
11F60:  MOVFF  3D7,8D1
11F64:  MOVFF  3D6,8D0
11F68:  MOVFF  3D5,8CF
11F6C:  MOVLW  04
11F6E:  MOVLB  8
11F70:  MOVWF  xD3
11F72:  MOVLB  0
11F74:  CALL   10C28
11F78:  MOVLW  17
11F7A:  MOVWF  FF6
11F7C:  MOVLW  1F
11F7E:  MOVWF  FF7
11F80:  MOVLW  00
11F82:  MOVWF  FF8
11F84:  MOVLW  07
11F86:  MOVLB  8
11F88:  MOVWF  xEB
11F8A:  MOVLB  0
11F8C:  CALL   AAC0
11F90:  MOVLW  10
11F92:  MOVWF  FE9
11F94:  MOVFF  386,8F7
11F98:  MOVFF  385,8F6
11F9C:  CALL   AAF2
11FA0:  MOVLW  21
11FA2:  MOVWF  FF6
11FA4:  MOVLW  1F
11FA6:  MOVWF  FF7
11FA8:  MOVLW  00
11FAA:  MOVWF  FF8
11FAC:  MOVLW  07
11FAE:  MOVLB  8
11FB0:  MOVWF  xEB
11FB2:  MOVLB  0
11FB4:  CALL   AAC0
11FB8:  MOVLW  10
11FBA:  MOVWF  FE9
11FBC:  MOVFF  388,8F7
11FC0:  MOVFF  387,8F6
11FC4:  CALL   AAF2
11FC8:  MOVLW  2B
11FCA:  MOVWF  FF6
11FCC:  MOVLW  1F
11FCE:  MOVWF  FF7
11FD0:  MOVLW  00
11FD2:  MOVWF  FF8
11FD4:  MOVLW  09
11FD6:  MOVLB  8
11FD8:  MOVWF  xEB
11FDA:  MOVLB  0
11FDC:  CALL   AAC0
11FE0:  MOVLW  89
11FE2:  MOVWF  FE9
11FE4:  MOVFF  3DC,8D2
11FE8:  MOVFF  3DB,8D1
11FEC:  MOVFF  3DA,8D0
11FF0:  MOVFF  3D9,8CF
11FF4:  MOVLW  04
11FF6:  MOVLB  8
11FF8:  MOVWF  xD3
11FFA:  MOVLB  0
11FFC:  CALL   10C28
12000:  MOVLW  39
12002:  MOVWF  FF6
12004:  MOVLW  1F
12006:  MOVWF  FF7
12008:  MOVLW  00
1200A:  MOVWF  FF8
1200C:  MOVLW  07
1200E:  MOVLB  8
12010:  MOVWF  xEB
12012:  MOVLB  0
12014:  CALL   AAC0
12018:  MOVLW  10
1201A:  MOVWF  FE9
1201C:  MOVFF  38A,8F7
12020:  MOVFF  389,8F6
12024:  CALL   AAF2
12028:  MOVLW  43
1202A:  MOVWF  FF6
1202C:  MOVLW  1F
1202E:  MOVWF  FF7
12030:  MOVLW  00
12032:  MOVWF  FF8
12034:  MOVLW  07
12036:  MOVLB  8
12038:  MOVWF  xEB
1203A:  MOVLB  0
1203C:  CALL   AAC0
12040:  MOVLW  10
12042:  MOVWF  FE9
12044:  MOVFF  38C,8F7
12048:  MOVFF  38B,8F6
1204C:  CALL   AAF2
12050:  MOVLW  4D
12052:  MOVWF  FF6
12054:  MOVLW  1F
12056:  MOVWF  FF7
12058:  MOVLW  00
1205A:  MOVWF  FF8
1205C:  MOVLW  09
1205E:  MOVLB  8
12060:  MOVWF  xEB
12062:  MOVLB  0
12064:  CALL   AAC0
12068:  MOVLW  89
1206A:  MOVWF  FE9
1206C:  MOVFF  3E0,8D2
12070:  MOVFF  3DF,8D1
12074:  MOVFF  3DE,8D0
12078:  MOVFF  3DD,8CF
1207C:  MOVLW  04
1207E:  MOVLB  8
12080:  MOVWF  xD3
12082:  MOVLB  0
12084:  CALL   10C28
....................    if (nv_report_mode != 2) fprintf(COM_A, "@Abs,NH4,%s\r\n", abs_str);     
12088:  MOVF   1F,W
1208A:  SUBLW  02
1208C:  BNZ   12092
1208E:  MOVF   20,F
12090:  BZ    120D2
12092:  MOVLW  5C
12094:  MOVWF  FF6
12096:  MOVLW  1F
12098:  MOVWF  FF7
1209A:  MOVLW  00
1209C:  MOVWF  FF8
1209E:  CLRF   1B
120A0:  BTFSC  FF2.7
120A2:  BSF    1B.7
120A4:  BCF    FF2.7
120A6:  MOVLW  09
120A8:  MOVLB  A
120AA:  MOVWF  x40
120AC:  MOVLB  0
120AE:  CALL   1018
120B2:  BTFSC  1B.7
120B4:  BSF    FF2.7
120B6:  MOVLW  04
120B8:  MOVWF  FEA
120BA:  MOVLW  25
120BC:  MOVWF  FE9
120BE:  CALL   798A
120C2:  MOVLW  0D
120C4:  BTFSS  F9E.4
120C6:  BRA    120C4
120C8:  MOVWF  FAD
120CA:  MOVLW  0A
120CC:  BTFSS  F9E.4
120CE:  BRA    120CC
120D0:  MOVWF  FAD
120D2:  GOTO   125E2 (RETURN)
....................     
....................    // old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   NH4_abs_array[0],NH4_abs_array[1],NH4_abs_array[2],NH4_abs_array[3]); 
....................    // if (nv_report_mode != 2) fprintf(COM_A, "@ABS,NH4,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_SiO(){ 
....................  
....................    int i; 
....................    float blank, react, ratio; 
....................     
....................    // zero-out abs array 
....................    for(i=0; i<4; ++i) SiO_abs_array[i] = 0; 
120D6:  MOVLB  8
120D8:  CLRF   xC2
120DA:  MOVF   xC2,W
120DC:  SUBLW  03
120DE:  BNC   120FE
120E0:  MOVF   xC2,W
120E2:  MULLW  04
120E4:  MOVF   FF3,W
120E6:  CLRF   03
120E8:  ADDLW  E5
120EA:  MOVWF  FE9
120EC:  MOVLW  03
120EE:  ADDWFC 03,W
120F0:  MOVWF  FEA
120F2:  CLRF   FEF
120F4:  CLRF   FEC
120F6:  CLRF   FEC
120F8:  CLRF   FEC
120FA:  INCF   xC2,F
120FC:  BRA    120DA
....................     
....................    // Br,Rr,Bs,Rs,Bt,Rt,Bu,Ru 
....................    if (SiO_array[0] > 0 && SiO_array[1] > 0) { 
120FE:  MOVLB  3
12100:  MOVF   x93,F
12102:  BTFSS  FD8.2
12104:  BRA    1210A
12106:  MOVF   x94,F
12108:  BZ    121A6
1210A:  MOVF   x95,F
1210C:  BNZ   12112
1210E:  MOVF   x96,F
12110:  BZ    121A6
....................       blank = SiO_array[0]; 
12112:  MOVFF  394,918
12116:  MOVFF  393,917
1211A:  MOVLB  0
1211C:  CALL   C8EA
12120:  MOVFF  03,8C6
12124:  MOVFF  02,8C5
12128:  MOVFF  01,8C4
1212C:  MOVFF  00,8C3
....................       react = SiO_array[1]; 
12130:  MOVFF  396,918
12134:  MOVFF  395,917
12138:  CALL   C8EA
1213C:  MOVFF  03,8CA
12140:  MOVFF  02,8C9
12144:  MOVFF  01,8C8
12148:  MOVFF  00,8C7
....................       ratio = blank / react; 
1214C:  MOVFF  8C6,8FE
12150:  MOVFF  8C5,8FD
12154:  MOVFF  8C4,8FC
12158:  MOVFF  8C3,8FB
1215C:  MOVFF  8CA,902
12160:  MOVFF  8C9,901
12164:  MOVFF  8C8,900
12168:  MOVFF  8C7,8FF
1216C:  CALL   C920
12170:  MOVFF  03,8CE
12174:  MOVFF  02,8CD
12178:  MOVFF  01,8CC
1217C:  MOVFF  00,8CB
....................       SiO_abs_array[0] = log10(ratio); 
12180:  MOVFF  8CE,8D2
12184:  MOVFF  8CD,8D1
12188:  MOVFF  8CC,8D0
1218C:  MOVFF  8CB,8CF
12190:  CALL   10BBC
12194:  MOVFF  03,3E8
12198:  MOVFF  02,3E7
1219C:  MOVFF  01,3E6
121A0:  MOVFF  00,3E5
121A4:  MOVLB  3
....................    } 
....................    if (SiO_array[2] > 0 && SiO_array[3] > 0) { 
121A6:  MOVF   x97,F
121A8:  BNZ   121AE
121AA:  MOVF   x98,F
121AC:  BZ    1224A
121AE:  MOVF   x99,F
121B0:  BNZ   121B6
121B2:  MOVF   x9A,F
121B4:  BZ    1224A
....................       blank = SiO_array[2]; 
121B6:  MOVFF  398,918
121BA:  MOVFF  397,917
121BE:  MOVLB  0
121C0:  CALL   C8EA
121C4:  MOVFF  03,8C6
121C8:  MOVFF  02,8C5
121CC:  MOVFF  01,8C4
121D0:  MOVFF  00,8C3
....................       react = SiO_array[3]; 
121D4:  MOVFF  39A,918
121D8:  MOVFF  399,917
121DC:  CALL   C8EA
121E0:  MOVFF  03,8CA
121E4:  MOVFF  02,8C9
121E8:  MOVFF  01,8C8
121EC:  MOVFF  00,8C7
....................       ratio = blank / react;    
121F0:  MOVFF  8C6,8FE
121F4:  MOVFF  8C5,8FD
121F8:  MOVFF  8C4,8FC
121FC:  MOVFF  8C3,8FB
12200:  MOVFF  8CA,902
12204:  MOVFF  8C9,901
12208:  MOVFF  8C8,900
1220C:  MOVFF  8C7,8FF
12210:  CALL   C920
12214:  MOVFF  03,8CE
12218:  MOVFF  02,8CD
1221C:  MOVFF  01,8CC
12220:  MOVFF  00,8CB
....................       SiO_abs_array[1] = log10(ratio); 
12224:  MOVFF  8CE,8D2
12228:  MOVFF  8CD,8D1
1222C:  MOVFF  8CC,8D0
12230:  MOVFF  8CB,8CF
12234:  CALL   10BBC
12238:  MOVFF  03,3EC
1223C:  MOVFF  02,3EB
12240:  MOVFF  01,3EA
12244:  MOVFF  00,3E9
12248:  MOVLB  3
....................    } 
....................    if (SiO_array[4] > 0 && SiO_array[5] > 0) { 
1224A:  MOVF   x9B,F
1224C:  BNZ   12252
1224E:  MOVF   x9C,F
12250:  BZ    122EE
12252:  MOVF   x9D,F
12254:  BNZ   1225A
12256:  MOVF   x9E,F
12258:  BZ    122EE
....................       blank = SiO_array[4]; 
1225A:  MOVFF  39C,918
1225E:  MOVFF  39B,917
12262:  MOVLB  0
12264:  CALL   C8EA
12268:  MOVFF  03,8C6
1226C:  MOVFF  02,8C5
12270:  MOVFF  01,8C4
12274:  MOVFF  00,8C3
....................       react = SiO_array[5]; 
12278:  MOVFF  39E,918
1227C:  MOVFF  39D,917
12280:  CALL   C8EA
12284:  MOVFF  03,8CA
12288:  MOVFF  02,8C9
1228C:  MOVFF  01,8C8
12290:  MOVFF  00,8C7
....................       ratio = blank / react; 
12294:  MOVFF  8C6,8FE
12298:  MOVFF  8C5,8FD
1229C:  MOVFF  8C4,8FC
122A0:  MOVFF  8C3,8FB
122A4:  MOVFF  8CA,902
122A8:  MOVFF  8C9,901
122AC:  MOVFF  8C8,900
122B0:  MOVFF  8C7,8FF
122B4:  CALL   C920
122B8:  MOVFF  03,8CE
122BC:  MOVFF  02,8CD
122C0:  MOVFF  01,8CC
122C4:  MOVFF  00,8CB
....................       SiO_abs_array[2] = log10(ratio); 
122C8:  MOVFF  8CE,8D2
122CC:  MOVFF  8CD,8D1
122D0:  MOVFF  8CC,8D0
122D4:  MOVFF  8CB,8CF
122D8:  CALL   10BBC
122DC:  MOVFF  03,3F0
122E0:  MOVFF  02,3EF
122E4:  MOVFF  01,3EE
122E8:  MOVFF  00,3ED
122EC:  MOVLB  3
....................    } 
....................    if (SiO_array[6] > 0 && SiO_array[7] > 0) { 
122EE:  MOVF   x9F,F
122F0:  BNZ   122F6
122F2:  MOVF   xA0,F
122F4:  BZ    12392
122F6:  MOVF   xA1,F
122F8:  BNZ   122FE
122FA:  MOVF   xA2,F
122FC:  BZ    12392
....................       blank = SiO_array[6]; 
122FE:  MOVFF  3A0,918
12302:  MOVFF  39F,917
12306:  MOVLB  0
12308:  CALL   C8EA
1230C:  MOVFF  03,8C6
12310:  MOVFF  02,8C5
12314:  MOVFF  01,8C4
12318:  MOVFF  00,8C3
....................       react = SiO_array[7]; 
1231C:  MOVFF  3A2,918
12320:  MOVFF  3A1,917
12324:  CALL   C8EA
12328:  MOVFF  03,8CA
1232C:  MOVFF  02,8C9
12330:  MOVFF  01,8C8
12334:  MOVFF  00,8C7
....................       ratio = blank / react; 
12338:  MOVFF  8C6,8FE
1233C:  MOVFF  8C5,8FD
12340:  MOVFF  8C4,8FC
12344:  MOVFF  8C3,8FB
12348:  MOVFF  8CA,902
1234C:  MOVFF  8C9,901
12350:  MOVFF  8C8,900
12354:  MOVFF  8C7,8FF
12358:  CALL   C920
1235C:  MOVFF  03,8CE
12360:  MOVFF  02,8CD
12364:  MOVFF  01,8CC
12368:  MOVFF  00,8CB
....................       SiO_abs_array[3] = log10(ratio); 
1236C:  MOVFF  8CE,8D2
12370:  MOVFF  8CD,8D1
12374:  MOVFF  8CC,8D0
12378:  MOVFF  8CB,8CF
1237C:  CALL   10BBC
12380:  MOVFF  03,3F4
12384:  MOVFF  02,3F3
12388:  MOVFF  01,3F2
1238C:  MOVFF  00,3F1
12390:  MOVLB  3
....................    } 
....................   
....................    // abs array = As[0,1],At[2,3],Ar[4,5],Au[6,7] 
....................    // removed  ,(Ar),%1.4g,(Au),%1.4g     NO3_abs_array[2],NO3_abs_array[3] VK 9/28/15 
....................    sprintf(abs_str, "(I0s),%Lu,(I1s),%Lu,(Abs-s),%1.4g,(I0t),%Lu,(I1t),%Lu,(Abs-t),%1.4g,(I0r),%Lu,(I1r),%Lu,(Abs-r),%1.4g", 
....................    SiO_array[0],SiO_array[1],SiO_abs_array[0],SiO_array[2],SiO_array[3],SiO_abs_array[1],SiO_array[4],SiO_array[5],SiO_abs_array[2]); 
12392:  MOVLW  04
12394:  MOVWF  1E
12396:  MOVLW  25
12398:  MOVWF  1D
1239A:  MOVLW  6A
1239C:  MOVWF  FF6
1239E:  MOVLW  1F
123A0:  MOVWF  FF7
123A2:  MOVLW  00
123A4:  MOVWF  FF8
123A6:  MOVLW  06
123A8:  MOVLB  8
123AA:  MOVWF  xEB
123AC:  MOVLB  0
123AE:  CALL   AAC0
123B2:  MOVLW  10
123B4:  MOVWF  FE9
123B6:  MOVFF  394,8F7
123BA:  MOVFF  393,8F6
123BE:  CALL   AAF2
123C2:  MOVLW  73
123C4:  MOVWF  FF6
123C6:  MOVLW  1F
123C8:  MOVWF  FF7
123CA:  MOVLW  00
123CC:  MOVWF  FF8
123CE:  MOVLW  07
123D0:  MOVLB  8
123D2:  MOVWF  xEB
123D4:  MOVLB  0
123D6:  CALL   AAC0
123DA:  MOVLW  10
123DC:  MOVWF  FE9
123DE:  MOVFF  396,8F7
123E2:  MOVFF  395,8F6
123E6:  CALL   AAF2
123EA:  MOVLW  7D
123EC:  MOVWF  FF6
123EE:  MOVLW  1F
123F0:  MOVWF  FF7
123F2:  MOVLW  00
123F4:  MOVWF  FF8
123F6:  MOVLW  09
123F8:  MOVLB  8
123FA:  MOVWF  xEB
123FC:  MOVLB  0
123FE:  CALL   AAC0
12402:  MOVLW  89
12404:  MOVWF  FE9
12406:  MOVFF  3E8,8D2
1240A:  MOVFF  3E7,8D1
1240E:  MOVFF  3E6,8D0
12412:  MOVFF  3E5,8CF
12416:  MOVLW  04
12418:  MOVLB  8
1241A:  MOVWF  xD3
1241C:  MOVLB  0
1241E:  CALL   10C28
12422:  MOVLW  8B
12424:  MOVWF  FF6
12426:  MOVLW  1F
12428:  MOVWF  FF7
1242A:  MOVLW  00
1242C:  MOVWF  FF8
1242E:  MOVLW  07
12430:  MOVLB  8
12432:  MOVWF  xEB
12434:  MOVLB  0
12436:  CALL   AAC0
1243A:  MOVLW  10
1243C:  MOVWF  FE9
1243E:  MOVFF  398,8F7
12442:  MOVFF  397,8F6
12446:  CALL   AAF2
1244A:  MOVLW  95
1244C:  MOVWF  FF6
1244E:  MOVLW  1F
12450:  MOVWF  FF7
12452:  MOVLW  00
12454:  MOVWF  FF8
12456:  MOVLW  07
12458:  MOVLB  8
1245A:  MOVWF  xEB
1245C:  MOVLB  0
1245E:  CALL   AAC0
12462:  MOVLW  10
12464:  MOVWF  FE9
12466:  MOVFF  39A,8F7
1246A:  MOVFF  399,8F6
1246E:  CALL   AAF2
12472:  MOVLW  9F
12474:  MOVWF  FF6
12476:  MOVLW  1F
12478:  MOVWF  FF7
1247A:  MOVLW  00
1247C:  MOVWF  FF8
1247E:  MOVLW  09
12480:  MOVLB  8
12482:  MOVWF  xEB
12484:  MOVLB  0
12486:  CALL   AAC0
1248A:  MOVLW  89
1248C:  MOVWF  FE9
1248E:  MOVFF  3EC,8D2
12492:  MOVFF  3EB,8D1
12496:  MOVFF  3EA,8D0
1249A:  MOVFF  3E9,8CF
1249E:  MOVLW  04
124A0:  MOVLB  8
124A2:  MOVWF  xD3
124A4:  MOVLB  0
124A6:  CALL   10C28
124AA:  MOVLW  AD
124AC:  MOVWF  FF6
124AE:  MOVLW  1F
124B0:  MOVWF  FF7
124B2:  MOVLW  00
124B4:  MOVWF  FF8
124B6:  MOVLW  07
124B8:  MOVLB  8
124BA:  MOVWF  xEB
124BC:  MOVLB  0
124BE:  CALL   AAC0
124C2:  MOVLW  10
124C4:  MOVWF  FE9
124C6:  MOVFF  39C,8F7
124CA:  MOVFF  39B,8F6
124CE:  CALL   AAF2
124D2:  MOVLW  B7
124D4:  MOVWF  FF6
124D6:  MOVLW  1F
124D8:  MOVWF  FF7
124DA:  MOVLW  00
124DC:  MOVWF  FF8
124DE:  MOVLW  07
124E0:  MOVLB  8
124E2:  MOVWF  xEB
124E4:  MOVLB  0
124E6:  CALL   AAC0
124EA:  MOVLW  10
124EC:  MOVWF  FE9
124EE:  MOVFF  39E,8F7
124F2:  MOVFF  39D,8F6
124F6:  CALL   AAF2
124FA:  MOVLW  C1
124FC:  MOVWF  FF6
124FE:  MOVLW  1F
12500:  MOVWF  FF7
12502:  MOVLW  00
12504:  MOVWF  FF8
12506:  MOVLW  09
12508:  MOVLB  8
1250A:  MOVWF  xEB
1250C:  MOVLB  0
1250E:  CALL   AAC0
12512:  MOVLW  89
12514:  MOVWF  FE9
12516:  MOVFF  3F0,8D2
1251A:  MOVFF  3EF,8D1
1251E:  MOVFF  3EE,8D0
12522:  MOVFF  3ED,8CF
12526:  MOVLW  04
12528:  MOVLB  8
1252A:  MOVWF  xD3
1252C:  MOVLB  0
1252E:  CALL   10C28
....................    if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str); 
12532:  MOVF   1F,W
12534:  SUBLW  02
12536:  BNZ   1253C
12538:  MOVF   20,F
1253A:  BZ    1257C
1253C:  MOVLW  D0
1253E:  MOVWF  FF6
12540:  MOVLW  1F
12542:  MOVWF  FF7
12544:  MOVLW  00
12546:  MOVWF  FF8
12548:  CLRF   1B
1254A:  BTFSC  FF2.7
1254C:  BSF    1B.7
1254E:  BCF    FF2.7
12550:  MOVLW  09
12552:  MOVLB  A
12554:  MOVWF  x40
12556:  MOVLB  0
12558:  CALL   1018
1255C:  BTFSC  1B.7
1255E:  BSF    FF2.7
12560:  MOVLW  04
12562:  MOVWF  FEA
12564:  MOVLW  25
12566:  MOVWF  FE9
12568:  CALL   798A
1256C:  MOVLW  0D
1256E:  BTFSS  F9E.4
12570:  BRA    1256E
12572:  MOVWF  FAD
12574:  MOVLW  0A
12576:  BTFSS  F9E.4
12578:  BRA    12576
1257A:  MOVWF  FAD
1257C:  GOTO   125E2 (RETURN)
....................     
....................    // Old code replaced 10/2015 VK 
....................    //sprintf(abs_str, "(As),%1.4g,(At),%1.4g,(Ar),%1.4g,(Au),%1.4g", 
....................    //   SiO_abs_array[0],SiO_abs_array[1],SiO_abs_array[2],SiO_abs_array[3]); 
....................    //if (nv_report_mode != 2) fprintf(COM_A, "@ABS,SiO,%s\r\n", abs_str);             
.................... } 
....................  
.................... void calc_abs_data(){ 
....................     
....................    strcopy(abs_str,",,,,,,,"); 
12580:  MOVLW  04
12582:  MOVWF  FEA
12584:  MOVLW  25
12586:  MOVWF  FE9
12588:  MOVLW  00
1258A:  CALL   056C
1258E:  TBLRD*-
12590:  TBLRD*+
12592:  MOVF   FF5,W
12594:  MOVWF  FEE
12596:  IORLW  00
12598:  BNZ   12590
....................     
....................    switch (chem){ 
1259A:  MOVLW  DE
1259C:  MOVWF  FF6
1259E:  MOVLW  1F
125A0:  MOVWF  FF7
125A2:  MOVLW  00
125A4:  MOVWF  FF8
125A6:  MOVLW  03
125A8:  MOVWF  FEA
125AA:  MOVLW  3D
125AC:  MOVWF  FE9
125AE:  CALL   FE56
125B2:  MOVF   01,W
125B4:  BZ    125C8
125B6:  XORLW  01
125B8:  BZ    125CE
125BA:  XORLW  03
125BC:  BZ    125D4
125BE:  XORLW  01
125C0:  BZ    125DA
125C2:  XORLW  07
125C4:  BZ    125E0
125C6:  BRA    125E2
....................       case "NO3" : calc_abs_NO3(); 
125C8:  GOTO   10E3E
....................          break; 
125CC:  BRA    125E2
....................       case "NO2" : calc_abs_NO2 (); 
125CE:  GOTO   112DA
....................          break;    
125D2:  BRA    125E2
....................       case "PO4" : calc_abs_PO4(); 
125D4:  GOTO   11782
....................          break; 
125D8:  BRA    125E2
....................       case "NH4" : calc_abs_NH4(); 
125DA:  GOTO   11C2C
....................          break; 
125DE:  BRA    125E2
....................       case "SiO" : calc_abs_SiO(); 
125E0:  BRA    120D6
....................          break; 
....................    } 
125E2:  RETURN 0
....................     
.................... } 
....................  
.................... void calc_NO3_real_data(){ 
....................     
....................    NO3_smp_conc = 0; 
....................     
....................    // apply current coeffs ... 
....................    if (NO3_abs_array[0] > 0) { 
....................       NO3_smp_conc = (NO3_slope * NO3_abs_array[0]) + NO3_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NO3_slope,NO3_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NO3_smp_conc); 
....................    fprintf(COM_A, "@CON,NO3,%s\r\n", real_str);   
.................... } 
....................  
....................  
.................... void calc_PO4_real_data(){ 
....................  
....................    PO4_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (PO4_abs_array[0] > 0) { 
....................       PO4_smp_conc = (PO4_slope * PO4_abs_array[0]) + PO4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", PO4_slope,PO4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", PO4_smp_conc); 
....................    fprintf(COM_A, "@CON,PO4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_NH4_real_data(){ 
....................  
....................    NH4_smp_conc =0; 
....................     
....................    // apply current coeffs ... 
....................    if (NH4_abs_array[0] > 0) { 
....................       NH4_smp_conc = (NH4_slope * NH4_abs_array[0]) + NH4_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", NH4_slope,NH4_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", NH4_smp_conc); 
....................    fprintf(COM_A, "@CON,NH4,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_SiO_real_data(){ 
....................  
....................    SiO_smp_conc = 0; 
....................  
....................    // apply current coeffs ... 
....................    if (SiO_abs_array[0] > 0) { 
....................       SiO_smp_conc = (SiO_slope * SiO_abs_array[0]) + SiO_inter; 
....................    } 
....................    sprintf(coeff_str, "(m),%3.3g,(c),%3.3g", SiO_slope,SiO_inter); 
....................    sprintf(real_str, "(Cs),%3.3g\r\n", SiO_smp_conc); 
....................    fprintf(COM_A, "@CON,SiO,%s\r\n", real_str);  
.................... } 
....................  
.................... void calc_real_data(){ 
....................     
....................    strcopy(real_str,",,,\r\n"); 
....................     
....................    switch (chem){ 
....................       case "NO3" : calc_NO3_real_data(); 
....................          break; 
....................       case "PO4" : calc_PO4_real_data(); 
....................          break; 
....................       case "NH4" : calc_NH4_real_data(); 
....................          break; 
....................       case "SiO" : calc_SiO_real_data(); 
....................          break; 
....................    } 
.................... } 
....................  
.................... //  Changes made by VK on 9-10/2015 to remove calculated data and add raw transmissions 
.................... // writes the processed abs data with tramsmission data to a file on the SD card 
.................... // data_buffer is cleared, string to be stored is compiled into "data_buffer" 
.................... // data are concatenated & append_data writes "data_buffer" to the 
.................... // "all" and "new" files 
....................  
.................... void store_rel_data() 
.................... { 
....................    clear_data_buffer(); 
125E4:  CALL   D51C
....................     
....................    if (data_available == TRUE) { 
125E8:  MOVLB  3
125EA:  DECFSZ x3B,W
125EC:  BRA    126F0
....................     
....................       strcat(data_buffer, proc_time_stmp_str); 
125EE:  MOVLB  8
125F0:  CLRF   xF9
125F2:  MOVLW  67
125F4:  MOVWF  xF8
125F6:  MOVLW  02
125F8:  MOVWF  xFB
125FA:  MOVLW  B7
125FC:  MOVWF  xFA
125FE:  MOVLB  0
12600:  CALL   54D2
....................       strcat(data_buffer, comma); 
12604:  MOVLB  8
12606:  CLRF   xF9
12608:  MOVLW  67
1260A:  MOVWF  xF8
1260C:  MOVLW  03
1260E:  MOVWF  xFB
12610:  MOVLW  39
12612:  MOVWF  xFA
12614:  MOVLB  0
12616:  CALL   54D2
....................       strcat(data_buffer, chem); 
1261A:  MOVLB  8
1261C:  CLRF   xF9
1261E:  MOVLW  67
12620:  MOVWF  xF8
12622:  MOVLW  03
12624:  MOVWF  xFB
12626:  MOVLW  3D
12628:  MOVWF  xFA
1262A:  MOVLB  0
1262C:  CALL   54D2
....................       strcat(data_buffer, comma); 
12630:  MOVLB  8
12632:  CLRF   xF9
12634:  MOVLW  67
12636:  MOVWF  xF8
12638:  MOVLW  03
1263A:  MOVWF  xFB
1263C:  MOVLW  39
1263E:  MOVWF  xFA
12640:  MOVLB  0
12642:  CALL   54D2
....................       strcat(data_buffer, abs_str); 
12646:  MOVLB  8
12648:  CLRF   xF9
1264A:  MOVLW  67
1264C:  MOVWF  xF8
1264E:  MOVLW  04
12650:  MOVWF  xFB
12652:  MOVLW  25
12654:  MOVWF  xFA
12656:  MOVLB  0
12658:  CALL   54D2
....................       strcat(data_buffer, endofline); 
1265C:  MOVLB  8
1265E:  CLRF   xF9
12660:  MOVLW  67
12662:  MOVWF  xF8
12664:  MOVLW  07
12666:  MOVWF  xFB
12668:  MOVLW  CE
1266A:  MOVWF  xFA
1266C:  MOVLB  0
1266E:  CALL   54D2
....................      // strcat(data_buffer, coeff_str); 
....................      // strcat(data_buffer, comma); 
....................      // strcat(data_buffer, real_str); 
....................        
....................       if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
12672:  MOVF   1F,W
12674:  SUBLW  04
12676:  BNZ   12696
12678:  MOVF   20,F
1267A:  BNZ   12696
1267C:  CLRF   FEA
1267E:  MOVLW  67
12680:  MOVWF  FE9
12682:  CALL   798A
12686:  MOVLW  0D
12688:  BTFSS  F9E.4
1268A:  BRA    12688
1268C:  MOVWF  FAD
1268E:  MOVLW  0A
12690:  BTFSS  F9E.4
12692:  BRA    12690
12694:  MOVWF  FAD
....................     
....................       if(sd_status==0){ 
12696:  MOVLB  2
12698:  MOVF   xDC,F
1269A:  BNZ   126EE
....................        
....................          buffer_select = 0; 
1269C:  MOVLB  0
1269E:  CLRF   x66
....................           
....................          heartbeat(FALSE); 
126A0:  MOVLB  8
126A2:  CLRF   xED
126A4:  MOVLB  0
126A6:  CALL   557A
....................             append_data(file_ptr_rel_all); 
126AA:  MOVLW  02
126AC:  MOVLB  8
126AE:  MOVWF  xEE
126B0:  MOVLW  F9
126B2:  MOVWF  xED
126B4:  MOVLB  0
126B6:  CALL   82EC
....................          heartbeat(TRUE);          
126BA:  MOVLW  01
126BC:  MOVLB  8
126BE:  MOVWF  xED
126C0:  MOVLB  0
126C2:  CALL   557A
....................           
....................          heartbeat(FALSE); 
126C6:  MOVLB  8
126C8:  CLRF   xED
126CA:  MOVLB  0
126CC:  CALL   557A
....................             append_data(file_ptr_rel_new);    
126D0:  MOVLW  03
126D2:  MOVLB  8
126D4:  MOVWF  xEE
126D6:  MOVLW  07
126D8:  MOVWF  xED
126DA:  MOVLB  0
126DC:  CALL   82EC
....................          heartbeat(TRUE); 
126E0:  MOVLW  01
126E2:  MOVLB  8
126E4:  MOVWF  xED
126E6:  MOVLB  0
126E8:  CALL   557A
126EC:  MOVLB  2
126EE:  MOVLB  3
....................       } 
....................    } 
126F0:  MOVLB  0
126F2:  RETURN 0
.................... } 
....................  
.................... void calculate_data(){ 
....................    //calc_abs_data(); // out by Fraser Hood on 7/6/15 
....................    //calc_coeffs(); 
....................    //calc_real_data(); //Commented out by Fraser Hood on 7/6/15 
....................    store_rel_data(); 
.................... } 
....................  
.................... void store_wms_data(int8 macro) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
0D632:  MOVLW  2C
0D634:  MOVLB  8
0D636:  MOVWF  x9E
0D638:  CLRF   x9F
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
0D63A:  MOVLW  0D
0D63C:  MOVWF  xA0
0D63E:  MOVLW  0A
0D640:  MOVWF  xA1
0D642:  CLRF   xA2
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
0D644:  MOVLB  0
0D646:  RCALL  D51C
....................    time_stamp(); 
0D648:  CALL   540E
....................    strcat(data_buffer, time_stmp_str); 
0D64C:  MOVLB  8
0D64E:  CLRF   xF9
0D650:  MOVLW  67
0D652:  MOVWF  xF8
0D654:  MOVLW  02
0D656:  MOVWF  xFB
0D658:  MOVLW  99
0D65A:  MOVWF  xFA
0D65C:  MOVLB  0
0D65E:  CALL   54D2
....................    strcat(data_buffer, comma); 
0D662:  MOVLB  8
0D664:  CLRF   xF9
0D666:  MOVLW  67
0D668:  MOVWF  xF8
0D66A:  MOVLW  08
0D66C:  MOVWF  xFB
0D66E:  MOVLW  9E
0D670:  MOVWF  xFA
0D672:  MOVLB  0
0D674:  CALL   54D2
....................    sprintf(config_str, "%u,%Lu,%Lu,%Lu,%Lu,%Lu,%Lu,%Ld", 
....................          macro,nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample, 
....................          e_target_port[0],m_lin_pos[1]);  // changed from e_port[0] 
0D678:  MOVLW  08
0D67A:  MOVWF  1E
0D67C:  MOVLW  A3
0D67E:  MOVWF  1D
0D680:  MOVFF  89D,8ED
0D684:  MOVLW  1B
0D686:  MOVLB  8
0D688:  MOVWF  xEE
0D68A:  MOVLB  0
0D68C:  CALL   5274
0D690:  MOVLW  2C
0D692:  MOVLB  8
0D694:  MOVWF  xFF
0D696:  MOVLB  0
0D698:  CALL   5092
0D69C:  MOVLW  10
0D69E:  MOVWF  FE9
0D6A0:  MOVFF  2A,8F7
0D6A4:  MOVFF  29,8F6
0D6A8:  CALL   AAF2
0D6AC:  MOVLW  2C
0D6AE:  MOVLB  8
0D6B0:  MOVWF  xFF
0D6B2:  MOVLB  0
0D6B4:  CALL   5092
0D6B8:  MOVLW  10
0D6BA:  MOVWF  FE9
0D6BC:  MOVFF  24,8F7
0D6C0:  MOVFF  23,8F6
0D6C4:  CALL   AAF2
0D6C8:  MOVLW  2C
0D6CA:  MOVLB  8
0D6CC:  MOVWF  xFF
0D6CE:  MOVLB  0
0D6D0:  CALL   5092
0D6D4:  MOVLW  10
0D6D6:  MOVWF  FE9
0D6D8:  MOVFF  2C,8F7
0D6DC:  MOVFF  2B,8F6
0D6E0:  CALL   AAF2
0D6E4:  MOVLW  2C
0D6E6:  MOVLB  8
0D6E8:  MOVWF  xFF
0D6EA:  MOVLB  0
0D6EC:  CALL   5092
0D6F0:  MOVLW  10
0D6F2:  MOVWF  FE9
0D6F4:  MOVFF  2E,8F7
0D6F8:  MOVFF  2D,8F6
0D6FC:  CALL   AAF2
0D700:  MOVLW  2C
0D702:  MOVLB  8
0D704:  MOVWF  xFF
0D706:  MOVLB  0
0D708:  CALL   5092
0D70C:  MOVLW  10
0D70E:  MOVWF  FE9
0D710:  MOVFF  22,8F7
0D714:  MOVFF  21,8F6
0D718:  CALL   AAF2
0D71C:  MOVLW  2C
0D71E:  MOVLB  8
0D720:  MOVWF  xFF
0D722:  MOVLB  0
0D724:  CALL   5092
0D728:  MOVLW  10
0D72A:  MOVWF  FE9
0D72C:  MOVFF  7C8,8F7
0D730:  MOVFF  7C7,8F6
0D734:  CALL   AAF2
0D738:  MOVLW  2C
0D73A:  MOVLB  8
0D73C:  MOVWF  xFF
0D73E:  MOVLB  0
0D740:  CALL   5092
0D744:  MOVLW  10
0D746:  MOVWF  FE9
0D748:  MOVFF  7B6,8C2
0D74C:  MOVFF  7B5,8C1
0D750:  BRA    D530
....................    strcat(data_buffer, config_str); 
0D752:  MOVLB  8
0D754:  CLRF   xF9
0D756:  MOVLW  67
0D758:  MOVWF  xF8
0D75A:  MOVLW  08
0D75C:  MOVWF  xFB
0D75E:  MOVLW  A3
0D760:  MOVWF  xFA
0D762:  MOVLB  0
0D764:  CALL   54D2
....................    strcat(data_buffer, endofline); 
0D768:  MOVLB  8
0D76A:  CLRF   xF9
0D76C:  MOVLW  67
0D76E:  MOVWF  xF8
0D770:  MOVLW  08
0D772:  MOVWF  xFB
0D774:  MOVLW  A0
0D776:  MOVWF  xFA
0D778:  MOVLB  0
0D77A:  CALL   54D2
....................     
....................    fprintf(COM_A, "%s\r\n", data_buffer); 
0D77E:  CLRF   FEA
0D780:  MOVLW  67
0D782:  MOVWF  FE9
0D784:  CALL   798A
0D788:  MOVLW  0D
0D78A:  BTFSS  F9E.4
0D78C:  BRA    D78A
0D78E:  MOVWF  FAD
0D790:  MOVLW  0A
0D792:  BTFSS  F9E.4
0D794:  BRA    D792
0D796:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
0D798:  MOVLB  2
0D79A:  MOVF   xDC,F
0D79C:  BNZ   D7F0
....................     
....................       buffer_select = 0; 
0D79E:  MOVLB  0
0D7A0:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
0D7A2:  MOVLB  8
0D7A4:  CLRF   xED
0D7A6:  MOVLB  0
0D7A8:  CALL   557A
....................          append_data(file_ptr_raw_all); 
0D7AC:  MOVLW  02
0D7AE:  MOVLB  8
0D7B0:  MOVWF  xEE
0D7B2:  MOVLW  DD
0D7B4:  MOVWF  xED
0D7B6:  MOVLB  0
0D7B8:  CALL   82EC
....................       heartbeat(TRUE);          
0D7BC:  MOVLW  01
0D7BE:  MOVLB  8
0D7C0:  MOVWF  xED
0D7C2:  MOVLB  0
0D7C4:  CALL   557A
....................        
....................       heartbeat(FALSE); 
0D7C8:  MOVLB  8
0D7CA:  CLRF   xED
0D7CC:  MOVLB  0
0D7CE:  CALL   557A
....................          append_data(file_ptr_raw_new);    
0D7D2:  MOVLW  02
0D7D4:  MOVLB  8
0D7D6:  MOVWF  xEE
0D7D8:  MOVLW  EB
0D7DA:  MOVWF  xED
0D7DC:  MOVLB  0
0D7DE:  CALL   82EC
....................       heartbeat(TRUE); 
0D7E2:  MOVLW  01
0D7E4:  MOVLB  8
0D7E6:  MOVWF  xED
0D7E8:  MOVLB  0
0D7EA:  CALL   557A
0D7EE:  MOVLB  2
....................    } 
0D7F0:  MOVLB  0
0D7F2:  RETURN 0
.................... } 
....................  
.................... void store_aws_data(int8 macro, int16 mmacro_var) 
.................... { 
....................    char comma[2] = {',' , '\0'}; 
*
1527E:  MOVLW  2C
15280:  MOVLB  8
15282:  MOVWF  xA0
15284:  CLRF   xA1
....................    char endofline[3] = {'\r' , '\n' , '\0'}; 
15286:  MOVLW  0D
15288:  MOVWF  xA2
1528A:  MOVLW  0A
1528C:  MOVWF  xA3
1528E:  CLRF   xA4
....................    char config_str[30]; 
....................     
....................    clear_data_buffer(); 
15290:  MOVLB  0
15292:  CALL   D51C
....................    time_stamp(); 
15296:  CALL   540E
....................    strcat(data_buffer, time_stmp_str); 
1529A:  MOVLB  8
1529C:  CLRF   xF9
1529E:  MOVLW  67
152A0:  MOVWF  xF8
152A2:  MOVLW  02
152A4:  MOVWF  xFB
152A6:  MOVLW  99
152A8:  MOVWF  xFA
152AA:  MOVLB  0
152AC:  CALL   54D2
....................    strcat(data_buffer, comma); 
152B0:  MOVLB  8
152B2:  CLRF   xF9
152B4:  MOVLW  67
152B6:  MOVWF  xF8
152B8:  MOVLW  08
152BA:  MOVWF  xFB
152BC:  MOVLW  A0
152BE:  MOVWF  xFA
152C0:  MOVLB  0
152C2:  CALL   54D2
....................    sprintf(config_str, "%u,%Lu",macro,mmacro_var); 
152C6:  MOVLW  08
152C8:  MOVWF  1E
152CA:  MOVLW  A5
152CC:  MOVWF  1D
152CE:  MOVFF  89D,8ED
152D2:  MOVLW  1B
152D4:  MOVLB  8
152D6:  MOVWF  xEE
152D8:  MOVLB  0
152DA:  CALL   5274
152DE:  MOVLW  2C
152E0:  MOVLB  8
152E2:  MOVWF  xFF
152E4:  MOVLB  0
152E6:  CALL   5092
152EA:  MOVLW  10
152EC:  MOVWF  FE9
152EE:  MOVFF  89F,8F7
152F2:  MOVFF  89E,8F6
152F6:  CALL   AAF2
....................    strcat(data_buffer, config_str); 
152FA:  MOVLB  8
152FC:  CLRF   xF9
152FE:  MOVLW  67
15300:  MOVWF  xF8
15302:  MOVLW  08
15304:  MOVWF  xFB
15306:  MOVLW  A5
15308:  MOVWF  xFA
1530A:  MOVLB  0
1530C:  CALL   54D2
....................    strcat(data_buffer, endofline); 
15310:  MOVLB  8
15312:  CLRF   xF9
15314:  MOVLW  67
15316:  MOVWF  xF8
15318:  MOVLW  08
1531A:  MOVWF  xFB
1531C:  MOVLW  A2
1531E:  MOVWF  xFA
15320:  MOVLB  0
15322:  CALL   54D2
....................     
....................    if (nv_report_mode == 4) fprintf(COM_A, "%s\r\n", data_buffer); 
15326:  MOVF   1F,W
15328:  SUBLW  04
1532A:  BNZ   1534A
1532C:  MOVF   20,F
1532E:  BNZ   1534A
15330:  CLRF   FEA
15332:  MOVLW  67
15334:  MOVWF  FE9
15336:  CALL   798A
1533A:  MOVLW  0D
1533C:  BTFSS  F9E.4
1533E:  BRA    1533C
15340:  MOVWF  FAD
15342:  MOVLW  0A
15344:  BTFSS  F9E.4
15346:  BRA    15344
15348:  MOVWF  FAD
....................  
....................    if(sd_status==0){ 
1534A:  MOVLB  2
1534C:  MOVF   xDC,F
1534E:  BNZ   153A2
....................     
....................       buffer_select = 0; 
15350:  MOVLB  0
15352:  CLRF   x66
....................        
....................       heartbeat(FALSE); 
15354:  MOVLB  8
15356:  CLRF   xED
15358:  MOVLB  0
1535A:  CALL   557A
....................          append_data(file_ptr_raw_all); 
1535E:  MOVLW  02
15360:  MOVLB  8
15362:  MOVWF  xEE
15364:  MOVLW  DD
15366:  MOVWF  xED
15368:  MOVLB  0
1536A:  CALL   82EC
....................       heartbeat(TRUE);          
1536E:  MOVLW  01
15370:  MOVLB  8
15372:  MOVWF  xED
15374:  MOVLB  0
15376:  CALL   557A
....................        
....................       heartbeat(FALSE); 
1537A:  MOVLB  8
1537C:  CLRF   xED
1537E:  MOVLB  0
15380:  CALL   557A
....................          append_data(file_ptr_raw_new);    
15384:  MOVLW  02
15386:  MOVLB  8
15388:  MOVWF  xEE
1538A:  MOVLW  EB
1538C:  MOVWF  xED
1538E:  MOVLB  0
15390:  CALL   82EC
....................       heartbeat(TRUE); 
15394:  MOVLW  01
15396:  MOVLB  8
15398:  MOVWF  xED
1539A:  MOVLB  0
1539C:  CALL   557A
153A0:  MOVLB  2
....................    } 
153A2:  MOVLB  0
153A4:  GOTO   15540 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "macros.c" 
....................  
.................... // --------------------------------------------------------------------// 
.................... #define MACEND  1024 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_ECO   "#/+-%rpdACDFGHiKlLPQRSTUvY;" // Valid macro commands 
.................... #define MASTERLIST_ECO  "#MZr%;"               // Master macro commands 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_WMS   "#+-BGPQRTY;" 
.................... #define MASTERLIST_WMS  "#JMP;" 
.................... // --------------------------------------------------------------------// 
.................... #define MACROLIST_AWS   "#+-CDPQSY;" 
.................... #define MASTERLIST_AWS  "#MP;" 
.................... // --------------------------------------------------------------------// 
....................  
.................... #include "command.h"  //Fraser 7/2/2015 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... int16 macro_address[21] = {MACROM,MACRO1,MACRO2,MACRO3,MACRO4,MACRO5,MACRO6, 
....................   MACRO7,MACRO8,MACRO9,MACRO10,MACRO11,MACRO12,MACRO13,MACRO14,MACRO15,MACRO16,MACRO17,MACRO18,MACRO19,MACRO20}; 
....................    
.................... int16 string_address[21] = {STRM,STR1,STR2,STR3,STR4,STR5,STR6,STR7,STR8,STR9, 
....................                            STR10,STR11,STR12,STR13,STR14,STR15,STR16,STR17,STR18,STR19,STR20}; 
....................  
.................... void bus_on() 
.................... { 
....................    output_high(VDET); 
*
0D364:  BSF    F90.7
....................    delay_ms(500); 
0D366:  MOVLW  02
0D368:  MOVLB  8
0D36A:  MOVWF  xC2
0D36C:  MOVLW  FA
0D36E:  MOVLB  9
0D370:  MOVWF  xEC
0D372:  MOVLB  0
0D374:  CALL   2904
0D378:  MOVLB  8
0D37A:  DECFSZ xC2,F
0D37C:  BRA    D36C
....................    bus_pwr_status=1; 
0D37E:  MOVLW  01
0D380:  MOVLB  4
0D382:  MOVWF  xB6
0D384:  MOVLB  0
0D386:  RETURN 0
.................... } 
....................  
.................... void bus_off() 
.................... { 
....................    output_low(VDET); 
0D388:  BCF    F90.7
....................    delay_ms(100); 
0D38A:  MOVLW  64
0D38C:  MOVLB  9
0D38E:  MOVWF  xEC
0D390:  MOVLB  0
0D392:  CALL   2904
....................    bus_pwr_status=0; 
0D396:  MOVLB  4
0D398:  CLRF   xB6
0D39A:  MOVLB  0
0D39C:  RETURN 0
.................... } 
....................  
.................... // *** UPLOAD MACRO FUNCTIONS *** // 
....................  
.................... //This variable holds strings if the print command is used 
.................... char string_arg[50]; 
....................  
.................... //If the command is p than this is called rather than get_arg().  
.................... void get_arg_string(){ 
*
17F98:  MOVLB  8
17F9A:  CLRF   x97
....................    int i = 0; 
....................    for (i = 0; i < 50; i++){ 
17F9C:  CLRF   x97
17F9E:  MOVF   x97,W
17FA0:  SUBLW  31
17FA2:  BNC   17FB8
....................       string_arg[i] = 0; 
17FA4:  CLRF   03
17FA6:  MOVF   x97,W
17FA8:  ADDLW  25
17FAA:  MOVWF  FE9
17FAC:  MOVLW  08
17FAE:  ADDWFC 03,W
17FB0:  MOVWF  FEA
17FB2:  CLRF   FEF
17FB4:  INCF   x97,F
17FB6:  BRA    17F9E
....................    } 
....................     
....................     
....................    for (i = 0; i < 50; i++) 
17FB8:  CLRF   x97
17FBA:  MOVF   x97,W
17FBC:  SUBLW  31
17FBE:  BNC   18038
....................    { 
....................       string_arg[i] = fgetc(COM_A); 
17FC0:  CLRF   03
17FC2:  MOVF   x97,W
17FC4:  ADDLW  25
17FC6:  MOVWF  FE9
17FC8:  MOVLW  08
17FCA:  ADDWFC 03,W
17FCC:  MOVWF  FEA
17FCE:  MOVFF  FEA,89B
17FD2:  MOVFF  FE9,89A
17FD6:  MOVLB  0
17FD8:  CALL   0E2C
17FDC:  MOVFF  89B,FEA
17FE0:  MOVFF  89A,FE9
17FE4:  MOVFF  01,FEF
....................       if(com_echo == TRUE) 
17FE8:  DECFSZ 4C,W
17FEA:  BRA    18008
....................       { 
....................          fputc(string_arg[i],COM_A); 
17FEC:  CLRF   03
17FEE:  MOVLB  8
17FF0:  MOVF   x97,W
17FF2:  ADDLW  25
17FF4:  MOVWF  FE9
17FF6:  MOVLW  08
17FF8:  ADDWFC 03,W
17FFA:  MOVWF  FEA
17FFC:  MOVFF  FEF,898
18000:  MOVF   x98,W
18002:  MOVLB  0
18004:  CALL   AEAC
....................       } 
....................  
....................       if(string_arg[i] == '\r' || string_arg[i] == '\n') 
18008:  CLRF   03
1800A:  MOVLB  8
1800C:  MOVF   x97,W
1800E:  ADDLW  25
18010:  MOVWF  FE9
18012:  MOVLW  08
18014:  ADDWFC 03,W
18016:  MOVWF  FEA
18018:  MOVF   FEF,W
1801A:  SUBLW  0D
1801C:  BZ    18032
1801E:  CLRF   03
18020:  MOVF   x97,W
18022:  ADDLW  25
18024:  MOVWF  FE9
18026:  MOVLW  08
18028:  ADDWFC 03,W
1802A:  MOVWF  FEA
1802C:  MOVF   FEF,W
1802E:  SUBLW  0A
18030:  BNZ   18034
....................       { 
....................          break; 
18032:  BRA    18038
....................       } 
18034:  INCF   x97,F
18036:  BRA    17FBA
....................    } 
18038:  MOVLB  0
1803A:  GOTO   18362 (RETURN)
.................... } 
....................  
....................  
.................... int16 get_arg() 
.................... { 
....................    int8 number; 
....................    int16 macro_arg; 
....................     
....................    number = 0; 
*
181E0:  MOVLB  8
181E2:  CLRF   x97
....................    macro_arg = 0; 
181E4:  CLRF   x99
181E6:  CLRF   x98
....................     
....................    while (number != CARRIAGE_RET) {                       // 13 = CR = terminator 
181E8:  MOVF   x97,W
181EA:  SUBLW  0D
181EC:  BZ    18278
....................       number = fgetc(COM_A); 
181EE:  MOVLB  0
181F0:  CALL   0E2C
181F4:  MOVFF  01,897
....................       if (com_echo == TRUE) 
181F8:  DECFSZ 4C,W
181FA:  BRA    1820C
....................       { 
....................          if (number != CARRIAGE_RET) fputc(number, COM_A); 
181FC:  MOVLB  8
181FE:  MOVF   x97,W
18200:  SUBLW  0D
18202:  BZ    1820E
18204:  MOVF   x97,W
18206:  MOVLB  0
18208:  CALL   AEAC
1820C:  MOVLB  8
....................       } 
....................       if (number > 47 && number < 58) 
1820E:  MOVF   x97,W
18210:  SUBLW  2F
18212:  BC    18248
18214:  MOVF   x97,W
18216:  SUBLW  39
18218:  BNC   18248
....................       {       // ASCII 0 = 48 
....................          number = number - 48; 
1821A:  MOVLW  30
1821C:  SUBWF  x97,F
....................          macro_arg = macro_arg * 10;                    // increase significance 
1821E:  MOVFF  899,A11
18222:  MOVFF  898,A10
18226:  MOVLB  A
18228:  CLRF   x13
1822A:  MOVLW  0A
1822C:  MOVWF  x12
1822E:  MOVLB  0
18230:  CALL   5C8C
18234:  MOVFF  02,899
18238:  MOVFF  01,898
....................          macro_arg = macro_arg + number;                // for each number 
1823C:  MOVLB  8
1823E:  MOVF   x97,W
18240:  ADDWF  x98,F
18242:  MOVLW  00
18244:  ADDWFC x99,F
....................       } 
18246:  BRA    18276
....................       else if (number == CARRIAGE_RET) 
18248:  MOVF   x97,W
1824A:  SUBLW  0D
1824C:  BNZ   1826E
....................       { 
....................          if (macro_arg < 65535) return(macro_arg); 
1824E:  INCFSZ x98,W
18250:  BRA    18258
18252:  INCFSZ x99,W
18254:  BRA    18258
18256:  BRA    18264
18258:  MOVFF  898,01
1825C:  MOVFF  899,02
18260:  BRA    18278
18262:  BRA    1826C
....................          else return(65535); 
18264:  MOVLW  FF
18266:  MOVWF  01
18268:  MOVWF  02
1826A:  BRA    18278
....................       } 
1826C:  BRA    18276
....................       else 
....................       { 
....................          return(65535); 
1826E:  MOVLW  FF
18270:  MOVWF  01
18272:  MOVWF  02
18274:  BRA    18278
....................       } 
18276:  BRA    181E8
....................    } 
18278:  MOVLB  0
1827A:  GOTO   1838C (RETURN)
.................... } 
....................  
....................  
.................... //Looks like this is causing the exit from the upload 
.................... int8 check_macro(int8 e, int8 macro) 
.................... { 
....................    int8 valid_macro; 
....................     
....................    switch(nv_product){ 
*
17D22:  MOVF   2F,W
17D24:  MOVWF  00
17D26:  MOVF   30,W
17D28:  MOVWF  03
17D2A:  BNZ   17D30
17D2C:  MOVF   00,F
17D2E:  BZ    17D56
17D30:  MOVF   03,W
17D32:  BNZ   17D3C
17D34:  MOVLW  03
17D36:  SUBWF  00,W
17D38:  BTFSC  FD8.2
17D3A:  BRA    17E1A
17D3C:  MOVF   03,W
17D3E:  BNZ   17D48
17D40:  MOVLW  01
17D42:  SUBWF  00,W
17D44:  BTFSC  FD8.2
17D46:  BRA    17E1A
17D48:  MOVF   03,W
17D4A:  BNZ   17D54
17D4C:  MOVLW  02
17D4E:  SUBWF  00,W
17D50:  BTFSC  FD8.2
17D52:  BRA    17E90
17D54:  BRA    17EFE
....................       case ECO :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_ECO); 
17D56:  MOVLB  8
17D58:  MOVF   x9B,F
17D5A:  BNZ   17D8A
17D5C:  MOVF   x9A,W
17D5E:  SUBLW  23
17D60:  BZ    17D84
17D62:  MOVF   x9A,W
17D64:  SUBLW  25
17D66:  BZ    17D84
17D68:  MOVF   x9A,W
17D6A:  SUBLW  3B
17D6C:  BZ    17D84
17D6E:  MOVF   x9A,W
17D70:  SUBLW  4D
17D72:  BZ    17D84
17D74:  MOVF   x9A,W
17D76:  SUBLW  5A
17D78:  BZ    17D84
17D7A:  MOVF   x9A,W
17D7C:  SUBLW  72
17D7E:  BZ    17D84
17D80:  MOVLW  00
17D82:  BRA    17D86
17D84:  MOVLW  01
17D86:  MOVWF  x9C
17D88:  BRA    17E16
....................                   else valid_macro = isamong (e, MACROLIST_ECO); 
17D8A:  MOVF   x9A,W
17D8C:  SUBLW  23
17D8E:  BZ    17E12
17D90:  MOVF   x9A,W
17D92:  SUBLW  25
17D94:  BZ    17E12
17D96:  MOVF   x9A,W
17D98:  SUBLW  2B
17D9A:  BZ    17E12
17D9C:  MOVF   x9A,W
17D9E:  SUBLW  2D
17DA0:  BZ    17E12
17DA2:  MOVF   x9A,W
17DA4:  SUBLW  2F
17DA6:  BZ    17E12
17DA8:  MOVF   x9A,W
17DAA:  SUBLW  3B
17DAC:  BZ    17E12
17DAE:  MOVF   x9A,W
17DB0:  SUBLW  41
17DB2:  BZ    17E12
17DB4:  MOVF   x9A,W
17DB6:  SUBLW  42
17DB8:  BC    17DC0
17DBA:  MOVF   x9A,W
17DBC:  SUBLW  44
17DBE:  BC    17E12
17DC0:  MOVF   x9A,W
17DC2:  SUBLW  45
17DC4:  BC    17DCC
17DC6:  MOVF   x9A,W
17DC8:  SUBLW  48
17DCA:  BC    17E12
17DCC:  MOVF   x9A,W
17DCE:  SUBLW  4A
17DD0:  BC    17DD8
17DD2:  MOVF   x9A,W
17DD4:  SUBLW  4C
17DD6:  BC    17E12
17DD8:  MOVF   x9A,W
17DDA:  SUBLW  4F
17DDC:  BC    17DE4
17DDE:  MOVF   x9A,W
17DE0:  SUBLW  55
17DE2:  BC    17E12
17DE4:  MOVF   x9A,W
17DE6:  SUBLW  59
17DE8:  BZ    17E12
17DEA:  MOVF   x9A,W
17DEC:  SUBLW  64
17DEE:  BZ    17E12
17DF0:  MOVF   x9A,W
17DF2:  SUBLW  69
17DF4:  BZ    17E12
17DF6:  MOVF   x9A,W
17DF8:  SUBLW  6C
17DFA:  BZ    17E12
17DFC:  MOVF   x9A,W
17DFE:  SUBLW  70
17E00:  BZ    17E12
17E02:  MOVF   x9A,W
17E04:  SUBLW  72
17E06:  BZ    17E12
17E08:  MOVF   x9A,W
17E0A:  SUBLW  76
17E0C:  BZ    17E12
17E0E:  MOVLW  00
17E10:  BRA    17E14
17E12:  MOVLW  01
17E14:  MOVWF  x9C
....................          break; 
17E16:  MOVLB  0
17E18:  BRA    17EFE
....................       case WMS2 : 
....................       case WMS4 : 
....................                   if (macro == 0) valid_macro = isamong (e, MASTERLIST_WMS); 
17E1A:  MOVLB  8
17E1C:  MOVF   x9B,F
17E1E:  BNZ   17E48
17E20:  MOVF   x9A,W
17E22:  SUBLW  23
17E24:  BZ    17E42
17E26:  MOVF   x9A,W
17E28:  SUBLW  3B
17E2A:  BZ    17E42
17E2C:  MOVF   x9A,W
17E2E:  SUBLW  4A
17E30:  BZ    17E42
17E32:  MOVF   x9A,W
17E34:  SUBLW  4D
17E36:  BZ    17E42
17E38:  MOVF   x9A,W
17E3A:  SUBLW  50
17E3C:  BZ    17E42
17E3E:  MOVLW  00
17E40:  BRA    17E44
17E42:  MOVLW  01
17E44:  MOVWF  x9C
17E46:  BRA    17E8C
....................                   else valid_macro = isamong (e, MACROLIST_WMS); 
17E48:  MOVF   x9A,W
17E4A:  SUBLW  23
17E4C:  BZ    17E88
17E4E:  MOVF   x9A,W
17E50:  SUBLW  2B
17E52:  BZ    17E88
17E54:  MOVF   x9A,W
17E56:  SUBLW  2D
17E58:  BZ    17E88
17E5A:  MOVF   x9A,W
17E5C:  SUBLW  3B
17E5E:  BZ    17E88
17E60:  MOVF   x9A,W
17E62:  SUBLW  42
17E64:  BZ    17E88
17E66:  MOVF   x9A,W
17E68:  SUBLW  47
17E6A:  BZ    17E88
17E6C:  MOVF   x9A,W
17E6E:  SUBLW  4F
17E70:  BC    17E78
17E72:  MOVF   x9A,W
17E74:  SUBLW  52
17E76:  BC    17E88
17E78:  MOVF   x9A,W
17E7A:  SUBLW  54
17E7C:  BZ    17E88
17E7E:  MOVF   x9A,W
17E80:  SUBLW  59
17E82:  BZ    17E88
17E84:  MOVLW  00
17E86:  BRA    17E8A
17E88:  MOVLW  01
17E8A:  MOVWF  x9C
....................          break;   
17E8C:  MOVLB  0
17E8E:  BRA    17EFE
....................       case AWS :  if (macro == 0) valid_macro = isamong (e, MASTERLIST_AWS); 
17E90:  MOVLB  8
17E92:  MOVF   x9B,F
17E94:  BNZ   17EB8
17E96:  MOVF   x9A,W
17E98:  SUBLW  23
17E9A:  BZ    17EB2
17E9C:  MOVF   x9A,W
17E9E:  SUBLW  3B
17EA0:  BZ    17EB2
17EA2:  MOVF   x9A,W
17EA4:  SUBLW  4D
17EA6:  BZ    17EB2
17EA8:  MOVF   x9A,W
17EAA:  SUBLW  50
17EAC:  BZ    17EB2
17EAE:  MOVLW  00
17EB0:  BRA    17EB4
17EB2:  MOVLW  01
17EB4:  MOVWF  x9C
17EB6:  BRA    17EFC
....................                   else valid_macro = isamong (e, MACROLIST_AWS); 
17EB8:  MOVF   x9A,W
17EBA:  SUBLW  23
17EBC:  BZ    17EF8
17EBE:  MOVF   x9A,W
17EC0:  SUBLW  2B
17EC2:  BZ    17EF8
17EC4:  MOVF   x9A,W
17EC6:  SUBLW  2D
17EC8:  BZ    17EF8
17ECA:  MOVF   x9A,W
17ECC:  SUBLW  3B
17ECE:  BZ    17EF8
17ED0:  MOVF   x9A,W
17ED2:  SUBLW  42
17ED4:  BC    17EDC
17ED6:  MOVF   x9A,W
17ED8:  SUBLW  44
17EDA:  BC    17EF8
17EDC:  MOVF   x9A,W
17EDE:  SUBLW  4F
17EE0:  BC    17EE8
17EE2:  MOVF   x9A,W
17EE4:  SUBLW  51
17EE6:  BC    17EF8
17EE8:  MOVF   x9A,W
17EEA:  SUBLW  53
17EEC:  BZ    17EF8
17EEE:  MOVF   x9A,W
17EF0:  SUBLW  59
17EF2:  BZ    17EF8
17EF4:  MOVLW  00
17EF6:  BRA    17EFA
17EF8:  MOVLW  01
17EFA:  MOVWF  x9C
....................          break;   
17EFC:  MOVLB  0
....................    } 
....................    return(valid_macro); 
17EFE:  MOVLB  8
17F00:  MOVFF  89C,01
17F04:  MOVLB  0
17F06:  GOTO   17F32 (RETURN)
.................... } 
.................... // returns 0 if macro command is invalid 
.................... int8 get_cmd(int8 macro) 
.................... { 
....................    int8 e; 
....................    int8 valid_macro; 
....................     
....................    valid_macro = TRUE; 
17F0A:  MOVLW  01
17F0C:  MOVLB  8
17F0E:  MOVWF  x99
....................     
....................    do{ 
....................       e=fgetc(COM_A); 
17F10:  MOVLB  0
17F12:  CALL   0E2C
17F16:  MOVFF  01,898
....................       if (com_echo == TRUE) fputc(e,COM_A); 
17F1A:  DECFSZ 4C,W
17F1C:  BRA    17F28
17F1E:  MOVLB  8
17F20:  MOVF   x98,W
17F22:  MOVLB  0
17F24:  CALL   AEAC
....................          valid_macro = check_macro(e, macro); 
17F28:  MOVFF  898,89A
17F2C:  MOVFF  897,89B
17F30:  BRA    17D22
17F32:  MOVFF  01,899
....................       if (valid_macro == TRUE) { 
17F36:  MOVLB  8
17F38:  DECFSZ x99,W
17F3A:  BRA    17F44
....................          return(e); 
17F3C:  MOVFF  898,01
17F40:  BRA    17F50
....................       } 
17F42:  BRA    17F4A
....................       else return(0); 
17F44:  MOVLW  00
17F46:  MOVWF  01
17F48:  BRA    17F50
....................    } while (valid_macro == TRUE); 
17F4A:  DECFSZ x99,W
17F4C:  BRA    17F50
17F4E:  BRA    17F10
17F50:  MOVLB  0
17F52:  GOTO   18344 (RETURN)
.................... } 
....................  
.................... void write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    //line*3 because 3 bytes but line incremented by one each time 
....................    addr = macro_address[macro] + (line*3);  
*
182CA:  BCF    FD8.0
182CC:  MOVLB  8
182CE:  RLCF   x9A,W
182D0:  CLRF   03
182D2:  ADDLW  D1
182D4:  MOVWF  FE9
182D6:  MOVLW  07
182D8:  ADDWFC 03,W
182DA:  MOVWF  FEA
182DC:  MOVFF  FEC,8A0
182E0:  MOVF   FED,F
182E2:  MOVFF  FEF,89F
182E6:  MOVFF  89C,A11
182EA:  MOVFF  89B,A10
182EE:  MOVLB  A
182F0:  CLRF   x13
182F2:  MOVLW  03
182F4:  MOVWF  x12
182F6:  MOVLB  0
182F8:  CALL   5C8C
182FC:  MOVF   01,W
182FE:  MOVLB  8
18300:  ADDWF  x9F,W
18302:  MOVWF  x9D
18304:  MOVF   02,W
18306:  ADDWFC xA0,W
18308:  MOVWF  x9E
....................     
....................    write_ext_eeprom(addr, macro_cmd); 
1830A:  MOVFF  89E,8A8
1830E:  MOVFF  89D,8A7
18312:  MOVFF  897,8A9
18316:  MOVLB  0
18318:  RCALL  1803E
....................     
....................    ++addr; 
1831A:  MOVLB  8
1831C:  INCF   x9D,F
1831E:  BTFSC  FD8.2
18320:  INCF   x9E,F
....................     
....................    write16_ext_eeprom(addr, macro_arg); 
18322:  MOVFF  89E,8A0
18326:  MOVFF  89D,89F
1832A:  MOVFF  899,8A2
1832E:  MOVFF  898,8A1
18332:  MOVLB  0
18334:  BRA    1827E
18336:  RETURN 0
.................... } 
....................  
.................... /*writes a string to the macro. The macro cmd goes to the standard memory 
.................... address, while the string is stored at a different location stored in the 
.................... string_address array*/ 
.................... void write_macro_line_string(int8 macro_cmd, int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
1809E:  BCF    FD8.0
180A0:  MOVLB  8
180A2:  RLCF   x98,W
180A4:  CLRF   03
180A6:  ADDLW  D1
180A8:  MOVWF  FE9
180AA:  MOVLW  07
180AC:  ADDWFC 03,W
180AE:  MOVWF  FEA
180B0:  MOVFF  FEC,8A1
180B4:  MOVF   FED,F
180B6:  MOVFF  FEF,8A0
180BA:  MOVFF  89A,A11
180BE:  MOVFF  899,A10
180C2:  MOVLB  A
180C4:  CLRF   x13
180C6:  MOVLW  03
180C8:  MOVWF  x12
180CA:  MOVLB  0
180CC:  CALL   5C8C
180D0:  MOVF   01,W
180D2:  MOVLB  8
180D4:  ADDWF  xA0,W
180D6:  MOVWF  x9D
180D8:  MOVF   02,W
180DA:  ADDWFC xA1,W
180DC:  MOVWF  x9E
....................    write_ext_eeprom(addr, macro_cmd); 
180DE:  MOVFF  89E,8A8
180E2:  MOVFF  89D,8A7
180E6:  MOVFF  897,8A9
180EA:  MOVLB  0
180EC:  RCALL  1803E
....................     
....................    int i = 0; 
180EE:  MOVLB  8
180F0:  CLRF   x9F
....................    addr = string_address[macro] + (count*50); 
180F2:  BCF    FD8.0
180F4:  RLCF   x98,W
180F6:  CLRF   03
180F8:  ADDLW  FB
180FA:  MOVWF  FE9
180FC:  MOVLW  07
180FE:  ADDWFC 03,W
18100:  MOVWF  FEA
18102:  MOVFF  FEC,8A1
18106:  MOVF   FED,F
18108:  MOVFF  FEF,8A0
1810C:  MOVFF  89C,A11
18110:  MOVFF  89B,A10
18114:  MOVLB  A
18116:  CLRF   x13
18118:  MOVLW  32
1811A:  MOVWF  x12
1811C:  MOVLB  0
1811E:  CALL   5C8C
18122:  MOVF   01,W
18124:  MOVLB  8
18126:  ADDWF  xA0,W
18128:  MOVWF  x9D
1812A:  MOVF   02,W
1812C:  ADDWFC xA1,W
1812E:  MOVWF  x9E
....................    //fprintf(COM_A,"%Lu\r\n",addr); 
....................    if(count <= 20){ 
18130:  MOVF   x9C,F
18132:  BNZ   18188
18134:  MOVF   x9B,W
18136:  SUBLW  14
18138:  BNC   18188
....................       for(i = 0; i<50; i++) { 
1813A:  CLRF   x9F
1813C:  MOVF   x9F,W
1813E:  SUBLW  31
18140:  BNC   18186
....................          write_ext_eeprom(addr + i, string_arg[i]); 
18142:  MOVF   x9F,W
18144:  ADDWF  x9D,W
18146:  MOVWF  xA0
18148:  MOVLW  00
1814A:  ADDWFC x9E,W
1814C:  MOVWF  xA1
1814E:  CLRF   03
18150:  MOVF   x9F,W
18152:  ADDLW  25
18154:  MOVWF  FE9
18156:  MOVLW  08
18158:  ADDWFC 03,W
1815A:  MOVWF  FEA
1815C:  MOVFF  FEF,8A9
18160:  MOVFF  8A1,8A8
18164:  MOVFF  8A0,8A7
18168:  MOVLB  0
1816A:  RCALL  1803E
....................          if(string_arg[i] == 0){ 
1816C:  CLRF   03
1816E:  MOVLB  8
18170:  MOVF   x9F,W
18172:  ADDLW  25
18174:  MOVWF  FE9
18176:  MOVLW  08
18178:  ADDWFC 03,W
1817A:  MOVWF  FEA
1817C:  MOVF   FEF,F
1817E:  BNZ   18182
....................             break; 
18180:  BRA    18186
....................          } 
18182:  INCF   x9F,F
18184:  BRA    1813C
....................       
....................       } 
....................    }else{ 
18186:  BRA    181DA
....................       fprintf(COM_A,"MEMORY OVERFLOW ERROR @ Line :%Lu\n\r",line); 
18188:  MOVLW  C6
1818A:  MOVWF  FF6
1818C:  MOVLW  20
1818E:  MOVWF  FF7
18190:  MOVLW  00
18192:  MOVWF  FF8
18194:  CLRF   1B
18196:  BTFSC  FF2.7
18198:  BSF    1B.7
1819A:  BCF    FF2.7
1819C:  MOVLW  1E
1819E:  MOVLB  A
181A0:  MOVWF  x40
181A2:  MOVLB  0
181A4:  CALL   1018
181A8:  BTFSC  1B.7
181AA:  BSF    FF2.7
181AC:  MOVLW  10
181AE:  MOVWF  FE9
181B0:  CLRF   1B
181B2:  BTFSC  FF2.7
181B4:  BSF    1B.7
181B6:  BCF    FF2.7
181B8:  MOVFF  89A,A41
181BC:  MOVFF  899,A40
181C0:  CALL   119A
181C4:  BTFSC  1B.7
181C6:  BSF    FF2.7
181C8:  MOVLW  0A
181CA:  BTFSS  F9E.4
181CC:  BRA    181CA
181CE:  MOVWF  FAD
181D0:  MOVLW  0D
181D2:  BTFSS  F9E.4
181D4:  BRA    181D2
181D6:  MOVWF  FAD
181D8:  MOVLB  8
....................    } 
181DA:  MOVLB  0
181DC:  GOTO   1837C (RETURN)
....................     
.................... } 
....................  
....................  
.................... void write_blank_macros() 
.................... { 
....................    init_ext_eeprom(); 
*
1851C:  CALL   105B6
....................     
....................    //write_macro_line(int8 macro_cmd, int16 macro_arg, int8 macro, int16 line) 
....................     
....................    write_macro_line(59, 0, 0, 0);      // 59 = ; (end of macro symbol) 
18520:  MOVLW  3B
18522:  MOVLB  8
18524:  MOVWF  x97
18526:  CLRF   x99
18528:  CLRF   x98
1852A:  CLRF   x9A
1852C:  CLRF   x9C
1852E:  CLRF   x9B
18530:  MOVLB  0
18532:  RCALL  182CA
....................     
....................    write_macro_line(59, 0, 1, 0); 
18534:  MOVLW  3B
18536:  MOVLB  8
18538:  MOVWF  x97
1853A:  CLRF   x99
1853C:  CLRF   x98
1853E:  MOVLW  01
18540:  MOVWF  x9A
18542:  CLRF   x9C
18544:  CLRF   x9B
18546:  MOVLB  0
18548:  RCALL  182CA
....................    write_macro_line(59, 0, 2, 0); 
1854A:  MOVLW  3B
1854C:  MOVLB  8
1854E:  MOVWF  x97
18550:  CLRF   x99
18552:  CLRF   x98
18554:  MOVLW  02
18556:  MOVWF  x9A
18558:  CLRF   x9C
1855A:  CLRF   x9B
1855C:  MOVLB  0
1855E:  RCALL  182CA
....................    write_macro_line(59, 0, 3, 0); 
18560:  MOVLW  3B
18562:  MOVLB  8
18564:  MOVWF  x97
18566:  CLRF   x99
18568:  CLRF   x98
1856A:  MOVLW  03
1856C:  MOVWF  x9A
1856E:  CLRF   x9C
18570:  CLRF   x9B
18572:  MOVLB  0
18574:  RCALL  182CA
....................    write_macro_line(59, 0, 4, 0); 
18576:  MOVLW  3B
18578:  MOVLB  8
1857A:  MOVWF  x97
1857C:  CLRF   x99
1857E:  CLRF   x98
18580:  MOVLW  04
18582:  MOVWF  x9A
18584:  CLRF   x9C
18586:  CLRF   x9B
18588:  MOVLB  0
1858A:  RCALL  182CA
....................    write_macro_line(59, 0, 5, 0); 
1858C:  MOVLW  3B
1858E:  MOVLB  8
18590:  MOVWF  x97
18592:  CLRF   x99
18594:  CLRF   x98
18596:  MOVLW  05
18598:  MOVWF  x9A
1859A:  CLRF   x9C
1859C:  CLRF   x9B
1859E:  MOVLB  0
185A0:  RCALL  182CA
....................    write_macro_line(59, 0, 6, 0); 
185A2:  MOVLW  3B
185A4:  MOVLB  8
185A6:  MOVWF  x97
185A8:  CLRF   x99
185AA:  CLRF   x98
185AC:  MOVLW  06
185AE:  MOVWF  x9A
185B0:  CLRF   x9C
185B2:  CLRF   x9B
185B4:  MOVLB  0
185B6:  RCALL  182CA
....................    write_macro_line(59, 0, 7, 0); 
185B8:  MOVLW  3B
185BA:  MOVLB  8
185BC:  MOVWF  x97
185BE:  CLRF   x99
185C0:  CLRF   x98
185C2:  MOVLW  07
185C4:  MOVWF  x9A
185C6:  CLRF   x9C
185C8:  CLRF   x9B
185CA:  MOVLB  0
185CC:  RCALL  182CA
....................    write_macro_line(59, 0, 8, 0); 
185CE:  MOVLW  3B
185D0:  MOVLB  8
185D2:  MOVWF  x97
185D4:  CLRF   x99
185D6:  CLRF   x98
185D8:  MOVLW  08
185DA:  MOVWF  x9A
185DC:  CLRF   x9C
185DE:  CLRF   x9B
185E0:  MOVLB  0
185E2:  RCALL  182CA
....................     
....................    write_macro_line(59, 0, 9, 0); 
185E4:  MOVLW  3B
185E6:  MOVLB  8
185E8:  MOVWF  x97
185EA:  CLRF   x99
185EC:  CLRF   x98
185EE:  MOVLW  09
185F0:  MOVWF  x9A
185F2:  CLRF   x9C
185F4:  CLRF   x9B
185F6:  MOVLB  0
185F8:  RCALL  182CA
....................    write_macro_line(59, 0, 10, 0); 
185FA:  MOVLW  3B
185FC:  MOVLB  8
185FE:  MOVWF  x97
18600:  CLRF   x99
18602:  CLRF   x98
18604:  MOVLW  0A
18606:  MOVWF  x9A
18608:  CLRF   x9C
1860A:  CLRF   x9B
1860C:  MOVLB  0
1860E:  RCALL  182CA
....................    write_macro_line(59, 0, 11, 0); 
18610:  MOVLW  3B
18612:  MOVLB  8
18614:  MOVWF  x97
18616:  CLRF   x99
18618:  CLRF   x98
1861A:  MOVLW  0B
1861C:  MOVWF  x9A
1861E:  CLRF   x9C
18620:  CLRF   x9B
18622:  MOVLB  0
18624:  RCALL  182CA
....................    write_macro_line(59, 0, 12, 0); 
18626:  MOVLW  3B
18628:  MOVLB  8
1862A:  MOVWF  x97
1862C:  CLRF   x99
1862E:  CLRF   x98
18630:  MOVLW  0C
18632:  MOVWF  x9A
18634:  CLRF   x9C
18636:  CLRF   x9B
18638:  MOVLB  0
1863A:  RCALL  182CA
....................    write_macro_line(59, 0, 13, 0); 
1863C:  MOVLW  3B
1863E:  MOVLB  8
18640:  MOVWF  x97
18642:  CLRF   x99
18644:  CLRF   x98
18646:  MOVLW  0D
18648:  MOVWF  x9A
1864A:  CLRF   x9C
1864C:  CLRF   x9B
1864E:  MOVLB  0
18650:  RCALL  182CA
....................    write_macro_line(59, 0, 14, 0); 
18652:  MOVLW  3B
18654:  MOVLB  8
18656:  MOVWF  x97
18658:  CLRF   x99
1865A:  CLRF   x98
1865C:  MOVLW  0E
1865E:  MOVWF  x9A
18660:  CLRF   x9C
18662:  CLRF   x9B
18664:  MOVLB  0
18666:  RCALL  182CA
....................    write_macro_line(59, 0, 15, 0); 
18668:  MOVLW  3B
1866A:  MOVLB  8
1866C:  MOVWF  x97
1866E:  CLRF   x99
18670:  CLRF   x98
18672:  MOVLW  0F
18674:  MOVWF  x9A
18676:  CLRF   x9C
18678:  CLRF   x9B
1867A:  MOVLB  0
1867C:  RCALL  182CA
....................    write_macro_line(59, 0, 16, 0); 
1867E:  MOVLW  3B
18680:  MOVLB  8
18682:  MOVWF  x97
18684:  CLRF   x99
18686:  CLRF   x98
18688:  MOVLW  10
1868A:  MOVWF  x9A
1868C:  CLRF   x9C
1868E:  CLRF   x9B
18690:  MOVLB  0
18692:  RCALL  182CA
18694:  GOTO   186CC (RETURN)
.................... } 
....................  
.................... void macro_comment() 
.................... { 
....................    int8 mcc; 
....................    mcc=0; 
*
17F56:  MOVLB  8
17F58:  CLRF   x97
....................     
....................    heartbeat(FALSE); 
17F5A:  CLRF   xED
17F5C:  MOVLB  0
17F5E:  CALL   557A
....................     
....................    while(mcc != CARRIAGE_RET){ 
17F62:  MOVLB  8
17F64:  MOVF   x97,W
17F66:  SUBLW  0D
17F68:  BZ    17F8A
....................       if (kbhit(COM_A)) { 
17F6A:  BTFSS  F9E.5
17F6C:  BRA    17F88
....................          mcc=fgetc(COM_A); 
17F6E:  MOVLB  0
17F70:  CALL   0E2C
17F74:  MOVFF  01,897
....................          if (com_echo == TRUE) fputc(mcc,COM_A); 
17F78:  DECFSZ 4C,W
17F7A:  BRA    17F86
17F7C:  MOVLB  8
17F7E:  MOVF   x97,W
17F80:  MOVLB  0
17F82:  CALL   AEAC
17F86:  MOVLB  8
....................       } 
17F88:  BRA    17F64
....................    } 
....................     
....................    heartbeat(TRUE); 
17F8A:  MOVLW  01
17F8C:  MOVWF  xED
17F8E:  MOVLB  0
17F90:  CALL   557A
17F94:  GOTO   18354 (RETURN)
.................... } 
....................  
.................... int8 get_macro_line(int8 macro, int16 line, int16 count) 
.................... { 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  valid_macro; 
....................     
....................    valid_macro = FALSE; 
*
18338:  MOVLB  8
1833A:  CLRF   x96
....................     
....................    macro_cmd = get_cmd(macro); 
1833C:  MOVFF  88E,897
18340:  MOVLB  0
18342:  BRA    17F0A
18344:  MOVFF  01,893
....................    if (macro_cmd == 35){  
18348:  MOVLB  8
1834A:  MOVF   x93,W
1834C:  SUBLW  23
1834E:  BNZ   18358
....................       macro_comment();        // # = 35 
18350:  MOVLB  0
18352:  BRA    17F56
....................    }else if(macro_cmd == 112){// 112 is p 
18354:  BRA    183DA
18356:  MOVLB  8
18358:  MOVF   x93,W
1835A:  SUBLW  70
1835C:  BNZ   18384
....................       //fprintf(COM_A,"test\r\n"); 
....................       get_arg_string(); 
1835E:  MOVLB  0
18360:  BRA    17F98
....................       //fprintf(COM_A,"test\r\n"); 
....................       write_macro_line_string(macro_cmd, macro, line, count); 
18362:  MOVFF  893,897
18366:  MOVFF  88E,898
1836A:  MOVFF  890,89A
1836E:  MOVFF  88F,899
18372:  MOVFF  892,89C
18376:  MOVFF  891,89B
1837A:  BRA    1809E
....................       valid_macro = TRUE; 
1837C:  MOVLW  01
1837E:  MOVLB  8
18380:  MOVWF  x96
....................    }else{ 
18382:  BRA    183D8
....................       if (macro_cmd != 0) { 
18384:  MOVF   x93,F
18386:  BZ    183AE
....................          macro_arg = get_arg(); 
18388:  MOVLB  0
1838A:  BRA    181E0
1838C:  MOVFF  02,895
18390:  MOVFF  01,894
....................          if (macro_arg != 65535) valid_macro = TRUE; 
18394:  MOVLB  8
18396:  INCFSZ x94,W
18398:  BRA    183A0
1839A:  INCFSZ x95,W
1839C:  BRA    183A0
1839E:  BRA    183A6
183A0:  MOVLW  01
183A2:  MOVWF  x96
183A4:  BRA    183AC
....................          else return(macro_cmd); 
183A6:  MOVFF  893,01
183AA:  BRA    183E0
....................       }else return(macro_cmd); 
183AC:  BRA    183B4
183AE:  MOVFF  893,01
183B2:  BRA    183E0
....................        
....................       write_macro_line(macro_cmd, macro_arg, macro, line); 
183B4:  MOVFF  893,897
183B8:  MOVFF  895,899
183BC:  MOVFF  894,898
183C0:  MOVFF  88E,89A
183C4:  MOVFF  890,89C
183C8:  MOVFF  88F,89B
183CC:  MOVLB  0
183CE:  RCALL  182CA
....................       return(macro_cmd); 
183D0:  MOVLB  8
183D2:  MOVFF  893,01
183D6:  BRA    183E0
183D8:  MOVLB  0
....................    } 
....................    return(macro_cmd); 
183DA:  MOVLB  8
183DC:  MOVFF  893,01
183E0:  MOVLB  0
183E2:  GOTO   18428 (RETURN)
.................... } 
....................  
.................... void upload_macro(int8 macro) 
183E6:  MOVLB  8
183E8:  CLRF   x8D
183EA:  CLRF   x8C
.................... { 
....................    int16 line; 
....................    int8  valid_macro; 
....................    int8  macro_cmd; 
....................    int8  macro_cmd2; 
....................    int16 count = 0; 
....................     
....................    line = 0; 
183EC:  CLRF   x88
183EE:  CLRF   x87
....................    valid_macro = TRUE; 
183F0:  MOVLW  01
183F2:  MOVWF  x89
....................    macro_cmd = 1; 
183F4:  MOVWF  x8A
....................     
....................    init_ext_eeprom(); 
183F6:  MOVLB  0
183F8:  CALL   105B6
....................     
....................    fprintf(COM_A, ":"); 
183FC:  MOVLW  3A
183FE:  BTFSS  F9E.4
18400:  BRA    183FE
18402:  MOVWF  FAD
....................     
....................    // not a critical hang 
....................     
....................    while(macro_cmd != 59 && macro_cmd != 0) { 
18404:  MOVLB  8
18406:  MOVF   x8A,W
18408:  SUBLW  3B
1840A:  BZ    1846E
1840C:  MOVF   x8A,F
1840E:  BZ    1846E
....................     
....................       macro_cmd = get_macro_line(macro, line,count); 
18410:  MOVFF  886,88E
18414:  MOVFF  888,890
18418:  MOVFF  887,88F
1841C:  MOVFF  88D,892
18420:  MOVFF  88C,891
18424:  MOVLB  0
18426:  BRA    18338
18428:  MOVFF  01,88A
....................       /*count keeps track of the location of the strings just like line does. 
....................       Since strings are stored in a seperate piece of memory we use two seperate 
....................       variables.*/ 
....................        
....................       if(macro_cmd == 'p'){ 
1842C:  MOVLB  8
1842E:  MOVF   x8A,W
18430:  SUBLW  70
18432:  BNZ   1843A
....................          count++; 
18434:  INCF   x8C,F
18436:  BTFSC  FD8.2
18438:  INCF   x8D,F
....................       } 
....................       if (macro_cmd != 35) ++line; 
1843A:  MOVF   x8A,W
1843C:  SUBLW  23
1843E:  BZ    18446
18440:  INCF   x87,F
18442:  BTFSC  FD8.2
18444:  INCF   x88,F
....................       if (macro_cmd != 59) printf("\r\n:"); 
18446:  MOVF   x8A,W
18448:  SUBLW  3B
1844A:  BZ    1846C
1844C:  MOVLW  EA
1844E:  MOVWF  FF6
18450:  MOVLW  20
18452:  MOVWF  FF7
18454:  MOVLW  00
18456:  MOVWF  FF8
18458:  CLRF   1B
1845A:  BTFSC  FF2.7
1845C:  BSF    1B.7
1845E:  BCF    FF2.7
18460:  MOVLB  0
18462:  CALL   0E42
18466:  BTFSC  1B.7
18468:  BSF    FF2.7
1846A:  MOVLB  8
1846C:  BRA    18406
....................    }       
....................    if (macro_cmd == 0){ 
1846E:  MOVF   x8A,F
18470:  BNZ   18506
....................       fprintf(COM_A, "\r\nWARNING: INVALID COMMAND IN MACRO!\r\n"); 
18472:  MOVLW  EE
18474:  MOVWF  FF6
18476:  MOVLW  20
18478:  MOVWF  FF7
1847A:  MOVLW  00
1847C:  MOVWF  FF8
1847E:  CLRF   1B
18480:  BTFSC  FF2.7
18482:  BSF    1B.7
18484:  BCF    FF2.7
18486:  MOVLB  0
18488:  CALL   0E42
1848C:  BTFSC  1B.7
1848E:  BSF    FF2.7
....................       fprintf(COM_A, "Bad command at line: %Ld \r\n",line); 
18490:  MOVLW  16
18492:  MOVWF  FF6
18494:  MOVLW  21
18496:  MOVWF  FF7
18498:  MOVLW  00
1849A:  MOVWF  FF8
1849C:  CLRF   1B
1849E:  BTFSC  FF2.7
184A0:  BSF    1B.7
184A2:  BCF    FF2.7
184A4:  MOVLW  15
184A6:  MOVLB  A
184A8:  MOVWF  x40
184AA:  MOVLB  0
184AC:  CALL   1018
184B0:  BTFSC  1B.7
184B2:  BSF    FF2.7
184B4:  MOVLW  10
184B6:  MOVWF  FE9
184B8:  MOVFF  888,8F1
184BC:  MOVFF  887,8F0
184C0:  CALL   8FD8
184C4:  MOVLW  2E
184C6:  MOVWF  FF6
184C8:  MOVLW  21
184CA:  MOVWF  FF7
184CC:  MOVLW  00
184CE:  MOVWF  FF8
184D0:  CLRF   1B
184D2:  BTFSC  FF2.7
184D4:  BSF    1B.7
184D6:  BCF    FF2.7
184D8:  MOVLW  03
184DA:  MOVLB  A
184DC:  MOVWF  x40
184DE:  MOVLB  0
184E0:  CALL   1018
184E4:  BTFSC  1B.7
184E6:  BSF    FF2.7
....................       fprintf(COM_A, "Please re-upload macro"); 
184E8:  MOVLW  32
184EA:  MOVWF  FF6
184EC:  MOVLW  21
184EE:  MOVWF  FF7
184F0:  MOVLW  00
184F2:  MOVWF  FF8
184F4:  CLRF   1B
184F6:  BTFSC  FF2.7
184F8:  BSF    1B.7
184FA:  BCF    FF2.7
184FC:  CALL   0E42
18500:  BTFSC  1B.7
18502:  BSF    FF2.7
18504:  MOVLB  8
....................    } 
....................    fprintf(COM_A, "\r\n"); 
18506:  MOVLW  0D
18508:  BTFSS  F9E.4
1850A:  BRA    18508
1850C:  MOVWF  FAD
1850E:  MOVLW  0A
18510:  BTFSS  F9E.4
18512:  BRA    18510
18514:  MOVWF  FAD
18516:  MOVLB  0
18518:  GOTO   186B4 (RETURN)
....................     
....................     
....................    //output_low(EEP_WP); 
.................... } 
....................  
.................... // *** READ MACRO FUNCTIONS *** // 
....................  
.................... int8 read_macro_line(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
186D6:  BCF    FD8.0
186D8:  MOVLB  8
186DA:  RLCF   x8B,W
186DC:  CLRF   03
186DE:  ADDLW  D1
186E0:  MOVWF  FE9
186E2:  MOVLW  07
186E4:  ADDWFC 03,W
186E6:  MOVWF  FEA
186E8:  MOVFF  FEC,894
186EC:  MOVF   FED,F
186EE:  MOVFF  FEF,893
186F2:  MOVFF  88D,A11
186F6:  MOVFF  88C,A10
186FA:  MOVLB  A
186FC:  CLRF   x13
186FE:  MOVLW  03
18700:  MOVWF  x12
18702:  MOVLB  0
18704:  CALL   5C8C
18708:  MOVF   01,W
1870A:  MOVLB  8
1870C:  ADDWF  x93,W
1870E:  MOVWF  x8E
18710:  MOVF   02,W
18712:  ADDWFC x94,W
18714:  MOVWF  x8F
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
18716:  MOVFF  88F,8CC
1871A:  MOVFF  88E,8CB
1871E:  MOVLB  0
18720:  CALL   105EE
18724:  MOVFF  01,890
....................    ++addr; 
18728:  MOVLB  8
1872A:  INCF   x8E,F
1872C:  BTFSC  FD8.2
1872E:  INCF   x8F,F
....................    macro_arg = read16_ext_eeprom(addr); 
18730:  MOVFF  88F,8C3
18734:  MOVFF  88E,8C2
18738:  MOVLB  0
1873A:  CALL   10702
1873E:  MOVFF  02,892
18742:  MOVFF  01,891
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
18746:  MOVLB  8
18748:  MOVF   x90,W
1874A:  BTFSS  F9E.4
1874C:  BRA    1874A
1874E:  MOVWF  FAD
18750:  MOVLW  10
18752:  MOVWF  FE9
18754:  CLRF   1B
18756:  BTFSC  FF2.7
18758:  BSF    1B.7
1875A:  BCF    FF2.7
1875C:  MOVFF  892,A41
18760:  MOVFF  891,A40
18764:  MOVLB  0
18766:  CALL   119A
1876A:  BTFSC  1B.7
1876C:  BSF    FF2.7
1876E:  MOVLW  0D
18770:  BTFSS  F9E.4
18772:  BRA    18770
18774:  MOVWF  FAD
18776:  MOVLW  0A
18778:  BTFSS  F9E.4
1877A:  BRA    18778
1877C:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
1877E:  MOVLB  8
18780:  MOVFF  890,01
18784:  MOVLB  0
18786:  GOTO   187BA (RETURN)
.................... } 
....................  
.................... int8 read_macro_line_silent(int8 macro, int16 line) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................     
....................    addr = macro_address[macro] + (line*3); 
*
1432E:  BCF    FD8.0
14330:  MOVLB  8
14332:  RLCF   xB7,W
14334:  CLRF   03
14336:  ADDLW  D1
14338:  MOVWF  FE9
1433A:  MOVLW  07
1433C:  ADDWFC 03,W
1433E:  MOVWF  FEA
14340:  MOVFF  FEC,8C0
14344:  MOVF   FED,F
14346:  MOVFF  FEF,8BF
1434A:  MOVFF  8B9,A11
1434E:  MOVFF  8B8,A10
14352:  MOVLB  A
14354:  CLRF   x13
14356:  MOVLW  03
14358:  MOVWF  x12
1435A:  MOVLB  0
1435C:  CALL   5C8C
14360:  MOVF   01,W
14362:  MOVLB  8
14364:  ADDWF  xBF,W
14366:  MOVWF  xBA
14368:  MOVF   02,W
1436A:  ADDWFC xC0,W
1436C:  MOVWF  xBB
....................     
....................    macro_cmd = read_ext_eeprom(addr); 
1436E:  MOVFF  8BB,8CC
14372:  MOVFF  8BA,8CB
14376:  MOVLB  0
14378:  CALL   105EE
1437C:  MOVFF  01,8BC
....................    ++addr; 
14380:  MOVLB  8
14382:  INCF   xBA,F
14384:  BTFSC  FD8.2
14386:  INCF   xBB,F
....................    macro_arg = read16_ext_eeprom(addr); 
14388:  MOVFF  8BB,8C3
1438C:  MOVFF  8BA,8C2
14390:  MOVLB  0
14392:  CALL   10702
14396:  MOVFF  02,8BE
1439A:  MOVFF  01,8BD
....................    fprintf(COM_A, "%c%Lu\r\n", macro_cmd, macro_arg); 
1439E:  MOVLB  8
143A0:  MOVF   xBC,W
143A2:  BTFSS  F9E.4
143A4:  BRA    143A2
143A6:  MOVWF  FAD
143A8:  MOVLW  10
143AA:  MOVWF  FE9
143AC:  CLRF   1B
143AE:  BTFSC  FF2.7
143B0:  BSF    1B.7
143B2:  BCF    FF2.7
143B4:  MOVFF  8BE,A41
143B8:  MOVFF  8BD,A40
143BC:  MOVLB  0
143BE:  CALL   119A
143C2:  BTFSC  1B.7
143C4:  BSF    FF2.7
143C6:  MOVLW  0D
143C8:  BTFSS  F9E.4
143CA:  BRA    143C8
143CC:  MOVWF  FAD
143CE:  MOVLW  0A
143D0:  BTFSS  F9E.4
143D2:  BRA    143D0
143D4:  MOVWF  FAD
....................     
....................    return(macro_cmd); 
143D6:  MOVLB  8
143D8:  MOVFF  8BC,01
143DC:  MOVLB  0
143DE:  GOTO   14BB6 (RETURN)
.................... } 
....................  
.................... /* the corresponding function for strings. See the equivalent write function 
.................... above for details*/ 
.................... void read_macro_line_string(int8 macro, int16 line, int16 count) 
.................... { 
....................    int16 addr; 
....................    addr = string_address[macro] + (count*50); 
*
10648:  BCF    FD8.0
1064A:  MOVLB  8
1064C:  RLCF   xB5,W
1064E:  CLRF   03
10650:  ADDLW  FB
10652:  MOVWF  FE9
10654:  MOVLW  07
10656:  ADDWFC 03,W
10658:  MOVWF  FEA
1065A:  MOVFF  FEC,8BE
1065E:  MOVF   FED,F
10660:  MOVFF  FEF,8BD
10664:  MOVFF  8B9,A11
10668:  MOVFF  8B8,A10
1066C:  MOVLB  A
1066E:  CLRF   x13
10670:  MOVLW  32
10672:  MOVWF  x12
10674:  MOVLB  0
10676:  CALL   5C8C
1067A:  MOVF   01,W
1067C:  MOVLB  8
1067E:  ADDWF  xBD,W
10680:  MOVWF  xBA
10682:  MOVF   02,W
10684:  ADDWFC xBE,W
10686:  MOVWF  xBB
....................     
....................    int i = 0; 
10688:  CLRF   xBC
....................    for(i = 0; i < 50; i++){ 
1068A:  CLRF   xBC
1068C:  MOVF   xBC,W
1068E:  SUBLW  31
10690:  BNC   106A6
....................       string_arg[i] = 0; 
10692:  CLRF   03
10694:  MOVF   xBC,W
10696:  ADDLW  25
10698:  MOVWF  FE9
1069A:  MOVLW  08
1069C:  ADDWFC 03,W
1069E:  MOVWF  FEA
106A0:  CLRF   FEF
106A2:  INCF   xBC,F
106A4:  BRA    1068C
....................    }  
....................    for(i = 0; i < 50; i++){ 
106A6:  CLRF   xBC
106A8:  MOVF   xBC,W
106AA:  SUBLW  31
106AC:  BNC   106FE
....................       string_arg[i] = read_ext_eeprom(addr + i); 
106AE:  CLRF   03
106B0:  MOVF   xBC,W
106B2:  ADDLW  25
106B4:  MOVWF  01
106B6:  MOVLW  08
106B8:  ADDWFC 03,F
106BA:  MOVFF  01,8BD
106BE:  MOVFF  03,8BE
106C2:  MOVF   xBC,W
106C4:  ADDWF  xBA,W
106C6:  MOVWF  xBF
106C8:  MOVLW  00
106CA:  ADDWFC xBB,W
106CC:  MOVWF  xC0
106CE:  MOVWF  xCC
106D0:  MOVFF  8BF,8CB
106D4:  MOVLB  0
106D6:  RCALL  105EE
106D8:  MOVFF  8BE,FEA
106DC:  MOVFF  8BD,FE9
106E0:  MOVFF  01,FEF
....................       //efficiency 
....................       if(string_arg[i] == 0){ 
106E4:  CLRF   03
106E6:  MOVLB  8
106E8:  MOVF   xBC,W
106EA:  ADDLW  25
106EC:  MOVWF  FE9
106EE:  MOVLW  08
106F0:  ADDWFC 03,W
106F2:  MOVWF  FEA
106F4:  MOVF   FEF,F
106F6:  BNZ   106FA
....................          break; 
106F8:  BRA    106FE
....................       } 
106FA:  INCF   xBC,F
106FC:  BRA    106A8
....................    }   
106FE:  MOVLB  0
10700:  RETURN 0
....................     
.................... } 
....................  
....................  
.................... void read_macro(int8 macro) 
*
1878A:  MOVLB  8
1878C:  CLRF   x8A
.................... { 
....................    int16 line; 
....................    int8  macro_cmd; 
....................    int count = 0; 
....................     
....................    line = 0;    
1878E:  CLRF   x88
18790:  CLRF   x87
....................    macro_cmd = 1; 
18792:  MOVLW  01
18794:  MOVWF  x89
....................     
....................    init_ext_eeprom(); 
18796:  MOVLB  0
18798:  CALL   105B6
....................     
....................    while (line < MACEND && macro_cmd != 59){      // 59 = ; 
1879C:  MOVLB  8
1879E:  MOVF   x88,W
187A0:  SUBLW  03
187A2:  BNC   187EA
187A4:  MOVF   x89,W
187A6:  SUBLW  3B
187A8:  BZ    187EA
....................       macro_cmd = read_macro_line(macro, line); 
187AA:  MOVFF  886,88B
187AE:  MOVFF  888,88D
187B2:  MOVFF  887,88C
187B6:  MOVLB  0
187B8:  BRA    186D6
187BA:  MOVFF  01,889
....................       if(macro_cmd == 'p'){ 
187BE:  MOVLB  8
187C0:  MOVF   x89,W
187C2:  SUBLW  70
187C4:  BNZ   187E2
....................          read_macro_line_string(macro,line,count); 
187C6:  MOVFF  886,8B5
187CA:  MOVFF  888,8B7
187CE:  MOVFF  887,8B6
187D2:  CLRF   xB9
187D4:  MOVFF  88A,8B8
187D8:  MOVLB  0
187DA:  CALL   10648
....................          count++; 
187DE:  MOVLB  8
187E0:  INCF   x8A,F
....................       } 
....................       ++line; 
187E2:  INCF   x87,F
187E4:  BTFSC  FD8.2
187E6:  INCF   x88,F
187E8:  BRA    1879E
....................    } 
187EA:  MOVLB  0
187EC:  GOTO   1880C (RETURN)
.................... }    
....................  
.................... // *** PLAY MACRO FUNCTIONS *** // 
....................  
.................... void delay_sec(int16 sec) 
.................... { 
....................    int16 j; 
....................     
....................    for (j=0; j<sec; ++j){ 
*
0D32E:  MOVLB  8
0D330:  CLRF   xC5
0D332:  CLRF   xC4
0D334:  MOVF   xC5,W
0D336:  SUBWF  xC3,W
0D338:  BNC   D360
0D33A:  BNZ   D342
0D33C:  MOVF   xC2,W
0D33E:  SUBWF  xC4,W
0D340:  BC    D360
....................       delay_ms(1000); 
0D342:  MOVLW  04
0D344:  MOVWF  xC6
0D346:  MOVLW  FA
0D348:  MOVLB  9
0D34A:  MOVWF  xEC
0D34C:  MOVLB  0
0D34E:  CALL   2904
0D352:  MOVLB  8
0D354:  DECFSZ xC6,F
0D356:  BRA    D346
0D358:  INCF   xC4,F
0D35A:  BTFSC  FD8.2
0D35C:  INCF   xC5,F
0D35E:  BRA    D334
....................    }  
0D360:  MOVLB  0
0D362:  RETURN 0
.................... } 
....................  
.................... int8 step_err_status() 
.................... { 
....................    int8 macro_status; 
....................     
....................    if (m_error[motor] == TRUE) 
*
0D2F6:  BCF    FD8.0
0D2F8:  MOVLB  7
0D2FA:  RLCF   x40,W
0D2FC:  CLRF   03
0D2FE:  ADDLW  96
0D300:  MOVWF  FE9
0D302:  MOVLW  07
0D304:  ADDWFC 03,W
0D306:  MOVWF  FEA
0D308:  MOVFF  FEC,8C4
0D30C:  MOVF   FED,F
0D30E:  MOVFF  FEF,8C3
0D312:  MOVLB  8
0D314:  DECFSZ xC3,W
0D316:  BRA    D322
0D318:  MOVF   xC4,F
0D31A:  BNZ   D322
....................    { 
....................       macro_status = 'e'; 
0D31C:  MOVLW  65
0D31E:  MOVWF  xC2
....................    } 
0D320:  BRA    D326
....................    else 
....................    { 
....................       macro_status = 'a'; 
0D322:  MOVLW  61
0D324:  MOVWF  xC2
....................    } 
....................    return(macro_status); 
0D326:  MOVFF  8C2,01
0D32A:  MOVLB  0
0D32C:  RETURN 0
.................... } 
....................  
.................... void get_reading() 
.................... { 
....................    if(nv_det_type==1) 
*
1384A:  DECFSZ 45,W
1384C:  BRA    13860
1384E:  MOVF   46,F
13850:  BNZ   13860
....................    { 
....................        get_det_read(TRUE,TRUE);    // store, display 
13852:  MOVLW  01
13854:  MOVLB  8
13856:  MOVWF  xC2
13858:  MOVWF  xC3
1385A:  MOVLB  0
1385C:  RCALL  13714
....................    } 
1385E:  BRA    1388A
....................    else if(nv_det_type==2 || nv_det_type==3) 
13860:  MOVF   45,W
13862:  SUBLW  02
13864:  BNZ   1386A
13866:  MOVF   46,F
13868:  BZ    13874
1386A:  MOVF   45,W
1386C:  SUBLW  03
1386E:  BNZ   1388A
13870:  MOVF   46,F
13872:  BNZ   1388A
....................    { 
....................       read_colorimeter(200,TRUE,TRUE,FALSE); 
13874:  MOVLB  8
13876:  CLRF   xC3
13878:  MOVLW  C8
1387A:  MOVWF  xC2
1387C:  MOVLW  01
1387E:  MOVWF  xC4
13880:  MOVWF  xC5
13882:  CLRF   xC6
13884:  MOVLB  0
13886:  CALL   10000
....................    } 
1388A:  RETURN 0
.................... } 
....................  
.................... void set_heat(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    if(nv_det_type==1) { 
*
12768:  DECFSZ 45,W
1276A:  BRA    12786
1276C:  MOVF   46,F
1276E:  BNZ   12786
....................       cmd = macro_cmd; 
12770:  MOVFF  8C2,47
....................       arg = macro_arg; 
12774:  CLRF   4B
12776:  CLRF   4A
12778:  MOVFF  8C4,49
1277C:  MOVFF  8C3,48
....................       det_cmd(); 
12780:  CALL   F3F6
....................    } 
12784:  BRA    127A0
....................    else if(nv_det_type==2 || nv_det_type==3) { 
12786:  MOVF   45,W
12788:  SUBLW  02
1278A:  BNZ   12790
1278C:  MOVF   46,F
1278E:  BZ    1279A
12790:  MOVF   45,W
12792:  SUBLW  03
12794:  BNZ   127A0
12796:  MOVF   46,F
12798:  BNZ   127A0
....................       set_heaters(macro_arg); 
1279A:  MOVFF  8C3,8C5
1279E:  RCALL  126F4
....................    } 
127A0:  RETURN 0
.................... } 
....................  
.................... void set_light(int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    //fprintf(COM_A,"%Lu\r\n",nv_det_type); 
....................    if(nv_det_type==1) { 
127A2:  DECFSZ 45,W
127A4:  BRA    127C0
127A6:  MOVF   46,F
127A8:  BNZ   127C0
....................       cmd = macro_cmd; 
127AA:  MOVFF  8C2,47
....................       arg = macro_arg; 
127AE:  CLRF   4B
127B0:  CLRF   4A
127B2:  MOVFF  8C4,49
127B6:  MOVFF  8C3,48
....................       det_cmd(); 
127BA:  CALL   F3F6
....................    } 
127BE:  BRA    127E0
....................    else if(nv_det_type==2 || nv_det_type==3) { 
127C0:  MOVF   45,W
127C2:  SUBLW  02
127C4:  BNZ   127CA
127C6:  MOVF   46,F
127C8:  BZ    127D4
127CA:  MOVF   45,W
127CC:  SUBLW  03
127CE:  BNZ   127E0
127D0:  MOVF   46,F
127D2:  BNZ   127E0
....................       set_LED(macro_arg); 
127D4:  MOVFF  8C4,8C6
127D8:  MOVFF  8C3,8C5
127DC:  CALL   F8BA
....................    } 
127E0:  RETURN 0
.................... } 
....................  
.................... // plays soft macros (search for "hard macro") 
.................... int16 count1 = 0; 
.................... int8 play_macro_line2(int8 macro, int16 line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
13F1E:  MOVLW  65
13F20:  MOVLB  8
13F22:  MOVWF  xC1
....................     
....................    addr = macro_address[macro] + (line*3); 
13F24:  BCF    FD8.0
13F26:  RLCF   xB7,W
13F28:  CLRF   03
13F2A:  ADDLW  D1
13F2C:  MOVWF  FE9
13F2E:  MOVLW  07
13F30:  ADDWFC 03,W
13F32:  MOVWF  FEA
13F34:  MOVFF  FEC,8C3
13F38:  MOVF   FED,F
13F3A:  MOVFF  FEF,8C2
13F3E:  MOVFF  8B9,A11
13F42:  MOVFF  8B8,A10
13F46:  MOVLB  A
13F48:  CLRF   x13
13F4A:  MOVLW  03
13F4C:  MOVWF  x12
13F4E:  MOVLB  0
13F50:  CALL   5C8C
13F54:  MOVF   01,W
13F56:  MOVLB  8
13F58:  ADDWF  xC2,W
13F5A:  MOVWF  xBC
13F5C:  MOVF   02,W
13F5E:  ADDWFC xC3,W
13F60:  MOVWF  xBD
....................  
....................    init_ext_eeprom(); 
13F62:  MOVLB  0
13F64:  CALL   105B6
....................    macro_cmd = read_ext_eeprom(addr); 
13F68:  MOVFF  8BD,8CC
13F6C:  MOVFF  8BC,8CB
13F70:  CALL   105EE
13F74:  MOVFF  01,8BE
....................    ++addr; 
13F78:  MOVLB  8
13F7A:  INCF   xBC,F
13F7C:  BTFSC  FD8.2
13F7E:  INCF   xBD,F
....................    //if(macro_cmd == 'p'){ 
....................      // read_macro_line_string(macro,line,count1); 
....................      // count1++; 
....................    //}else{ 
....................    macro_arg = read16_ext_eeprom(addr); 
13F80:  MOVFF  8BD,8C3
13F84:  MOVFF  8BC,8C2
13F88:  MOVLB  0
13F8A:  CALL   10702
13F8E:  MOVFF  02,8C0
13F92:  MOVFF  01,8BF
....................    //} 
....................    heartbeat(TRUE); 
13F96:  MOVLW  01
13F98:  MOVLB  8
13F9A:  MOVWF  xED
13F9C:  MOVLB  0
13F9E:  CALL   557A
....................     
....................    //if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
13FA2:  MOVF   2F,F
13FA4:  BTFSS  FD8.2
13FA6:  BRA    1426A
13FA8:  MOVF   30,F
13FAA:  BTFSS  FD8.2
13FAC:  BRA    1426A
....................       switch(macro_cmd) 
13FAE:  MOVLW  2B
13FB0:  MOVLB  8
13FB2:  SUBWF  xBE,W
13FB4:  ADDLW  B4
13FB6:  BTFSC  FD8.0
13FB8:  BRA    1426C
13FBA:  ADDLW  4C
13FBC:  MOVLB  0
13FBE:  GOTO   14276
....................       { 
....................          case 'A' : 
....................             calc_abs_data(); 
13FC2:  CALL   12580
....................             store_rel_data(); 
13FC6:  CALL   125E4
....................             macro_status = 'a'; 
13FCA:  MOVLW  61
13FCC:  MOVLB  8
13FCE:  MOVWF  xC1
....................             break; 
13FD0:  BRA    1426C
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
13FD2:  MOVLW  08
13FD4:  MOVWF  FEA
13FD6:  MOVLW  25
13FD8:  MOVWF  FE9
13FDA:  CALL   798A
13FDE:  MOVLW  0D
13FE0:  BTFSS  F9E.4
13FE2:  BRA    13FE0
13FE4:  MOVWF  FAD
13FE6:  MOVLW  0A
13FE8:  BTFSS  F9E.4
13FEA:  BRA    13FE8
13FEC:  MOVWF  FAD
....................             macro_status = 'a'; 
13FEE:  MOVLW  61
13FF0:  MOVLB  8
13FF2:  MOVWF  xC1
....................             break; 
13FF4:  BRA    1426C
....................          case 'C' : 
....................             calc_abs_data(); 
13FF6:  CALL   12580
....................             break; 
13FFA:  MOVLB  8
13FFC:  BRA    1426C
....................          case 'D' : //arg = macro_arg; //Test this later 
....................             //commandD(); 
....................             delay_sec(macro_arg); 
13FFE:  MOVFF  8C0,8C3
14002:  MOVFF  8BF,8C2
14006:  CALL   D32E
....................             macro_status = 'a'; 
1400A:  MOVLW  61
1400C:  MOVLB  8
1400E:  MOVWF  xC1
....................             break; 
14010:  BRA    1426C
....................          case 'F' : macro_flag = macro_arg; 
14012:  MOVFF  8C0,324
14016:  MOVFF  8BF,323
....................                     macro_status = 'a'; 
1401A:  MOVLW  61
1401C:  MOVLB  8
1401E:  MOVWF  xC1
....................             break ; 
14020:  BRA    1426C
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14022:  MOVFF  8BF,2D5
....................                     macro_status = 'a'; 
14026:  MOVLW  61
14028:  MOVLB  8
1402A:  MOVWF  xC1
....................             break ; 
1402C:  BRA    1426C
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
1402E:  MOVFF  8BE,8C2
14032:  MOVFF  8C0,8C4
14036:  MOVFF  8BF,8C3
1403A:  CALL   12768
....................                     macro_status = 'a'; 
1403E:  MOVLW  61
14040:  MOVLB  8
14042:  MOVWF  xC1
....................             break; 
14044:  BRA    1426C
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14046:  MOVFF  8BE,8C2
1404A:  MOVFF  8C0,8C4
1404E:  MOVFF  8BF,8C3
14052:  CALL   12768
....................                     macro_status = 'a'; 
14056:  MOVLW  61
14058:  MOVLB  8
1405A:  MOVWF  xC1
....................             break; 
1405C:  BRA    1426C
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
1405E:  MOVFF  8C0,8DC
14062:  MOVFF  8BF,8DB
14066:  MOVLB  8
14068:  CLRF   xDE
1406A:  MOVLW  64
1406C:  MOVWF  xDD
1406E:  MOVLB  0
14070:  CALL   2CC8
14074:  MOVFF  02,74D
14078:  MOVFF  01,74C
....................                     macro_status = 'a'; 
1407C:  MOVLW  61
1407E:  MOVLB  8
14080:  MOVWF  xC1
....................             break;    
14082:  BRA    1426C
....................          case 'l' : LightTargetFlag = 1; 
14084:  MOVLW  01
14086:  MOVLB  2
14088:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
1408A:  MOVFF  8BE,8C2
1408E:  MOVFF  8C0,8C4
14092:  MOVFF  8BF,8C3
14096:  MOVLB  0
14098:  CALL   127A2
....................                     delay_ms(10000); 
1409C:  MOVLW  28
1409E:  MOVLB  8
140A0:  MOVWF  xC2
140A2:  MOVLW  FA
140A4:  MOVLB  9
140A6:  MOVWF  xEC
140A8:  MOVLB  0
140AA:  CALL   2904
140AE:  MOVLB  8
140B0:  DECFSZ xC2,F
140B2:  BRA    140A2
....................                     macro_status = 'a'; 
140B4:  MOVLW  61
140B6:  MOVWF  xC1
....................             break;        
140B8:  BRA    1426C
....................          case 'L' : LightTargetFlag = 0; 
140BA:  MOVLB  2
140BC:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
140BE:  MOVFF  8BE,8C2
140C2:  MOVFF  8C0,8C4
140C6:  MOVFF  8BF,8C3
140CA:  MOVLB  0
140CC:  CALL   127A2
....................                     macro_status = 'a'; 
140D0:  MOVLW  61
140D2:  MOVLB  8
140D4:  MOVWF  xC1
....................             break; 
140D6:  BRA    1426C
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
140D8:  MOVFF  8BE,47
....................                     arg = macro_arg; 
140DC:  CLRF   4B
140DE:  CLRF   4A
140E0:  MOVFF  8C0,49
140E4:  MOVFF  8BF,48
....................                     det_cmd(); 
140E8:  CALL   F3F6
....................                     macro_status = 'a'; 
140EC:  MOVLW  61
140EE:  MOVLB  8
140F0:  MOVWF  xC1
....................             break ; 
140F2:  BRA    1426C
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
140F4:  MOVLB  8
140F6:  DECFSZ xBF,W
140F8:  BRA    14106
140FA:  MOVF   xC0,F
140FC:  BNZ   14106
140FE:  MOVLB  0
14100:  CALL   1384A
14104:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14106:  MOVF   xBF,W
14108:  SUBLW  02
1410A:  BNZ   1411C
1410C:  MOVF   xC0,F
1410E:  BNZ   1411C
14110:  MOVLW  01
14112:  MOVWF  xC2
14114:  MOVWF  xC3
14116:  MOVLB  0
14118:  RCALL  13A16
1411A:  MOVLB  8
....................                     macro_status = 'a'; 
1411C:  MOVLW  61
1411E:  MOVWF  xC1
....................             break ;  
14120:  BRA    1426C
....................          case 'T' : det_temp(); 
14122:  RCALL  13BD6
....................                     macro_status = 'a'; 
14124:  MOVLW  61
14126:  MOVLB  8
14128:  MOVWF  xC1
....................             break; 
1412A:  BRA    1426C
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
1412C:  MOVLW  01
1412E:  MOVLB  7
14130:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14132:  MOVLB  8
14134:  CLRF   xC7
14136:  CLRF   xC8
14138:  CLRF   xCC
1413A:  CLRF   xCB
1413C:  MOVFF  8C0,8CA
14140:  MOVFF  8BF,8C9
14144:  MOVWF  xCD
14146:  MOVLB  0
14148:  CALL   9D6C
....................                     macro_status=step_err_status(); 
1414C:  CALL   D2F6
14150:  MOVFF  01,8C1
....................             break; 
14154:  MOVLB  8
14156:  BRA    1426C
....................          case '-' : motor=1; 
14158:  MOVLW  01
1415A:  MOVLB  7
1415C:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
1415E:  MOVLB  8
14160:  CLRF   xC7
14162:  MOVWF  xC8
14164:  CLRF   xCC
14166:  CLRF   xCB
14168:  MOVFF  8C0,8CA
1416C:  MOVFF  8BF,8C9
14170:  MOVWF  xCD
14172:  MOVLB  0
14174:  CALL   9D6C
....................                     macro_status=step_err_status(); 
14178:  CALL   D2F6
1417C:  MOVFF  01,8C1
....................             break; 
14180:  MOVLB  8
14182:  BRA    1426C
....................          case 'G' : motor=0; 
14184:  MOVLB  7
14186:  CLRF   x40
....................                     align(0); 
14188:  MOVLB  8
1418A:  CLRF   xC2
1418C:  MOVLB  0
1418E:  CALL   A8A8
....................                     macro_status=step_err_status(); 
14192:  CALL   D2F6
14196:  MOVFF  01,8C1
....................             break ;           
1419A:  MOVLB  8
1419C:  BRA    1426C
....................          case 'P' : motor=0; 
1419E:  MOVLB  7
141A0:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
141A2:  MOVLW  01
141A4:  MOVLB  8
141A6:  MOVWF  xC7
141A8:  CLRF   xC8
141AA:  CLRF   xCC
141AC:  CLRF   xCB
141AE:  MOVFF  8C0,8CA
141B2:  MOVFF  8BF,8C9
141B6:  MOVWF  xCD
141B8:  MOVLB  0
141BA:  CALL   9D6C
....................                     macro_status=step_err_status(); 
141BE:  CALL   D2F6
141C2:  MOVFF  01,8C1
....................             break; 
141C6:  MOVLB  8
141C8:  BRA    1426C
....................          case 'Q' : motor=0; 
141CA:  MOVLB  7
141CC:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
141CE:  MOVLB  8
141D0:  CLRF   xC7
141D2:  CLRF   xC8
141D4:  CLRF   xCC
141D6:  CLRF   xCB
141D8:  MOVFF  8C0,8CA
141DC:  MOVFF  8BF,8C9
141E0:  MOVLW  01
141E2:  MOVWF  xCD
141E4:  MOVLB  0
141E6:  CALL   9D6C
....................                     macro_status=step_err_status(); 
141EA:  CALL   D2F6
141EE:  MOVFF  01,8C1
....................             break; 
141F2:  MOVLB  8
141F4:  BRA    1426C
....................          case 'R' : motor=0; 
141F6:  MOVLB  7
141F8:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
141FA:  MOVLB  8
141FC:  CLRF   xC7
141FE:  MOVLW  01
14200:  MOVWF  xC8
14202:  CLRF   xCC
14204:  CLRF   xCB
14206:  MOVFF  8C0,8CA
1420A:  MOVFF  8BF,8C9
1420E:  MOVWF  xCD
14210:  MOVLB  0
14212:  CALL   9D6C
....................                     macro_status=step_err_status(); 
14216:  CALL   D2F6
1421A:  MOVFF  01,8C1
....................             break; 
1421E:  MOVLB  8
14220:  BRA    1426C
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14222:  MOVLB  8
14224:  DECFSZ xBF,W
14226:  BRA    14236
14228:  MOVF   xC0,F
1422A:  BNZ   14236
1422C:  MOVLB  0
1422E:  CALL   D364
14232:  BRA    14244
14234:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14236:  MOVF   xBF,F
14238:  BNZ   14246
1423A:  MOVF   xC0,F
1423C:  BNZ   14246
1423E:  MOVLB  0
14240:  CALL   D388
14244:  MOVLB  8
....................                     macro_status = 'a'; 
14246:  MOVLW  61
14248:  MOVWF  xC1
....................             break; 
1424A:  BRA    1426C
....................          case 'v': 
....................             arg = macro_arg; 
1424C:  CLRF   4B
1424E:  CLRF   4A
14250:  MOVFF  8C0,49
14254:  MOVFF  8BF,48
....................             command_v(); 
14258:  RCALL  13DC2
....................             macro_status = 'a'; 
1425A:  MOVLW  61
1425C:  MOVLB  8
1425E:  MOVWF  xC1
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
14260:  BRA    1426C
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14262:  MOVLW  66
14264:  MOVLB  8
14266:  MOVWF  xC1
....................             break ; 
14268:  BRA    1426C
1426A:  MOVLB  8
....................       } 
....................    } 
....................        
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
1426C:  MOVFF  8C1,01
14270:  MOVLB  0
14272:  GOTO   14B7E (RETURN)
.................... } 
....................  
.................... //Duplicate of above function inserted because recursion not permitted so calls copy of self instead. 
.................... int8 play_macro_line(int8 macro, int16* line, int16 mmacro_var) 
.................... { 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_status; 
....................     
....................     
....................    macro_status = 'e'; // error 
*
149DA:  MOVLW  65
149DC:  MOVLB  8
149DE:  MOVWF  xA7
....................     
....................    addr = macro_address[macro] + ((*line)*3); 
149E0:  BCF    FD8.0
149E2:  RLCF   x9D,W
149E4:  CLRF   03
149E6:  ADDLW  D1
149E8:  MOVWF  FE9
149EA:  MOVLW  07
149EC:  ADDWFC 03,W
149EE:  MOVWF  FEA
149F0:  MOVFF  FEC,8B6
149F4:  MOVF   FED,F
149F6:  MOVFF  FEF,8B5
149FA:  MOVFF  89F,03
149FE:  MOVFF  89E,FE9
14A02:  MOVFF  89F,FEA
14A06:  MOVFF  FEC,A11
14A0A:  MOVF   FED,F
14A0C:  MOVFF  FEF,A10
14A10:  MOVLB  A
14A12:  CLRF   x13
14A14:  MOVLW  03
14A16:  MOVWF  x12
14A18:  MOVLB  0
14A1A:  CALL   5C8C
14A1E:  MOVF   01,W
14A20:  MOVLB  8
14A22:  ADDWF  xB5,W
14A24:  MOVWF  xA2
14A26:  MOVF   02,W
14A28:  ADDWFC xB6,W
14A2A:  MOVWF  xA3
....................  
....................    init_ext_eeprom(); 
14A2C:  MOVLB  0
14A2E:  CALL   105B6
....................    macro_cmd = read_ext_eeprom(addr); 
14A32:  MOVFF  8A3,8CC
14A36:  MOVFF  8A2,8CB
14A3A:  CALL   105EE
14A3E:  MOVFF  01,8A4
....................    ++addr; 
14A42:  MOVLB  8
14A44:  INCF   xA2,F
14A46:  BTFSC  FD8.2
14A48:  INCF   xA3,F
....................    if(macro_cmd == 'p'){ 
14A4A:  MOVF   xA4,W
14A4C:  SUBLW  70
14A4E:  BNZ   14A74
....................       //count1 keeps track of where in the string memory we are. 
....................       read_macro_line_string(macro,line,count1); 
14A50:  MOVFF  89D,8B5
14A54:  MOVFF  89F,8B7
14A58:  MOVFF  89E,8B6
14A5C:  MOVFF  858,8B9
14A60:  MOVFF  857,8B8
14A64:  MOVLB  0
14A66:  CALL   10648
....................       count1++; 
14A6A:  MOVLB  8
14A6C:  INCF   x57,F
14A6E:  BTFSC  FD8.2
14A70:  INCF   x58,F
....................    }else{ 
14A72:  BRA    14A8C
....................    macro_arg = read16_ext_eeprom(addr); 
14A74:  MOVFF  8A3,8C3
14A78:  MOVFF  8A2,8C2
14A7C:  MOVLB  0
14A7E:  CALL   10702
14A82:  MOVFF  02,8A6
14A86:  MOVFF  01,8A5
14A8A:  MOVLB  8
....................    } 
....................    heartbeat(TRUE); 
14A8C:  MOVLW  01
14A8E:  MOVWF  xED
14A90:  MOVLB  0
14A92:  CALL   557A
....................     
....................   // if (nv_report_mode >= 3) fprintf(COM_A, "@CMD[%c]ARG[%Lu]VAR[%Lu]\r\n", macro_cmd, macro_arg, mmacro_var); 
....................     
....................    if(nv_product==ECO){ 
14A96:  MOVF   2F,F
14A98:  BTFSS  FD8.2
14A9A:  BRA    14F00
14A9C:  MOVF   30,F
14A9E:  BTFSS  FD8.2
14AA0:  BRA    14F00
....................       switch(macro_cmd){ 
14AA2:  MOVLW  2B
14AA4:  MOVLB  8
14AA6:  SUBWF  xA4,W
14AA8:  ADDLW  B4
14AAA:  BTFSC  FD8.0
14AAC:  BRA    14EFC
14AAE:  ADDLW  4C
14AB0:  MOVLB  0
14AB2:  GOTO   151C6
....................          case 'A' : 
....................             calc_abs_data(); 
14AB6:  CALL   12580
....................             store_rel_data(); 
14ABA:  CALL   125E4
....................             macro_status = 'a'; 
14ABE:  MOVLW  61
14AC0:  MOVLB  8
14AC2:  MOVWF  xA7
....................             break; 
14AC4:  BRA    14EFC
....................          case 'p' : 
....................             fprintf(COM_A,"%s\r\n",string_arg); 
14AC6:  MOVLW  08
14AC8:  MOVWF  FEA
14ACA:  MOVLW  25
14ACC:  MOVWF  FE9
14ACE:  CALL   798A
14AD2:  MOVLW  0D
14AD4:  BTFSS  F9E.4
14AD6:  BRA    14AD4
14AD8:  MOVWF  FAD
14ADA:  MOVLW  0A
14ADC:  BTFSS  F9E.4
14ADE:  BRA    14ADC
14AE0:  MOVWF  FAD
....................             macro_status = 'a'; 
14AE2:  MOVLW  61
14AE4:  MOVLB  8
14AE6:  MOVWF  xA7
....................             break; 
14AE8:  BRA    14EFC
....................          case 'C' : 
....................             calc_abs_data(); 
14AEA:  CALL   12580
....................             break; 
14AEE:  MOVLB  8
14AF0:  BRA    14EFC
....................          //r is the repeat function 
....................          case 'r' : 
....................                   int32 count = 0; 
14AF2:  MOVLB  8
14AF4:  CLRF   xAB
14AF6:  CLRF   xAA
14AF8:  CLRF   xA9
14AFA:  CLRF   xA8
....................                   //Using a pointer for line so that its value is shared  
....................                   //accross functions. 
....................                   (*line)++; 
14AFC:  MOVFF  89F,03
14B00:  MOVFF  89E,FE9
14B04:  MOVFF  89F,FEA
14B08:  MOVLW  01
14B0A:  ADDWF  FEE,F
14B0C:  BNC   14B10
14B0E:  INCF   FEF,F
....................                   int32 start_line = (*line); 
....................                   int32 end_line = 0; 
14B10:  MOVFF  89E,FE9
14B14:  MOVFF  89F,FEA
14B18:  CLRF   xAF
14B1A:  CLRF   xAE
14B1C:  MOVFF  FEC,8AD
14B20:  MOVF   FED,F
14B22:  MOVFF  FEF,8AC
14B26:  CLRF   xB3
14B28:  CLRF   xB2
14B2A:  CLRF   xB1
14B2C:  CLRF   xB0
....................                    
....................                   while(count < macro_arg){ 
14B2E:  MOVF   xAB,F
14B30:  BTFSS  FD8.2
14B32:  BRA    14C6E
14B34:  MOVF   xAA,F
14B36:  BTFSS  FD8.2
14B38:  BRA    14C6E
14B3A:  MOVF   xA9,W
14B3C:  SUBWF  xA6,W
14B3E:  BTFSS  FD8.0
14B40:  BRA    14C6E
14B42:  BNZ   14B4C
14B44:  MOVF   xA5,W
14B46:  SUBWF  xA8,W
14B48:  BTFSC  FD8.0
14B4A:  BRA    14C6E
....................                      char curr = 'A'; 
14B4C:  MOVLW  41
14B4E:  MOVWF  xB4
....................                      while(curr != '%'){ 
14B50:  MOVF   xB4,W
14B52:  SUBLW  25
14B54:  BZ    14BC0
....................                         //This is added in because recursion is not supported. 
....................                         play_macro_line2(macro,(*line),mmacro_var); 
14B56:  MOVFF  89F,03
14B5A:  MOVFF  89E,FE9
14B5E:  MOVFF  89F,FEA
14B62:  MOVFF  FEC,8B9
14B66:  MOVF   FED,F
14B68:  MOVFF  FEF,8B8
14B6C:  MOVFF  89D,8B7
14B70:  MOVFF  8A1,8BB
14B74:  MOVFF  8A0,8BA
14B78:  MOVLB  0
14B7A:  GOTO   13F1E
....................                         (*line)++; 
14B7E:  MOVFF  89F,03
14B82:  MOVLB  8
14B84:  MOVF   x9E,W
14B86:  MOVWF  FE9
14B88:  MOVFF  03,FEA
14B8C:  MOVLW  01
14B8E:  ADDWF  FEE,F
14B90:  BNC   14B94
14B92:  INCF   FEF,F
....................                         //not actually silent, dunno why 
....................                         output_low(MD1_TXEN); // Turn off RS232 TX line to stop output of commands 
14B94:  BCF    F91.5
....................                         curr = read_macro_line_silent(macro,(*line)); 
14B96:  MOVFF  89F,03
14B9A:  MOVFF  89E,FE9
14B9E:  MOVFF  89F,FEA
14BA2:  MOVFF  FEC,8B9
14BA6:  MOVF   FED,F
14BA8:  MOVFF  FEF,8B8
14BAC:  MOVFF  89D,8B7
14BB0:  MOVLB  0
14BB2:  GOTO   1432E
14BB6:  MOVFF  01,8B4
....................                         output_high(MD1_TXEN); // Turn RS232 Tx back on 
14BBA:  BSF    F91.5
14BBC:  MOVLB  8
14BBE:  BRA    14B50
....................                      } 
....................                      end_line = (*line); 
14BC0:  MOVFF  89E,FE9
14BC4:  MOVFF  89F,FEA
14BC8:  CLRF   xB3
14BCA:  CLRF   xB2
14BCC:  MOVFF  FEC,8B1
14BD0:  MOVF   FED,F
14BD2:  MOVFF  FEF,8B0
....................                      count++; 
14BD6:  MOVLW  01
14BD8:  ADDWF  xA8,F
14BDA:  BTFSC  FD8.0
14BDC:  INCF   xA9,F
14BDE:  BTFSC  FD8.2
14BE0:  INCF   xAA,F
14BE2:  BTFSC  FD8.2
14BE4:  INCF   xAB,F
....................                      printf("Iterations left: %Lu\r\n",macro_arg - count); 
14BE6:  MOVF   xA8,W
14BE8:  SUBWF  xA5,W
14BEA:  MOVWF  xB5
14BEC:  MOVF   xA9,W
14BEE:  SUBWFB xA6,W
14BF0:  MOVWF  xB6
14BF2:  MOVLW  00
14BF4:  SUBFWB xAA,W
14BF6:  MOVWF  xB7
14BF8:  MOVLW  00
14BFA:  SUBFWB xAB,W
14BFC:  MOVWF  xB8
14BFE:  MOVLW  4A
14C00:  MOVWF  FF6
14C02:  MOVLW  21
14C04:  MOVWF  FF7
14C06:  MOVLW  00
14C08:  MOVWF  FF8
14C0A:  CLRF   1B
14C0C:  BTFSC  FF2.7
14C0E:  BSF    1B.7
14C10:  BCF    FF2.7
14C12:  MOVLW  11
14C14:  MOVLB  A
14C16:  MOVWF  x40
14C18:  MOVLB  0
14C1A:  CALL   1018
14C1E:  BTFSC  1B.7
14C20:  BSF    FF2.7
14C22:  MOVLW  41
14C24:  MOVWF  FE9
14C26:  CLRF   1B
14C28:  BTFSC  FF2.7
14C2A:  BSF    1B.7
14C2C:  BCF    FF2.7
14C2E:  MOVFF  8B8,A43
14C32:  MOVFF  8B7,A42
14C36:  MOVFF  8B6,A41
14C3A:  MOVFF  8B5,A40
14C3E:  CALL   10DE
14C42:  BTFSC  1B.7
14C44:  BSF    FF2.7
14C46:  MOVLW  0D
14C48:  BTFSS  F9E.4
14C4A:  BRA    14C48
14C4C:  MOVWF  FAD
14C4E:  MOVLW  0A
14C50:  BTFSS  F9E.4
14C52:  BRA    14C50
14C54:  MOVWF  FAD
....................                      (*line) = start_line; 
14C56:  MOVFF  89F,03
14C5A:  MOVLB  8
14C5C:  MOVFF  89E,FE9
14C60:  MOVFF  89F,FEA
14C64:  MOVFF  8AC,FEF
14C68:  MOVFF  8AD,FEC
14C6C:  BRA    14B2E
....................                   } 
....................                   (*line) = end_line + 1; 
14C6E:  MOVFF  89E,FE9
14C72:  MOVFF  89F,FEA
14C76:  MOVLW  01
14C78:  ADDWF  xB0,W
14C7A:  MOVWF  FEF
14C7C:  MOVLW  00
14C7E:  ADDWFC xB1,W
14C80:  MOVWF  FEC
....................                   macro_status = 'a'; 
14C82:  MOVLW  61
14C84:  MOVWF  xA7
....................             break; 
14C86:  BRA    14EFC
....................          case 'D' : //arg = macro_arg; //Test this later 
....................                     //commandD(); 
....................                     delay_sec(macro_arg); 
14C88:  MOVFF  8A6,8C3
14C8C:  MOVFF  8A5,8C2
14C90:  CALL   D32E
....................                     macro_status = 'a'; 
14C94:  MOVLW  61
14C96:  MOVLB  8
14C98:  MOVWF  xA7
....................             break; 
14C9A:  BRA    14EFC
....................          case 'F' : macro_flag = macro_arg; 
14C9C:  MOVFF  8A6,324
14CA0:  MOVFF  8A5,323
....................                     macro_status = 'a'; 
14CA4:  MOVLW  61
14CA6:  MOVLB  8
14CA8:  MOVWF  xA7
....................             break ; 
14CAA:  BRA    14EFC
....................          // detector commands 
....................          case '/' : detector = macro_arg; 
14CAC:  MOVFF  8A5,2D5
....................                     macro_status = 'a'; 
14CB0:  MOVLW  61
14CB2:  MOVLB  8
14CB4:  MOVWF  xA7
....................             break ; 
14CB6:  BRA    14EFC
....................          case 'd' : set_heat(macro_cmd,macro_arg); 
14CB8:  MOVFF  8A4,8C2
14CBC:  MOVFF  8A6,8C4
14CC0:  MOVFF  8A5,8C3
14CC4:  CALL   12768
....................                     macro_status = 'a'; 
14CC8:  MOVLW  61
14CCA:  MOVLB  8
14CCC:  MOVWF  xA7
....................             break; 
14CCE:  BRA    14EFC
....................          case 'H' : set_heat(macro_cmd,macro_arg); 
14CD0:  MOVFF  8A4,8C2
14CD4:  MOVFF  8A6,8C4
14CD8:  MOVFF  8A5,8C3
14CDC:  CALL   12768
....................                     macro_status = 'a'; 
14CE0:  MOVLW  61
14CE2:  MOVLB  8
14CE4:  MOVWF  xA7
....................             break; 
14CE6:  BRA    14EFC
....................          case 'i' : m_stp_int[1] = (macro_arg/100);  // Change syringe motor speed 
14CE8:  MOVFF  8A6,8DC
14CEC:  MOVFF  8A5,8DB
14CF0:  MOVLB  8
14CF2:  CLRF   xDE
14CF4:  MOVLW  64
14CF6:  MOVWF  xDD
14CF8:  MOVLB  0
14CFA:  CALL   2CC8
14CFE:  MOVFF  02,74D
14D02:  MOVFF  01,74C
....................                     macro_status = 'a'; 
14D06:  MOVLW  61
14D08:  MOVLB  8
14D0A:  MOVWF  xA7
....................             break;    
14D0C:  BRA    14EFC
....................          case 'l' : LightTargetFlag = 1; 
14D0E:  MOVLW  01
14D10:  MOVLB  2
14D12:  MOVWF  xD9
....................                     set_light(macro_cmd,macro_arg); 
14D14:  MOVFF  8A4,8C2
14D18:  MOVFF  8A6,8C4
14D1C:  MOVFF  8A5,8C3
14D20:  MOVLB  0
14D22:  CALL   127A2
....................                     delay_ms(10000); 
14D26:  MOVLW  28
14D28:  MOVLB  8
14D2A:  MOVWF  xB5
14D2C:  MOVLW  FA
14D2E:  MOVLB  9
14D30:  MOVWF  xEC
14D32:  MOVLB  0
14D34:  CALL   2904
14D38:  MOVLB  8
14D3A:  DECFSZ xB5,F
14D3C:  BRA    14D2C
....................                     macro_status = 'a'; 
14D3E:  MOVLW  61
14D40:  MOVWF  xA7
....................             break;        
14D42:  BRA    14EFC
....................          case 'L' : LightTargetFlag = 0; 
14D44:  MOVLB  2
14D46:  CLRF   xD9
....................                     set_light(macro_cmd,macro_arg); 
14D48:  MOVFF  8A4,8C2
14D4C:  MOVFF  8A6,8C4
14D50:  MOVFF  8A5,8C3
14D54:  MOVLB  0
14D56:  CALL   127A2
....................                     macro_status = 'a'; 
14D5A:  MOVLW  61
14D5C:  MOVLB  8
14D5E:  MOVWF  xA7
....................             break; 
14D60:  BRA    14EFC
....................          case 'K' : // set detector channel 1 or 2 
....................                     cmd = macro_cmd; 
14D62:  MOVFF  8A4,47
....................                     arg = macro_arg; 
14D66:  CLRF   4B
14D68:  CLRF   4A
14D6A:  MOVFF  8A6,49
14D6E:  MOVFF  8A5,48
....................                     det_cmd(); 
14D72:  CALL   F3F6
....................                     macro_status = 'a'; 
14D76:  MOVLW  61
14D78:  MOVLB  8
14D7A:  MOVWF  xA7
....................             break ; 
14D7C:  BRA    14EFC
....................          case 'S' : if(macro_arg==1) get_reading();     // store & display 
14D7E:  MOVLB  8
14D80:  DECFSZ xA5,W
14D82:  BRA    14D90
14D84:  MOVF   xA6,F
14D86:  BNZ   14D90
14D88:  MOVLB  0
14D8A:  CALL   1384A
14D8E:  MOVLB  8
....................                     if(macro_arg==2) probe_read(TRUE,TRUE); 
14D90:  MOVF   xA5,W
14D92:  SUBLW  02
14D94:  BNZ   14DA8
14D96:  MOVF   xA6,F
14D98:  BNZ   14DA8
14D9A:  MOVLW  01
14D9C:  MOVWF  xC2
14D9E:  MOVWF  xC3
14DA0:  MOVLB  0
14DA2:  CALL   13A16
14DA6:  MOVLB  8
....................                     macro_status = 'a'; 
14DA8:  MOVLW  61
14DAA:  MOVWF  xA7
....................             break ;  
14DAC:  BRA    14EFC
....................          case 'T' : det_temp(); 
14DAE:  CALL   13BD6
....................                     macro_status = 'a'; 
14DB2:  MOVLW  61
14DB4:  MOVLB  8
14DB6:  MOVWF  xA7
....................             break; 
14DB8:  BRA    14EFC
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14DBA:  MOVLW  01
14DBC:  MOVLB  7
14DBE:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14DC0:  MOVLB  8
14DC2:  CLRF   xC7
14DC4:  CLRF   xC8
14DC6:  CLRF   xCC
14DC8:  CLRF   xCB
14DCA:  MOVFF  8A6,8CA
14DCE:  MOVFF  8A5,8C9
14DD2:  MOVWF  xCD
14DD4:  MOVLB  0
14DD6:  CALL   9D6C
....................                     macro_status=step_err_status(); 
14DDA:  CALL   D2F6
14DDE:  MOVFF  01,8A7
....................             break; 
14DE2:  MOVLB  8
14DE4:  BRA    14EFC
....................          case '-' : motor=1; 
14DE6:  MOVLW  01
14DE8:  MOVLB  7
14DEA:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14DEC:  MOVLB  8
14DEE:  CLRF   xC7
14DF0:  MOVWF  xC8
14DF2:  CLRF   xCC
14DF4:  CLRF   xCB
14DF6:  MOVFF  8A6,8CA
14DFA:  MOVFF  8A5,8C9
14DFE:  MOVWF  xCD
14E00:  MOVLB  0
14E02:  CALL   9D6C
....................                     macro_status=step_err_status(); 
14E06:  CALL   D2F6
14E0A:  MOVFF  01,8A7
....................             break; 
14E0E:  MOVLB  8
14E10:  BRA    14EFC
....................          case 'G' : motor=0; 
14E12:  MOVLB  7
14E14:  CLRF   x40
....................                     align(0); 
14E16:  MOVLB  8
14E18:  CLRF   xC2
14E1A:  MOVLB  0
14E1C:  CALL   A8A8
....................                     macro_status=step_err_status(); 
14E20:  CALL   D2F6
14E24:  MOVFF  01,8A7
....................             break ;           
14E28:  MOVLB  8
14E2A:  BRA    14EFC
....................          case 'P' : motor=0; 
14E2C:  MOVLB  7
14E2E:  CLRF   x40
....................                     move_motor(1,0,macro_arg,1);   
14E30:  MOVLW  01
14E32:  MOVLB  8
14E34:  MOVWF  xC7
14E36:  CLRF   xC8
14E38:  CLRF   xCC
14E3A:  CLRF   xCB
14E3C:  MOVFF  8A6,8CA
14E40:  MOVFF  8A5,8C9
14E44:  MOVWF  xCD
14E46:  MOVLB  0
14E48:  CALL   9D6C
....................                     macro_status=step_err_status(); 
14E4C:  CALL   D2F6
14E50:  MOVFF  01,8A7
....................             break; 
14E54:  MOVLB  8
14E56:  BRA    14EFC
....................          case 'Q' : motor=0; 
14E58:  MOVLB  7
14E5A:  CLRF   x40
....................                     move_motor(0,0,macro_arg,1); 
14E5C:  MOVLB  8
14E5E:  CLRF   xC7
14E60:  CLRF   xC8
14E62:  CLRF   xCC
14E64:  CLRF   xCB
14E66:  MOVFF  8A6,8CA
14E6A:  MOVFF  8A5,8C9
14E6E:  MOVLW  01
14E70:  MOVWF  xCD
14E72:  MOVLB  0
14E74:  CALL   9D6C
....................                     macro_status=step_err_status(); 
14E78:  CALL   D2F6
14E7C:  MOVFF  01,8A7
....................             break; 
14E80:  MOVLB  8
14E82:  BRA    14EFC
....................          case 'R' : motor=0; 
14E84:  MOVLB  7
14E86:  CLRF   x40
....................                     move_motor(0,1,macro_arg,1); 
14E88:  MOVLB  8
14E8A:  CLRF   xC7
14E8C:  MOVLW  01
14E8E:  MOVWF  xC8
14E90:  CLRF   xCC
14E92:  CLRF   xCB
14E94:  MOVFF  8A6,8CA
14E98:  MOVFF  8A5,8C9
14E9C:  MOVWF  xCD
14E9E:  MOVLB  0
14EA0:  CALL   9D6C
....................                     macro_status=step_err_status(); 
14EA4:  CALL   D2F6
14EA8:  MOVFF  01,8A7
....................             break; 
14EAC:  MOVLB  8
14EAE:  BRA    14EFC
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
14EB0:  MOVLB  8
14EB2:  DECFSZ xA5,W
14EB4:  BRA    14EC4
14EB6:  MOVF   xA6,F
14EB8:  BNZ   14EC4
14EBA:  MOVLB  0
14EBC:  CALL   D364
14EC0:  BRA    14ED2
14EC2:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
14EC4:  MOVF   xA5,F
14EC6:  BNZ   14ED4
14EC8:  MOVF   xA6,F
14ECA:  BNZ   14ED4
14ECC:  MOVLB  0
14ECE:  CALL   D388
14ED2:  MOVLB  8
....................                     macro_status = 'a'; 
14ED4:  MOVLW  61
14ED6:  MOVWF  xA7
....................             break; 
14ED8:  BRA    14EFC
....................          case 'v':  
....................             arg = macro_arg; 
14EDA:  CLRF   4B
14EDC:  CLRF   4A
14EDE:  MOVFF  8A6,49
14EE2:  MOVFF  8A5,48
....................             command_v(); 
14EE6:  CALL   13DC2
....................             macro_status = 'a'; 
14EEA:  MOVLW  61
14EEC:  MOVLB  8
14EEE:  MOVWF  xA7
....................             /*if(macro_arg == 00){ 
....................                output_bit(PIN_D0,0); 
....................             }else if(macro_arg == 01){ 
....................                output_bit(PIN_D0,1); 
....................             }else if(macro_arg == 10){ 
....................                output_bit(PIN_D1,0); 
....................             }else if(macro_arg == 11){ 
....................                output_bit(PIN_D1,1); 
....................             }else if(macro_arg == 20){ 
....................                output_bit(PIN_D2,0); 
....................             }else if(macro_arg == 21){ 
....................                output_bit(PIN_D2,1); 
....................             }else if(macro_arg == 30){ 
....................                output_bit(PIN_D3,0); 
....................             }else if(macro_arg == 31){ 
....................                output_bit(PIN_D3,1); 
....................             }else if(macro_arg == 40){ 
....................                output_bit(PIN_D4,0); 
....................             }else if(macro_arg == 41){ 
....................                output_bit(PIN_D4,1); 
....................             }else if(macro_arg == 50){ 
....................                output_bit(PIN_D5,0); 
....................             }else if(macro_arg == 51){ 
....................                output_bit(PIN_D5,1); 
....................             }else if(macro_arg == 60){ 
....................                output_bit(PIN_D6,0); 
....................             }else if(macro_arg == 61){ 
....................                output_bit(PIN_D6,1); 
....................             }else if(macro_arg == 70){ 
....................                output_bit(PIN_D7,0); 
....................             }else if(macro_arg == 71){ 
....................                output_bit(PIN_D7,1); 
....................             }*/      
....................             break; 
14EF0:  BRA    14EFC
....................          // end of macro    
....................          case ';' : macro_status = 'f'; 
14EF2:  MOVLW  66
14EF4:  MOVLB  8
14EF6:  MOVWF  xA7
....................             break ; 
14EF8:  BRA    14EFC
14EFA:  MOVLB  8
....................       } 
....................    } 
14EFC:  BRA    151BC
14EFE:  MOVLB  0
....................    else if (nv_product==WMS4 || nv_product==WMS2){ 
14F00:  DECFSZ 2F,W
14F02:  BRA    14F08
14F04:  MOVF   30,F
14F06:  BZ    14F16
14F08:  MOVF   2F,W
14F0A:  SUBLW  03
14F0C:  BTFSS  FD8.2
14F0E:  BRA    15094
14F10:  MOVF   30,F
14F12:  BTFSS  FD8.2
14F14:  BRA    15094
....................       switch(macro_cmd){ 
14F16:  MOVLB  8
14F18:  MOVF   xA4,W
14F1A:  XORLW  2B
14F1C:  MOVLB  0
14F1E:  BZ    14F4C
14F20:  XORLW  06
14F22:  BZ    14F76
14F24:  XORLW  6F
14F26:  BZ    14FA0
14F28:  XORLW  05
14F2A:  BZ    14FB2
14F2C:  XORLW  17
14F2E:  BZ    14FCA
14F30:  XORLW  01
14F32:  BZ    14FF4
14F34:  XORLW  03
14F36:  BZ    1501E
14F38:  XORLW  06
14F3A:  BTFSC  FD8.2
14F3C:  BRA    15048
14F3E:  XORLW  0D
14F40:  BTFSC  FD8.2
14F42:  BRA    1505E
14F44:  XORLW  62
14F46:  BTFSC  FD8.2
14F48:  BRA    1508A
14F4A:  BRA    15092
....................          //!      case 'L' : switch_valve(macro_arg); 
....................          //!                 macro_status = 'a'; 
....................          //!         break;       
....................           
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
14F4C:  MOVLW  01
14F4E:  MOVLB  7
14F50:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
14F52:  MOVLB  8
14F54:  CLRF   xC7
14F56:  CLRF   xC8
14F58:  CLRF   xCC
14F5A:  CLRF   xCB
14F5C:  MOVFF  8A6,8CA
14F60:  MOVFF  8A5,8C9
14F64:  MOVWF  xCD
14F66:  MOVLB  0
14F68:  CALL   9D6C
....................                     macro_status=step_err_status(); 
14F6C:  CALL   D2F6
14F70:  MOVFF  01,8A7
....................             break; 
14F74:  BRA    15092
....................          case '-' : motor=1; 
14F76:  MOVLW  01
14F78:  MOVLB  7
14F7A:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
14F7C:  MOVLB  8
14F7E:  CLRF   xC7
14F80:  MOVWF  xC8
14F82:  CLRF   xCC
14F84:  CLRF   xCB
14F86:  MOVFF  8A6,8CA
14F8A:  MOVFF  8A5,8C9
14F8E:  MOVWF  xCD
14F90:  MOVLB  0
14F92:  CALL   9D6C
....................                     macro_status=step_err_status(); 
14F96:  CALL   D2F6
14F9A:  MOVFF  01,8A7
....................             break; 
14F9E:  BRA    15092
....................          case 'B' : h_bridge(macro_arg); 
14FA0:  MOVFF  8A5,8B5
14FA4:  CALL   C244
....................                     macro_status = 'a'; 
14FA8:  MOVLW  61
14FAA:  MOVLB  8
14FAC:  MOVWF  xA7
....................             break;             
14FAE:  MOVLB  0
14FB0:  BRA    15092
....................          case 'G' : motor=0; 
14FB2:  MOVLB  7
14FB4:  CLRF   x40
....................                     align(0); 
14FB6:  MOVLB  8
14FB8:  CLRF   xC2
14FBA:  MOVLB  0
14FBC:  CALL   A8A8
....................                     macro_status=step_err_status(); 
14FC0:  CALL   D2F6
14FC4:  MOVFF  01,8A7
....................             break ;           
14FC8:  BRA    15092
....................          case 'P' : motor=0; 
14FCA:  MOVLB  7
14FCC:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1);   
14FCE:  MOVLB  8
14FD0:  CLRF   xC7
14FD2:  CLRF   xC8
14FD4:  CLRF   xCC
14FD6:  CLRF   xCB
14FD8:  MOVFF  8A1,8CA
14FDC:  MOVFF  8A0,8C9
14FE0:  MOVLW  01
14FE2:  MOVWF  xCD
14FE4:  MOVLB  0
14FE6:  CALL   9D6C
....................                     macro_status=step_err_status(); 
14FEA:  CALL   D2F6
14FEE:  MOVFF  01,8A7
....................             break; 
14FF2:  BRA    15092
....................          case 'Q' : motor=0; 
14FF4:  MOVLB  7
14FF6:  CLRF   x40
....................                     move_motor(0,0,mmacro_var,1); 
14FF8:  MOVLB  8
14FFA:  CLRF   xC7
14FFC:  CLRF   xC8
14FFE:  CLRF   xCC
15000:  CLRF   xCB
15002:  MOVFF  8A1,8CA
15006:  MOVFF  8A0,8C9
1500A:  MOVLW  01
1500C:  MOVWF  xCD
1500E:  MOVLB  0
15010:  CALL   9D6C
....................                     macro_status=step_err_status(); 
15014:  CALL   D2F6
15018:  MOVFF  01,8A7
....................             break; 
1501C:  BRA    15092
....................          case 'R' : motor=0; 
1501E:  MOVLB  7
15020:  CLRF   x40
....................                     move_motor(0,1,mmacro_var,1); 
15022:  MOVLB  8
15024:  CLRF   xC7
15026:  MOVLW  01
15028:  MOVWF  xC8
1502A:  CLRF   xCC
1502C:  CLRF   xCB
1502E:  MOVFF  8A1,8CA
15032:  MOVFF  8A0,8C9
15036:  MOVWF  xCD
15038:  MOVLB  0
1503A:  CALL   9D6C
....................                     macro_status=step_err_status(); 
1503E:  CALL   D2F6
15042:  MOVFF  01,8A7
....................             break; 
15046:  BRA    15092
....................          // end stepper commands 
....................          case 'T' : delay_sec(macro_arg); 
15048:  MOVFF  8A6,8C3
1504C:  MOVFF  8A5,8C2
15050:  CALL   D32E
....................                     macro_status = 'a'; 
15054:  MOVLW  61
15056:  MOVLB  8
15058:  MOVWF  xA7
....................             break; 
1505A:  MOVLB  0
1505C:  BRA    15092
....................       case 'Y'    : if (macro_arg == 1) bus_on(); 
1505E:  MOVLB  8
15060:  DECFSZ xA5,W
15062:  BRA    15072
15064:  MOVF   xA6,F
15066:  BNZ   15072
15068:  MOVLB  0
1506A:  CALL   D364
1506E:  BRA    15080
15070:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
15072:  MOVF   xA5,F
15074:  BNZ   15082
15076:  MOVF   xA6,F
15078:  BNZ   15082
1507A:  MOVLB  0
1507C:  CALL   D388
15080:  MOVLB  8
....................                     macro_status = 'a'; 
15082:  MOVLW  61
15084:  MOVWF  xA7
....................             break; 
15086:  MOVLB  0
15088:  BRA    15092
....................          case ';' : macro_status = 'f'; 
1508A:  MOVLW  66
1508C:  MOVLB  8
1508E:  MOVWF  xA7
....................             break;            
15090:  MOVLB  0
....................       } 
....................    } 
15092:  BRA    151BA
....................    else if (nv_product==AWS){ 
15094:  MOVF   2F,W
15096:  SUBLW  02
15098:  BTFSS  FD8.2
1509A:  BRA    151BA
1509C:  MOVF   30,F
1509E:  BTFSS  FD8.2
150A0:  BRA    151BA
....................       switch(macro_cmd){ 
150A2:  MOVLB  8
150A4:  MOVF   xA4,W
150A6:  XORLW  2B
150A8:  MOVLB  0
150AA:  BZ    150D0
150AC:  XORLW  06
150AE:  BZ    150FA
150B0:  XORLW  6E
150B2:  BZ    15124
150B4:  XORLW  07
150B6:  BZ    15136
150B8:  XORLW  14
150BA:  BZ    1514C
150BC:  XORLW  01
150BE:  BZ    1515E
150C0:  XORLW  02
150C2:  BZ    15170
150C4:  XORLW  0A
150C6:  BZ    15186
150C8:  XORLW  62
150CA:  BTFSC  FD8.2
150CC:  BRA    151B2
150CE:  BRA    151BA
....................          // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................          case '+' : motor=1; 
150D0:  MOVLW  01
150D2:  MOVLB  7
150D4:  MOVWF  x40
....................                     move_motor(0,0,macro_arg,1); 
150D6:  MOVLB  8
150D8:  CLRF   xC7
150DA:  CLRF   xC8
150DC:  CLRF   xCC
150DE:  CLRF   xCB
150E0:  MOVFF  8A6,8CA
150E4:  MOVFF  8A5,8C9
150E8:  MOVWF  xCD
150EA:  MOVLB  0
150EC:  CALL   9D6C
....................                     macro_status=step_err_status(); 
150F0:  CALL   D2F6
150F4:  MOVFF  01,8A7
....................             break; 
150F8:  BRA    151BA
....................          case '-' : motor=1; 
150FA:  MOVLW  01
150FC:  MOVLB  7
150FE:  MOVWF  x40
....................                     move_motor(0,1,macro_arg,1); 
15100:  MOVLB  8
15102:  CLRF   xC7
15104:  MOVWF  xC8
15106:  CLRF   xCC
15108:  CLRF   xCB
1510A:  MOVFF  8A6,8CA
1510E:  MOVFF  8A5,8C9
15112:  MOVWF  xCD
15114:  MOVLB  0
15116:  CALL   9D6C
....................                     macro_status=step_err_status(); 
1511A:  CALL   D2F6
1511E:  MOVFF  01,8A7
....................             break; 
15122:  BRA    151BA
....................          // end stepper commands 
....................          case 'C' : sol_chip_cmd(macro_arg); 
15124:  MOVFF  8A5,8B6
15128:  CALL   DBAA
....................                     macro_status = 'a';  
1512C:  MOVLW  61
1512E:  MOVLB  8
15130:  MOVWF  xA7
....................             break;          
15132:  MOVLB  0
15134:  BRA    151BA
....................          case 'D' : delay_sec(macro_arg); 
15136:  MOVFF  8A6,8C3
1513A:  MOVFF  8A5,8C2
1513E:  CALL   D32E
....................                     macro_status = 'a'; 
15142:  MOVLW  61
15144:  MOVLB  8
15146:  MOVWF  xA7
....................             break; 
15148:  MOVLB  0
1514A:  BRA    151BA
....................          case 'P' : sol_switch(mmacro_var); 
1514C:  MOVFF  8A0,8B5
15150:  CALL   14552
....................                     macro_status = 'a'; 
15154:  MOVLW  61
15156:  MOVLB  8
15158:  MOVWF  xA7
....................             break;              
1515A:  MOVLB  0
1515C:  BRA    151BA
....................          case 'Q' : sol_switch(macro_arg); 
1515E:  MOVFF  8A5,8B5
15162:  CALL   14552
....................                     macro_status = 'a'; 
15166:  MOVLW  61
15168:  MOVLB  8
1516A:  MOVWF  xA7
....................             break;             
1516C:  MOVLB  0
1516E:  BRA    151BA
....................          case 'S' : sol_switch_cmd(macro_arg); 
15170:  MOVFF  8A6,8B7
15174:  MOVFF  8A5,8B6
15178:  CALL   1449C
....................                     macro_status = 'a'; 
1517C:  MOVLW  61
1517E:  MOVLB  8
15180:  MOVWF  xA7
....................             break; 
15182:  MOVLB  0
15184:  BRA    151BA
....................          // bus power ON/OFF 
....................          case 'Y' : if (macro_arg == 1) bus_on(); 
15186:  MOVLB  8
15188:  DECFSZ xA5,W
1518A:  BRA    1519A
1518C:  MOVF   xA6,F
1518E:  BNZ   1519A
15190:  MOVLB  0
15192:  CALL   D364
15196:  BRA    151A8
15198:  MOVLB  8
....................                     else if (macro_arg == 0) bus_off(); 
1519A:  MOVF   xA5,F
1519C:  BNZ   151AA
1519E:  MOVF   xA6,F
151A0:  BNZ   151AA
151A2:  MOVLB  0
151A4:  CALL   D388
151A8:  MOVLB  8
....................                     macro_status = 'a'; 
151AA:  MOVLW  61
151AC:  MOVWF  xA7
....................             break;               
151AE:  MOVLB  0
151B0:  BRA    151BA
....................          case ';' : macro_status = 'f'; 
151B2:  MOVLW  66
151B4:  MOVLB  8
151B6:  MOVWF  xA7
....................             break;            
151B8:  MOVLB  0
151BA:  MOVLB  8
....................       } 
....................    }    
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                50(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
151BC:  MOVFF  8A7,01
151C0:  MOVLB  0
151C2:  GOTO   154DA (RETURN)
.................... } 
....................  
....................  
.................... // pass macro number and variable used in macro 
.................... void play_macro(int8 macro, int16 mmacro_var) 
.................... { 
....................    int16 line; 
....................    int8  macro_status; 
....................    count1=0; 
*
153A8:  MOVLB  8
153AA:  CLRF   x58
153AC:  CLRF   x57
....................     
....................    clear_time_stmp_str(); // function store_rel_data() uses this to test for a reading 
153AE:  MOVLB  0
153B0:  CALL   50DA
....................    clear_data_arrays(); 
153B4:  GOTO   104F0
....................     
....................    line = 0;  
153B8:  MOVLB  8
153BA:  CLRF   x9B
153BC:  CLRF   x9A
....................    macro_status = 'a'; 
153BE:  MOVLW  61
153C0:  MOVWF  x9C
....................    data_available = FALSE; 
153C2:  MOVLB  3
153C4:  CLRF   x3B
....................    macro_flag = 900; 
153C6:  MOVLW  03
153C8:  MOVWF  x24
153CA:  MOVLW  84
153CC:  MOVWF  x23
....................     
....................    sprintf(event_str, ",macro[%u],start\r\n", macro); 
153CE:  MOVLW  01
153D0:  MOVWF  1E
153D2:  MOVLW  A7
153D4:  MOVWF  1D
153D6:  MOVLW  62
153D8:  MOVWF  FF6
153DA:  MOVLW  21
153DC:  MOVWF  FF7
153DE:  MOVLW  00
153E0:  MOVWF  FF8
153E2:  MOVLW  07
153E4:  MOVLB  8
153E6:  MOVWF  xEB
153E8:  MOVLB  0
153EA:  CALL   AAC0
153EE:  MOVFF  897,8ED
153F2:  MOVLW  1B
153F4:  MOVLB  8
153F6:  MOVWF  xEE
153F8:  MOVLB  0
153FA:  CALL   5274
153FE:  MOVLW  6B
15400:  MOVWF  FF6
15402:  MOVLW  21
15404:  MOVWF  FF7
15406:  MOVLW  00
15408:  MOVWF  FF8
1540A:  MOVLW  09
1540C:  MOVLB  8
1540E:  MOVWF  xEB
15410:  MOVLB  0
15412:  CALL   AAC0
....................    record_event();    
15416:  CALL   84CE
....................    
....................   // moved to below macro execution for proper port labeling 
....................   /* switch(nv_product){ 
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
....................          break; 
....................       case AWS : store_aws_data(macro,mmacro_var); 
....................          break; 
....................    } */ 
....................     
....................     
....................    // runs until line > end of memory AND macro status is  
....................    // ... NOT finished or something bad 
....................    while (line < MACEND && macro_status == 'a') 
1541A:  MOVLB  8
1541C:  MOVF   x9B,W
1541E:  SUBLW  03
15420:  BNC   154F2
15422:  MOVF   x9C,W
15424:  SUBLW  61
15426:  BNZ   154F2
....................    {       
....................       if(nv_report_mode == 4) fprintf (COM_A, "@MCL[%c][%Lu]\r\n",  
15428:  MOVF   1F,W
1542A:  SUBLW  04
1542C:  BNZ   154C0
1542E:  MOVF   20,F
15430:  BNZ   154C0
....................                                                macro_status, (line + 1)); 
15432:  MOVLW  01
15434:  ADDWF  x9A,W
15436:  MOVWF  x9D
15438:  MOVLW  00
1543A:  ADDWFC x9B,W
1543C:  MOVWF  x9E
1543E:  MOVLW  76
15440:  MOVWF  FF6
15442:  MOVLW  21
15444:  MOVWF  FF7
15446:  MOVLW  00
15448:  MOVWF  FF8
1544A:  CLRF   1B
1544C:  BTFSC  FF2.7
1544E:  BSF    1B.7
15450:  BCF    FF2.7
15452:  MOVLW  05
15454:  MOVLB  A
15456:  MOVWF  x40
15458:  MOVLB  0
1545A:  CALL   1018
1545E:  BTFSC  1B.7
15460:  BSF    FF2.7
15462:  MOVLB  8
15464:  MOVF   x9C,W
15466:  BTFSS  F9E.4
15468:  BRA    15466
1546A:  MOVWF  FAD
1546C:  MOVLW  5D
1546E:  BTFSS  F9E.4
15470:  BRA    1546E
15472:  MOVWF  FAD
15474:  MOVLW  5B
15476:  BTFSS  F9E.4
15478:  BRA    15476
1547A:  MOVWF  FAD
1547C:  MOVLW  10
1547E:  MOVWF  FE9
15480:  CLRF   1B
15482:  BTFSC  FF2.7
15484:  BSF    1B.7
15486:  BCF    FF2.7
15488:  MOVFF  89E,A41
1548C:  MOVFF  89D,A40
15490:  MOVLB  0
15492:  CALL   119A
15496:  BTFSC  1B.7
15498:  BSF    FF2.7
1549A:  MOVLW  82
1549C:  MOVWF  FF6
1549E:  MOVLW  21
154A0:  MOVWF  FF7
154A2:  MOVLW  00
154A4:  MOVWF  FF8
154A6:  CLRF   1B
154A8:  BTFSC  FF2.7
154AA:  BSF    1B.7
154AC:  BCF    FF2.7
154AE:  MOVLW  03
154B0:  MOVLB  A
154B2:  MOVWF  x40
154B4:  MOVLB  0
154B6:  CALL   1018
154BA:  BTFSC  1B.7
154BC:  BSF    FF2.7
154BE:  MOVLB  8
....................       macro_status = play_macro_line(macro, &line, mmacro_var); 
154C0:  MOVFF  897,89D
154C4:  MOVLW  08
154C6:  MOVWF  x9F
154C8:  MOVLW  9A
154CA:  MOVWF  x9E
154CC:  MOVFF  899,8A1
154D0:  MOVFF  898,8A0
154D4:  MOVLB  0
154D6:  GOTO   149DA
154DA:  MOVFF  01,89C
....................       ++line; 
154DE:  MOVLB  8
154E0:  INCF   x9A,F
154E2:  BTFSC  FD8.2
154E4:  INCF   x9B,F
....................       
....................       if (user_quit == TRUE) {           // 17 = CTRL-Q (quit) 
154E6:  DECFSZ 50,W
154E8:  BRA    154F0
....................          macro_status = 'g'; 
154EA:  MOVLW  67
154EC:  MOVWF  x9C
....................          break;    
154EE:  BRA    154F2
....................       } 
154F0:  BRA    1541C
....................    } 
....................     
....................    // writes data to uart and SD card 
....................    switch(nv_product){ 
154F2:  MOVF   2F,W
154F4:  MOVWF  00
154F6:  MOVF   30,W
154F8:  MOVWF  03
154FA:  MOVF   03,W
154FC:  BNZ   15508
154FE:  MOVLW  01
15500:  SUBWF  00,W
15502:  MOVLB  0
15504:  BZ    15526
15506:  MOVLB  8
15508:  MOVF   03,W
1550A:  BNZ   15516
1550C:  MOVLW  03
1550E:  SUBWF  00,W
15510:  MOVLB  0
15512:  BZ    15526
15514:  MOVLB  8
15516:  MOVF   03,W
15518:  BNZ   15524
1551A:  MOVLW  02
1551C:  SUBWF  00,W
1551E:  MOVLB  0
15520:  BZ    15532
15522:  MOVLB  8
15524:  BRA    15542
....................       case WMS4 :  
....................       case WMS2 : store_wms_data(macro); 
15526:  MOVFF  897,89D
1552A:  CALL   D632
....................          break; 
1552E:  MOVLB  8
15530:  BRA    15542
....................       case AWS : store_aws_data(macro,mmacro_var); 
15532:  MOVFF  897,89D
15536:  MOVFF  899,89F
1553A:  MOVFF  898,89E
1553E:  BRA    1527E
....................          break; 
15540:  MOVLB  8
....................    } 
....................     
....................    switch(macro_status){ 
15542:  MOVLW  61
15544:  SUBWF  x9C,W
15546:  ADDLW  F9
15548:  BC    15634
1554A:  ADDLW  07
1554C:  MOVLB  0
1554E:  GOTO   156E0
....................       case 'a': fprintf(COM_A, "@LNE\r\n"); 
15552:  MOVLW  86
15554:  MOVWF  FF6
15556:  MOVLW  21
15558:  MOVWF  FF7
1555A:  MOVLW  00
1555C:  MOVWF  FF8
1555E:  CLRF   1B
15560:  BTFSC  FF2.7
15562:  BSF    1B.7
15564:  BCF    FF2.7
15566:  CALL   0E42
1556A:  BTFSC  1B.7
1556C:  BSF    FF2.7
....................          break; 
1556E:  MOVLB  8
15570:  BRA    15634
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
15572:  MOVLW  8E
15574:  MOVWF  FF6
15576:  MOVLW  21
15578:  MOVWF  FF7
1557A:  MOVLW  00
1557C:  MOVWF  FF8
1557E:  CLRF   1B
15580:  BTFSC  FF2.7
15582:  BSF    1B.7
15584:  BCF    FF2.7
15586:  CALL   0E42
1558A:  BTFSC  1B.7
1558C:  BSF    FF2.7
....................          break; 
1558E:  MOVLB  8
15590:  BRA    15634
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
15592:  MOVLW  96
15594:  MOVWF  FF6
15596:  MOVLW  21
15598:  MOVWF  FF7
1559A:  MOVLW  00
1559C:  MOVWF  FF8
1559E:  CLRF   1B
155A0:  BTFSC  FF2.7
155A2:  BSF    1B.7
155A4:  BCF    FF2.7
155A6:  CALL   0E42
155AA:  BTFSC  1B.7
155AC:  BSF    FF2.7
....................          break; 
155AE:  MOVLB  8
155B0:  BRA    15634
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
155B2:  MOVLW  9E
155B4:  MOVWF  FF6
155B6:  MOVLW  21
155B8:  MOVWF  FF7
155BA:  MOVLW  00
155BC:  MOVWF  FF8
155BE:  CLRF   1B
155C0:  BTFSC  FF2.7
155C2:  BSF    1B.7
155C4:  BCF    FF2.7
155C6:  CALL   0E42
155CA:  BTFSC  1B.7
155CC:  BSF    FF2.7
....................          break; 
155CE:  MOVLB  8
155D0:  BRA    15634
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
155D2:  MOVLW  A6
155D4:  MOVWF  FF6
155D6:  MOVLW  21
155D8:  MOVWF  FF7
155DA:  MOVLW  00
155DC:  MOVWF  FF8
155DE:  CLRF   1B
155E0:  BTFSC  FF2.7
155E2:  BSF    1B.7
155E4:  BCF    FF2.7
155E6:  CALL   0E42
155EA:  BTFSC  1B.7
155EC:  BSF    FF2.7
....................          break;    
155EE:  MOVLB  8
155F0:  BRA    15634
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
155F2:  MOVLW  AE
155F4:  MOVWF  FF6
155F6:  MOVLW  21
155F8:  MOVWF  FF7
155FA:  MOVLW  00
155FC:  MOVWF  FF8
155FE:  CLRF   1B
15600:  BTFSC  FF2.7
15602:  BSF    1B.7
15604:  BCF    FF2.7
15606:  CALL   0E42
1560A:  BTFSC  1B.7
1560C:  BSF    FF2.7
....................          break;    
1560E:  MOVLB  8
15610:  BRA    15634
....................       case 'g': fprintf(COM_A, "@HLT\r\n"); 
15612:  MOVLW  B6
15614:  MOVWF  FF6
15616:  MOVLW  21
15618:  MOVWF  FF7
1561A:  MOVLW  00
1561C:  MOVWF  FF8
1561E:  CLRF   1B
15620:  BTFSC  FF2.7
15622:  BSF    1B.7
15624:  BCF    FF2.7
15626:  CALL   0E42
1562A:  BTFSC  1B.7
1562C:  BSF    FF2.7
....................          break;           
1562E:  MOVLB  8
15630:  BRA    15634
15632:  MOVLB  8
....................    } 
....................     
....................    sprintf(event_str, ",macro[%u],status[%c],line[%Lu]\r\n",  
....................                            macro, macro_status, line); 
15634:  MOVLW  01
15636:  MOVWF  1E
15638:  MOVLW  A7
1563A:  MOVWF  1D
1563C:  MOVLW  BE
1563E:  MOVWF  FF6
15640:  MOVLW  21
15642:  MOVWF  FF7
15644:  MOVLW  00
15646:  MOVWF  FF8
15648:  MOVLW  07
1564A:  MOVWF  xEB
1564C:  MOVLB  0
1564E:  CALL   AAC0
15652:  MOVFF  897,8ED
15656:  MOVLW  1B
15658:  MOVLB  8
1565A:  MOVWF  xEE
1565C:  MOVLB  0
1565E:  CALL   5274
15662:  MOVLW  C7
15664:  MOVWF  FF6
15666:  MOVLW  21
15668:  MOVWF  FF7
1566A:  MOVLW  00
1566C:  MOVWF  FF8
1566E:  MOVLW  09
15670:  MOVLB  8
15672:  MOVWF  xEB
15674:  MOVLB  0
15676:  CALL   AAC0
1567A:  MOVFF  89C,8FF
1567E:  CALL   5092
15682:  MOVLW  D2
15684:  MOVWF  FF6
15686:  MOVLW  21
15688:  MOVWF  FF7
1568A:  MOVLW  00
1568C:  MOVWF  FF8
1568E:  MOVLW  07
15690:  MOVLB  8
15692:  MOVWF  xEB
15694:  MOVLB  0
15696:  CALL   AAC0
1569A:  MOVLW  10
1569C:  MOVWF  FE9
1569E:  MOVFF  89B,8F7
156A2:  MOVFF  89A,8F6
156A6:  CALL   AAF2
156AA:  MOVLW  DC
156AC:  MOVWF  FF6
156AE:  MOVLW  21
156B0:  MOVWF  FF7
156B2:  MOVLW  00
156B4:  MOVWF  FF8
156B6:  MOVLW  03
156B8:  MOVLB  8
156BA:  MOVWF  xEB
156BC:  MOVLB  0
156BE:  CALL   AAC0
....................    record_event(); 
156C2:  CALL   84CE
....................     
.................... //   if (nv_product==ECO) calculate_data();  Now only done with A command VK 10/19/2015 
....................     
....................    // f & g are the only two natural ways to end a macro 
....................    // if error then recover the situation 
....................    if (macro_status != 'f' && macro_status != 'g') recovery(); 
156C6:  MOVLB  8
156C8:  MOVF   x9C,W
156CA:  SUBLW  66
156CC:  BZ    156DC
156CE:  MOVF   x9C,W
156D0:  SUBLW  67
156D2:  BZ    156DC
156D4:  MOVLB  0
156D6:  CALL   AA4C
156DA:  MOVLB  8
156DC:  MOVLB  0
156DE:  RETURN 0
.................... } 
....................  
.................... int32 master_macro_loop_count = 0; 
.................... int32 master_macro_loop_start = 0; 
....................  
.................... int8 master_macro_eco(){ 
....................    int16 addr; 
....................    int8  macro_cmd; 
....................    int16 macro_arg; 
....................    int8  macro_batch;    
....................    macro_batch = TRUE;    
*
15F8E:  MOVLW  01
15F90:  MOVLB  8
15F92:  MOVWF  x8F
....................    while (macro_batch == TRUE){ 
15F94:  DECFSZ x8F,W
15F96:  BRA    1621C
....................       // the step in the master macro (including loops) is passed from the caller 
....................       addr = macro_address[0] + (nv_macro_step*3); 
15F98:  MOVFF  38,A11
15F9C:  MOVFF  37,A10
15FA0:  MOVLB  A
15FA2:  CLRF   x13
15FA4:  MOVLW  03
15FA6:  MOVWF  x12
15FA8:  MOVLB  0
15FAA:  CALL   5C8C
15FAE:  MOVF   01,W
15FB0:  MOVLB  7
15FB2:  ADDWF  xD1,W
15FB4:  MOVLB  8
15FB6:  MOVWF  x8A
15FB8:  MOVF   02,W
15FBA:  MOVLB  7
15FBC:  ADDWFC xD2,W
15FBE:  MOVLB  8
15FC0:  MOVWF  x8B
....................       init_ext_eeprom(); 
15FC2:  MOVLB  0
15FC4:  CALL   105B6
....................       // get the sub-macro 
....................       macro_cmd = read_ext_eeprom(addr); 
15FC8:  MOVFF  88B,8CC
15FCC:  MOVFF  88A,8CB
15FD0:  CALL   105EE
15FD4:  MOVFF  01,88C
....................       ++addr; 
15FD8:  MOVLB  8
15FDA:  INCF   x8A,F
15FDC:  BTFSC  FD8.2
15FDE:  INCF   x8B,F
....................       macro_arg = read16_ext_eeprom(addr); 
15FE0:  MOVFF  88B,8C3
15FE4:  MOVFF  88A,8C2
15FE8:  MOVLB  0
15FEA:  CALL   10702
15FEE:  MOVFF  02,88E
15FF2:  MOVFF  01,88D
....................       ++addr; 
15FF6:  MOVLB  8
15FF8:  INCF   x8A,F
15FFA:  BTFSC  FD8.2
15FFC:  INCF   x8B,F
....................       ++addr;      
15FFE:  INCF   x8A,F
16000:  BTFSC  FD8.2
16002:  INCF   x8B,F
....................       //if (nv_report_mode >= 3) fprintf(COM_A, "@MAC[%c]ARG[%Lu]\r\n", macro_cmd, macro_arg); 
....................        
....................       if (macro_cmd == 'M' && macro_arg>0) // VK 5/22/17 Only ouput on M commands 
16004:  MOVF   x8C,W
16006:  SUBLW  4D
16008:  BTFSS  FD8.2
1600A:  BRA    16134
1600C:  MOVF   x8D,F
1600E:  BNZ   16016
16010:  MOVF   x8E,F
16012:  BTFSC  FD8.2
16014:  BRA    16134
....................          { 
....................          RTC_reset_HT(); 
16016:  MOVLB  0
16018:  CALL   34A6
....................          RTC_read(); 
1601C:  CALL   3338
....................          RTC_display(); 
16020:  CALL   E27E
....................           
....................          fprintf(COM_A, "@Running %c%Lu \r\n", macro_cmd,macro_arg); 
16024:  MOVLW  E0
16026:  MOVWF  FF6
16028:  MOVLW  21
1602A:  MOVWF  FF7
1602C:  MOVLW  00
1602E:  MOVWF  FF8
16030:  CLRF   1B
16032:  BTFSC  FF2.7
16034:  BSF    1B.7
16036:  BCF    FF2.7
16038:  MOVLW  09
1603A:  MOVLB  A
1603C:  MOVWF  x40
1603E:  MOVLB  0
16040:  CALL   1018
16044:  BTFSC  1B.7
16046:  BSF    FF2.7
16048:  MOVLB  8
1604A:  MOVF   x8C,W
1604C:  BTFSS  F9E.4
1604E:  BRA    1604C
16050:  MOVWF  FAD
16052:  MOVLW  10
16054:  MOVWF  FE9
16056:  CLRF   1B
16058:  BTFSC  FF2.7
1605A:  BSF    1B.7
1605C:  BCF    FF2.7
1605E:  MOVFF  88E,A41
16062:  MOVFF  88D,A40
16066:  MOVLB  0
16068:  CALL   119A
1606C:  BTFSC  1B.7
1606E:  BSF    FF2.7
16070:  MOVLW  EE
16072:  MOVWF  FF6
16074:  MOVLW  21
16076:  MOVWF  FF7
16078:  MOVLW  00
1607A:  MOVWF  FF8
1607C:  CLRF   1B
1607E:  BTFSC  FF2.7
16080:  BSF    1B.7
16082:  BCF    FF2.7
16084:  MOVLW  03
16086:  MOVLB  A
16088:  MOVWF  x40
1608A:  MOVLB  0
1608C:  CALL   1018
16090:  BTFSC  1B.7
16092:  BSF    FF2.7
....................          fprintf(COM_A, "@Macro %04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
16094:  MOVLW  01
16096:  ADDWF  21,W
16098:  MOVLB  8
1609A:  MOVWF  x90
1609C:  MOVLW  00
1609E:  ADDWFC 22,W
160A0:  MOVWF  x91
160A2:  MOVLW  F2
160A4:  MOVWF  FF6
160A6:  MOVLW  21
160A8:  MOVWF  FF7
160AA:  MOVLW  00
160AC:  MOVWF  FF8
160AE:  CLRF   1B
160B0:  BTFSC  FF2.7
160B2:  BSF    1B.7
160B4:  BCF    FF2.7
160B6:  MOVLW  07
160B8:  MOVLB  A
160BA:  MOVWF  x40
160BC:  MOVLB  0
160BE:  CALL   1018
160C2:  BTFSC  1B.7
160C4:  BSF    FF2.7
160C6:  MOVLW  09
160C8:  MOVWF  FE9
160CA:  CLRF   1B
160CC:  BTFSC  FF2.7
160CE:  BSF    1B.7
160D0:  BCF    FF2.7
160D2:  MOVFF  891,A41
160D6:  MOVFF  890,A40
160DA:  CALL   119A
160DE:  BTFSC  1B.7
160E0:  BSF    FF2.7
160E2:  MOVLW  FE
160E4:  MOVWF  FF6
160E6:  MOVLW  21
160E8:  MOVWF  FF7
160EA:  MOVLW  00
160EC:  MOVWF  FF8
160EE:  CLRF   1B
160F0:  BTFSC  FF2.7
160F2:  BSF    1B.7
160F4:  BCF    FF2.7
160F6:  MOVLW  04
160F8:  MOVLB  A
160FA:  MOVWF  x40
160FC:  MOVLB  0
160FE:  CALL   1018
16102:  BTFSC  1B.7
16104:  BSF    FF2.7
16106:  MOVLW  09
16108:  MOVWF  FE9
1610A:  CLRF   1B
1610C:  BTFSC  FF2.7
1610E:  BSF    1B.7
16110:  BCF    FF2.7
16112:  MOVFF  28,A41
16116:  MOVFF  27,A40
1611A:  CALL   119A
1611E:  BTFSC  1B.7
16120:  BSF    FF2.7
16122:  MOVLW  0D
16124:  BTFSS  F9E.4
16126:  BRA    16124
16128:  MOVWF  FAD
1612A:  MOVLW  0A
1612C:  BTFSS  F9E.4
1612E:  BRA    1612C
16130:  MOVWF  FAD
16132:  MOVLB  8
....................          } 
....................        
....................       if (nv_sample >= nv_max_samples) 
16134:  MOVF   28,W
16136:  SUBWF  22,W
16138:  BNC   16146
1613A:  BNZ   16142
1613C:  MOVF   27,W
1613E:  SUBWF  21,W
16140:  BNC   16146
....................          {macro_cmd = 'Z';} 
16142:  MOVLW  5A
16144:  MOVWF  x8C
....................        
....................          // run macro, sleep, end .... 
....................          switch (macro_cmd) { 
16146:  MOVF   x8C,W
16148:  XORLW  72
1614A:  MOVLB  0
1614C:  BZ    16160
1614E:  XORLW  57
16150:  BZ    16182
16152:  XORLW  68
16154:  BZ    161B8
16156:  XORLW  17
16158:  BZ    161EE
1615A:  XORLW  61
1615C:  BZ    161FA
1615E:  BRA    16204
....................             //case 'p': 
....................               // fprintf(COM_A, "test command \r\n"); 
....................                //++nv_macro_step; 
....................                //break; 
....................             case 'r': 
....................                ++nv_macro_step; 
16160:  INCF   37,F
16162:  BTFSC  FD8.2
16164:  INCF   38,F
....................                master_macro_loop_start = nv_macro_step; 
16166:  MOVLB  8
16168:  CLRF   x60
1616A:  CLRF   x5F
1616C:  MOVFF  38,85E
16170:  MOVFF  37,85D
....................                master_macro_loop_count = macro_arg; 
16174:  CLRF   x5C
16176:  CLRF   x5B
16178:  MOVFF  88E,85A
1617C:  MOVFF  88D,859
....................             break; 
16180:  BRA    16210
....................             case '%': 
....................                if (master_macro_loop_count > 1){ 
16182:  MOVLB  8
16184:  MOVF   x5C,F
16186:  BNZ   16196
16188:  MOVF   x5B,F
1618A:  BNZ   16196
1618C:  MOVF   x5A,F
1618E:  BNZ   16196
16190:  MOVF   x59,W
16192:  SUBLW  01
16194:  BC    161B0
....................                   nv_macro_step = master_macro_loop_start; 
16196:  MOVFF  85E,38
1619A:  MOVFF  85D,37
....................                   master_macro_loop_count--; 
1619E:  MOVLW  FF
161A0:  ADDWF  x59,F
161A2:  BTFSS  FD8.0
161A4:  ADDWF  x5A,F
161A6:  BTFSS  FD8.0
161A8:  ADDWF  x5B,F
161AA:  BTFSS  FD8.0
161AC:  ADDWF  x5C,F
....................                }else{ 
161AE:  BRA    161B6
....................                   nv_macro_step++; 
161B0:  INCF   37,F
161B2:  BTFSC  FD8.2
161B4:  INCF   38,F
....................                } 
....................             break; 
161B6:  BRA    16210
....................             case 'M' : 
....................                // run sub-macro (if valid) 
....................                if (macro_arg < 21) { 
161B8:  MOVLB  8
161BA:  MOVF   x8E,F
161BC:  BNZ   161EC
161BE:  MOVF   x8D,W
161C0:  SUBLW  14
161C2:  BNC   161EC
....................                   play_macro(macro_arg,0);     // casts to int8 
161C4:  MOVFF  88D,897
161C8:  CLRF   x99
161CA:  CLRF   x98
161CC:  MOVLB  0
161CE:  CALL   153A8
....................                   delay_ms(100); 
161D2:  MOVLW  64
161D4:  MOVLB  9
161D6:  MOVWF  xEC
161D8:  MOVLB  0
161DA:  CALL   2904
....................                   ++nv_sample; 
161DE:  INCF   21,F
161E0:  BTFSC  FD8.2
161E2:  INCF   22,F
....................                   ++nv_macro_step; 
161E4:  INCF   37,F
161E6:  BTFSC  FD8.2
161E8:  INCF   38,F
161EA:  MOVLB  8
....................                } 
....................                break; 
161EC:  BRA    16210
....................             case 'Z' : ++nv_macro_step; 
161EE:  INCF   37,F
161F0:  BTFSC  FD8.2
161F2:  INCF   38,F
....................                        macro_batch = FALSE; 
161F4:  MOVLB  8
161F6:  CLRF   x8F
....................                break; 
161F8:  BRA    16210
....................             case ';' : nv_macro_step = 0; 
161FA:  CLRF   38
161FC:  CLRF   37
....................                        // macro_batch = FALSE; 
....................                break; 
161FE:  MOVLB  8
16200:  BRA    16210
16202:  MOVLB  0
....................             default  : cmd_err(); 
16204:  CALL   BFB4
....................                        macro_cmd = 'e'; 
16208:  MOVLW  65
1620A:  MOVLB  8
1620C:  MOVWF  x8C
....................                        macro_batch = FALSE; 
1620E:  CLRF   x8F
....................                break; 
....................          } 
....................          if (user_quit == TRUE) { 
16210:  DECFSZ 50,W
16212:  BRA    1621A
....................             macro_cmd = ';'; 
16214:  MOVLW  3B
16216:  MOVWF  x8C
....................             break;         // 17 = CTRL-Q (quit) 
16218:  BRA    1621C
....................          } 
1621A:  BRA    15F94
....................    } 
....................    return (macro_cmd); 
1621C:  MOVFF  88C,01
16220:  MOVLB  0
16222:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... #include "macro_wms.c" 
.................... // Executes only hard macro commands  
.................... int8 play_wms_macro_cmd (int8 macro_cmd, int16 macro_arg) 
.................... { 
....................    int8  macro_status; 
....................     
....................    switch(macro_cmd){ 
*
0D39E:  MOVLB  8
0D3A0:  MOVF   x8C,W
0D3A2:  XORLW  2B
0D3A4:  MOVLB  0
0D3A6:  BZ    D3D6
0D3A8:  XORLW  06
0D3AA:  BZ    D3FE
0D3AC:  XORLW  6F
0D3AE:  BZ    D426
0D3B0:  XORLW  05
0D3B2:  BZ    D438
0D3B4:  XORLW  17
0D3B6:  BZ    D44E
0D3B8:  XORLW  01
0D3BA:  BZ    D47E
0D3BC:  XORLW  03
0D3BE:  BTFSC  FD8.2
0D3C0:  BRA    D4A6
0D3C2:  XORLW  06
0D3C4:  BTFSC  FD8.2
0D3C6:  BRA    D4CE
0D3C8:  XORLW  0D
0D3CA:  BTFSC  FD8.2
0D3CC:  BRA    D4E2
0D3CE:  XORLW  62
0D3D0:  BTFSC  FD8.2
0D3D2:  BRA    D50A
0D3D4:  BRA    D512
....................       //!      case 'L' : switch_valve(macro_arg); 
....................       //!                 macro_status = 'a'; 
....................       //!         break;       
....................        
....................       // stepper commands - move_motor(use dir/shortest,dir,steps); 
....................       case '+' : motor=1; 
0D3D6:  MOVLW  01
0D3D8:  MOVLB  7
0D3DA:  MOVWF  x40
....................                  move_motor(0,0,macro_arg,1); 
0D3DC:  MOVLB  8
0D3DE:  CLRF   xC7
0D3E0:  CLRF   xC8
0D3E2:  CLRF   xCC
0D3E4:  CLRF   xCB
0D3E6:  MOVFF  88E,8CA
0D3EA:  MOVFF  88D,8C9
0D3EE:  MOVWF  xCD
0D3F0:  MOVLB  0
0D3F2:  CALL   9D6C
....................                  macro_status=step_err_status(); 
0D3F6:  RCALL  D2F6
0D3F8:  MOVFF  01,88F
....................          break; 
0D3FC:  BRA    D512
....................       case '-' : motor=1; 
0D3FE:  MOVLW  01
0D400:  MOVLB  7
0D402:  MOVWF  x40
....................                  move_motor(0,1,macro_arg,1); 
0D404:  MOVLB  8
0D406:  CLRF   xC7
0D408:  MOVWF  xC8
0D40A:  CLRF   xCC
0D40C:  CLRF   xCB
0D40E:  MOVFF  88E,8CA
0D412:  MOVFF  88D,8C9
0D416:  MOVWF  xCD
0D418:  MOVLB  0
0D41A:  CALL   9D6C
....................                  macro_status=step_err_status(); 
0D41E:  RCALL  D2F6
0D420:  MOVFF  01,88F
....................          break; 
0D424:  BRA    D512
....................       case 'B' : h_bridge(macro_arg); 
0D426:  MOVFF  88D,8B5
0D42A:  CALL   C244
....................                  macro_status = 'a'; 
0D42E:  MOVLW  61
0D430:  MOVLB  8
0D432:  MOVWF  x8F
....................          break; 
0D434:  MOVLB  0
0D436:  BRA    D512
....................       case 'G' : motor=0; 
0D438:  MOVLB  7
0D43A:  CLRF   x40
....................                  align(0); 
0D43C:  MOVLB  8
0D43E:  CLRF   xC2
0D440:  MOVLB  0
0D442:  CALL   A8A8
....................                  macro_status=step_err_status(); 
0D446:  RCALL  D2F6
0D448:  MOVFF  01,88F
....................          break ;           
0D44C:  BRA    D512
....................       case 'P' : nv_port = macro_arg; // macro port will be recorded 
0D44E:  MOVFF  88E,2E
0D452:  MOVFF  88D,2D
....................                  motor=0; 
0D456:  MOVLB  7
0D458:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1);   
0D45A:  MOVLB  8
0D45C:  CLRF   xC7
0D45E:  CLRF   xC8
0D460:  CLRF   xCC
0D462:  CLRF   xCB
0D464:  MOVFF  88E,8CA
0D468:  MOVFF  88D,8C9
0D46C:  MOVLW  01
0D46E:  MOVWF  xCD
0D470:  MOVLB  0
0D472:  CALL   9D6C
....................                  macro_status=step_err_status(); 
0D476:  RCALL  D2F6
0D478:  MOVFF  01,88F
....................          break; 
0D47C:  BRA    D512
....................       case 'Q' : motor=0; 
0D47E:  MOVLB  7
0D480:  CLRF   x40
....................                  move_motor(0,0,macro_arg,1); 
0D482:  MOVLB  8
0D484:  CLRF   xC7
0D486:  CLRF   xC8
0D488:  CLRF   xCC
0D48A:  CLRF   xCB
0D48C:  MOVFF  88E,8CA
0D490:  MOVFF  88D,8C9
0D494:  MOVLW  01
0D496:  MOVWF  xCD
0D498:  MOVLB  0
0D49A:  CALL   9D6C
....................                  macro_status=step_err_status(); 
0D49E:  RCALL  D2F6
0D4A0:  MOVFF  01,88F
....................          break; 
0D4A4:  BRA    D512
....................       case 'R' : motor=0; 
0D4A6:  MOVLB  7
0D4A8:  CLRF   x40
....................                  move_motor(0,1,macro_arg,1); 
0D4AA:  MOVLB  8
0D4AC:  CLRF   xC7
0D4AE:  MOVLW  01
0D4B0:  MOVWF  xC8
0D4B2:  CLRF   xCC
0D4B4:  CLRF   xCB
0D4B6:  MOVFF  88E,8CA
0D4BA:  MOVFF  88D,8C9
0D4BE:  MOVWF  xCD
0D4C0:  MOVLB  0
0D4C2:  CALL   9D6C
....................                  macro_status=step_err_status(); 
0D4C6:  RCALL  D2F6
0D4C8:  MOVFF  01,88F
....................          break; 
0D4CC:  BRA    D512
....................       // end stepper commands 
....................       case 'T' : delay_sec(macro_arg); 
0D4CE:  MOVFF  88E,8C3
0D4D2:  MOVFF  88D,8C2
0D4D6:  RCALL  D32E
....................                  macro_status = 'a'; 
0D4D8:  MOVLW  61
0D4DA:  MOVLB  8
0D4DC:  MOVWF  x8F
....................          break; 
0D4DE:  MOVLB  0
0D4E0:  BRA    D512
....................          // bus power ON/OFF 
....................       case 'Y' : if (macro_arg == 1) bus_on(); 
0D4E2:  MOVLB  8
0D4E4:  DECFSZ x8D,W
0D4E6:  BRA    D4F4
0D4E8:  MOVF   x8E,F
0D4EA:  BNZ   D4F4
0D4EC:  MOVLB  0
0D4EE:  RCALL  D364
0D4F0:  BRA    D500
0D4F2:  MOVLB  8
....................                  else if (macro_arg == 0) bus_off(); 
0D4F4:  MOVF   x8D,F
0D4F6:  BNZ   D502
0D4F8:  MOVF   x8E,F
0D4FA:  BNZ   D502
0D4FC:  MOVLB  0
0D4FE:  RCALL  D388
0D500:  MOVLB  8
....................                  macro_status = 'a'; 
0D502:  MOVLW  61
0D504:  MOVWF  x8F
....................          break;           
0D506:  MOVLB  0
0D508:  BRA    D512
....................       case ';' : macro_status = 'f'; 
0D50A:  MOVLW  66
0D50C:  MOVLB  8
0D50E:  MOVWF  x8F
....................          break;            
0D510:  MOVLB  0
....................    } 
....................    // macro_status =  97(a): command complete 
....................    //                 98(b): running (not possible) 
....................    //                 99(c): crap response 
....................    //                100(d): time-out 
....................    //                101(e): error 
....................    //                102(f): finished    
....................    return(macro_status); 
0D512:  MOVLB  8
0D514:  MOVFF  88F,01
0D518:  MOVLB  0
0D51A:  RETURN 0
.................... } 
....................  
.................... void play_wms_hard_macro(int16 port) 
.................... { 
....................    int8  macro_status; 
....................     
....................    if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................       (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
*
0D7F4:  MOVF   2E,F
0D7F6:  BNZ   D7FE
0D7F8:  MOVF   2D,W
0D7FA:  SUBLW  01
0D7FC:  BC    D810
0D7FE:  MOVF   2E,F
0D800:  BNZ   D810
0D802:  MOVF   2D,W
0D804:  SUBLW  30
0D806:  BNC   D810
0D808:  DECFSZ 2F,W
0D80A:  BRA    D810
0D80C:  MOVF   30,F
0D80E:  BZ    D82E
0D810:  MOVF   2E,F
0D812:  BNZ   D81A
0D814:  MOVF   2D,W
0D816:  SUBLW  01
0D818:  BC    D838
0D81A:  MOVF   2E,F
0D81C:  BNZ   D838
0D81E:  MOVF   2D,W
0D820:  SUBLW  32
0D822:  BNC   D838
0D824:  MOVF   2F,W
0D826:  SUBLW  03
0D828:  BNZ   D838
0D82A:  MOVF   30,F
0D82C:  BNZ   D838
....................    { 
....................       //store_wms_data(0); // moved to below macro execution 
....................       macro_status = 'a'; 
0D82E:  MOVLW  61
0D830:  MOVLB  8
0D832:  MOVWF  x8B
....................    } 
0D834:  BRA    D840
0D836:  MOVLB  0
....................    else { 
....................       macro_status = 'e'; 
0D838:  MOVLW  65
0D83A:  MOVLB  8
0D83C:  MOVWF  x8B
....................       goto end_macro;       
0D83E:  BRA    D8F0
....................    } 
....................     
....................    macro_status = play_wms_macro_cmd('Y',1); 
0D840:  MOVLW  59
0D842:  MOVWF  x8C
0D844:  CLRF   x8E
0D846:  MOVLW  01
0D848:  MOVWF  x8D
0D84A:  MOVLB  0
0D84C:  RCALL  D39E
0D84E:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D852:  MOVLB  8
0D854:  MOVF   x8B,W
0D856:  SUBLW  61
0D858:  BTFSS  FD8.2
0D85A:  BRA    D8F0
....................    macro_status = play_wms_macro_cmd('G',1); 
0D85C:  MOVLW  47
0D85E:  MOVWF  x8C
0D860:  CLRF   x8E
0D862:  MOVLW  01
0D864:  MOVWF  x8D
0D866:  MOVLB  0
0D868:  RCALL  D39E
0D86A:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D86E:  MOVLB  8
0D870:  MOVF   x8B,W
0D872:  SUBLW  61
0D874:  BTFSS  FD8.2
0D876:  BRA    D8F0
....................    macro_status = play_wms_macro_cmd('-',nv_volume); 
0D878:  MOVLW  2D
0D87A:  MOVWF  x8C
0D87C:  MOVFF  2C,88E
0D880:  MOVFF  2B,88D
0D884:  MOVLB  0
0D886:  RCALL  D39E
0D888:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D88C:  MOVLB  8
0D88E:  MOVF   x8B,W
0D890:  SUBLW  61
0D892:  BTFSS  FD8.2
0D894:  BRA    D8F0
....................    macro_status = play_wms_macro_cmd('P',port); 
0D896:  MOVLW  50
0D898:  MOVWF  x8C
0D89A:  MOVFF  88A,88E
0D89E:  MOVFF  889,88D
0D8A2:  MOVLB  0
0D8A4:  RCALL  D39E
0D8A6:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro;    
0D8AA:  MOVLB  8
0D8AC:  MOVF   x8B,W
0D8AE:  SUBLW  61
0D8B0:  BTFSS  FD8.2
0D8B2:  BRA    D8F0
....................    macro_status = play_wms_macro_cmd('+',nv_volume); 
0D8B4:  MOVLW  2B
0D8B6:  MOVWF  x8C
0D8B8:  MOVFF  2C,88E
0D8BC:  MOVFF  2B,88D
0D8C0:  MOVLB  0
0D8C2:  RCALL  D39E
0D8C4:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D8C8:  MOVLB  8
0D8CA:  MOVF   x8B,W
0D8CC:  SUBLW  61
0D8CE:  BTFSS  FD8.2
0D8D0:  BRA    D8F0
....................    macro_status = play_wms_macro_cmd('Y',0); 
0D8D2:  MOVLW  59
0D8D4:  MOVWF  x8C
0D8D6:  CLRF   x8E
0D8D8:  CLRF   x8D
0D8DA:  MOVLB  0
0D8DC:  RCALL  D39E
0D8DE:  MOVFF  01,88B
....................    if (macro_status != 'a') goto end_macro; 
0D8E2:  MOVLB  8
0D8E4:  MOVF   x8B,W
0D8E6:  SUBLW  61
0D8E8:  BTFSS  FD8.2
0D8EA:  BRA    D8F0
....................    macro_status='f';  
0D8EC:  MOVLW  66
0D8EE:  MOVWF  x8B
....................     
....................    end_macro: 
....................  
....................    store_wms_data(0); // write data to uart and SD card 
0D8F0:  CLRF   x9D
0D8F2:  MOVLB  0
0D8F4:  RCALL  D632
....................    
....................    switch(macro_status){ 
0D8F6:  MOVLW  61
0D8F8:  MOVLB  8
0D8FA:  SUBWF  x8B,W
0D8FC:  ADDLW  FA
0D8FE:  BC    D9D2
0D900:  ADDLW  06
0D902:  MOVLB  0
0D904:  GOTO   D9D6
....................       case 'a': if (nv_report_mode > 0) fprintf(COM_A, "@LNE\r\n"); 
0D908:  MOVF   1F,F
0D90A:  BNZ   D910
0D90C:  MOVF   20,F
0D90E:  BZ    D92C
0D910:  MOVLW  0A
0D912:  MOVWF  FF6
0D914:  MOVLW  22
0D916:  MOVWF  FF7
0D918:  MOVLW  00
0D91A:  MOVWF  FF8
0D91C:  CLRF   1B
0D91E:  BTFSC  FF2.7
0D920:  BSF    1B.7
0D922:  BCF    FF2.7
0D924:  CALL   0E42
0D928:  BTFSC  1B.7
0D92A:  BSF    FF2.7
....................          break; 
0D92C:  MOVLB  8
0D92E:  BRA    D9D2
....................       case 'b': fprintf(COM_A, "@RUN\r\n"); 
0D930:  MOVLW  12
0D932:  MOVWF  FF6
0D934:  MOVLW  22
0D936:  MOVWF  FF7
0D938:  MOVLW  00
0D93A:  MOVWF  FF8
0D93C:  CLRF   1B
0D93E:  BTFSC  FF2.7
0D940:  BSF    1B.7
0D942:  BCF    FF2.7
0D944:  CALL   0E42
0D948:  BTFSC  1B.7
0D94A:  BSF    FF2.7
....................          break; 
0D94C:  MOVLB  8
0D94E:  BRA    D9D2
....................       case 'c': fprintf(COM_A, "@BAD\r\n"); 
0D950:  MOVLW  1A
0D952:  MOVWF  FF6
0D954:  MOVLW  22
0D956:  MOVWF  FF7
0D958:  MOVLW  00
0D95A:  MOVWF  FF8
0D95C:  CLRF   1B
0D95E:  BTFSC  FF2.7
0D960:  BSF    1B.7
0D962:  BCF    FF2.7
0D964:  CALL   0E42
0D968:  BTFSC  1B.7
0D96A:  BSF    FF2.7
....................          break; 
0D96C:  MOVLB  8
0D96E:  BRA    D9D2
....................       case 'd': fprintf(COM_A, "@T/O\r\n"); 
0D970:  MOVLW  22
0D972:  MOVWF  FF6
0D974:  MOVLW  22
0D976:  MOVWF  FF7
0D978:  MOVLW  00
0D97A:  MOVWF  FF8
0D97C:  CLRF   1B
0D97E:  BTFSC  FF2.7
0D980:  BSF    1B.7
0D982:  BCF    FF2.7
0D984:  CALL   0E42
0D988:  BTFSC  1B.7
0D98A:  BSF    FF2.7
....................          break; 
0D98C:  MOVLB  8
0D98E:  BRA    D9D2
....................       case 'e': fprintf(COM_A, "@ERR\r\n"); 
0D990:  MOVLW  2A
0D992:  MOVWF  FF6
0D994:  MOVLW  22
0D996:  MOVWF  FF7
0D998:  MOVLW  00
0D99A:  MOVWF  FF8
0D99C:  CLRF   1B
0D99E:  BTFSC  FF2.7
0D9A0:  BSF    1B.7
0D9A2:  BCF    FF2.7
0D9A4:  CALL   0E42
0D9A8:  BTFSC  1B.7
0D9AA:  BSF    FF2.7
....................          break;    
0D9AC:  MOVLB  8
0D9AE:  BRA    D9D2
....................       case 'f': fprintf(COM_A, "@END\r\n"); 
0D9B0:  MOVLW  32
0D9B2:  MOVWF  FF6
0D9B4:  MOVLW  22
0D9B6:  MOVWF  FF7
0D9B8:  MOVLW  00
0D9BA:  MOVWF  FF8
0D9BC:  CLRF   1B
0D9BE:  BTFSC  FF2.7
0D9C0:  BSF    1B.7
0D9C2:  BCF    FF2.7
0D9C4:  CALL   0E42
0D9C8:  BTFSC  1B.7
0D9CA:  BSF    FF2.7
....................          break;           
0D9CC:  MOVLB  8
0D9CE:  BRA    D9D2
0D9D0:  MOVLB  8
....................    } 
0D9D2:  MOVLB  0
0D9D4:  RETURN 0
....................     
....................     
.................... } 
....................  
.................... int8 master_macro_wms(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[3]; 
....................    int16 macro_arg[3]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
16464:  MOVLB  8
16466:  MOVF   x88,W
16468:  BTFSC  FD8.2
1646A:  DECF   x89,F
1646C:  DECF   x88,F
....................    addr = macro_address[0] + (step*9); 
1646E:  MOVFF  889,A11
16472:  MOVFF  888,A10
16476:  MOVLB  A
16478:  CLRF   x13
1647A:  MOVLW  09
1647C:  MOVWF  x12
1647E:  MOVLB  0
16480:  CALL   5C8C
16484:  MOVF   01,W
16486:  MOVLB  7
16488:  ADDWF  xD1,W
1648A:  MOVLB  8
1648C:  MOVWF  x8A
1648E:  MOVF   02,W
16490:  MOVLB  7
16492:  ADDWFC xD2,W
16494:  MOVLB  8
16496:  MOVWF  x8B
....................     
....................    init_ext_eeprom(); 
16498:  MOVLB  0
1649A:  CALL   105B6
....................     
....................    // interval 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
1649E:  MOVFF  88B,8CC
164A2:  MOVFF  88A,8CB
164A6:  CALL   105EE
164AA:  MOVFF  01,88C
....................    ++addr; 
164AE:  MOVLB  8
164B0:  INCF   x8A,F
164B2:  BTFSC  FD8.2
164B4:  INCF   x8B,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
164B6:  MOVFF  88B,8C3
164BA:  MOVFF  88A,8C2
164BE:  MOVLB  0
164C0:  CALL   10702
164C4:  MOVFF  02,890
164C8:  MOVFF  01,88F
....................    ++addr; 
164CC:  MOVLB  8
164CE:  INCF   x8A,F
164D0:  BTFSC  FD8.2
164D2:  INCF   x8B,F
....................    ++addr; 
164D4:  INCF   x8A,F
164D6:  BTFSC  FD8.2
164D8:  INCF   x8B,F
....................    // port 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
164DA:  MOVFF  88B,8CC
164DE:  MOVFF  88A,8CB
164E2:  MOVLB  0
164E4:  CALL   105EE
164E8:  MOVFF  01,88D
....................    ++addr; 
164EC:  MOVLB  8
164EE:  INCF   x8A,F
164F0:  BTFSC  FD8.2
164F2:  INCF   x8B,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
164F4:  MOVFF  88B,8C3
164F8:  MOVFF  88A,8C2
164FC:  MOVLB  0
164FE:  CALL   10702
16502:  MOVFF  02,892
16506:  MOVFF  01,891
....................    ++addr; 
1650A:  MOVLB  8
1650C:  INCF   x8A,F
1650E:  BTFSC  FD8.2
16510:  INCF   x8B,F
....................    ++addr; 
16512:  INCF   x8A,F
16514:  BTFSC  FD8.2
16516:  INCF   x8B,F
....................    // macro 
....................    macro_cmd[2] = read_ext_eeprom(addr); 
16518:  MOVFF  88B,8CC
1651C:  MOVFF  88A,8CB
16520:  MOVLB  0
16522:  CALL   105EE
16526:  MOVFF  01,88E
....................    ++addr; 
1652A:  MOVLB  8
1652C:  INCF   x8A,F
1652E:  BTFSC  FD8.2
16530:  INCF   x8B,F
....................    macro_arg[2] = read16_ext_eeprom(addr);    
16532:  MOVFF  88B,8C3
16536:  MOVFF  88A,8C2
1653A:  MOVLB  0
1653C:  CALL   10702
16540:  MOVFF  02,894
16544:  MOVFF  01,893
....................    ++addr; 
16548:  MOVLB  8
1654A:  INCF   x8A,F
1654C:  BTFSC  FD8.2
1654E:  INCF   x8B,F
....................    ++addr; 
16550:  INCF   x8A,F
16552:  BTFSC  FD8.2
16554:  INCF   x8B,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
16556:  MOVFF  88B,8CC
1655A:  MOVFF  88A,8CB
1655E:  MOVLB  0
16560:  CALL   105EE
16564:  MOVFF  01,895
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'J' && macro_cmd[1] == 'P' && macro_cmd[2] == 'M') { 
16568:  MOVLB  8
1656A:  MOVF   x8C,W
1656C:  SUBLW  4A
1656E:  BTFSS  FD8.2
16570:  BRA    16646
16572:  MOVF   x8D,W
16574:  SUBLW  50
16576:  BNZ   16646
16578:  MOVF   x8E,W
1657A:  SUBLW  4D
1657C:  BNZ   16646
....................        
....................       fprintf(COM_A, "%c%Lu,%c%Lu,%c%Lu\r\n",  
....................          macro_cmd[0], macro_arg[0],            // int 
....................          macro_cmd[1], macro_arg[1],            // port 
....................          macro_cmd[2], macro_arg[2],);          // macro 
1657E:  MOVF   x8C,W
16580:  BTFSS  F9E.4
16582:  BRA    16580
16584:  MOVWF  FAD
16586:  MOVLW  10
16588:  MOVWF  FE9
1658A:  CLRF   1B
1658C:  BTFSC  FF2.7
1658E:  BSF    1B.7
16590:  BCF    FF2.7
16592:  MOVFF  890,A41
16596:  MOVFF  88F,A40
1659A:  MOVLB  0
1659C:  CALL   119A
165A0:  BTFSC  1B.7
165A2:  BSF    FF2.7
165A4:  MOVLW  2C
165A6:  BTFSS  F9E.4
165A8:  BRA    165A6
165AA:  MOVWF  FAD
165AC:  MOVLB  8
165AE:  MOVF   x8D,W
165B0:  BTFSS  F9E.4
165B2:  BRA    165B0
165B4:  MOVWF  FAD
165B6:  MOVLW  10
165B8:  MOVWF  FE9
165BA:  CLRF   1B
165BC:  BTFSC  FF2.7
165BE:  BSF    1B.7
165C0:  BCF    FF2.7
165C2:  MOVFF  892,A41
165C6:  MOVFF  891,A40
165CA:  MOVLB  0
165CC:  CALL   119A
165D0:  BTFSC  1B.7
165D2:  BSF    FF2.7
165D4:  MOVLW  2C
165D6:  BTFSS  F9E.4
165D8:  BRA    165D6
165DA:  MOVWF  FAD
165DC:  MOVLB  8
165DE:  MOVF   x8E,W
165E0:  BTFSS  F9E.4
165E2:  BRA    165E0
165E4:  MOVWF  FAD
165E6:  MOVLW  10
165E8:  MOVWF  FE9
165EA:  CLRF   1B
165EC:  BTFSC  FF2.7
165EE:  BSF    1B.7
165F0:  BCF    FF2.7
165F2:  MOVFF  894,A41
165F6:  MOVFF  893,A40
165FA:  MOVLB  0
165FC:  CALL   119A
16600:  BTFSC  1B.7
16602:  BSF    FF2.7
16604:  MOVLW  0D
16606:  BTFSS  F9E.4
16608:  BRA    16606
1660A:  MOVWF  FAD
1660C:  MOVLW  0A
1660E:  BTFSS  F9E.4
16610:  BRA    1660E
16612:  MOVWF  FAD
....................  
....................       // set interval 
....................       nv_interval = macro_arg[0]; 
16614:  MOVFF  890,24
16618:  MOVFF  88F,23
....................  
....................       if (macro_arg[2] > 0 && macro_arg[2] < 17) { 
1661C:  MOVLB  8
1661E:  MOVF   x93,F
16620:  BNZ   16626
16622:  MOVF   x94,F
16624:  BZ    16644
16626:  MOVF   x94,F
16628:  BNZ   16644
1662A:  MOVF   x93,W
1662C:  SUBLW  10
1662E:  BNC   16644
....................          play_macro(macro_arg[2], macro_arg[1]);   // [2] casts to int8 / [1] = port 
16630:  MOVFF  893,897
16634:  MOVFF  892,899
16638:  MOVFF  891,898
1663C:  MOVLB  0
1663E:  CALL   153A8
16642:  MOVLB  8
....................       } 
....................    } 
16644:  BRA    16652
....................    else { 
....................       cmd_err(); 
16646:  MOVLB  0
16648:  CALL   BFB4
....................       macro_end = 59; 
1664C:  MOVLW  3B
1664E:  MOVLB  8
16650:  MOVWF  x95
....................    } 
....................     
....................    return (macro_end); 
16652:  MOVFF  895,01
16656:  MOVLB  0
16658:  GOTO   16742 (RETURN)
.................... } 
....................  
....................  
.................... #include "macro_aws.c" 
.................... int8 master_macro_aws(int16 step){ 
....................  
....................    int16 addr; 
....................     
....................    int8  macro_cmd[2]; 
....................    int16 macro_arg[2]; 
....................    int8  macro_end; 
....................     
....................    --step; 
*
16844:  MOVLB  8
16846:  MOVF   x8C,W
16848:  BTFSC  FD8.2
1684A:  DECF   x8D,F
1684C:  DECF   x8C,F
....................    addr = macro_address[0] + (step*6); 
1684E:  MOVFF  88D,A11
16852:  MOVFF  88C,A10
16856:  MOVLB  A
16858:  CLRF   x13
1685A:  MOVLW  06
1685C:  MOVWF  x12
1685E:  MOVLB  0
16860:  CALL   5C8C
16864:  MOVF   01,W
16866:  MOVLB  7
16868:  ADDWF  xD1,W
1686A:  MOVLB  8
1686C:  MOVWF  x8E
1686E:  MOVF   02,W
16870:  MOVLB  7
16872:  ADDWFC xD2,W
16874:  MOVLB  8
16876:  MOVWF  x8F
....................     
....................    init_ext_eeprom(); 
16878:  MOVLB  0
1687A:  CALL   105B6
....................     
....................    // port 
....................    macro_cmd[0] = read_ext_eeprom(addr); 
1687E:  MOVFF  88F,8CC
16882:  MOVFF  88E,8CB
16886:  CALL   105EE
1688A:  MOVFF  01,890
....................    ++addr; 
1688E:  MOVLB  8
16890:  INCF   x8E,F
16892:  BTFSC  FD8.2
16894:  INCF   x8F,F
....................    macro_arg[0] = read16_ext_eeprom(addr); 
16896:  MOVFF  88F,8C3
1689A:  MOVFF  88E,8C2
1689E:  MOVLB  0
168A0:  CALL   10702
168A4:  MOVFF  02,893
168A8:  MOVFF  01,892
....................    ++addr; 
168AC:  MOVLB  8
168AE:  INCF   x8E,F
168B0:  BTFSC  FD8.2
168B2:  INCF   x8F,F
....................    ++addr; 
168B4:  INCF   x8E,F
168B6:  BTFSC  FD8.2
168B8:  INCF   x8F,F
....................    // macro 
....................    macro_cmd[1] = read_ext_eeprom(addr); 
168BA:  MOVFF  88F,8CC
168BE:  MOVFF  88E,8CB
168C2:  MOVLB  0
168C4:  CALL   105EE
168C8:  MOVFF  01,891
....................    ++addr; 
168CC:  MOVLB  8
168CE:  INCF   x8E,F
168D0:  BTFSC  FD8.2
168D2:  INCF   x8F,F
....................    macro_arg[1] = read16_ext_eeprom(addr); 
168D4:  MOVFF  88F,8C3
168D8:  MOVFF  88E,8C2
168DC:  MOVLB  0
168DE:  CALL   10702
168E2:  MOVFF  02,895
168E6:  MOVFF  01,894
....................    ++addr; 
168EA:  MOVLB  8
168EC:  INCF   x8E,F
168EE:  BTFSC  FD8.2
168F0:  INCF   x8F,F
....................    ++addr; 
168F2:  INCF   x8E,F
168F4:  BTFSC  FD8.2
168F6:  INCF   x8F,F
....................     
....................    macro_end = read_ext_eeprom(addr); 
168F8:  MOVFF  88F,8CC
168FC:  MOVFF  88E,8CB
16900:  MOVLB  0
16902:  CALL   105EE
16906:  MOVFF  01,896
....................     
....................    // check basic structure 
....................    if (macro_cmd[0] == 'P' && macro_cmd[1] == 'M') { 
1690A:  MOVLB  8
1690C:  MOVF   x90,W
1690E:  SUBLW  50
16910:  BNZ   169B4
16912:  MOVF   x91,W
16914:  SUBLW  4D
16916:  BNZ   169B4
....................        
....................       RTC_read(); 
16918:  MOVLB  0
1691A:  CALL   3338
....................       RTC_display(); 
1691E:  CALL   E27E
....................       fprintf(COM_A, "%c%Lu,%c%Lu\r\n", 
....................          macro_cmd[0], macro_arg[0],            // port 
....................          macro_cmd[1], macro_arg[1]);           // macro 
16922:  MOVLB  8
16924:  MOVF   x90,W
16926:  BTFSS  F9E.4
16928:  BRA    16926
1692A:  MOVWF  FAD
1692C:  MOVLW  10
1692E:  MOVWF  FE9
16930:  CLRF   1B
16932:  BTFSC  FF2.7
16934:  BSF    1B.7
16936:  BCF    FF2.7
16938:  MOVFF  893,A41
1693C:  MOVFF  892,A40
16940:  MOVLB  0
16942:  CALL   119A
16946:  BTFSC  1B.7
16948:  BSF    FF2.7
1694A:  MOVLW  2C
1694C:  BTFSS  F9E.4
1694E:  BRA    1694C
16950:  MOVWF  FAD
16952:  MOVLB  8
16954:  MOVF   x91,W
16956:  BTFSS  F9E.4
16958:  BRA    16956
1695A:  MOVWF  FAD
1695C:  MOVLW  10
1695E:  MOVWF  FE9
16960:  CLRF   1B
16962:  BTFSC  FF2.7
16964:  BSF    1B.7
16966:  BCF    FF2.7
16968:  MOVFF  895,A41
1696C:  MOVFF  894,A40
16970:  MOVLB  0
16972:  CALL   119A
16976:  BTFSC  1B.7
16978:  BSF    FF2.7
1697A:  MOVLW  0D
1697C:  BTFSS  F9E.4
1697E:  BRA    1697C
16980:  MOVWF  FAD
16982:  MOVLW  0A
16984:  BTFSS  F9E.4
16986:  BRA    16984
16988:  MOVWF  FAD
....................  
....................       if (macro_arg[1] > 0 && macro_arg[1] < 17) { 
1698A:  MOVLB  8
1698C:  MOVF   x94,F
1698E:  BNZ   16994
16990:  MOVF   x95,F
16992:  BZ    169B2
16994:  MOVF   x95,F
16996:  BNZ   169B2
16998:  MOVF   x94,W
1699A:  SUBLW  10
1699C:  BNC   169B2
....................          play_macro(macro_arg[1], macro_arg[0]);   // [1] casts to int8 / [0] = port 
1699E:  MOVFF  894,897
169A2:  MOVFF  893,899
169A6:  MOVFF  892,898
169AA:  MOVLB  0
169AC:  CALL   153A8
169B0:  MOVLB  8
....................       } 
....................    } 
169B2:  BRA    169C0
....................    else { 
....................       cmd_err(); 
169B4:  MOVLB  0
169B6:  CALL   BFB4
....................       macro_end = 59; 
169BA:  MOVLW  3B
169BC:  MOVLB  8
169BE:  MOVWF  x96
....................    } 
....................     
....................    return (macro_end); 
169C0:  MOVFF  896,01
169C4:  MOVLB  0
169C6:  RETURN 0
.................... } 
....................  
....................  
....................     
....................   
....................  
....................  
.................... #include "auto.c" 
.................... int8 auto_sample_eco() 
.................... { 
....................    int8 macro_cmd; 
....................  
....................    while(TRUE){ 
....................       if ( (nv_elapsed >= nv_interval) && (MaxSamples == FALSE) ) 
*
16242:  MOVF   24,W
16244:  SUBWF  36,W
16246:  BTFSS  FD8.0
16248:  BRA    16450
1624A:  BNZ   16254
1624C:  MOVF   23,W
1624E:  SUBWF  35,W
16250:  BTFSS  FD8.0
16252:  BRA    16450
16254:  MOVF   33,F
16256:  BTFSS  FD8.2
16258:  BRA    16450
1625A:  MOVF   34,F
1625C:  BTFSS  FD8.2
1625E:  BRA    16450
....................       { 
....................          nv_elapsed = 0; 
16260:  CLRF   36
16262:  CLRF   35
....................  
....................          init_hardware(); 
16264:  CALL   292E
....................          sd_status = init_sdcard(); 
16268:  CALL   502E
1626C:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
16270:  MOVLB  2
16272:  MOVF   xDC,F
16274:  BZ    1627E
16276:  MOVLB  0
16278:  CALL   5074
1627C:  MOVLB  2
....................  
....................          // changed by VK 5/9/2017 with Nmax fix and improved macro counting output 
....................          // fprintf(COM_A, "@Macro number S%04Lu of %04Lu\r\n", (nv_sample+1),nv_max_samples); 
....................                   
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
1627E:  MOVLW  01
16280:  MOVWF  1E
16282:  MOVLW  A7
16284:  MOVWF  1D
16286:  MOVLW  3A
16288:  MOVWF  FF6
1628A:  MOVLW  22
1628C:  MOVWF  FF7
1628E:  MOVLW  00
16290:  MOVWF  FF8
16292:  MOVLW  14
16294:  MOVLB  8
16296:  MOVWF  xEB
16298:  MOVLB  0
1629A:  CALL   AAC0
1629E:  MOVLW  10
162A0:  MOVWF  FE9
162A2:  MOVFF  22,8F7
162A6:  MOVFF  21,8F6
162AA:  CALL   AAF2
162AE:  MOVLW  51
162B0:  MOVWF  FF6
162B2:  MOVLW  22
162B4:  MOVWF  FF7
162B6:  MOVLW  00
162B8:  MOVWF  FF8
162BA:  MOVLW  09
162BC:  MOVLB  8
162BE:  MOVWF  xEB
162C0:  MOVLB  0
162C2:  CALL   AAC0
....................          record_event();          
162C6:  CALL   84CE
....................              
....................          macro_cmd = master_macro_eco(); 
162CA:  RCALL  15F8E
162CC:  MOVFF  01,887
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample number 
162D0:  MOVLW  16
162D2:  MOVLB  8
162D4:  MOVWF  xEE
162D6:  MOVFF  22,8F0
162DA:  MOVFF  21,8EF
162DE:  MOVLB  0
162E0:  CALL   4FC8
....................          write16(ADDR_MACRO_STEP, nv_macro_step); 
162E4:  MOVLW  3A
162E6:  MOVLB  8
162E8:  MOVWF  xEE
162EA:  MOVFF  38,8F0
162EE:  MOVFF  37,8EF
162F2:  MOVLB  0
162F4:  CALL   4FC8
....................          // both nv_sample & nv_macro_step are updated by master_macro(); 
....................  
....................          if (user_quit == TRUE) 
162F8:  DECFSZ 50,W
162FA:  BRA    1631E
....................          { 
....................             disable_interrupts (INT_EXT); 
162FC:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
162FE:  CLRF   32
16300:  MOVLW  01
16302:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16304:  MOVLW  02
16306:  MOVLB  8
16308:  MOVWF  x89
1630A:  MOVFF  31,88A
1630E:  MOVLB  0
16310:  CALL   3406
....................             busy_clear(); 
16314:  CALL   AEA4
....................             return (user_quit); 
16318:  MOVFF  50,01
1631C:  BRA    16460
....................          } 
....................  
....................          motor_sleep_rdy(); 
1631E:  CALL   298C
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16322:  MOVLW  01
16324:  MOVWF  1E
16326:  MOVLW  A7
16328:  MOVWF  1D
1632A:  MOVLW  5C
1632C:  MOVWF  FF6
1632E:  MOVLW  22
16330:  MOVWF  FF7
16332:  MOVLW  00
16334:  MOVWF  FF8
16336:  MOVLW  14
16338:  MOVLB  8
1633A:  MOVWF  xEB
1633C:  MOVLB  0
1633E:  CALL   AAC0
16342:  MOVLW  10
16344:  MOVWF  FE9
16346:  MOVFF  22,8F7
1634A:  MOVFF  21,8F6
1634E:  CALL   AAF2
16352:  MOVLW  73
16354:  MOVWF  FF6
16356:  MOVLW  22
16358:  MOVWF  FF7
1635A:  MOVLW  00
1635C:  MOVWF  FF8
1635E:  MOVLW  0C
16360:  MOVLB  8
16362:  MOVWF  xEB
16364:  MOVLB  0
16366:  CALL   AAC0
....................          record_event();  
1636A:  CALL   84CE
....................           
....................          if (macro_cmd == 'e') 
1636E:  MOVLB  8
16370:  MOVF   x87,W
16372:  SUBLW  65
16374:  BNZ   163C8
....................          { 
....................             disable_interrupts (INT_EXT); 
16376:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],error\r\n", nv_sample); 
16378:  MOVLW  01
1637A:  MOVWF  1E
1637C:  MOVLW  A7
1637E:  MOVWF  1D
16380:  MOVLW  80
16382:  MOVWF  FF6
16384:  MOVLW  22
16386:  MOVWF  FF7
16388:  MOVLW  00
1638A:  MOVWF  FF8
1638C:  MOVLW  14
1638E:  MOVWF  xEB
16390:  MOVLB  0
16392:  CALL   AAC0
16396:  MOVLW  10
16398:  MOVWF  FE9
1639A:  MOVFF  22,8F7
1639E:  MOVFF  21,8F6
163A2:  CALL   AAF2
163A6:  MOVLW  97
163A8:  MOVWF  FF6
163AA:  MOVLW  22
163AC:  MOVWF  FF7
163AE:  MOVLW  00
163B0:  MOVWF  FF8
163B2:  MOVLW  09
163B4:  MOVLB  8
163B6:  MOVWF  xEB
163B8:  MOVLB  0
163BA:  CALL   AAC0
....................             record_event();  
163BE:  CALL   84CE
....................             cmd_err(); 
163C2:  CALL   BFB4
163C6:  MOVLB  8
....................          }  
....................          if (nv_sample >= nv_max_samples) 
163C8:  MOVF   28,W
163CA:  SUBWF  22,W
163CC:  BNC   16452
163CE:  BNZ   163D6
163D0:  MOVF   27,W
163D2:  SUBWF  21,W
163D4:  BNC   16452
....................          { 
....................             disable_interrupts (INT_EXT); 
163D6:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
163D8:  MOVLW  01
163DA:  MOVWF  1E
163DC:  MOVLW  A7
163DE:  MOVWF  1D
163E0:  MOVLW  A2
163E2:  MOVWF  FF6
163E4:  MOVLW  22
163E6:  MOVWF  FF7
163E8:  MOVLW  00
163EA:  MOVWF  FF8
163EC:  MOVLW  14
163EE:  MOVWF  xEB
163F0:  MOVLB  0
163F2:  CALL   AAC0
163F6:  MOVLW  10
163F8:  MOVWF  FE9
163FA:  MOVFF  22,8F7
163FE:  MOVFF  21,8F6
16402:  CALL   AAF2
16406:  MOVLW  B9
16408:  MOVWF  FF6
1640A:  MOVLW  22
1640C:  MOVWF  FF7
1640E:  MOVLW  00
16410:  MOVWF  FF8
16412:  MOVLW  0F
16414:  MOVLB  8
16416:  MOVWF  xEB
16418:  MOVLB  0
1641A:  CALL   AAC0
....................             record_event();   
1641E:  CALL   84CE
....................             msg_max(); 
16422:  RCALL  16224
....................             // set MaxSamples flag 
....................             MaxSamples = TRUE; 
16424:  CLRF   34
16426:  MOVLW  01
16428:  MOVWF  33
....................             write8(ADDR_MaxSamples,MaxSamples);  // Set flag to stop sampling on power cycle 
1642A:  MOVLW  28
1642C:  MOVLB  8
1642E:  MOVWF  x89
16430:  MOVFF  33,88A
16434:  MOVLB  0
16436:  CALL   3406
....................             nv_cmd_mode = TRUE;  // Vince's fix for non-terminating logging 
1643A:  CLRF   32
1643C:  MOVLW  01
1643E:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16440:  MOVLW  02
16442:  MOVLB  8
16444:  MOVWF  x89
16446:  MOVFF  31,88A
1644A:  MOVLB  0
1644C:  CALL   3406
16450:  MOVLB  8
....................           } 
....................       } 
....................       go_to_sleep(); 
16452:  MOVLB  0
16454:  RCALL  15EC8
16456:  BRA    16242
....................    } 
....................     
....................    busy_clear(); 
16458:  CALL   AEA4
....................    return (user_quit); 
1645C:  MOVFF  50,01
16460:  GOTO   16D84 (RETURN)
.................... } 
....................  
.................... int8 auto_sample_wms() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
1665C:  MOVF   24,W
1665E:  SUBWF  36,W
16660:  BTFSS  FD8.0
16662:  BRA    16832
16664:  BNZ   1666E
16666:  MOVF   23,W
16668:  SUBWF  35,W
1666A:  BTFSS  FD8.0
1666C:  BRA    16832
....................       { 
....................          nv_elapsed = 0; 
1666E:  CLRF   36
16670:  CLRF   35
....................  
....................          init_hardware(); 
16672:  CALL   292E
....................          sd_status = init_sdcard(); 
16676:  CALL   502E
1667A:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
1667E:  MOVLB  2
16680:  MOVF   xDC,F
16682:  BZ    1668C
16684:  MOVLB  0
16686:  CALL   5074
1668A:  MOVLB  2
....................  
....................          ++nv_sample; 
1668C:  INCF   21,F
1668E:  BTFSC  FD8.2
16690:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
16692:  MOVLW  40
16694:  BTFSS  F9E.4
16696:  BRA    16694
16698:  MOVWF  FAD
1669A:  MOVLW  53
1669C:  BTFSS  F9E.4
1669E:  BRA    1669C
166A0:  MOVWF  FAD
166A2:  MOVLW  09
166A4:  MOVWF  FE9
166A6:  CLRF   1B
166A8:  BTFSC  FF2.7
166AA:  BSF    1B.7
166AC:  BCF    FF2.7
166AE:  MOVFF  22,A41
166B2:  MOVFF  21,A40
166B6:  MOVLB  0
166B8:  CALL   119A
166BC:  BTFSC  1B.7
166BE:  BSF    FF2.7
166C0:  MOVLW  0D
166C2:  BTFSS  F9E.4
166C4:  BRA    166C2
166C6:  MOVWF  FAD
166C8:  MOVLW  0A
166CA:  BTFSS  F9E.4
166CC:  BRA    166CA
166CE:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
166D0:  MOVLW  01
166D2:  MOVWF  1E
166D4:  MOVLW  A7
166D6:  MOVWF  1D
166D8:  MOVLW  CA
166DA:  MOVWF  FF6
166DC:  MOVLW  22
166DE:  MOVWF  FF7
166E0:  MOVLW  00
166E2:  MOVWF  FF8
166E4:  MOVLW  14
166E6:  MOVLB  8
166E8:  MOVWF  xEB
166EA:  MOVLB  0
166EC:  CALL   AAC0
166F0:  MOVLW  10
166F2:  MOVWF  FE9
166F4:  MOVFF  22,8F7
166F8:  MOVFF  21,8F6
166FC:  CALL   AAF2
16700:  MOVLW  E1
16702:  MOVWF  FF6
16704:  MOVLW  22
16706:  MOVWF  FF7
16708:  MOVLW  00
1670A:  MOVWF  FF8
1670C:  MOVLW  09
1670E:  MOVLB  8
16710:  MOVWF  xEB
16712:  MOVLB  0
16714:  CALL   AAC0
....................          record_event();   
16718:  CALL   84CE
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
1671C:  MOVLW  16
1671E:  MOVLB  8
16720:  MOVWF  xEE
16722:  MOVFF  22,8F0
16726:  MOVFF  21,8EF
1672A:  MOVLB  0
1672C:  CALL   4FC8
....................  
....................          if (nv_macro_mode==TRUE) 
16730:  DECFSZ 29,W
16732:  BRA    16748
16734:  MOVF   2A,F
16736:  BNZ   16748
....................          { 
....................             macro_end = master_macro_wms(nv_sample); 
16738:  MOVFF  22,889
1673C:  MOVFF  21,888
16740:  BRA    16464
16742:  MOVFF  01,887
....................          } 
16746:  BRA    167B0
....................          else 
....................          { 
....................             time_stamp(); 
16748:  CALL   540E
....................             play_wms_hard_macro(nv_port); 
1674C:  MOVFF  2E,88A
16750:  MOVFF  2D,889
16754:  CALL   D7F4
....................             ++nv_port; 
16758:  INCF   2D,F
1675A:  BTFSC  FD8.2
1675C:  INCF   2E,F
....................             if((nv_port>1 && nv_port<49 && nv_product==WMS4) || 
....................                (nv_port>1 && nv_port<51 && nv_product==WMS2)) 
1675E:  MOVF   2E,F
16760:  BNZ   16768
16762:  MOVF   2D,W
16764:  SUBLW  01
16766:  BC    1677A
16768:  MOVF   2E,F
1676A:  BNZ   1677A
1676C:  MOVF   2D,W
1676E:  SUBLW  30
16770:  BNC   1677A
16772:  DECFSZ 2F,W
16774:  BRA    1677A
16776:  MOVF   30,F
16778:  BZ    16798
1677A:  MOVF   2E,F
1677C:  BNZ   16784
1677E:  MOVF   2D,W
16780:  SUBLW  01
16782:  BC    167AE
16784:  MOVF   2E,F
16786:  BNZ   167AE
16788:  MOVF   2D,W
1678A:  SUBLW  32
1678C:  BNC   167AE
1678E:  MOVF   2F,W
16790:  SUBLW  03
16792:  BNZ   167AE
16794:  MOVF   30,F
16796:  BNZ   167AE
....................             { 
....................                write16(ADDR_PORT, nv_port);             
16798:  MOVLW  24
1679A:  MOVLB  8
1679C:  MOVWF  xEE
1679E:  MOVFF  2E,8F0
167A2:  MOVFF  2D,8EF
167A6:  MOVLB  0
167A8:  CALL   4FC8
....................             } 
167AC:  BRA    167B0
....................             else disable_interrupts (INT_EXT); 
167AE:  BCF    FF2.4
....................          } 
....................           
....................          if (user_quit == TRUE) 
167B0:  DECFSZ 50,W
167B2:  BRA    167D6
....................          { 
....................             disable_interrupts (INT_EXT); 
167B4:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
167B6:  CLRF   32
167B8:  MOVLW  01
167BA:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
167BC:  MOVLW  02
167BE:  MOVLB  8
167C0:  MOVWF  x89
167C2:  MOVFF  31,88A
167C6:  MOVLB  0
167C8:  CALL   3406
....................             busy_clear(); 
167CC:  CALL   AEA4
....................             return (user_quit); 
167D0:  MOVFF  50,01
167D4:  BRA    16840
....................          } 
....................           
....................          motor_sleep_rdy(); 
167D6:  CALL   298C
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
167DA:  MOVLW  01
167DC:  MOVWF  1E
167DE:  MOVLW  A7
167E0:  MOVWF  1D
167E2:  MOVLW  EC
167E4:  MOVWF  FF6
167E6:  MOVLW  22
167E8:  MOVWF  FF7
167EA:  MOVLW  00
167EC:  MOVWF  FF8
167EE:  MOVLW  14
167F0:  MOVLB  8
167F2:  MOVWF  xEB
167F4:  MOVLB  0
167F6:  CALL   AAC0
167FA:  MOVLW  10
167FC:  MOVWF  FE9
167FE:  MOVFF  22,8F7
16802:  MOVFF  21,8F6
16806:  CALL   AAF2
1680A:  MOVLW  03
1680C:  MOVWF  FF6
1680E:  MOVLW  23
16810:  MOVWF  FF7
16812:  MOVLW  00
16814:  MOVWF  FF8
16816:  MOVLW  0C
16818:  MOVLB  8
1681A:  MOVWF  xEB
1681C:  MOVLB  0
1681E:  CALL   AAC0
....................          record_event();  
16822:  CALL   84CE
....................           
....................          if (macro_end == ';') 
16826:  MOVLB  8
16828:  MOVF   x87,W
1682A:  SUBLW  3B
1682C:  BNZ   16830
....................          { 
....................             disable_interrupts (INT_EXT); 
1682E:  BCF    FF2.4
16830:  MOVLB  0
....................          }  
....................       } 
....................       go_to_sleep(); 
16832:  CALL   15EC8
16836:  BRA    1665C
....................    } 
....................    busy_clear(); 
16838:  CALL   AEA4
....................    return (user_quit); 
1683C:  MOVFF  50,01
16840:  GOTO   16D8C (RETURN)
.................... } 
....................  
.................... int8 auto_sample_aws() 
.................... { 
....................    int8 macro_end; 
....................     
....................    while(TRUE){ 
....................       if (nv_elapsed >= nv_interval) 
*
169C8:  MOVF   24,W
169CA:  SUBWF  36,W
169CC:  BTFSS  FD8.0
169CE:  BRA    16B88
169D0:  BNZ   169DA
169D2:  MOVF   23,W
169D4:  SUBWF  35,W
169D6:  BTFSS  FD8.0
169D8:  BRA    16B88
....................       { 
....................          nv_elapsed = 0; 
169DA:  CLRF   36
169DC:  CLRF   35
....................  
....................          init_hardware(); 
169DE:  CALL   292E
....................          sd_status = init_sdcard(); 
169E2:  CALL   502E
169E6:  MOVFF  01,2DC
....................          if(sd_status>0) msg_card_fail(); 
169EA:  MOVLB  2
169EC:  MOVF   xDC,F
169EE:  BZ    169F8
169F0:  MOVLB  0
169F2:  CALL   5074
169F6:  MOVLB  2
....................  
....................          ++nv_sample; 
169F8:  INCF   21,F
169FA:  BTFSC  FD8.2
169FC:  INCF   22,F
....................  
....................          fprintf(COM_A, "@S%04Lu\r\n", (nv_sample)); 
169FE:  MOVLW  40
16A00:  BTFSS  F9E.4
16A02:  BRA    16A00
16A04:  MOVWF  FAD
16A06:  MOVLW  53
16A08:  BTFSS  F9E.4
16A0A:  BRA    16A08
16A0C:  MOVWF  FAD
16A0E:  MOVLW  09
16A10:  MOVWF  FE9
16A12:  CLRF   1B
16A14:  BTFSC  FF2.7
16A16:  BSF    1B.7
16A18:  BCF    FF2.7
16A1A:  MOVFF  22,A41
16A1E:  MOVFF  21,A40
16A22:  MOVLB  0
16A24:  CALL   119A
16A28:  BTFSC  1B.7
16A2A:  BSF    FF2.7
16A2C:  MOVLW  0D
16A2E:  BTFSS  F9E.4
16A30:  BRA    16A2E
16A32:  MOVWF  FAD
16A34:  MOVLW  0A
16A36:  BTFSS  F9E.4
16A38:  BRA    16A36
16A3A:  MOVWF  FAD
....................  
....................          sprintf(event_str, ",auto-sample,sample[%Lu],start\r\n", nv_sample); 
16A3C:  MOVLW  01
16A3E:  MOVWF  1E
16A40:  MOVLW  A7
16A42:  MOVWF  1D
16A44:  MOVLW  10
16A46:  MOVWF  FF6
16A48:  MOVLW  23
16A4A:  MOVWF  FF7
16A4C:  MOVLW  00
16A4E:  MOVWF  FF8
16A50:  MOVLW  14
16A52:  MOVLB  8
16A54:  MOVWF  xEB
16A56:  MOVLB  0
16A58:  CALL   AAC0
16A5C:  MOVLW  10
16A5E:  MOVWF  FE9
16A60:  MOVFF  22,8F7
16A64:  MOVFF  21,8F6
16A68:  CALL   AAF2
16A6C:  MOVLW  27
16A6E:  MOVWF  FF6
16A70:  MOVLW  23
16A72:  MOVWF  FF7
16A74:  MOVLW  00
16A76:  MOVWF  FF8
16A78:  MOVLW  09
16A7A:  MOVLB  8
16A7C:  MOVWF  xEB
16A7E:  MOVLB  0
16A80:  CALL   AAC0
....................          record_event();   
16A84:  CALL   84CE
....................  
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
16A88:  MOVLW  16
16A8A:  MOVLB  8
16A8C:  MOVWF  xEE
16A8E:  MOVFF  22,8F0
16A92:  MOVFF  21,8EF
16A96:  MOVLB  0
16A98:  CALL   4FC8
....................  
....................          macro_end = master_macro_aws(nv_sample); 
16A9C:  MOVFF  22,88D
16AA0:  MOVFF  21,88C
16AA4:  RCALL  16844
16AA6:  MOVFF  01,887
....................           
....................          if (user_quit == TRUE) 
16AAA:  DECFSZ 50,W
16AAC:  BRA    16AD0
....................          { 
....................             disable_interrupts (INT_EXT); 
16AAE:  BCF    FF2.4
....................             nv_cmd_mode = TRUE; 
16AB0:  CLRF   32
16AB2:  MOVLW  01
16AB4:  MOVWF  31
....................             write8(ADDR_CMD_MODE, nv_cmd_mode); 
16AB6:  MOVLW  02
16AB8:  MOVLB  8
16ABA:  MOVWF  x89
16ABC:  MOVFF  31,88A
16AC0:  MOVLB  0
16AC2:  CALL   3406
....................             busy_clear(); 
16AC6:  CALL   AEA4
....................             return (user_quit); 
16ACA:  MOVFF  50,01
16ACE:  BRA    16B9A
....................          } 
....................           
....................          motor_sleep_rdy(); 
16AD0:  CALL   298C
....................           
....................          sprintf(event_str, ",auto-sample,sample[%Lu],complete\r\n", nv_sample); 
16AD4:  MOVLW  01
16AD6:  MOVWF  1E
16AD8:  MOVLW  A7
16ADA:  MOVWF  1D
16ADC:  MOVLW  32
16ADE:  MOVWF  FF6
16AE0:  MOVLW  23
16AE2:  MOVWF  FF7
16AE4:  MOVLW  00
16AE6:  MOVWF  FF8
16AE8:  MOVLW  14
16AEA:  MOVLB  8
16AEC:  MOVWF  xEB
16AEE:  MOVLB  0
16AF0:  CALL   AAC0
16AF4:  MOVLW  10
16AF6:  MOVWF  FE9
16AF8:  MOVFF  22,8F7
16AFC:  MOVFF  21,8F6
16B00:  CALL   AAF2
16B04:  MOVLW  49
16B06:  MOVWF  FF6
16B08:  MOVLW  23
16B0A:  MOVWF  FF7
16B0C:  MOVLW  00
16B0E:  MOVWF  FF8
16B10:  MOVLW  0C
16B12:  MOVLB  8
16B14:  MOVWF  xEB
16B16:  MOVLB  0
16B18:  CALL   AAC0
....................          record_event();  
16B1C:  CALL   84CE
....................           
....................          if (macro_end == ';') 
16B20:  MOVLB  8
16B22:  MOVF   x87,W
16B24:  SUBLW  3B
16B26:  BNZ   16B2A
....................          { 
....................             disable_interrupts (INT_EXT); 
16B28:  BCF    FF2.4
....................          }  
....................          if (nv_sample >= nv_max_samples) 
16B2A:  MOVF   28,W
16B2C:  SUBWF  22,W
16B2E:  BNC   16B8A
16B30:  BNZ   16B38
16B32:  MOVF   27,W
16B34:  SUBWF  21,W
16B36:  BNC   16B8A
....................          { 
....................             disable_interrupts (INT_EXT); 
16B38:  BCF    FF2.4
....................             sprintf(event_str, ",auto-sample,sample[%Lu],max samples\r\n", nv_sample); 
16B3A:  MOVLW  01
16B3C:  MOVWF  1E
16B3E:  MOVLW  A7
16B40:  MOVWF  1D
16B42:  MOVLW  56
16B44:  MOVWF  FF6
16B46:  MOVLW  23
16B48:  MOVWF  FF7
16B4A:  MOVLW  00
16B4C:  MOVWF  FF8
16B4E:  MOVLW  14
16B50:  MOVWF  xEB
16B52:  MOVLB  0
16B54:  CALL   AAC0
16B58:  MOVLW  10
16B5A:  MOVWF  FE9
16B5C:  MOVFF  22,8F7
16B60:  MOVFF  21,8F6
16B64:  CALL   AAF2
16B68:  MOVLW  6D
16B6A:  MOVWF  FF6
16B6C:  MOVLW  23
16B6E:  MOVWF  FF7
16B70:  MOVLW  00
16B72:  MOVWF  FF8
16B74:  MOVLW  0F
16B76:  MOVLB  8
16B78:  MOVWF  xEB
16B7A:  MOVLB  0
16B7C:  CALL   AAC0
....................             record_event();   
16B80:  CALL   84CE
....................             msg_max(); 
16B84:  CALL   16224
16B88:  MOVLB  8
....................          } 
....................       } 
....................       go_to_sleep(); 
16B8A:  MOVLB  0
16B8C:  CALL   15EC8
16B90:  BRA    169C8
....................    } 
....................    busy_clear(); 
16B92:  CALL   AEA4
....................    return (user_quit); 
16B96:  MOVFF  50,01
16B9A:  GOTO   16D94 (RETURN)
.................... } 
....................  
....................  
.................... int8 auto_sample_ready() 
.................... {   
....................    busy_set(); 
16B9E:  CALL   29B4
....................     
....................    sprintf(event_str, ",auto-sample,initialize\r\n"); 
16BA2:  MOVLW  01
16BA4:  MOVWF  1E
16BA6:  MOVLW  A7
16BA8:  MOVWF  1D
16BAA:  MOVLW  7E
16BAC:  MOVWF  FF6
16BAE:  MOVLW  23
16BB0:  MOVWF  FF7
16BB2:  MOVLW  00
16BB4:  MOVWF  FF8
16BB6:  CALL   50B2
....................    record_event(); 
16BBA:  CALL   84CE
....................    sprintf(event_str, ",header,id#[%Lu],int[%Lu],max[%Lu]\r\n", 
....................                         nv_serial,nv_interval,nv_max_samples); 
16BBE:  MOVLW  01
16BC0:  MOVWF  1E
16BC2:  MOVLW  A7
16BC4:  MOVWF  1D
16BC6:  MOVLW  98
16BC8:  MOVWF  FF6
16BCA:  MOVLW  23
16BCC:  MOVWF  FF7
16BCE:  MOVLW  00
16BD0:  MOVWF  FF8
16BD2:  MOVLW  0C
16BD4:  MOVLB  8
16BD6:  MOVWF  xEB
16BD8:  MOVLB  0
16BDA:  CALL   AAC0
16BDE:  MOVLW  10
16BE0:  MOVWF  FE9
16BE2:  MOVFF  26,8F7
16BE6:  MOVFF  25,8F6
16BEA:  CALL   AAF2
16BEE:  MOVLW  A7
16BF0:  MOVWF  FF6
16BF2:  MOVLW  23
16BF4:  MOVWF  FF7
16BF6:  MOVLW  00
16BF8:  MOVWF  FF8
16BFA:  MOVLW  06
16BFC:  MOVLB  8
16BFE:  MOVWF  xEB
16C00:  MOVLB  0
16C02:  CALL   AAC0
16C06:  MOVLW  10
16C08:  MOVWF  FE9
16C0A:  MOVFF  24,8F7
16C0E:  MOVFF  23,8F6
16C12:  CALL   AAF2
16C16:  MOVLW  B0
16C18:  MOVWF  FF6
16C1A:  MOVLW  23
16C1C:  MOVWF  FF7
16C1E:  MOVLW  00
16C20:  MOVWF  FF8
16C22:  MOVLW  06
16C24:  MOVLB  8
16C26:  MOVWF  xEB
16C28:  MOVLB  0
16C2A:  CALL   AAC0
16C2E:  MOVLW  10
16C30:  MOVWF  FE9
16C32:  MOVFF  28,8F7
16C36:  MOVFF  27,8F6
16C3A:  CALL   AAF2
16C3E:  MOVLW  B9
16C40:  MOVWF  FF6
16C42:  MOVLW  23
16C44:  MOVWF  FF7
16C46:  MOVLW  00
16C48:  MOVWF  FF8
16C4A:  MOVLW  03
16C4C:  MOVLB  8
16C4E:  MOVWF  xEB
16C50:  MOVLB  0
16C52:  CALL   AAC0
....................    record_event(); 
16C56:  CALL   84CE
....................     
....................    user_quit = FALSE; 
16C5A:  CLRF   50
....................     
....................    nv_cmd_mode = FALSE; 
16C5C:  CLRF   32
16C5E:  CLRF   31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
16C60:  MOVLW  02
16C62:  MOVLB  8
16C64:  MOVWF  x89
16C66:  MOVFF  31,88A
16C6A:  MOVLB  0
16C6C:  CALL   3406
....................  
....................    RTC_set_AFE(); 
16C70:  GOTO   1570E
....................    // check if start is earlier than now 
....................    RTC_late(); 
16C74:  CALL   15766
....................    // show clock 
....................    RTC_display(); 
16C78:  CALL   E27E
....................    // show alarm 
....................    RTC_display_alarm(); 
16C7C:  CALL   E4DE
....................    // show if alarm is late 
....................    RTC_alarm_status(); 
16C80:  CALL   15C2C
....................  
....................    if (alarm_passed == FALSE){ 
16C84:  BTFSC  4D.3
16C86:  BRA    16C88
....................       //nv_sample = 0; 
....................       //write16(ADDR_SAMPLE, nv_sample); 
....................       //nv_macro_step = 0; 
....................       //write16(ADDR_MACRO_STEP, nv_macro_step); 
....................    } 
....................  
....................    sprintf(event_str, ",auto-sample,sample[%Lu],alarm[%u]\r\n",  
....................                                     nv_sample,alarm_passed); 
16C88:  MOVLW  00
16C8A:  BTFSC  4D.3
16C8C:  MOVLW  01
16C8E:  MOVLB  8
16C90:  MOVWF  x87
16C92:  MOVLW  01
16C94:  MOVWF  1E
16C96:  MOVLW  A7
16C98:  MOVWF  1D
16C9A:  MOVLW  BE
16C9C:  MOVWF  FF6
16C9E:  MOVLW  23
16CA0:  MOVWF  FF7
16CA2:  MOVLW  00
16CA4:  MOVWF  FF8
16CA6:  MOVLW  14
16CA8:  MOVWF  xEB
16CAA:  MOVLB  0
16CAC:  CALL   AAC0
16CB0:  MOVLW  10
16CB2:  MOVWF  FE9
16CB4:  MOVFF  22,8F7
16CB8:  MOVFF  21,8F6
16CBC:  CALL   AAF2
16CC0:  MOVLW  D5
16CC2:  MOVWF  FF6
16CC4:  MOVLW  23
16CC6:  MOVWF  FF7
16CC8:  MOVLW  00
16CCA:  MOVWF  FF8
16CCC:  MOVLW  08
16CCE:  MOVLB  8
16CD0:  MOVWF  xEB
16CD2:  MOVLB  0
16CD4:  CALL   AAC0
16CD8:  MOVFF  887,8ED
16CDC:  MOVLW  1B
16CDE:  MOVLB  8
16CE0:  MOVWF  xEE
16CE2:  MOVLB  0
16CE4:  CALL   5274
16CE8:  MOVLW  DF
16CEA:  MOVWF  FF6
16CEC:  MOVLW  23
16CEE:  MOVWF  FF7
16CF0:  MOVLW  00
16CF2:  MOVWF  FF8
16CF4:  MOVLW  03
16CF6:  MOVLB  8
16CF8:  MOVWF  xEB
16CFA:  MOVLB  0
16CFC:  CALL   AAC0
....................    record_event();  
16D00:  CALL   84CE
....................  
....................    while (TRUE == RTC_read_flags_running) 
16D04:  BTFSS  4D.2
16D06:  BRA    16D0A
....................    { 
....................       ; 
16D08:  BRA    16D04
....................    } 
....................    RTC_read_flags_running = TRUE; 
16D0A:  BSF    4D.2
16D0C:  CLRF   1B
16D0E:  BTFSC  FF2.7
16D10:  BSF    1B.7
16D12:  BCF    FF2.7
....................    RTC_read_flags(); 
16D14:  CALL   0DCC
16D18:  BTFSC  1B.7
16D1A:  BSF    FF2.7
....................  
....................    enable_interrupts(INT_EXT);   // enable RTC alarms 
16D1C:  BSF    FF2.4
....................  
....................    motor_sleep_rdy(); 
16D1E:  CALL   298C
.................... //   shutdown(); 
....................     
....................    // if wake-up is in the future, go to sleep & wait 
....................    if (alarm_passed == FALSE) { 
16D22:  BTFSC  4D.3
16D24:  BRA    16D46
....................       sprintf(event_str, ",auto-sample,sleep\r\n"); 
16D26:  MOVLW  01
16D28:  MOVWF  1E
16D2A:  MOVLW  A7
16D2C:  MOVWF  1D
16D2E:  MOVLW  E4
16D30:  MOVWF  FF6
16D32:  MOVLW  23
16D34:  MOVWF  FF7
16D36:  MOVLW  00
16D38:  MOVWF  FF8
16D3A:  CALL   50B2
....................       record_event(); 
16D3E:  CALL   84CE
....................       go_to_sleep(); 
16D42:  CALL   15EC8
....................    } 
....................     
....................    RTC_minute();                 // set 1 minute alarms 
16D46:  GOTO   15EDE
....................    nv_elapsed = nv_interval; 
16D4A:  MOVFF  24,36
16D4E:  MOVFF  23,35
....................     
....................    switch(nv_product){ 
16D52:  MOVFF  2F,00
16D56:  MOVF   30,W
16D58:  MOVWF  03
16D5A:  BNZ   16D60
16D5C:  MOVF   00,F
16D5E:  BZ    16D80
16D60:  MOVF   03,W
16D62:  BNZ   16D6A
16D64:  MOVLW  01
16D66:  SUBWF  00,W
16D68:  BZ    16D8A
16D6A:  MOVF   03,W
16D6C:  BNZ   16D74
16D6E:  MOVLW  03
16D70:  SUBWF  00,W
16D72:  BZ    16D8A
16D74:  MOVF   03,W
16D76:  BNZ   16D7E
16D78:  MOVLW  02
16D7A:  SUBWF  00,W
16D7C:  BZ    16D92
16D7E:  BRA    16D98
....................       case ECO: user_quit = auto_sample_eco(); 
16D80:  GOTO   16242
16D84:  MOVFF  01,50
....................          break; 
16D88:  BRA    16D98
....................       case WMS4 :  
....................       case WMS2 : user_quit = auto_sample_wms(); 
16D8A:  BRA    1665C
16D8C:  MOVFF  01,50
....................          break; 
16D90:  BRA    16D98
....................       case AWS: user_quit = auto_sample_aws(); 
16D92:  BRA    169C8
16D94:  MOVFF  01,50
....................          break;          
....................    } 
....................    return(user_quit); 
16D98:  MOVFF  50,01
16D9C:  GOTO   16EAE (RETURN)
.................... } 
....................  
....................  
.................... #include "command.c" 
....................  
.................... // ********** COMMANDS ********** // 
.................... //  C command to calculate data removed  
.................... #define USERCMDLIST  "%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^" 
.................... #define FULLCMDLIST  "#%*/&+-ABDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz" 
.................... #include "command.h" 
.................... #ifndef _command_h 
.................... #define _command_h 
.................... /* The following is being added so that the methods listed in the command.c 
.................... file can be accessed elsewhere.*/ 
.................... void commandA(); 
.................... void commandB(); 
.................... void commandC(); 
.................... void commandD(); 
.................... void commandE(); 
.................... void commandF(); 
.................... void commandG(); 
.................... void commandH(); 
.................... void commandI(); 
.................... void commandJ(); 
.................... void commandK(); 
.................... void commandL(); 
.................... void commandM(int1 LoggingReentry); 
.................... void commandN(); 
.................... void commandO(); 
.................... void commandP(); 
.................... void commandQ(); 
.................... void commandR(); 
.................... void commandS(); 
.................... void commandT(); 
.................... void commandU(); 
.................... void commandV(); 
.................... void commandW(); 
.................... void commandX(); 
.................... void commandY(); 
.................... void commandZ(); 
.................... void command_v(); 
....................  
....................  
.................... void calc_abs_data(); 
....................  
.................... #endif 
....................  
....................  
.................... void command_addr() 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
0BF84:  MOVF   48,F
0BF86:  BNZ   BF94
0BF88:  MOVF   49,F
0BF8A:  BNZ   BF94
0BF8C:  MOVF   4A,F
0BF8E:  BNZ   BF94
0BF90:  MOVF   4B,F
0BF92:  BZ    BFAC
0BF94:  MOVF   4B,F
0BF96:  BNZ   BFAC
0BF98:  MOVF   4A,F
0BF9A:  BNZ   BFAC
0BF9C:  MOVF   49,F
0BF9E:  BNZ   BFAC
0BFA0:  MOVF   48,W
0BFA2:  SUBLW  02
0BFA4:  BNC   BFAC
....................       detector = arg; 
0BFA6:  MOVFF  48,2D5
....................    } 
0BFAA:  BRA    BFB0
....................    else cmd_arg(); 
0BFAC:  CALL   B2F2
0BFB0:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandAe() 
.................... { 
....................    if(arg>0 && arg<65536){ 
*
0BFD2:  MOVF   48,F
0BFD4:  BNZ   BFE2
0BFD6:  MOVF   49,F
0BFD8:  BNZ   BFE2
0BFDA:  MOVF   4A,F
0BFDC:  BNZ   BFE2
0BFDE:  MOVF   4B,F
0BFE0:  BZ    C03C
0BFE2:  MOVF   4B,F
0BFE4:  BNZ   C03C
0BFE6:  MOVF   4A,W
0BFE8:  SUBLW  00
0BFEA:  BNC   C03C
....................       switch (detector){ 
0BFEC:  MOVLB  2
0BFEE:  MOVF   xD5,W
0BFF0:  XORLW  01
0BFF2:  MOVLB  0
0BFF4:  BZ    BFFC
0BFF6:  XORLW  03
0BFF8:  BZ    C01A
0BFFA:  BRA    C038
....................          case 1 : nv_d1_temp = arg; 
0BFFC:  MOVFF  49,42
0C000:  MOVFF  48,41
....................                   write16(ADDR_D1_TEMP,nv_d1_temp); 
0C004:  MOVLW  40
0C006:  MOVLB  8
0C008:  MOVWF  xEE
0C00A:  MOVFF  42,8F0
0C00E:  MOVFF  41,8EF
0C012:  MOVLB  0
0C014:  CALL   4FC8
....................             break; 
0C018:  BRA    C03A
....................          case 2 : nv_d2_temp = arg; 
0C01A:  MOVFF  49,44
0C01E:  MOVFF  48,43
....................                   write16(ADDR_D2_TEMP,nv_d2_temp); 
0C022:  MOVLW  42
0C024:  MOVLB  8
0C026:  MOVWF  xEE
0C028:  MOVFF  44,8F0
0C02C:  MOVFF  43,8EF
0C030:  MOVLB  0
0C032:  CALL   4FC8
....................             break; 
0C036:  BRA    C03A
....................          default : cmd_err(); 
0C038:  RCALL  BFB4
....................             break; 
....................       } 
....................    } 
0C03A:  BRA    C0E2
....................    else if (arg==0) fprintf(COM_A, "t1:%Lu t2:%Lu\r\n", nv_d1_temp, nv_d2_temp); 
0C03C:  MOVF   48,F
0C03E:  BNZ   C0DE
0C040:  MOVF   49,F
0C042:  BNZ   C0DE
0C044:  MOVF   4A,F
0C046:  BNZ   C0DE
0C048:  MOVF   4B,F
0C04A:  BNZ   C0DE
0C04C:  MOVLW  FA
0C04E:  MOVWF  FF6
0C050:  MOVLW  23
0C052:  MOVWF  FF7
0C054:  MOVLW  00
0C056:  MOVWF  FF8
0C058:  CLRF   1B
0C05A:  BTFSC  FF2.7
0C05C:  BSF    1B.7
0C05E:  BCF    FF2.7
0C060:  MOVLW  03
0C062:  MOVLB  A
0C064:  MOVWF  x40
0C066:  MOVLB  0
0C068:  CALL   1018
0C06C:  BTFSC  1B.7
0C06E:  BSF    FF2.7
0C070:  MOVLW  10
0C072:  MOVWF  FE9
0C074:  CLRF   1B
0C076:  BTFSC  FF2.7
0C078:  BSF    1B.7
0C07A:  BCF    FF2.7
0C07C:  MOVFF  42,A41
0C080:  MOVFF  41,A40
0C084:  CALL   119A
0C088:  BTFSC  1B.7
0C08A:  BSF    FF2.7
0C08C:  MOVLW  00
0C08E:  MOVWF  FF6
0C090:  MOVLW  24
0C092:  MOVWF  FF7
0C094:  MOVLW  00
0C096:  MOVWF  FF8
0C098:  CLRF   1B
0C09A:  BTFSC  FF2.7
0C09C:  BSF    1B.7
0C09E:  BCF    FF2.7
0C0A0:  MOVLW  04
0C0A2:  MOVLB  A
0C0A4:  MOVWF  x40
0C0A6:  MOVLB  0
0C0A8:  CALL   1018
0C0AC:  BTFSC  1B.7
0C0AE:  BSF    FF2.7
0C0B0:  MOVLW  10
0C0B2:  MOVWF  FE9
0C0B4:  CLRF   1B
0C0B6:  BTFSC  FF2.7
0C0B8:  BSF    1B.7
0C0BA:  BCF    FF2.7
0C0BC:  MOVFF  44,A41
0C0C0:  MOVFF  43,A40
0C0C4:  CALL   119A
0C0C8:  BTFSC  1B.7
0C0CA:  BSF    FF2.7
0C0CC:  MOVLW  0D
0C0CE:  BTFSS  F9E.4
0C0D0:  BRA    C0CE
0C0D2:  MOVWF  FAD
0C0D4:  MOVLW  0A
0C0D6:  BTFSS  F9E.4
0C0D8:  BRA    C0D6
0C0DA:  MOVWF  FAD
0C0DC:  BRA    C0E2
....................    else cmd_arg(); 
0C0DE:  CALL   B2F2
0C0E2:  GOTO   C148 (RETURN)
.................... } 
....................  
.................... void commandAw() 
.................... { 
....................    if(arg < 2){ 
0C0E6:  MOVF   4B,F
0C0E8:  BNZ   C116
0C0EA:  MOVF   4A,F
0C0EC:  BNZ   C116
0C0EE:  MOVF   49,F
0C0F0:  BNZ   C116
0C0F2:  MOVF   48,W
0C0F4:  SUBLW  01
0C0F6:  BNC   C116
....................       nv_macro_mode = arg; 
0C0F8:  MOVFF  49,2A
0C0FC:  MOVFF  48,29
....................       write16(ADDR_MACRO_MODE, nv_macro_mode); 
0C100:  MOVLW  20
0C102:  MOVLB  8
0C104:  MOVWF  xEE
0C106:  MOVFF  2A,8F0
0C10A:  MOVFF  29,8EF
0C10E:  MOVLB  0
0C110:  CALL   4FC8
....................    } 
0C114:  BRA    C11A
....................    else cmd_arg(); 
0C116:  CALL   B2F2
0C11A:  GOTO   C148 (RETURN)
.................... } 
....................  
.................... void commandA() 
.................... { 
....................    switch(nv_product){ 
0C11E:  MOVF   2F,W
0C120:  MOVWF  00
0C122:  MOVF   30,W
0C124:  MOVWF  03
0C126:  BNZ   C12C
0C128:  MOVF   00,F
0C12A:  BZ    C142
0C12C:  MOVF   03,W
0C12E:  BNZ   C136
0C130:  MOVLW  01
0C132:  SUBWF  00,W
0C134:  BZ    C146
0C136:  MOVF   03,W
0C138:  BNZ   C140
0C13A:  MOVLW  03
0C13C:  SUBWF  00,W
0C13E:  BZ    C146
0C140:  BRA    C148
....................       case ECO : commandAe(); 
0C142:  BRA    BFD2
....................          break; 
0C144:  BRA    C148
....................       case WMS4 :  
....................       case WMS2 : commandAw(); 
0C146:  BRA    C0E6
....................          break; 
....................    } 
0C148:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandBe() 
.................... { 
....................    if(arg > 0 && arg < 4) { 
0C14C:  MOVF   48,F
0C14E:  BNZ   C15C
0C150:  MOVF   49,F
0C152:  BNZ   C15C
0C154:  MOVF   4A,F
0C156:  BNZ   C15C
0C158:  MOVF   4B,F
0C15A:  BZ    C18C
0C15C:  MOVF   4B,F
0C15E:  BNZ   C18C
0C160:  MOVF   4A,F
0C162:  BNZ   C18C
0C164:  MOVF   49,F
0C166:  BNZ   C18C
0C168:  MOVF   48,W
0C16A:  SUBLW  03
0C16C:  BNC   C18C
....................       nv_det_type = arg; 
0C16E:  MOVFF  49,46
0C172:  MOVFF  48,45
....................       write16(ADDR_DET_TYPE, nv_det_type); 
0C176:  MOVLW  26
0C178:  MOVLB  8
0C17A:  MOVWF  xEE
0C17C:  MOVFF  46,8F0
0C180:  MOVFF  45,8EF
0C184:  MOVLB  0
0C186:  CALL   4FC8
....................    } 
0C18A:  BRA    C1F2
....................    else if(arg==0) { 
0C18C:  MOVF   48,F
0C18E:  BNZ   C1EE
0C190:  MOVF   49,F
0C192:  BNZ   C1EE
0C194:  MOVF   4A,F
0C196:  BNZ   C1EE
0C198:  MOVF   4B,F
0C19A:  BNZ   C1EE
....................       fprintf(COM_A, "@DET,%Lu\r\n",nv_det_type);  
0C19C:  MOVLW  0A
0C19E:  MOVWF  FF6
0C1A0:  MOVLW  24
0C1A2:  MOVWF  FF7
0C1A4:  MOVLW  00
0C1A6:  MOVWF  FF8
0C1A8:  CLRF   1B
0C1AA:  BTFSC  FF2.7
0C1AC:  BSF    1B.7
0C1AE:  BCF    FF2.7
0C1B0:  MOVLW  05
0C1B2:  MOVLB  A
0C1B4:  MOVWF  x40
0C1B6:  MOVLB  0
0C1B8:  CALL   1018
0C1BC:  BTFSC  1B.7
0C1BE:  BSF    FF2.7
0C1C0:  MOVLW  10
0C1C2:  MOVWF  FE9
0C1C4:  CLRF   1B
0C1C6:  BTFSC  FF2.7
0C1C8:  BSF    1B.7
0C1CA:  BCF    FF2.7
0C1CC:  MOVFF  46,A41
0C1D0:  MOVFF  45,A40
0C1D4:  CALL   119A
0C1D8:  BTFSC  1B.7
0C1DA:  BSF    FF2.7
0C1DC:  MOVLW  0D
0C1DE:  BTFSS  F9E.4
0C1E0:  BRA    C1DE
0C1E2:  MOVWF  FAD
0C1E4:  MOVLW  0A
0C1E6:  BTFSS  F9E.4
0C1E8:  BRA    C1E6
0C1EA:  MOVWF  FAD
....................    } 
0C1EC:  BRA    C1F2
....................    else cmd_arg(); 
0C1EE:  CALL   B2F2
0C1F2:  GOTO   C2B4 (RETURN)
.................... } 
....................  
.................... void commandBw() 
.................... { 
....................    int8 hb_cmd; 
....................  
....................    if(arg < 4) { 
*
0C264:  MOVF   4B,F
0C266:  BNZ   C282
0C268:  MOVF   4A,F
0C26A:  BNZ   C282
0C26C:  MOVF   49,F
0C26E:  BNZ   C282
0C270:  MOVF   48,W
0C272:  SUBLW  03
0C274:  BNC   C282
....................       hb_cmd=arg; 
0C276:  MOVFF  48,885
....................       h_bridge(hb_cmd); 
0C27A:  MOVFF  885,8B5
0C27E:  RCALL  C244
....................    } 
0C280:  BRA    C286
....................    else cmd_arg(); 
0C282:  CALL   B2F2
0C286:  GOTO   C2B4 (RETURN)
.................... } 
....................  
.................... void commandB() 
.................... { 
....................    switch(nv_product){ 
0C28A:  MOVF   2F,W
0C28C:  MOVWF  00
0C28E:  MOVF   30,W
0C290:  MOVWF  03
0C292:  BNZ   C298
0C294:  MOVF   00,F
0C296:  BZ    C2AE
0C298:  MOVF   03,W
0C29A:  BNZ   C2A2
0C29C:  MOVLW  01
0C29E:  SUBWF  00,W
0C2A0:  BZ    C2B2
0C2A2:  MOVF   03,W
0C2A4:  BNZ   C2AC
0C2A6:  MOVLW  03
0C2A8:  SUBWF  00,W
0C2AA:  BZ    C2B2
0C2AC:  BRA    C2B4
....................       case ECO : commandBe(); 
0C2AE:  BRA    C14C
....................          break; 
0C2B0:  BRA    C2B4
....................       case WMS4 : 
....................       case WMS2 : commandBw(); 
0C2B2:  BRA    C264
....................          break; 
....................    } 
0C2B4:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandCe() 
.................... { 
....................    switch(arg){ 
*
0CDAE:  MOVF   48,W
0CDB0:  MOVWF  00
0CDB2:  MOVF   49,W
0CDB4:  MOVWF  03
0CDB6:  BNZ   CDBC
0CDB8:  MOVF   00,F
0CDBA:  BZ    CE1E
0CDBC:  MOVF   03,W
0CDBE:  BNZ   CDC8
0CDC0:  MOVLW  01
0CDC2:  SUBWF  00,W
0CDC4:  BTFSC  FD8.2
0CDC6:  BRA    D00E
0CDC8:  MOVF   03,W
0CDCA:  BNZ   CDD4
0CDCC:  MOVLW  02
0CDCE:  SUBWF  00,W
0CDD0:  BTFSC  FD8.2
0CDD2:  BRA    D06A
0CDD4:  MOVF   03,W
0CDD6:  BNZ   CDE0
0CDD8:  MOVLW  03
0CDDA:  SUBWF  00,W
0CDDC:  BTFSC  FD8.2
0CDDE:  BRA    D0C6
0CDE0:  MOVF   03,W
0CDE2:  BNZ   CDEC
0CDE4:  MOVLW  04
0CDE6:  SUBWF  00,W
0CDE8:  BTFSC  FD8.2
0CDEA:  BRA    D122
0CDEC:  MOVF   03,W
0CDEE:  BNZ   CDF8
0CDF0:  MOVLW  05
0CDF2:  SUBWF  00,W
0CDF4:  BTFSC  FD8.2
0CDF6:  BRA    D17E
0CDF8:  MOVF   03,W
0CDFA:  BNZ   CE04
0CDFC:  MOVLW  06
0CDFE:  SUBWF  00,W
0CE00:  BTFSC  FD8.2
0CE02:  BRA    D1DA
0CE04:  MOVF   03,W
0CE06:  BNZ   CE10
0CE08:  MOVLW  07
0CE0A:  SUBWF  00,W
0CE0C:  BTFSC  FD8.2
0CE0E:  BRA    D236
0CE10:  MOVF   03,W
0CE12:  BNZ   CE1C
0CE14:  MOVLW  08
0CE16:  SUBWF  00,W
0CE18:  BTFSC  FD8.2
0CE1A:  BRA    D292
0CE1C:  BRA    D2EE
....................       case 0 : fprintf(COM_A, "NO3,%1.5g,%1.5g\r\n", NO3_slope, NO3_inter); 
0CE1E:  MOVLW  16
0CE20:  MOVWF  FF6
0CE22:  MOVLW  24
0CE24:  MOVWF  FF7
0CE26:  MOVLW  00
0CE28:  MOVWF  FF8
0CE2A:  CLRF   1B
0CE2C:  BTFSC  FF2.7
0CE2E:  BSF    1B.7
0CE30:  BCF    FF2.7
0CE32:  MOVLW  04
0CE34:  MOVLB  A
0CE36:  MOVWF  x40
0CE38:  MOVLB  0
0CE3A:  CALL   1018
0CE3E:  BTFSC  1B.7
0CE40:  BSF    FF2.7
0CE42:  MOVLW  89
0CE44:  MOVWF  FE9
0CE46:  MOVFF  3F8,888
0CE4A:  MOVFF  3F7,887
0CE4E:  MOVFF  3F6,886
0CE52:  MOVFF  3F5,885
0CE56:  MOVLW  05
0CE58:  MOVLB  8
0CE5A:  MOVWF  x89
0CE5C:  MOVLB  0
0CE5E:  RCALL  C668
0CE60:  MOVLW  2C
0CE62:  BTFSS  F9E.4
0CE64:  BRA    CE62
0CE66:  MOVWF  FAD
0CE68:  MOVLW  89
0CE6A:  MOVWF  FE9
0CE6C:  MOVFF  3FC,888
0CE70:  MOVFF  3FB,887
0CE74:  MOVFF  3FA,886
0CE78:  MOVFF  3F9,885
0CE7C:  MOVLW  05
0CE7E:  MOVLB  8
0CE80:  MOVWF  x89
0CE82:  MOVLB  0
0CE84:  CALL   C668
0CE88:  MOVLW  0D
0CE8A:  BTFSS  F9E.4
0CE8C:  BRA    CE8A
0CE8E:  MOVWF  FAD
0CE90:  MOVLW  0A
0CE92:  BTFSS  F9E.4
0CE94:  BRA    CE92
0CE96:  MOVWF  FAD
....................                fprintf(COM_A, "PO4,%1.5g,%1.5g\r\n", PO4_slope, PO4_inter); 
0CE98:  MOVLW  28
0CE9A:  MOVWF  FF6
0CE9C:  MOVLW  24
0CE9E:  MOVWF  FF7
0CEA0:  MOVLW  00
0CEA2:  MOVWF  FF8
0CEA4:  CLRF   1B
0CEA6:  BTFSC  FF2.7
0CEA8:  BSF    1B.7
0CEAA:  BCF    FF2.7
0CEAC:  MOVLW  04
0CEAE:  MOVLB  A
0CEB0:  MOVWF  x40
0CEB2:  MOVLB  0
0CEB4:  CALL   1018
0CEB8:  BTFSC  1B.7
0CEBA:  BSF    FF2.7
0CEBC:  MOVLW  89
0CEBE:  MOVWF  FE9
0CEC0:  MOVFF  400,888
0CEC4:  MOVFF  3FF,887
0CEC8:  MOVFF  3FE,886
0CECC:  MOVFF  3FD,885
0CED0:  MOVLW  05
0CED2:  MOVLB  8
0CED4:  MOVWF  x89
0CED6:  MOVLB  0
0CED8:  CALL   C668
0CEDC:  MOVLW  2C
0CEDE:  BTFSS  F9E.4
0CEE0:  BRA    CEDE
0CEE2:  MOVWF  FAD
0CEE4:  MOVLW  89
0CEE6:  MOVWF  FE9
0CEE8:  MOVFF  404,888
0CEEC:  MOVFF  403,887
0CEF0:  MOVFF  402,886
0CEF4:  MOVFF  401,885
0CEF8:  MOVLW  05
0CEFA:  MOVLB  8
0CEFC:  MOVWF  x89
0CEFE:  MOVLB  0
0CF00:  CALL   C668
0CF04:  MOVLW  0D
0CF06:  BTFSS  F9E.4
0CF08:  BRA    CF06
0CF0A:  MOVWF  FAD
0CF0C:  MOVLW  0A
0CF0E:  BTFSS  F9E.4
0CF10:  BRA    CF0E
0CF12:  MOVWF  FAD
....................                fprintf(COM_A, "NH4,%1.5g,%1.5g\r\n", NH4_slope, NH4_inter); 
0CF14:  MOVLW  3A
0CF16:  MOVWF  FF6
0CF18:  MOVLW  24
0CF1A:  MOVWF  FF7
0CF1C:  MOVLW  00
0CF1E:  MOVWF  FF8
0CF20:  CLRF   1B
0CF22:  BTFSC  FF2.7
0CF24:  BSF    1B.7
0CF26:  BCF    FF2.7
0CF28:  MOVLW  04
0CF2A:  MOVLB  A
0CF2C:  MOVWF  x40
0CF2E:  MOVLB  0
0CF30:  CALL   1018
0CF34:  BTFSC  1B.7
0CF36:  BSF    FF2.7
0CF38:  MOVLW  89
0CF3A:  MOVWF  FE9
0CF3C:  MOVFF  408,888
0CF40:  MOVFF  407,887
0CF44:  MOVFF  406,886
0CF48:  MOVFF  405,885
0CF4C:  MOVLW  05
0CF4E:  MOVLB  8
0CF50:  MOVWF  x89
0CF52:  MOVLB  0
0CF54:  CALL   C668
0CF58:  MOVLW  2C
0CF5A:  BTFSS  F9E.4
0CF5C:  BRA    CF5A
0CF5E:  MOVWF  FAD
0CF60:  MOVLW  89
0CF62:  MOVWF  FE9
0CF64:  MOVFF  40C,888
0CF68:  MOVFF  40B,887
0CF6C:  MOVFF  40A,886
0CF70:  MOVFF  409,885
0CF74:  MOVLW  05
0CF76:  MOVLB  8
0CF78:  MOVWF  x89
0CF7A:  MOVLB  0
0CF7C:  CALL   C668
0CF80:  MOVLW  0D
0CF82:  BTFSS  F9E.4
0CF84:  BRA    CF82
0CF86:  MOVWF  FAD
0CF88:  MOVLW  0A
0CF8A:  BTFSS  F9E.4
0CF8C:  BRA    CF8A
0CF8E:  MOVWF  FAD
....................                fprintf(COM_A, "SiO4,%1.5g,%1.5g\r\n", SiO_slope, SiO_inter); 
0CF90:  MOVLW  4C
0CF92:  MOVWF  FF6
0CF94:  MOVLW  24
0CF96:  MOVWF  FF7
0CF98:  MOVLW  00
0CF9A:  MOVWF  FF8
0CF9C:  CLRF   1B
0CF9E:  BTFSC  FF2.7
0CFA0:  BSF    1B.7
0CFA2:  BCF    FF2.7
0CFA4:  MOVLW  05
0CFA6:  MOVLB  A
0CFA8:  MOVWF  x40
0CFAA:  MOVLB  0
0CFAC:  CALL   1018
0CFB0:  BTFSC  1B.7
0CFB2:  BSF    FF2.7
0CFB4:  MOVLW  89
0CFB6:  MOVWF  FE9
0CFB8:  MOVFF  410,888
0CFBC:  MOVFF  40F,887
0CFC0:  MOVFF  40E,886
0CFC4:  MOVFF  40D,885
0CFC8:  MOVLW  05
0CFCA:  MOVLB  8
0CFCC:  MOVWF  x89
0CFCE:  MOVLB  0
0CFD0:  CALL   C668
0CFD4:  MOVLW  2C
0CFD6:  BTFSS  F9E.4
0CFD8:  BRA    CFD6
0CFDA:  MOVWF  FAD
0CFDC:  MOVLW  89
0CFDE:  MOVWF  FE9
0CFE0:  MOVFF  414,888
0CFE4:  MOVFF  413,887
0CFE8:  MOVFF  412,886
0CFEC:  MOVFF  411,885
0CFF0:  MOVLW  05
0CFF2:  MOVLB  8
0CFF4:  MOVWF  x89
0CFF6:  MOVLB  0
0CFF8:  CALL   C668
0CFFC:  MOVLW  0D
0CFFE:  BTFSS  F9E.4
0D000:  BRA    CFFE
0D002:  MOVWF  FAD
0D004:  MOVLW  0A
0D006:  BTFSS  F9E.4
0D008:  BRA    D006
0D00A:  MOVWF  FAD
....................                   break; 
0D00C:  BRA    D2F2
....................       case 1 : fprintf(COM_A,"NO3(m):"); 
0D00E:  MOVLW  60
0D010:  MOVWF  FF6
0D012:  MOVLW  24
0D014:  MOVWF  FF7
0D016:  MOVLW  00
0D018:  MOVWF  FF8
0D01A:  CLRF   1B
0D01C:  BTFSC  FF2.7
0D01E:  BSF    1B.7
0D020:  BCF    FF2.7
0D022:  CALL   0E42
0D026:  BTFSC  1B.7
0D028:  BSF    FF2.7
....................                NO3_slope = get_float(); 
0D02A:  RCALL  CCFA
0D02C:  MOVFF  03,3F8
0D030:  MOVFF  02,3F7
0D034:  MOVFF  01,3F6
0D038:  MOVFF  00,3F5
....................                fprintf(COM_A,"\r\n");   
0D03C:  MOVLW  0D
0D03E:  BTFSS  F9E.4
0D040:  BRA    D03E
0D042:  MOVWF  FAD
0D044:  MOVLW  0A
0D046:  BTFSS  F9E.4
0D048:  BRA    D046
0D04A:  MOVWF  FAD
....................                write_float(ADDR_CAL_M1,NO3_slope); 
0D04C:  MOVLB  8
0D04E:  CLRF   x86
0D050:  MOVLW  44
0D052:  MOVWF  x85
0D054:  MOVFF  3F8,88A
0D058:  MOVFF  3F7,889
0D05C:  MOVFF  3F6,888
0D060:  MOVFF  3F5,887
0D064:  MOVLB  0
0D066:  RCALL  CD40
....................          break; 
0D068:  BRA    D2F2
....................       case 2 : fprintf(COM_A,"NO3(c):"); 
0D06A:  MOVLW  68
0D06C:  MOVWF  FF6
0D06E:  MOVLW  24
0D070:  MOVWF  FF7
0D072:  MOVLW  00
0D074:  MOVWF  FF8
0D076:  CLRF   1B
0D078:  BTFSC  FF2.7
0D07A:  BSF    1B.7
0D07C:  BCF    FF2.7
0D07E:  CALL   0E42
0D082:  BTFSC  1B.7
0D084:  BSF    FF2.7
....................                NO3_inter = get_float(); 
0D086:  RCALL  CCFA
0D088:  MOVFF  03,3FC
0D08C:  MOVFF  02,3FB
0D090:  MOVFF  01,3FA
0D094:  MOVFF  00,3F9
....................                fprintf(COM_A,"\r\n");  
0D098:  MOVLW  0D
0D09A:  BTFSS  F9E.4
0D09C:  BRA    D09A
0D09E:  MOVWF  FAD
0D0A0:  MOVLW  0A
0D0A2:  BTFSS  F9E.4
0D0A4:  BRA    D0A2
0D0A6:  MOVWF  FAD
....................                write_float(ADDR_CAL_C1,NO3_inter); 
0D0A8:  MOVLB  8
0D0AA:  CLRF   x86
0D0AC:  MOVLW  48
0D0AE:  MOVWF  x85
0D0B0:  MOVFF  3FC,88A
0D0B4:  MOVFF  3FB,889
0D0B8:  MOVFF  3FA,888
0D0BC:  MOVFF  3F9,887
0D0C0:  MOVLB  0
0D0C2:  RCALL  CD40
....................          break; 
0D0C4:  BRA    D2F2
....................       case 3 : fprintf(COM_A,"PO4(m):"); 
0D0C6:  MOVLW  70
0D0C8:  MOVWF  FF6
0D0CA:  MOVLW  24
0D0CC:  MOVWF  FF7
0D0CE:  MOVLW  00
0D0D0:  MOVWF  FF8
0D0D2:  CLRF   1B
0D0D4:  BTFSC  FF2.7
0D0D6:  BSF    1B.7
0D0D8:  BCF    FF2.7
0D0DA:  CALL   0E42
0D0DE:  BTFSC  1B.7
0D0E0:  BSF    FF2.7
....................                PO4_slope = get_float(); 
0D0E2:  RCALL  CCFA
0D0E4:  MOVFF  03,400
0D0E8:  MOVFF  02,3FF
0D0EC:  MOVFF  01,3FE
0D0F0:  MOVFF  00,3FD
....................                fprintf(COM_A,"\r\n"); 
0D0F4:  MOVLW  0D
0D0F6:  BTFSS  F9E.4
0D0F8:  BRA    D0F6
0D0FA:  MOVWF  FAD
0D0FC:  MOVLW  0A
0D0FE:  BTFSS  F9E.4
0D100:  BRA    D0FE
0D102:  MOVWF  FAD
....................                write_float(ADDR_CAL_M2,PO4_slope); 
0D104:  MOVLB  8
0D106:  CLRF   x86
0D108:  MOVLW  4C
0D10A:  MOVWF  x85
0D10C:  MOVFF  400,88A
0D110:  MOVFF  3FF,889
0D114:  MOVFF  3FE,888
0D118:  MOVFF  3FD,887
0D11C:  MOVLB  0
0D11E:  RCALL  CD40
....................          break; 
0D120:  BRA    D2F2
....................       case 4 : fprintf(COM_A,"PO4(c):"); 
0D122:  MOVLW  78
0D124:  MOVWF  FF6
0D126:  MOVLW  24
0D128:  MOVWF  FF7
0D12A:  MOVLW  00
0D12C:  MOVWF  FF8
0D12E:  CLRF   1B
0D130:  BTFSC  FF2.7
0D132:  BSF    1B.7
0D134:  BCF    FF2.7
0D136:  CALL   0E42
0D13A:  BTFSC  1B.7
0D13C:  BSF    FF2.7
....................                PO4_inter = get_float(); 
0D13E:  RCALL  CCFA
0D140:  MOVFF  03,404
0D144:  MOVFF  02,403
0D148:  MOVFF  01,402
0D14C:  MOVFF  00,401
....................                fprintf(COM_A,"\r\n");  
0D150:  MOVLW  0D
0D152:  BTFSS  F9E.4
0D154:  BRA    D152
0D156:  MOVWF  FAD
0D158:  MOVLW  0A
0D15A:  BTFSS  F9E.4
0D15C:  BRA    D15A
0D15E:  MOVWF  FAD
....................                write_float(ADDR_CAL_C2,NO3_inter); 
0D160:  MOVLB  8
0D162:  CLRF   x86
0D164:  MOVLW  52
0D166:  MOVWF  x85
0D168:  MOVFF  3FC,88A
0D16C:  MOVFF  3FB,889
0D170:  MOVFF  3FA,888
0D174:  MOVFF  3F9,887
0D178:  MOVLB  0
0D17A:  RCALL  CD40
....................          break; 
0D17C:  BRA    D2F2
....................       case 5 : fprintf(COM_A,"NH4(m):"); 
0D17E:  MOVLW  80
0D180:  MOVWF  FF6
0D182:  MOVLW  24
0D184:  MOVWF  FF7
0D186:  MOVLW  00
0D188:  MOVWF  FF8
0D18A:  CLRF   1B
0D18C:  BTFSC  FF2.7
0D18E:  BSF    1B.7
0D190:  BCF    FF2.7
0D192:  CALL   0E42
0D196:  BTFSC  1B.7
0D198:  BSF    FF2.7
....................                NH4_slope = get_float(); 
0D19A:  RCALL  CCFA
0D19C:  MOVFF  03,408
0D1A0:  MOVFF  02,407
0D1A4:  MOVFF  01,406
0D1A8:  MOVFF  00,405
....................                fprintf(COM_A,"\r\n");   
0D1AC:  MOVLW  0D
0D1AE:  BTFSS  F9E.4
0D1B0:  BRA    D1AE
0D1B2:  MOVWF  FAD
0D1B4:  MOVLW  0A
0D1B6:  BTFSS  F9E.4
0D1B8:  BRA    D1B6
0D1BA:  MOVWF  FAD
....................                write_float(ADDR_CAL_M3,NH4_slope); 
0D1BC:  MOVLB  8
0D1BE:  CLRF   x86
0D1C0:  MOVLW  56
0D1C2:  MOVWF  x85
0D1C4:  MOVFF  408,88A
0D1C8:  MOVFF  407,889
0D1CC:  MOVFF  406,888
0D1D0:  MOVFF  405,887
0D1D4:  MOVLB  0
0D1D6:  RCALL  CD40
....................          break; 
0D1D8:  BRA    D2F2
....................       case 6 : fprintf(COM_A,"NH4(c):"); 
0D1DA:  MOVLW  88
0D1DC:  MOVWF  FF6
0D1DE:  MOVLW  24
0D1E0:  MOVWF  FF7
0D1E2:  MOVLW  00
0D1E4:  MOVWF  FF8
0D1E6:  CLRF   1B
0D1E8:  BTFSC  FF2.7
0D1EA:  BSF    1B.7
0D1EC:  BCF    FF2.7
0D1EE:  CALL   0E42
0D1F2:  BTFSC  1B.7
0D1F4:  BSF    FF2.7
....................                NH4_inter = get_float(); 
0D1F6:  RCALL  CCFA
0D1F8:  MOVFF  03,40C
0D1FC:  MOVFF  02,40B
0D200:  MOVFF  01,40A
0D204:  MOVFF  00,409
....................                fprintf(COM_A,"\r\n");  
0D208:  MOVLW  0D
0D20A:  BTFSS  F9E.4
0D20C:  BRA    D20A
0D20E:  MOVWF  FAD
0D210:  MOVLW  0A
0D212:  BTFSS  F9E.4
0D214:  BRA    D212
0D216:  MOVWF  FAD
....................                write_float(ADDR_CAL_C3,NH4_inter); 
0D218:  MOVLB  8
0D21A:  CLRF   x86
0D21C:  MOVLW  5A
0D21E:  MOVWF  x85
0D220:  MOVFF  40C,88A
0D224:  MOVFF  40B,889
0D228:  MOVFF  40A,888
0D22C:  MOVFF  409,887
0D230:  MOVLB  0
0D232:  RCALL  CD40
....................          break; 
0D234:  BRA    D2F2
....................       case 7 : fprintf(COM_A,"SiO4(m):"); 
0D236:  MOVLW  90
0D238:  MOVWF  FF6
0D23A:  MOVLW  24
0D23C:  MOVWF  FF7
0D23E:  MOVLW  00
0D240:  MOVWF  FF8
0D242:  CLRF   1B
0D244:  BTFSC  FF2.7
0D246:  BSF    1B.7
0D248:  BCF    FF2.7
0D24A:  CALL   0E42
0D24E:  BTFSC  1B.7
0D250:  BSF    FF2.7
....................                SiO_slope = get_float(); 
0D252:  RCALL  CCFA
0D254:  MOVFF  03,410
0D258:  MOVFF  02,40F
0D25C:  MOVFF  01,40E
0D260:  MOVFF  00,40D
....................                fprintf(COM_A,"\r\n");   
0D264:  MOVLW  0D
0D266:  BTFSS  F9E.4
0D268:  BRA    D266
0D26A:  MOVWF  FAD
0D26C:  MOVLW  0A
0D26E:  BTFSS  F9E.4
0D270:  BRA    D26E
0D272:  MOVWF  FAD
....................                write_float(ADDR_CAL_M4,SiO_slope); 
0D274:  MOVLB  8
0D276:  CLRF   x86
0D278:  MOVLW  5E
0D27A:  MOVWF  x85
0D27C:  MOVFF  410,88A
0D280:  MOVFF  40F,889
0D284:  MOVFF  40E,888
0D288:  MOVFF  40D,887
0D28C:  MOVLB  0
0D28E:  RCALL  CD40
....................          break; 
0D290:  BRA    D2F2
....................       case 8 : fprintf(COM_A,"SiO4(c):"); 
0D292:  MOVLW  9A
0D294:  MOVWF  FF6
0D296:  MOVLW  24
0D298:  MOVWF  FF7
0D29A:  MOVLW  00
0D29C:  MOVWF  FF8
0D29E:  CLRF   1B
0D2A0:  BTFSC  FF2.7
0D2A2:  BSF    1B.7
0D2A4:  BCF    FF2.7
0D2A6:  CALL   0E42
0D2AA:  BTFSC  1B.7
0D2AC:  BSF    FF2.7
....................                SiO_inter = get_float(); 
0D2AE:  RCALL  CCFA
0D2B0:  MOVFF  03,414
0D2B4:  MOVFF  02,413
0D2B8:  MOVFF  01,412
0D2BC:  MOVFF  00,411
....................                fprintf(COM_A,"\r\n");  
0D2C0:  MOVLW  0D
0D2C2:  BTFSS  F9E.4
0D2C4:  BRA    D2C2
0D2C6:  MOVWF  FAD
0D2C8:  MOVLW  0A
0D2CA:  BTFSS  F9E.4
0D2CC:  BRA    D2CA
0D2CE:  MOVWF  FAD
....................                write_float(ADDR_CAL_C4,SiO_inter); 
0D2D0:  MOVLB  8
0D2D2:  CLRF   x86
0D2D4:  MOVLW  62
0D2D6:  MOVWF  x85
0D2D8:  MOVFF  414,88A
0D2DC:  MOVFF  413,889
0D2E0:  MOVFF  412,888
0D2E4:  MOVFF  411,887
0D2E8:  MOVLB  0
0D2EA:  RCALL  CD40
....................          break;         
0D2EC:  BRA    D2F2
....................       default: cmd_arg(); 
0D2EE:  CALL   B2F2
....................          break; 
....................    } 
0D2F2:  GOTO   DCE8 (RETURN)
.................... } 
....................  
.................... void commandCw() 
.................... { 
....................    int16 port; 
....................     
....................    if(arg>1){ 
*
0DA02:  MOVF   4B,F
0DA04:  BNZ   DA14
0DA06:  MOVF   4A,F
0DA08:  BNZ   DA14
0DA0A:  MOVF   49,F
0DA0C:  BNZ   DA14
0DA0E:  MOVF   48,W
0DA10:  SUBLW  01
0DA12:  BC    DA64
....................       if ((arg<49 && nv_product == WMS4)||(arg<51 && nv_product == WMS2)){ 
0DA14:  MOVF   4B,F
0DA16:  BNZ   DA2E
0DA18:  MOVF   4A,F
0DA1A:  BNZ   DA2E
0DA1C:  MOVF   49,F
0DA1E:  BNZ   DA2E
0DA20:  MOVF   48,W
0DA22:  SUBLW  30
0DA24:  BNC   DA2E
0DA26:  DECFSZ 2F,W
0DA28:  BRA    DA2E
0DA2A:  MOVF   30,F
0DA2C:  BZ    DA4A
0DA2E:  MOVF   4B,F
0DA30:  BNZ   DA5E
0DA32:  MOVF   4A,F
0DA34:  BNZ   DA5E
0DA36:  MOVF   49,F
0DA38:  BNZ   DA5E
0DA3A:  MOVF   48,W
0DA3C:  SUBLW  32
0DA3E:  BNC   DA5E
0DA40:  MOVF   2F,W
0DA42:  SUBLW  03
0DA44:  BNZ   DA5E
0DA46:  MOVF   30,F
0DA48:  BNZ   DA5E
....................          port=arg; 
0DA4A:  MOVFF  49,886
0DA4E:  MOVFF  48,885
....................          play_wms_hard_macro(port);    
0DA52:  MOVFF  886,88A
0DA56:  MOVFF  885,889
0DA5A:  RCALL  D7F4
....................       } 
0DA5C:  BRA    DA62
....................       else cmd_arg(); 
0DA5E:  CALL   B2F2
....................    } 
0DA62:  BRA    DA68
....................    else cmd_arg(); 
0DA64:  CALL   B2F2
0DA68:  GOTO   DCE8 (RETURN)
.................... } 
....................  
.................... void commandCa() 
.................... { 
....................    int8 chip; 
....................     
....................    if(arg>0 && arg<5){ 
*
0DC78:  MOVF   48,F
0DC7A:  BNZ   DC88
0DC7C:  MOVF   49,F
0DC7E:  BNZ   DC88
0DC80:  MOVF   4A,F
0DC82:  BNZ   DC88
0DC84:  MOVF   4B,F
0DC86:  BZ    DCA6
0DC88:  MOVF   4B,F
0DC8A:  BNZ   DCA6
0DC8C:  MOVF   4A,F
0DC8E:  BNZ   DCA6
0DC90:  MOVF   49,F
0DC92:  BNZ   DCA6
0DC94:  MOVF   48,W
0DC96:  SUBLW  04
0DC98:  BNC   DCA6
....................       chip=arg; 
0DC9A:  MOVFF  48,885
....................       sol_chip_cmd(chip); 
0DC9E:  MOVFF  885,8B6
0DCA2:  RCALL  DBAA
....................    } 
0DCA4:  BRA    DCAA
....................    else cmd_arg();    
0DCA6:  CALL   B2F2
0DCAA:  GOTO   DCE8 (RETURN)
.................... } 
....................  
.................... void commandC() 
.................... { 
....................    switch(nv_product){ 
0DCAE:  MOVF   2F,W
0DCB0:  MOVWF  00
0DCB2:  MOVF   30,W
0DCB4:  MOVWF  03
0DCB6:  BNZ   DCBC
0DCB8:  MOVF   00,F
0DCBA:  BZ    DCDC
0DCBC:  MOVF   03,W
0DCBE:  BNZ   DCC6
0DCC0:  MOVLW  01
0DCC2:  SUBWF  00,W
0DCC4:  BZ    DCE2
0DCC6:  MOVF   03,W
0DCC8:  BNZ   DCD0
0DCCA:  MOVLW  03
0DCCC:  SUBWF  00,W
0DCCE:  BZ    DCE2
0DCD0:  MOVF   03,W
0DCD2:  BNZ   DCDA
0DCD4:  MOVLW  02
0DCD6:  SUBWF  00,W
0DCD8:  BZ    DCE6
0DCDA:  BRA    DCE8
....................       case ECO : commandCe(); 
0DCDC:  GOTO   CDAE
....................          break; 
0DCE0:  BRA    DCE8
....................       case WMS4 :  
....................       case WMS2 : commandCw(); 
0DCE2:  BRA    DA02
....................          break; 
0DCE4:  BRA    DCE8
....................       case AWS : commandCa(); 
0DCE6:  BRA    DC78
....................          break;          
....................    } 
0DCE8:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandD() 
.................... { 
....................    switch (arg){ 
0DCEC:  MOVF   48,W
0DCEE:  MOVWF  00
0DCF0:  MOVF   49,W
0DCF2:  MOVWF  03
0DCF4:  BNZ   DCFA
0DCF6:  MOVF   00,F
0DCF8:  BZ    DD1A
0DCFA:  MOVF   03,W
0DCFC:  BNZ   DD04
0DCFE:  MOVLW  01
0DD00:  SUBWF  00,W
0DD02:  BZ    DD2C
0DD04:  MOVF   03,W
0DD06:  BNZ   DD0E
0DD08:  MOVLW  02
0DD0A:  SUBWF  00,W
0DD0C:  BZ    DD4E
0DD0E:  MOVF   03,W
0DD10:  BNZ   DD18
0DD12:  MOVLW  03
0DD14:  SUBWF  00,W
0DD16:  BZ    DD60
0DD18:  BRA    DD82
....................       case 0 : file_list(file_ptr_raw_all); 
0DD1A:  MOVLW  02
0DD1C:  MOVLB  8
0DD1E:  MOVWF  x8A
0DD20:  MOVLW  DD
0DD22:  MOVWF  x89
0DD24:  MOVLB  0
0DD26:  CALL   BB18
....................          break; 
0DD2A:  BRA    DD86
....................       case 1 : file_list(file_ptr_raw_new); 
0DD2C:  MOVLW  02
0DD2E:  MOVLB  8
0DD30:  MOVWF  x8A
0DD32:  MOVLW  EB
0DD34:  MOVWF  x89
0DD36:  MOVLB  0
0DD38:  CALL   BB18
....................                f_unlink(file_ptr_raw_new); 
0DD3C:  MOVLW  02
0DD3E:  MOVLB  8
0DD40:  MOVWF  x8A
0DD42:  MOVLW  EB
0DD44:  MOVWF  x89
0DD46:  MOVLB  0
0DD48:  CALL   BC92
....................          break; 
0DD4C:  BRA    DD86
....................       case 2 : file_list(file_ptr_rel_all); 
0DD4E:  MOVLW  02
0DD50:  MOVLB  8
0DD52:  MOVWF  x8A
0DD54:  MOVLW  F9
0DD56:  MOVWF  x89
0DD58:  MOVLB  0
0DD5A:  CALL   BB18
....................          break; 
0DD5E:  BRA    DD86
....................       case 3 : file_list(file_ptr_rel_new); 
0DD60:  MOVLW  03
0DD62:  MOVLB  8
0DD64:  MOVWF  x8A
0DD66:  MOVLW  07
0DD68:  MOVWF  x89
0DD6A:  MOVLB  0
0DD6C:  CALL   BB18
....................                f_unlink(file_ptr_rel_new); 
0DD70:  MOVLW  03
0DD72:  MOVLB  8
0DD74:  MOVWF  x8A
0DD76:  MOVLW  07
0DD78:  MOVWF  x89
0DD7A:  MOVLB  0
0DD7C:  CALL   BC92
....................          break;  
0DD80:  BRA    DD86
....................       default : cmd_arg(); 
0DD82:  CALL   B2F2
....................          break; 
....................    } 
0DD86:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandE() 
.................... { 
....................    switch (arg){ 
0DD8A:  MOVF   48,W
0DD8C:  MOVWF  00
0DD8E:  MOVF   49,W
0DD90:  MOVWF  03
0DD92:  BNZ   DD98
0DD94:  MOVF   00,F
0DD96:  BZ    DDA4
0DD98:  MOVF   03,W
0DD9A:  BNZ   DDA2
0DD9C:  MOVLW  02
0DD9E:  SUBWF  00,W
0DDA0:  BZ    DE1E
0DDA2:  BRA    DE98
....................       case 0 :  
....................       printf("Are you sure you want to erase the raw data file? Y or N!\r\n"); 
0DDA4:  MOVLW  A4
0DDA6:  MOVWF  FF6
0DDA8:  MOVLW  24
0DDAA:  MOVWF  FF7
0DDAC:  MOVLW  00
0DDAE:  MOVWF  FF8
0DDB0:  CLRF   1B
0DDB2:  BTFSC  FF2.7
0DDB4:  BSF    1B.7
0DDB6:  BCF    FF2.7
0DDB8:  CALL   0E42
0DDBC:  BTFSC  1B.7
0DDBE:  BSF    FF2.7
....................       char result; 
....................       result = fgetc(COM_A); 
0DDC0:  CALL   0E2C
0DDC4:  MOVFF  01,885
....................       if(result == 'Y'){ 
0DDC8:  MOVLB  8
0DDCA:  MOVF   x85,W
0DDCC:  SUBLW  59
0DDCE:  BNZ   DDFE
....................       f_unlink(file_ptr_raw_all); 
0DDD0:  MOVLW  02
0DDD2:  MOVWF  x8A
0DDD4:  MOVLW  DD
0DDD6:  MOVWF  x89
0DDD8:  MOVLB  0
0DDDA:  CALL   BC92
....................       printf("File deleted!\n\r"); 
0DDDE:  MOVLW  E0
0DDE0:  MOVWF  FF6
0DDE2:  MOVLW  24
0DDE4:  MOVWF  FF7
0DDE6:  MOVLW  00
0DDE8:  MOVWF  FF8
0DDEA:  CLRF   1B
0DDEC:  BTFSC  FF2.7
0DDEE:  BSF    1B.7
0DDF0:  BCF    FF2.7
0DDF2:  CALL   0E42
0DDF6:  BTFSC  1B.7
0DDF8:  BSF    FF2.7
....................       }else{ 
0DDFA:  BRA    DE1C
0DDFC:  MOVLB  8
....................          printf("Operation canceled!\r\n"); 
0DDFE:  MOVLW  F0
0DE00:  MOVWF  FF6
0DE02:  MOVLW  24
0DE04:  MOVWF  FF7
0DE06:  MOVLW  00
0DE08:  MOVWF  FF8
0DE0A:  CLRF   1B
0DE0C:  BTFSC  FF2.7
0DE0E:  BSF    1B.7
0DE10:  BCF    FF2.7
0DE12:  MOVLB  0
0DE14:  CALL   0E42
0DE18:  BTFSC  1B.7
0DE1A:  BSF    FF2.7
....................       } 
....................          break; 
0DE1C:  BRA    DE9C
....................       case 2 :  
....................          printf("Are you sure you want to erase the calculated data file? Y or N!\r\n"); 
0DE1E:  MOVLW  06
0DE20:  MOVWF  FF6
0DE22:  MOVLW  25
0DE24:  MOVWF  FF7
0DE26:  MOVLW  00
0DE28:  MOVWF  FF8
0DE2A:  CLRF   1B
0DE2C:  BTFSC  FF2.7
0DE2E:  BSF    1B.7
0DE30:  BCF    FF2.7
0DE32:  CALL   0E42
0DE36:  BTFSC  1B.7
0DE38:  BSF    FF2.7
....................          result = fgetc(COM_A); 
0DE3A:  CALL   0E2C
0DE3E:  MOVFF  01,885
....................          if(result == 'Y'){ 
0DE42:  MOVLB  8
0DE44:  MOVF   x85,W
0DE46:  SUBLW  59
0DE48:  BNZ   DE78
....................             f_unlink(file_ptr_rel_all); 
0DE4A:  MOVLW  02
0DE4C:  MOVWF  x8A
0DE4E:  MOVLW  F9
0DE50:  MOVWF  x89
0DE52:  MOVLB  0
0DE54:  CALL   BC92
....................             printf("File deleted!\n\r"); 
0DE58:  MOVLW  4A
0DE5A:  MOVWF  FF6
0DE5C:  MOVLW  25
0DE5E:  MOVWF  FF7
0DE60:  MOVLW  00
0DE62:  MOVWF  FF8
0DE64:  CLRF   1B
0DE66:  BTFSC  FF2.7
0DE68:  BSF    1B.7
0DE6A:  BCF    FF2.7
0DE6C:  CALL   0E42
0DE70:  BTFSC  1B.7
0DE72:  BSF    FF2.7
....................          }else{ 
0DE74:  BRA    DE96
0DE76:  MOVLB  8
....................             printf("Operation canceled!\r\n"); 
0DE78:  MOVLW  5A
0DE7A:  MOVWF  FF6
0DE7C:  MOVLW  25
0DE7E:  MOVWF  FF7
0DE80:  MOVLW  00
0DE82:  MOVWF  FF8
0DE84:  CLRF   1B
0DE86:  BTFSC  FF2.7
0DE88:  BSF    1B.7
0DE8A:  BCF    FF2.7
0DE8C:  MOVLB  0
0DE8E:  CALL   0E42
0DE92:  BTFSC  1B.7
0DE94:  BSF    FF2.7
....................          } 
....................          break; 
0DE96:  BRA    DE9C
....................       default : cmd_arg(); 
0DE98:  CALL   B2F2
....................          break;          
....................    } 
0DE9C:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandF() 
.................... { 
....................    if(arg == 5525){ 
*
0E088:  MOVF   48,W
0E08A:  SUBLW  95
0E08C:  BNZ   E0A0
0E08E:  MOVF   49,W
0E090:  SUBLW  15
0E092:  BNZ   E0A0
0E094:  MOVF   4A,F
0E096:  BNZ   E0A0
0E098:  MOVF   4B,F
0E09A:  BNZ   E0A0
....................       reset_nv_vars(); 
0E09C:  BRA    DEA0
....................    } 
0E09E:  BRA    E0A4
....................    else cmd_arg(); 
0E0A0:  CALL   B2F2
0E0A4:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandG() 
.................... { 
....................    if(nv_product==ECO || nv_product==WMS4 || nv_product==WMS2) 
*
0E0F2:  MOVF   2F,F
0E0F4:  BNZ   E0FA
0E0F6:  MOVF   30,F
0E0F8:  BZ    E10C
0E0FA:  DECFSZ 2F,W
0E0FC:  BRA    E102
0E0FE:  MOVF   30,F
0E100:  BZ    E10C
0E102:  MOVF   2F,W
0E104:  SUBLW  03
0E106:  BNZ   E17E
0E108:  MOVF   30,F
0E10A:  BNZ   E17E
....................    { 
....................       busy_set(); 
0E10C:  CALL   29B4
....................  
....................       switch(arg) 
0E110:  MOVFF  48,00
0E114:  MOVF   49,W
0E116:  MOVWF  03
0E118:  BNZ   E120
0E11A:  MOVLW  01
0E11C:  SUBWF  00,W
0E11E:  BZ    E136
0E120:  MOVF   03,W
0E122:  BNZ   E12A
0E124:  MOVLW  02
0E126:  SUBWF  00,W
0E128:  BZ    E146
0E12A:  MOVF   03,W
0E12C:  BNZ   E134
0E12E:  MOVLW  03
0E130:  SUBWF  00,W
0E132:  BZ    E170
0E134:  BRA    E176
....................       { 
....................          case 1: 
....................          { 
....................             motor=0; 
0E136:  MOVLB  7
0E138:  CLRF   x40
....................             align(0); 
0E13A:  MOVLB  8
0E13C:  CLRF   xC2
0E13E:  MOVLB  0
0E140:  CALL   A8A8
....................             break; 
0E144:  BRA    E17A
....................          } 
....................          case 2: 
....................          { 
....................             if (arg==2 && nv_report_mode==4) 
0E146:  MOVF   48,W
0E148:  SUBLW  02
0E14A:  BNZ   E16E
0E14C:  MOVF   49,F
0E14E:  BNZ   E16E
0E150:  MOVF   4A,F
0E152:  BNZ   E16E
0E154:  MOVF   4B,F
0E156:  BNZ   E16E
0E158:  MOVF   1F,W
0E15A:  SUBLW  04
0E15C:  BNZ   E16E
0E15E:  MOVF   20,F
0E160:  BNZ   E16E
....................             { 
....................                motor=0; 
0E162:  MOVLB  7
0E164:  CLRF   x40
....................                cal_disk(0); 
0E166:  MOVLB  8
0E168:  CLRF   x85
0E16A:  MOVLB  0
0E16C:  BRA    E0A8
....................             } 
....................             break; 
0E16E:  BRA    E17A
....................          } 
....................          case 3: 
....................          { 
....................             recovery(); 
0E170:  CALL   AA4C
....................             break; 
0E174:  BRA    E17A
....................          } 
....................          default: 
....................          { 
....................             cmd_arg(); 
0E176:  CALL   B2F2
....................             break; 
....................          } 
....................       } 
....................  
....................       busy_clear(); 
0E17A:  CALL   AEA4
....................    } 
0E17E:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandHe() 
.................... { 
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0E658:  DECFSZ 48,W
0E65A:  BRA    EA78
0E65C:  MOVF   49,F
0E65E:  BTFSS  FD8.2
0E660:  BRA    EA78
0E662:  MOVF   4A,F
0E664:  BTFSS  FD8.2
0E666:  BRA    EA78
0E668:  MOVF   4B,F
0E66A:  BTFSS  FD8.2
0E66C:  BRA    EA78
....................       v_supply = read_supply(); 
0E66E:  CALL   50F0
0E672:  MOVFF  02,886
0E676:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0E67A:  CALL   34A6
....................       RTC_read(); 
0E67E:  CALL   3338
....................     
....................       fprintf(COM_A, "@ID#%Lu I%Lu N%Lu/%Lu X%Lu U%u %4.2wV\r\n", // 
....................            nv_serial,nv_interval,nv_sample,nv_max_samples,nv_report_mode,motor,v_supply); 
0E682:  MOVLW  70
0E684:  MOVWF  FF6
0E686:  MOVLW  25
0E688:  MOVWF  FF7
0E68A:  MOVLW  00
0E68C:  MOVWF  FF8
0E68E:  CLRF   1B
0E690:  BTFSC  FF2.7
0E692:  BSF    1B.7
0E694:  BCF    FF2.7
0E696:  MOVLW  04
0E698:  MOVLB  A
0E69A:  MOVWF  x40
0E69C:  MOVLB  0
0E69E:  CALL   1018
0E6A2:  BTFSC  1B.7
0E6A4:  BSF    FF2.7
0E6A6:  MOVLW  10
0E6A8:  MOVWF  FE9
0E6AA:  CLRF   1B
0E6AC:  BTFSC  FF2.7
0E6AE:  BSF    1B.7
0E6B0:  BCF    FF2.7
0E6B2:  MOVFF  26,A41
0E6B6:  MOVFF  25,A40
0E6BA:  CALL   119A
0E6BE:  BTFSC  1B.7
0E6C0:  BSF    FF2.7
0E6C2:  MOVLW  20
0E6C4:  BTFSS  F9E.4
0E6C6:  BRA    E6C4
0E6C8:  MOVWF  FAD
0E6CA:  MOVLW  49
0E6CC:  BTFSS  F9E.4
0E6CE:  BRA    E6CC
0E6D0:  MOVWF  FAD
0E6D2:  MOVLW  10
0E6D4:  MOVWF  FE9
0E6D6:  CLRF   1B
0E6D8:  BTFSC  FF2.7
0E6DA:  BSF    1B.7
0E6DC:  BCF    FF2.7
0E6DE:  MOVFF  24,A41
0E6E2:  MOVFF  23,A40
0E6E6:  CALL   119A
0E6EA:  BTFSC  1B.7
0E6EC:  BSF    FF2.7
0E6EE:  MOVLW  20
0E6F0:  BTFSS  F9E.4
0E6F2:  BRA    E6F0
0E6F4:  MOVWF  FAD
0E6F6:  MOVLW  4E
0E6F8:  BTFSS  F9E.4
0E6FA:  BRA    E6F8
0E6FC:  MOVWF  FAD
0E6FE:  MOVLW  10
0E700:  MOVWF  FE9
0E702:  CLRF   1B
0E704:  BTFSC  FF2.7
0E706:  BSF    1B.7
0E708:  BCF    FF2.7
0E70A:  MOVFF  22,A41
0E70E:  MOVFF  21,A40
0E712:  CALL   119A
0E716:  BTFSC  1B.7
0E718:  BSF    FF2.7
0E71A:  MOVLW  2F
0E71C:  BTFSS  F9E.4
0E71E:  BRA    E71C
0E720:  MOVWF  FAD
0E722:  MOVLW  10
0E724:  MOVWF  FE9
0E726:  CLRF   1B
0E728:  BTFSC  FF2.7
0E72A:  BSF    1B.7
0E72C:  BCF    FF2.7
0E72E:  MOVFF  28,A41
0E732:  MOVFF  27,A40
0E736:  CALL   119A
0E73A:  BTFSC  1B.7
0E73C:  BSF    FF2.7
0E73E:  MOVLW  20
0E740:  BTFSS  F9E.4
0E742:  BRA    E740
0E744:  MOVWF  FAD
0E746:  MOVLW  58
0E748:  BTFSS  F9E.4
0E74A:  BRA    E748
0E74C:  MOVWF  FAD
0E74E:  MOVLW  10
0E750:  MOVWF  FE9
0E752:  CLRF   1B
0E754:  BTFSC  FF2.7
0E756:  BSF    1B.7
0E758:  BCF    FF2.7
0E75A:  MOVFF  20,A41
0E75E:  MOVFF  1F,A40
0E762:  CALL   119A
0E766:  BTFSC  1B.7
0E768:  BSF    FF2.7
0E76A:  MOVLW  20
0E76C:  BTFSS  F9E.4
0E76E:  BRA    E76C
0E770:  MOVWF  FAD
0E772:  MOVLW  55
0E774:  BTFSS  F9E.4
0E776:  BRA    E774
0E778:  MOVWF  FAD
0E77A:  CLRF   1B
0E77C:  BTFSC  FF2.7
0E77E:  BSF    1B.7
0E780:  BCF    FF2.7
0E782:  MOVFF  740,A40
0E786:  MOVLW  1B
0E788:  MOVLB  A
0E78A:  MOVWF  x41
0E78C:  MOVLB  0
0E78E:  CALL   0F9A
0E792:  BTFSC  1B.7
0E794:  BSF    FF2.7
0E796:  MOVLW  20
0E798:  BTFSS  F9E.4
0E79A:  BRA    E798
0E79C:  MOVWF  FAD
0E79E:  MOVLW  04
0E7A0:  MOVWF  FE9
0E7A2:  MOVLB  8
0E7A4:  CLRF   x8A
0E7A6:  CLRF   x89
0E7A8:  MOVFF  886,888
0E7AC:  MOVFF  885,887
0E7B0:  MOVLW  02
0E7B2:  MOVWF  x8B
0E7B4:  MOVLB  0
0E7B6:  RCALL  E182
0E7B8:  MOVLW  94
0E7BA:  MOVWF  FF6
0E7BC:  MOVLW  25
0E7BE:  MOVWF  FF7
0E7C0:  MOVLW  00
0E7C2:  MOVWF  FF8
0E7C4:  CLRF   1B
0E7C6:  BTFSC  FF2.7
0E7C8:  BSF    1B.7
0E7CA:  BCF    FF2.7
0E7CC:  MOVLW  03
0E7CE:  MOVLB  A
0E7D0:  MOVWF  x40
0E7D2:  MOVLB  0
0E7D4:  CALL   1018
0E7D8:  BTFSC  1B.7
0E7DA:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0E7DC:  MOVLW  98
0E7DE:  MOVWF  FF6
0E7E0:  MOVLW  25
0E7E2:  MOVWF  FF7
0E7E4:  MOVLW  00
0E7E6:  MOVWF  FF8
0E7E8:  CLRF   1B
0E7EA:  BTFSC  FF2.7
0E7EC:  BSF    1B.7
0E7EE:  BCF    FF2.7
0E7F0:  MOVLW  09
0E7F2:  MOVLB  A
0E7F4:  MOVWF  x40
0E7F6:  MOVLB  0
0E7F8:  CALL   1018
0E7FC:  BTFSC  1B.7
0E7FE:  BSF    FF2.7
0E800:  MOVLW  10
0E802:  MOVWF  FE9
0E804:  CLRF   1B
0E806:  BTFSC  FF2.7
0E808:  BSF    1B.7
0E80A:  BCF    FF2.7
0E80C:  MOVFF  7C4,A41
0E810:  MOVFF  7C3,A40
0E814:  CALL   119A
0E818:  BTFSC  1B.7
0E81A:  BSF    FF2.7
0E81C:  MOVLW  A4
0E81E:  MOVWF  FF6
0E820:  MOVLW  25
0E822:  MOVWF  FF7
0E824:  MOVLW  00
0E826:  MOVWF  FF8
0E828:  CLRF   1B
0E82A:  BTFSC  FF2.7
0E82C:  BSF    1B.7
0E82E:  BCF    FF2.7
0E830:  MOVLW  05
0E832:  MOVLB  A
0E834:  MOVWF  x40
0E836:  MOVLB  0
0E838:  CALL   1018
0E83C:  BTFSC  1B.7
0E83E:  BSF    FF2.7
0E840:  MOVLW  10
0E842:  MOVWF  FE9
0E844:  MOVFF  7B6,8F1
0E848:  MOVFF  7B5,8F0
0E84C:  CALL   8FD8
0E850:  MOVLW  0D
0E852:  BTFSS  F9E.4
0E854:  BRA    E852
0E856:  MOVWF  FAD
0E858:  MOVLW  0A
0E85A:  BTFSS  F9E.4
0E85C:  BRA    E85A
0E85E:  MOVWF  FAD
....................       RTC_display(); 
0E860:  RCALL  E27E
....................       if (RTCfmt == 0) 
0E862:  MOVF   4F,F
0E864:  BTFSS  FD8.2
0E866:  BRA    E96C
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_month,rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E868:  MOVLW  B0
0E86A:  MOVWF  FF6
0E86C:  MOVLW  25
0E86E:  MOVWF  FF7
0E870:  MOVLW  00
0E872:  MOVWF  FF8
0E874:  CLRF   1B
0E876:  BTFSC  FF2.7
0E878:  BSF    1B.7
0E87A:  BCF    FF2.7
0E87C:  MOVLW  05
0E87E:  MOVLB  A
0E880:  MOVWF  x40
0E882:  MOVLB  0
0E884:  CALL   1018
0E888:  BTFSC  1B.7
0E88A:  BSF    FF2.7
0E88C:  CLRF   1B
0E88E:  BTFSC  FF2.7
0E890:  BSF    1B.7
0E892:  BCF    FF2.7
0E894:  MOVFF  73A,A40
0E898:  MOVLW  01
0E89A:  MOVLB  A
0E89C:  MOVWF  x41
0E89E:  MOVLB  0
0E8A0:  CALL   0F9A
0E8A4:  BTFSC  1B.7
0E8A6:  BSF    FF2.7
0E8A8:  MOVLW  2F
0E8AA:  BTFSS  F9E.4
0E8AC:  BRA    E8AA
0E8AE:  MOVWF  FAD
0E8B0:  CLRF   1B
0E8B2:  BTFSC  FF2.7
0E8B4:  BSF    1B.7
0E8B6:  BCF    FF2.7
0E8B8:  MOVFF  73B,A40
0E8BC:  MOVLW  01
0E8BE:  MOVLB  A
0E8C0:  MOVWF  x41
0E8C2:  MOVLB  0
0E8C4:  CALL   0F9A
0E8C8:  BTFSC  1B.7
0E8CA:  BSF    FF2.7
0E8CC:  MOVLW  2F
0E8CE:  BTFSS  F9E.4
0E8D0:  BRA    E8CE
0E8D2:  MOVWF  FAD
0E8D4:  CLRF   1B
0E8D6:  BTFSC  FF2.7
0E8D8:  BSF    1B.7
0E8DA:  BCF    FF2.7
0E8DC:  MOVFF  73C,A40
0E8E0:  MOVLW  01
0E8E2:  MOVLB  A
0E8E4:  MOVWF  x41
0E8E6:  MOVLB  0
0E8E8:  CALL   0F9A
0E8EC:  BTFSC  1B.7
0E8EE:  BSF    FF2.7
0E8F0:  MOVLW  20
0E8F2:  BTFSS  F9E.4
0E8F4:  BRA    E8F2
0E8F6:  MOVWF  FAD
0E8F8:  CLRF   1B
0E8FA:  BTFSC  FF2.7
0E8FC:  BSF    1B.7
0E8FE:  BCF    FF2.7
0E900:  MOVFF  73D,A40
0E904:  MOVLW  01
0E906:  MOVLB  A
0E908:  MOVWF  x41
0E90A:  MOVLB  0
0E90C:  CALL   0F9A
0E910:  BTFSC  1B.7
0E912:  BSF    FF2.7
0E914:  MOVLW  3A
0E916:  BTFSS  F9E.4
0E918:  BRA    E916
0E91A:  MOVWF  FAD
0E91C:  CLRF   1B
0E91E:  BTFSC  FF2.7
0E920:  BSF    1B.7
0E922:  BCF    FF2.7
0E924:  MOVFF  73E,A40
0E928:  MOVLW  01
0E92A:  MOVLB  A
0E92C:  MOVWF  x41
0E92E:  MOVLB  0
0E930:  CALL   0F9A
0E934:  BTFSC  1B.7
0E936:  BSF    FF2.7
0E938:  MOVLW  3A
0E93A:  BTFSS  F9E.4
0E93C:  BRA    E93A
0E93E:  MOVWF  FAD
0E940:  CLRF   1B
0E942:  BTFSC  FF2.7
0E944:  BSF    1B.7
0E946:  BCF    FF2.7
0E948:  MOVFF  73F,A40
0E94C:  MOVLW  01
0E94E:  MOVLB  A
0E950:  MOVWF  x41
0E952:  MOVLB  0
0E954:  CALL   0F9A
0E958:  BTFSC  1B.7
0E95A:  BSF    FF2.7
0E95C:  MOVLW  0D
0E95E:  BTFSS  F9E.4
0E960:  BRA    E95E
0E962:  MOVWF  FAD
0E964:  MOVLW  0A
0E966:  BTFSS  F9E.4
0E968:  BRA    E966
0E96A:  MOVWF  FAD
....................       } 
....................       if (RTCfmt == 1)  
0E96C:  DECFSZ 4F,W
0E96E:  BRA    EA74
....................       { 
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", 
....................            rtc_last_day,rtc_last_month,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0E970:  MOVLW  D6
0E972:  MOVWF  FF6
0E974:  MOVLW  25
0E976:  MOVWF  FF7
0E978:  MOVLW  00
0E97A:  MOVWF  FF8
0E97C:  CLRF   1B
0E97E:  BTFSC  FF2.7
0E980:  BSF    1B.7
0E982:  BCF    FF2.7
0E984:  MOVLW  05
0E986:  MOVLB  A
0E988:  MOVWF  x40
0E98A:  MOVLB  0
0E98C:  CALL   1018
0E990:  BTFSC  1B.7
0E992:  BSF    FF2.7
0E994:  CLRF   1B
0E996:  BTFSC  FF2.7
0E998:  BSF    1B.7
0E99A:  BCF    FF2.7
0E99C:  MOVFF  73B,A40
0E9A0:  MOVLW  01
0E9A2:  MOVLB  A
0E9A4:  MOVWF  x41
0E9A6:  MOVLB  0
0E9A8:  CALL   0F9A
0E9AC:  BTFSC  1B.7
0E9AE:  BSF    FF2.7
0E9B0:  MOVLW  2F
0E9B2:  BTFSS  F9E.4
0E9B4:  BRA    E9B2
0E9B6:  MOVWF  FAD
0E9B8:  CLRF   1B
0E9BA:  BTFSC  FF2.7
0E9BC:  BSF    1B.7
0E9BE:  BCF    FF2.7
0E9C0:  MOVFF  73A,A40
0E9C4:  MOVLW  01
0E9C6:  MOVLB  A
0E9C8:  MOVWF  x41
0E9CA:  MOVLB  0
0E9CC:  CALL   0F9A
0E9D0:  BTFSC  1B.7
0E9D2:  BSF    FF2.7
0E9D4:  MOVLW  2F
0E9D6:  BTFSS  F9E.4
0E9D8:  BRA    E9D6
0E9DA:  MOVWF  FAD
0E9DC:  CLRF   1B
0E9DE:  BTFSC  FF2.7
0E9E0:  BSF    1B.7
0E9E2:  BCF    FF2.7
0E9E4:  MOVFF  73C,A40
0E9E8:  MOVLW  01
0E9EA:  MOVLB  A
0E9EC:  MOVWF  x41
0E9EE:  MOVLB  0
0E9F0:  CALL   0F9A
0E9F4:  BTFSC  1B.7
0E9F6:  BSF    FF2.7
0E9F8:  MOVLW  20
0E9FA:  BTFSS  F9E.4
0E9FC:  BRA    E9FA
0E9FE:  MOVWF  FAD
0EA00:  CLRF   1B
0EA02:  BTFSC  FF2.7
0EA04:  BSF    1B.7
0EA06:  BCF    FF2.7
0EA08:  MOVFF  73D,A40
0EA0C:  MOVLW  01
0EA0E:  MOVLB  A
0EA10:  MOVWF  x41
0EA12:  MOVLB  0
0EA14:  CALL   0F9A
0EA18:  BTFSC  1B.7
0EA1A:  BSF    FF2.7
0EA1C:  MOVLW  3A
0EA1E:  BTFSS  F9E.4
0EA20:  BRA    EA1E
0EA22:  MOVWF  FAD
0EA24:  CLRF   1B
0EA26:  BTFSC  FF2.7
0EA28:  BSF    1B.7
0EA2A:  BCF    FF2.7
0EA2C:  MOVFF  73E,A40
0EA30:  MOVLW  01
0EA32:  MOVLB  A
0EA34:  MOVWF  x41
0EA36:  MOVLB  0
0EA38:  CALL   0F9A
0EA3C:  BTFSC  1B.7
0EA3E:  BSF    FF2.7
0EA40:  MOVLW  3A
0EA42:  BTFSS  F9E.4
0EA44:  BRA    EA42
0EA46:  MOVWF  FAD
0EA48:  CLRF   1B
0EA4A:  BTFSC  FF2.7
0EA4C:  BSF    1B.7
0EA4E:  BCF    FF2.7
0EA50:  MOVFF  73F,A40
0EA54:  MOVLW  01
0EA56:  MOVLB  A
0EA58:  MOVWF  x41
0EA5A:  MOVLB  0
0EA5C:  CALL   0F9A
0EA60:  BTFSC  1B.7
0EA62:  BSF    FF2.7
0EA64:  MOVLW  0D
0EA66:  BTFSS  F9E.4
0EA68:  BRA    EA66
0EA6A:  MOVWF  FAD
0EA6C:  MOVLW  0A
0EA6E:  BTFSS  F9E.4
0EA70:  BRA    EA6E
0EA72:  MOVWF  FAD
....................       }     
....................       RTC_read_alarm(); 
0EA74:  RCALL  E408
....................       RTC_display_alarm(); 
0EA76:  RCALL  E4DE
....................    } 
0EA78:  GOTO   F28C (RETURN)
.................... } 
....................  
.................... void commandHw() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
0EA7C:  DECFSZ 48,W
0EA7E:  BRA    ED56
0EA80:  MOVF   49,F
0EA82:  BTFSS  FD8.2
0EA84:  BRA    ED56
0EA86:  MOVF   4A,F
0EA88:  BTFSS  FD8.2
0EA8A:  BRA    ED56
0EA8C:  MOVF   4B,F
0EA8E:  BTFSS  FD8.2
0EA90:  BRA    ED56
....................       v_supply = read_supply(); 
0EA92:  CALL   50F0
0EA96:  MOVFF  02,886
0EA9A:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0EA9E:  CALL   34A6
....................       RTC_read(); 
0EAA2:  CALL   3338
....................   
....................       fprintf(COM_A, "A%Lu I%Lu L%Lu Q%Lu S%Lu %4.2wV\r\n",  
....................          nv_macro_mode, nv_interval, nv_volume, nv_port, nv_sample,v_supply); 
0EAA6:  MOVLW  41
0EAA8:  BTFSS  F9E.4
0EAAA:  BRA    EAA8
0EAAC:  MOVWF  FAD
0EAAE:  MOVLW  10
0EAB0:  MOVWF  FE9
0EAB2:  CLRF   1B
0EAB4:  BTFSC  FF2.7
0EAB6:  BSF    1B.7
0EAB8:  BCF    FF2.7
0EABA:  MOVFF  2A,A41
0EABE:  MOVFF  29,A40
0EAC2:  CALL   119A
0EAC6:  BTFSC  1B.7
0EAC8:  BSF    FF2.7
0EACA:  MOVLW  20
0EACC:  BTFSS  F9E.4
0EACE:  BRA    EACC
0EAD0:  MOVWF  FAD
0EAD2:  MOVLW  49
0EAD4:  BTFSS  F9E.4
0EAD6:  BRA    EAD4
0EAD8:  MOVWF  FAD
0EADA:  MOVLW  10
0EADC:  MOVWF  FE9
0EADE:  CLRF   1B
0EAE0:  BTFSC  FF2.7
0EAE2:  BSF    1B.7
0EAE4:  BCF    FF2.7
0EAE6:  MOVFF  24,A41
0EAEA:  MOVFF  23,A40
0EAEE:  CALL   119A
0EAF2:  BTFSC  1B.7
0EAF4:  BSF    FF2.7
0EAF6:  MOVLW  20
0EAF8:  BTFSS  F9E.4
0EAFA:  BRA    EAF8
0EAFC:  MOVWF  FAD
0EAFE:  MOVLW  4C
0EB00:  BTFSS  F9E.4
0EB02:  BRA    EB00
0EB04:  MOVWF  FAD
0EB06:  MOVLW  10
0EB08:  MOVWF  FE9
0EB0A:  CLRF   1B
0EB0C:  BTFSC  FF2.7
0EB0E:  BSF    1B.7
0EB10:  BCF    FF2.7
0EB12:  MOVFF  2C,A41
0EB16:  MOVFF  2B,A40
0EB1A:  CALL   119A
0EB1E:  BTFSC  1B.7
0EB20:  BSF    FF2.7
0EB22:  MOVLW  20
0EB24:  BTFSS  F9E.4
0EB26:  BRA    EB24
0EB28:  MOVWF  FAD
0EB2A:  MOVLW  51
0EB2C:  BTFSS  F9E.4
0EB2E:  BRA    EB2C
0EB30:  MOVWF  FAD
0EB32:  MOVLW  10
0EB34:  MOVWF  FE9
0EB36:  CLRF   1B
0EB38:  BTFSC  FF2.7
0EB3A:  BSF    1B.7
0EB3C:  BCF    FF2.7
0EB3E:  MOVFF  2E,A41
0EB42:  MOVFF  2D,A40
0EB46:  CALL   119A
0EB4A:  BTFSC  1B.7
0EB4C:  BSF    FF2.7
0EB4E:  MOVLW  20
0EB50:  BTFSS  F9E.4
0EB52:  BRA    EB50
0EB54:  MOVWF  FAD
0EB56:  MOVLW  53
0EB58:  BTFSS  F9E.4
0EB5A:  BRA    EB58
0EB5C:  MOVWF  FAD
0EB5E:  MOVLW  10
0EB60:  MOVWF  FE9
0EB62:  CLRF   1B
0EB64:  BTFSC  FF2.7
0EB66:  BSF    1B.7
0EB68:  BCF    FF2.7
0EB6A:  MOVFF  22,A41
0EB6E:  MOVFF  21,A40
0EB72:  CALL   119A
0EB76:  BTFSC  1B.7
0EB78:  BSF    FF2.7
0EB7A:  MOVLW  20
0EB7C:  BTFSS  F9E.4
0EB7E:  BRA    EB7C
0EB80:  MOVWF  FAD
0EB82:  MOVLW  04
0EB84:  MOVWF  FE9
0EB86:  MOVLB  8
0EB88:  CLRF   x8A
0EB8A:  CLRF   x89
0EB8C:  MOVFF  886,888
0EB90:  MOVFF  885,887
0EB94:  MOVLW  02
0EB96:  MOVWF  x8B
0EB98:  MOVLB  0
0EB9A:  CALL   E182
0EB9E:  MOVLW  1A
0EBA0:  MOVWF  FF6
0EBA2:  MOVLW  26
0EBA4:  MOVWF  FF7
0EBA6:  MOVLW  00
0EBA8:  MOVWF  FF8
0EBAA:  CLRF   1B
0EBAC:  BTFSC  FF2.7
0EBAE:  BSF    1B.7
0EBB0:  BCF    FF2.7
0EBB2:  MOVLW  03
0EBB4:  MOVLB  A
0EBB6:  MOVWF  x40
0EBB8:  MOVLB  0
0EBBA:  CALL   1018
0EBBE:  BTFSC  1B.7
0EBC0:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:VAL=%Lu SYR=%Ld\r\n", e_port[0],m_lin_pos[1]); 
0EBC2:  MOVLW  1E
0EBC4:  MOVWF  FF6
0EBC6:  MOVLW  26
0EBC8:  MOVWF  FF7
0EBCA:  MOVLW  00
0EBCC:  MOVWF  FF8
0EBCE:  CLRF   1B
0EBD0:  BTFSC  FF2.7
0EBD2:  BSF    1B.7
0EBD4:  BCF    FF2.7
0EBD6:  MOVLW  09
0EBD8:  MOVLB  A
0EBDA:  MOVWF  x40
0EBDC:  MOVLB  0
0EBDE:  CALL   1018
0EBE2:  BTFSC  1B.7
0EBE4:  BSF    FF2.7
0EBE6:  MOVLW  10
0EBE8:  MOVWF  FE9
0EBEA:  CLRF   1B
0EBEC:  BTFSC  FF2.7
0EBEE:  BSF    1B.7
0EBF0:  BCF    FF2.7
0EBF2:  MOVFF  7C4,A41
0EBF6:  MOVFF  7C3,A40
0EBFA:  CALL   119A
0EBFE:  BTFSC  1B.7
0EC00:  BSF    FF2.7
0EC02:  MOVLW  2A
0EC04:  MOVWF  FF6
0EC06:  MOVLW  26
0EC08:  MOVWF  FF7
0EC0A:  MOVLW  00
0EC0C:  MOVWF  FF8
0EC0E:  CLRF   1B
0EC10:  BTFSC  FF2.7
0EC12:  BSF    1B.7
0EC14:  BCF    FF2.7
0EC16:  MOVLW  05
0EC18:  MOVLB  A
0EC1A:  MOVWF  x40
0EC1C:  MOVLB  0
0EC1E:  CALL   1018
0EC22:  BTFSC  1B.7
0EC24:  BSF    FF2.7
0EC26:  MOVLW  10
0EC28:  MOVWF  FE9
0EC2A:  MOVFF  7B6,8F1
0EC2E:  MOVFF  7B5,8F0
0EC32:  CALL   8FD8
0EC36:  MOVLW  0D
0EC38:  BTFSS  F9E.4
0EC3A:  BRA    EC38
0EC3C:  MOVWF  FAD
0EC3E:  MOVLW  0A
0EC40:  BTFSS  F9E.4
0EC42:  BRA    EC40
0EC44:  MOVWF  FAD
....................       RTC_display(); 
0EC46:  CALL   E27E
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0EC4A:  MOVLW  36
0EC4C:  MOVWF  FF6
0EC4E:  MOVLW  26
0EC50:  MOVWF  FF7
0EC52:  MOVLW  00
0EC54:  MOVWF  FF8
0EC56:  CLRF   1B
0EC58:  BTFSC  FF2.7
0EC5A:  BSF    1B.7
0EC5C:  BCF    FF2.7
0EC5E:  MOVLW  05
0EC60:  MOVLB  A
0EC62:  MOVWF  x40
0EC64:  MOVLB  0
0EC66:  CALL   1018
0EC6A:  BTFSC  1B.7
0EC6C:  BSF    FF2.7
0EC6E:  CLRF   1B
0EC70:  BTFSC  FF2.7
0EC72:  BSF    1B.7
0EC74:  BCF    FF2.7
0EC76:  MOVFF  73A,A40
0EC7A:  MOVLW  01
0EC7C:  MOVLB  A
0EC7E:  MOVWF  x41
0EC80:  MOVLB  0
0EC82:  CALL   0F9A
0EC86:  BTFSC  1B.7
0EC88:  BSF    FF2.7
0EC8A:  MOVLW  2F
0EC8C:  BTFSS  F9E.4
0EC8E:  BRA    EC8C
0EC90:  MOVWF  FAD
0EC92:  CLRF   1B
0EC94:  BTFSC  FF2.7
0EC96:  BSF    1B.7
0EC98:  BCF    FF2.7
0EC9A:  MOVFF  73B,A40
0EC9E:  MOVLW  01
0ECA0:  MOVLB  A
0ECA2:  MOVWF  x41
0ECA4:  MOVLB  0
0ECA6:  CALL   0F9A
0ECAA:  BTFSC  1B.7
0ECAC:  BSF    FF2.7
0ECAE:  MOVLW  2F
0ECB0:  BTFSS  F9E.4
0ECB2:  BRA    ECB0
0ECB4:  MOVWF  FAD
0ECB6:  CLRF   1B
0ECB8:  BTFSC  FF2.7
0ECBA:  BSF    1B.7
0ECBC:  BCF    FF2.7
0ECBE:  MOVFF  73C,A40
0ECC2:  MOVLW  01
0ECC4:  MOVLB  A
0ECC6:  MOVWF  x41
0ECC8:  MOVLB  0
0ECCA:  CALL   0F9A
0ECCE:  BTFSC  1B.7
0ECD0:  BSF    FF2.7
0ECD2:  MOVLW  20
0ECD4:  BTFSS  F9E.4
0ECD6:  BRA    ECD4
0ECD8:  MOVWF  FAD
0ECDA:  CLRF   1B
0ECDC:  BTFSC  FF2.7
0ECDE:  BSF    1B.7
0ECE0:  BCF    FF2.7
0ECE2:  MOVFF  73D,A40
0ECE6:  MOVLW  01
0ECE8:  MOVLB  A
0ECEA:  MOVWF  x41
0ECEC:  MOVLB  0
0ECEE:  CALL   0F9A
0ECF2:  BTFSC  1B.7
0ECF4:  BSF    FF2.7
0ECF6:  MOVLW  3A
0ECF8:  BTFSS  F9E.4
0ECFA:  BRA    ECF8
0ECFC:  MOVWF  FAD
0ECFE:  CLRF   1B
0ED00:  BTFSC  FF2.7
0ED02:  BSF    1B.7
0ED04:  BCF    FF2.7
0ED06:  MOVFF  73E,A40
0ED0A:  MOVLW  01
0ED0C:  MOVLB  A
0ED0E:  MOVWF  x41
0ED10:  MOVLB  0
0ED12:  CALL   0F9A
0ED16:  BTFSC  1B.7
0ED18:  BSF    FF2.7
0ED1A:  MOVLW  3A
0ED1C:  BTFSS  F9E.4
0ED1E:  BRA    ED1C
0ED20:  MOVWF  FAD
0ED22:  CLRF   1B
0ED24:  BTFSC  FF2.7
0ED26:  BSF    1B.7
0ED28:  BCF    FF2.7
0ED2A:  MOVFF  73F,A40
0ED2E:  MOVLW  01
0ED30:  MOVLB  A
0ED32:  MOVWF  x41
0ED34:  MOVLB  0
0ED36:  CALL   0F9A
0ED3A:  BTFSC  1B.7
0ED3C:  BSF    FF2.7
0ED3E:  MOVLW  0D
0ED40:  BTFSS  F9E.4
0ED42:  BRA    ED40
0ED44:  MOVWF  FAD
0ED46:  MOVLW  0A
0ED48:  BTFSS  F9E.4
0ED4A:  BRA    ED48
0ED4C:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0ED4E:  CALL   E408
....................       RTC_display_alarm(); 
0ED52:  CALL   E4DE
....................    } 
0ED56:  GOTO   F28C (RETURN)
.................... } 
....................  
.................... void commandHa() 
.................... { 
....................  
....................    int16 v_supply; 
....................     
....................    if (arg == 1) { 
*
0EFE4:  DECFSZ 48,W
0EFE6:  BRA    F24C
0EFE8:  MOVF   49,F
0EFEA:  BTFSS  FD8.2
0EFEC:  BRA    F24C
0EFEE:  MOVF   4A,F
0EFF0:  BTFSS  FD8.2
0EFF2:  BRA    F24C
0EFF4:  MOVF   4B,F
0EFF6:  BTFSS  FD8.2
0EFF8:  BRA    F24C
....................       v_supply = read_supply(); 
0EFFA:  CALL   50F0
0EFFE:  MOVFF  02,886
0F002:  MOVFF  01,885
....................        
....................       RTC_reset_HT(); 
0F006:  CALL   34A6
....................       RTC_read(); 
0F00A:  CALL   3338
....................   
....................       fprintf(COM_A, "I%Lu N%Lu/%Lu P%Lu %4.2wV\r\n",  
....................          nv_interval,nv_sample,nv_max_samples,nv_port,v_supply); 
0F00E:  MOVLW  49
0F010:  BTFSS  F9E.4
0F012:  BRA    F010
0F014:  MOVWF  FAD
0F016:  MOVLW  10
0F018:  MOVWF  FE9
0F01A:  CLRF   1B
0F01C:  BTFSC  FF2.7
0F01E:  BSF    1B.7
0F020:  BCF    FF2.7
0F022:  MOVFF  24,A41
0F026:  MOVFF  23,A40
0F02A:  CALL   119A
0F02E:  BTFSC  1B.7
0F030:  BSF    FF2.7
0F032:  MOVLW  20
0F034:  BTFSS  F9E.4
0F036:  BRA    F034
0F038:  MOVWF  FAD
0F03A:  MOVLW  4E
0F03C:  BTFSS  F9E.4
0F03E:  BRA    F03C
0F040:  MOVWF  FAD
0F042:  MOVLW  10
0F044:  MOVWF  FE9
0F046:  CLRF   1B
0F048:  BTFSC  FF2.7
0F04A:  BSF    1B.7
0F04C:  BCF    FF2.7
0F04E:  MOVFF  22,A41
0F052:  MOVFF  21,A40
0F056:  CALL   119A
0F05A:  BTFSC  1B.7
0F05C:  BSF    FF2.7
0F05E:  MOVLW  2F
0F060:  BTFSS  F9E.4
0F062:  BRA    F060
0F064:  MOVWF  FAD
0F066:  MOVLW  10
0F068:  MOVWF  FE9
0F06A:  CLRF   1B
0F06C:  BTFSC  FF2.7
0F06E:  BSF    1B.7
0F070:  BCF    FF2.7
0F072:  MOVFF  28,A41
0F076:  MOVFF  27,A40
0F07A:  CALL   119A
0F07E:  BTFSC  1B.7
0F080:  BSF    FF2.7
0F082:  MOVLW  20
0F084:  BTFSS  F9E.4
0F086:  BRA    F084
0F088:  MOVWF  FAD
0F08A:  MOVLW  50
0F08C:  BTFSS  F9E.4
0F08E:  BRA    F08C
0F090:  MOVWF  FAD
0F092:  MOVLW  10
0F094:  MOVWF  FE9
0F096:  CLRF   1B
0F098:  BTFSC  FF2.7
0F09A:  BSF    1B.7
0F09C:  BCF    FF2.7
0F09E:  MOVFF  2E,A41
0F0A2:  MOVFF  2D,A40
0F0A6:  CALL   119A
0F0AA:  BTFSC  1B.7
0F0AC:  BSF    FF2.7
0F0AE:  MOVLW  20
0F0B0:  BTFSS  F9E.4
0F0B2:  BRA    F0B0
0F0B4:  MOVWF  FAD
0F0B6:  MOVLW  04
0F0B8:  MOVWF  FE9
0F0BA:  MOVLB  8
0F0BC:  CLRF   x8A
0F0BE:  CLRF   x89
0F0C0:  MOVFF  886,888
0F0C4:  MOVFF  885,887
0F0C8:  MOVLW  02
0F0CA:  MOVWF  x8B
0F0CC:  MOVLB  0
0F0CE:  CALL   E182
0F0D2:  MOVLW  74
0F0D4:  MOVWF  FF6
0F0D6:  MOVLW  26
0F0D8:  MOVWF  FF7
0F0DA:  MOVLW  00
0F0DC:  MOVWF  FF8
0F0DE:  CLRF   1B
0F0E0:  BTFSC  FF2.7
0F0E2:  BSF    1B.7
0F0E4:  BCF    FF2.7
0F0E6:  MOVLW  03
0F0E8:  MOVLB  A
0F0EA:  MOVWF  x40
0F0EC:  MOVLB  0
0F0EE:  CALL   1018
0F0F2:  BTFSC  1B.7
0F0F4:  BSF    FF2.7
....................       fprintf(COM_A, "@MOT:SYR=%Ld\r\n", m_lin_pos[1]); 
0F0F6:  MOVLW  78
0F0F8:  MOVWF  FF6
0F0FA:  MOVLW  26
0F0FC:  MOVWF  FF7
0F0FE:  MOVLW  00
0F100:  MOVWF  FF8
0F102:  CLRF   1B
0F104:  BTFSC  FF2.7
0F106:  BSF    1B.7
0F108:  BCF    FF2.7
0F10A:  MOVLW  09
0F10C:  MOVLB  A
0F10E:  MOVWF  x40
0F110:  MOVLB  0
0F112:  CALL   1018
0F116:  BTFSC  1B.7
0F118:  BSF    FF2.7
0F11A:  MOVLW  10
0F11C:  MOVWF  FE9
0F11E:  MOVFF  7B6,8F1
0F122:  MOVFF  7B5,8F0
0F126:  CALL   8FD8
0F12A:  MOVLW  0D
0F12C:  BTFSS  F9E.4
0F12E:  BRA    F12C
0F130:  MOVWF  FAD
0F132:  MOVLW  0A
0F134:  BTFSS  F9E.4
0F136:  BRA    F134
0F138:  MOVWF  FAD
....................       display_valve_status(); 
0F13A:  RCALL  ED5A
....................       RTC_display(); 
0F13C:  CALL   E27E
....................       fprintf(COM_A, "@PWR:%02u/%02u/%02u %02u:%02u:%02u\r\n", rtc_last_month, 
....................          rtc_last_day,rtc_last_year,rtc_last_hour,rtc_last_min,rtc_last_sec); 
0F140:  MOVLW  88
0F142:  MOVWF  FF6
0F144:  MOVLW  26
0F146:  MOVWF  FF7
0F148:  MOVLW  00
0F14A:  MOVWF  FF8
0F14C:  CLRF   1B
0F14E:  BTFSC  FF2.7
0F150:  BSF    1B.7
0F152:  BCF    FF2.7
0F154:  MOVLW  05
0F156:  MOVLB  A
0F158:  MOVWF  x40
0F15A:  MOVLB  0
0F15C:  CALL   1018
0F160:  BTFSC  1B.7
0F162:  BSF    FF2.7
0F164:  CLRF   1B
0F166:  BTFSC  FF2.7
0F168:  BSF    1B.7
0F16A:  BCF    FF2.7
0F16C:  MOVFF  73A,A40
0F170:  MOVLW  01
0F172:  MOVLB  A
0F174:  MOVWF  x41
0F176:  MOVLB  0
0F178:  CALL   0F9A
0F17C:  BTFSC  1B.7
0F17E:  BSF    FF2.7
0F180:  MOVLW  2F
0F182:  BTFSS  F9E.4
0F184:  BRA    F182
0F186:  MOVWF  FAD
0F188:  CLRF   1B
0F18A:  BTFSC  FF2.7
0F18C:  BSF    1B.7
0F18E:  BCF    FF2.7
0F190:  MOVFF  73B,A40
0F194:  MOVLW  01
0F196:  MOVLB  A
0F198:  MOVWF  x41
0F19A:  MOVLB  0
0F19C:  CALL   0F9A
0F1A0:  BTFSC  1B.7
0F1A2:  BSF    FF2.7
0F1A4:  MOVLW  2F
0F1A6:  BTFSS  F9E.4
0F1A8:  BRA    F1A6
0F1AA:  MOVWF  FAD
0F1AC:  CLRF   1B
0F1AE:  BTFSC  FF2.7
0F1B0:  BSF    1B.7
0F1B2:  BCF    FF2.7
0F1B4:  MOVFF  73C,A40
0F1B8:  MOVLW  01
0F1BA:  MOVLB  A
0F1BC:  MOVWF  x41
0F1BE:  MOVLB  0
0F1C0:  CALL   0F9A
0F1C4:  BTFSC  1B.7
0F1C6:  BSF    FF2.7
0F1C8:  MOVLW  20
0F1CA:  BTFSS  F9E.4
0F1CC:  BRA    F1CA
0F1CE:  MOVWF  FAD
0F1D0:  CLRF   1B
0F1D2:  BTFSC  FF2.7
0F1D4:  BSF    1B.7
0F1D6:  BCF    FF2.7
0F1D8:  MOVFF  73D,A40
0F1DC:  MOVLW  01
0F1DE:  MOVLB  A
0F1E0:  MOVWF  x41
0F1E2:  MOVLB  0
0F1E4:  CALL   0F9A
0F1E8:  BTFSC  1B.7
0F1EA:  BSF    FF2.7
0F1EC:  MOVLW  3A
0F1EE:  BTFSS  F9E.4
0F1F0:  BRA    F1EE
0F1F2:  MOVWF  FAD
0F1F4:  CLRF   1B
0F1F6:  BTFSC  FF2.7
0F1F8:  BSF    1B.7
0F1FA:  BCF    FF2.7
0F1FC:  MOVFF  73E,A40
0F200:  MOVLW  01
0F202:  MOVLB  A
0F204:  MOVWF  x41
0F206:  MOVLB  0
0F208:  CALL   0F9A
0F20C:  BTFSC  1B.7
0F20E:  BSF    FF2.7
0F210:  MOVLW  3A
0F212:  BTFSS  F9E.4
0F214:  BRA    F212
0F216:  MOVWF  FAD
0F218:  CLRF   1B
0F21A:  BTFSC  FF2.7
0F21C:  BSF    1B.7
0F21E:  BCF    FF2.7
0F220:  MOVFF  73F,A40
0F224:  MOVLW  01
0F226:  MOVLB  A
0F228:  MOVWF  x41
0F22A:  MOVLB  0
0F22C:  CALL   0F9A
0F230:  BTFSC  1B.7
0F232:  BSF    FF2.7
0F234:  MOVLW  0D
0F236:  BTFSS  F9E.4
0F238:  BRA    F236
0F23A:  MOVWF  FAD
0F23C:  MOVLW  0A
0F23E:  BTFSS  F9E.4
0F240:  BRA    F23E
0F242:  MOVWF  FAD
....................        
....................       RTC_read_alarm(); 
0F244:  CALL   E408
....................       RTC_display_alarm(); 
0F248:  CALL   E4DE
....................    } 
0F24C:  GOTO   F28C (RETURN)
.................... } 
....................  
.................... void commandH() 
.................... { 
....................    switch(nv_product){ 
0F250:  MOVF   2F,W
0F252:  MOVWF  00
0F254:  MOVF   30,W
0F256:  MOVWF  03
0F258:  BNZ   F25E
0F25A:  MOVF   00,F
0F25C:  BZ    F27E
0F25E:  MOVF   03,W
0F260:  BNZ   F268
0F262:  MOVLW  01
0F264:  SUBWF  00,W
0F266:  BZ    F284
0F268:  MOVF   03,W
0F26A:  BNZ   F272
0F26C:  MOVLW  03
0F26E:  SUBWF  00,W
0F270:  BZ    F284
0F272:  MOVF   03,W
0F274:  BNZ   F27C
0F276:  MOVLW  02
0F278:  SUBWF  00,W
0F27A:  BZ    F28A
0F27C:  BRA    F28C
....................       case ECO : commandHe(); 
0F27E:  GOTO   E658
....................          break; 
0F282:  BRA    F28C
....................       case WMS4 :  
....................       case WMS2 : commandHw(); 
0F284:  GOTO   EA7C
....................          break; 
0F288:  BRA    F28C
....................       case AWS : commandHa(); 
0F28A:  BRA    EFE4
....................          break;          
....................    } 
0F28C:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandI() 
.................... { 
....................    if(arg > 0 && arg < 64801) { 
0F290:  MOVF   48,F
0F292:  BNZ   F2A0
0F294:  MOVF   49,F
0F296:  BNZ   F2A0
0F298:  MOVF   4A,F
0F29A:  BNZ   F2A0
0F29C:  MOVF   4B,F
0F29E:  BZ    F2D4
0F2A0:  MOVF   4B,F
0F2A2:  BNZ   F2D4
0F2A4:  MOVF   4A,F
0F2A6:  BNZ   F2D4
0F2A8:  MOVF   49,W
0F2AA:  SUBLW  FD
0F2AC:  BNC   F2D4
0F2AE:  BNZ   F2B6
0F2B0:  MOVF   48,W
0F2B2:  SUBLW  20
0F2B4:  BNC   F2D4
....................       nv_interval = arg; 
0F2B6:  MOVFF  49,24
0F2BA:  MOVFF  48,23
....................       write16(ADDR_INTERVAL, nv_interval); 
0F2BE:  MOVLW  14
0F2C0:  MOVLB  8
0F2C2:  MOVWF  xEE
0F2C4:  MOVFF  24,8F0
0F2C8:  MOVFF  23,8EF
0F2CC:  MOVLB  0
0F2CE:  CALL   4FC8
....................    } 
0F2D2:  BRA    F2D8
....................    else cmd_arg(); 
0F2D4:  CALL   B2F2
0F2D8:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandJ() 
.................... { 
....................    if(arg < 10000) { 
0F2DC:  MOVF   4B,F
0F2DE:  BNZ   F30E
0F2E0:  MOVF   4A,F
0F2E2:  BNZ   F30E
0F2E4:  MOVF   49,W
0F2E6:  SUBLW  27
0F2E8:  BNC   F30E
0F2EA:  BNZ   F2F2
0F2EC:  MOVF   48,W
0F2EE:  SUBLW  0F
0F2F0:  BNC   F30E
....................       nv_serial = arg; 
0F2F2:  MOVFF  49,26
0F2F6:  MOVFF  48,25
....................       write16(ADDR_SERIALNO, nv_serial); 
0F2FA:  MOVLB  8
0F2FC:  CLRF   xEE
0F2FE:  MOVFF  26,8F0
0F302:  MOVFF  25,8EF
0F306:  MOVLB  0
0F308:  CALL   4FC8
....................    } 
0F30C:  BRA    F312
....................    else cmd_arg(); 
0F30E:  CALL   B2F2
0F312:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandK() 
.................... { 
....................    if(nv_product==ECO){ 
*
0F536:  MOVF   2F,F
0F538:  BNZ   F568
0F53A:  MOVF   30,F
0F53C:  BNZ   F568
....................        
....................       if (arg > 0 && arg < 3){ 
0F53E:  MOVF   48,F
0F540:  BNZ   F54E
0F542:  MOVF   49,F
0F544:  BNZ   F54E
0F546:  MOVF   4A,F
0F548:  BNZ   F54E
0F54A:  MOVF   4B,F
0F54C:  BZ    F564
0F54E:  MOVF   4B,F
0F550:  BNZ   F564
0F552:  MOVF   4A,F
0F554:  BNZ   F564
0F556:  MOVF   49,F
0F558:  BNZ   F564
0F55A:  MOVF   48,W
0F55C:  SUBLW  02
0F55E:  BNC   F564
....................          det_cmd(); 
0F560:  RCALL  F3F6
....................       } 
0F562:  BRA    F568
....................       else cmd_arg(); 
0F564:  CALL   B2F2
....................        
....................    } 
0F568:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandLe() 
.................... { 
....................    if(arg<4096){ 
*
103B6:  MOVF   4B,F
103B8:  BNZ   10424
103BA:  MOVF   4A,F
103BC:  BNZ   10424
103BE:  MOVF   49,W
103C0:  SUBLW  0F
103C2:  BNC   10424
....................       switch (nv_det_type){ 
103C4:  MOVFF  45,00
103C8:  MOVF   46,W
103CA:  MOVWF  03
103CC:  BNZ   103D4
103CE:  MOVLW  01
103D0:  SUBWF  00,W
103D2:  BZ    103EA
103D4:  MOVF   03,W
103D6:  BNZ   103DE
103D8:  MOVLW  02
103DA:  SUBWF  00,W
103DC:  BZ    103F0
103DE:  MOVF   03,W
103E0:  BNZ   103E8
103E2:  MOVLW  03
103E4:  SUBWF  00,W
103E6:  BZ    1040E
103E8:  BRA    10422
....................          case 1 : det_cmd(); 
103EA:  CALL   F3F6
....................             break; 
103EE:  BRA    10422
....................          case 2 : DAC_set(1,arg); 
103F0:  MOVFF  49,886
103F4:  MOVFF  48,885
103F8:  MOVLW  01
103FA:  MOVLB  8
103FC:  MOVWF  xD3
103FE:  MOVFF  49,8D5
10402:  MOVFF  48,8D4
10406:  MOVLB  0
10408:  CALL   F56C
....................             break; 
1040C:  BRA    10422
....................          case 3 : set_LED(arg); 
1040E:  MOVFF  49,886
10412:  MOVFF  48,885
10416:  MOVFF  49,8C6
1041A:  MOVFF  48,8C5
1041E:  CALL   F8BA
....................             break; 
....................       } 
....................    } 
10422:  BRA    10482
....................    else if(arg>20000 && arg<20003)DAC_set_test(arg); 
10424:  MOVF   4B,F
10426:  BNZ   1043C
10428:  MOVF   4A,F
1042A:  BNZ   1043C
1042C:  MOVF   49,W
1042E:  SUBLW  4D
10430:  BC    10466
10432:  XORLW  FF
10434:  BNZ   1043C
10436:  MOVF   48,W
10438:  SUBLW  20
1043A:  BC    10466
1043C:  MOVF   4B,F
1043E:  BNZ   10466
10440:  MOVF   4A,F
10442:  BNZ   10466
10444:  MOVF   49,W
10446:  SUBLW  4E
10448:  BNC   10466
1044A:  BNZ   10452
1044C:  MOVF   48,W
1044E:  SUBLW  22
10450:  BNC   10466
10452:  MOVFF  49,886
10456:  MOVFF  48,885
1045A:  MOVFF  49,888
1045E:  MOVFF  48,887
10462:  BRA    1026E
10464:  BRA    10482
....................    else if(arg==30001)set_LED_test(); 
10466:  MOVF   48,W
10468:  SUBLW  31
1046A:  BNZ   1047E
1046C:  MOVF   49,W
1046E:  SUBLW  75
10470:  BNZ   1047E
10472:  MOVF   4A,F
10474:  BNZ   1047E
10476:  MOVF   4B,F
10478:  BNZ   1047E
1047A:  BRA    1032A
1047C:  BRA    10482
....................    else cmd_arg(); 
1047E:  CALL   B2F2
10482:  GOTO   104EC (RETURN)
.................... } 
....................  
.................... void commandLw() 
.................... { 
....................    if(arg >= 0 && arg < 22501){ 
10486:  MOVF   4B,F
10488:  BNZ   104BA
1048A:  MOVF   4A,F
1048C:  BNZ   104BA
1048E:  MOVF   49,W
10490:  SUBLW  57
10492:  BNC   104BA
10494:  BNZ   1049C
10496:  MOVF   48,W
10498:  SUBLW  E4
1049A:  BNC   104BA
....................       nv_volume = arg; 
1049C:  MOVFF  49,2C
104A0:  MOVFF  48,2B
....................       write16(ADDR_VOLUME, nv_volume); 
104A4:  MOVLW  22
104A6:  MOVLB  8
104A8:  MOVWF  xEE
104AA:  MOVFF  2C,8F0
104AE:  MOVFF  2B,8EF
104B2:  MOVLB  0
104B4:  CALL   4FC8
....................    } 
104B8:  BRA    104BE
....................    else cmd_arg(); 
104BA:  CALL   B2F2
104BE:  GOTO   104EC (RETURN)
.................... } 
....................  
.................... void commandL() 
.................... { 
....................    switch(nv_product){ 
104C2:  MOVF   2F,W
104C4:  MOVWF  00
104C6:  MOVF   30,W
104C8:  MOVWF  03
104CA:  BNZ   104D0
104CC:  MOVF   00,F
104CE:  BZ    104E6
104D0:  MOVF   03,W
104D2:  BNZ   104DA
104D4:  MOVLW  01
104D6:  SUBWF  00,W
104D8:  BZ    104EA
104DA:  MOVF   03,W
104DC:  BNZ   104E4
104DE:  MOVLW  03
104E0:  SUBWF  00,W
104E2:  BZ    104EA
104E4:  BRA    104EC
....................       case ECO : commandLe(); 
104E6:  BRA    103B6
....................          break; 
104E8:  BRA    104EC
....................       case WMS4 :  
....................       case WMS2 : commandLw(); 
104EA:  BRA    10486
....................          break; 
....................    } 
104EC:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandM(int1 LoggingReentry) 
.................... { 
....................    int8 macro; 
....................     
....................    busy_set(); 
*
16DA0:  CALL   29B4
....................     
....................    user_quit = FALSE; 
16DA4:  CLRF   50
....................     
....................    if(arg > 0 && arg < 21) 
16DA6:  MOVF   48,F
16DA8:  BNZ   16DB6
16DAA:  MOVF   49,F
16DAC:  BNZ   16DB6
16DAE:  MOVF   4A,F
16DB0:  BNZ   16DB6
16DB2:  MOVF   4B,F
16DB4:  BZ    16E32
16DB6:  MOVF   4B,F
16DB8:  BNZ   16E32
16DBA:  MOVF   4A,F
16DBC:  BNZ   16E32
16DBE:  MOVF   49,F
16DC0:  BNZ   16E32
16DC2:  MOVF   48,W
16DC4:  SUBLW  14
16DC6:  BNC   16E32
....................    { 
....................       macro = arg; 
16DC8:  MOVFF  48,886
....................       switch(nv_product){ 
16DCC:  MOVFF  2F,00
16DD0:  MOVF   30,W
16DD2:  MOVWF  03
16DD4:  BNZ   16DDA
16DD6:  MOVF   00,F
16DD8:  BZ    16DFA
16DDA:  MOVF   03,W
16DDC:  BNZ   16DE4
16DDE:  MOVLW  01
16DE0:  SUBWF  00,W
16DE2:  BZ    16DFA
16DE4:  MOVF   03,W
16DE6:  BNZ   16DEE
16DE8:  MOVLW  03
16DEA:  SUBWF  00,W
16DEC:  BZ    16DFA
16DEE:  MOVF   03,W
16DF0:  BNZ   16DF8
16DF2:  MOVLW  02
16DF4:  SUBWF  00,W
16DF6:  BZ    16E20
16DF8:  BRA    16E30
....................          case ECO : 
....................          case WMS4 :  
....................          case WMS2 : play_macro(macro,(e_port[0]+1)); 
16DFA:  MOVLW  01
16DFC:  MOVLB  7
16DFE:  ADDWF  xC3,W
16E00:  MOVLB  8
16E02:  MOVWF  x87
16E04:  MOVLW  00
16E06:  MOVLB  7
16E08:  ADDWFC xC4,W
16E0A:  MOVLB  8
16E0C:  MOVWF  x88
16E0E:  MOVFF  886,897
16E12:  MOVWF  x99
16E14:  MOVFF  887,898
16E18:  MOVLB  0
16E1A:  CALL   153A8
....................             break; 
16E1E:  BRA    16E30
....................          case AWS : play_macro(macro,nv_port); 
16E20:  MOVFF  886,897
16E24:  MOVFF  2E,899
16E28:  MOVFF  2D,898
16E2C:  CALL   153A8
....................             break; 
....................       } 
....................    }    
16E30:  BRA    16EB8
....................    else if (arg == 0) 
16E32:  MOVF   48,F
16E34:  BNZ   16EB4
16E36:  MOVF   49,F
16E38:  BNZ   16EB4
16E3A:  MOVF   4A,F
16E3C:  BNZ   16EB4
16E3E:  MOVF   4B,F
16E40:  BNZ   16EB4
....................    { 
....................       //start watchdog at beginning of logging mode 
....................       //RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
16E42:  BCF    F91.0
....................       spi_write(0x89); 
16E44:  MOVF   FC9,W
16E46:  MOVLW  89
16E48:  MOVWF  FC9
16E4A:  RRCF   FC7,W
16E4C:  BNC   16E4A
....................       spi_write(0b11111111); 
16E4E:  MOVF   FC9,W
16E50:  SETF   FC9
16E52:  RRCF   FC7,W
16E54:  BNC   16E52
....................       spi_read(0x00); 
16E56:  MOVF   FC9,W
16E58:  CLRF   FC9
16E5A:  RRCF   FC7,W
16E5C:  BNC   16E5A
....................       output_bit(RTC_CS, DISABLE); 
16E5E:  BSF    F91.0
....................        
....................       MaxSamples=FALSE; 
16E60:  CLRF   34
16E62:  CLRF   33
....................       write8(ADDR_MaxSamples, MaxSamples);  
16E64:  MOVLW  28
16E66:  MOVLB  8
16E68:  MOVWF  x89
16E6A:  MOVFF  33,88A
16E6E:  MOVLB  0
16E70:  CALL   3406
....................       if (LoggingReentry != TRUE) 
16E74:  MOVLB  8
16E76:  DECFSZ x85,W
16E78:  BRA    16E7C
16E7A:  BRA    16E94
....................       { 
....................          nv_sample = 0; 
16E7C:  CLRF   22
16E7E:  CLRF   21
....................          write16(ADDR_SAMPLE, nv_sample);     
16E80:  MOVLW  16
16E82:  MOVWF  xEE
16E84:  MOVFF  22,8F0
16E88:  MOVFF  21,8EF
16E8C:  MOVLB  0
16E8E:  CALL   4FC8
16E92:  MOVLB  8
....................       } 
....................  
....................       LoggingReentry = 0; 
16E94:  CLRF   x85
....................       nv_macro_step = 0; 
16E96:  CLRF   38
16E98:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step);       
16E9A:  MOVLW  3A
16E9C:  MOVWF  xEE
16E9E:  MOVFF  38,8F0
16EA2:  MOVFF  37,8EF
16EA6:  MOVLB  0
16EA8:  CALL   4FC8
....................       user_quit = auto_sample_ready(); 
16EAC:  BRA    16B9E
16EAE:  MOVFF  01,50
....................    } 
16EB2:  BRA    16EB8
....................    else cmd_arg(); 
16EB4:  CALL   B2F2
....................     
....................    busy_clear(); 
16EB8:  CALL   AEA4
16EBC:  RETURN 0
.................... } 
....................  
.................... void commandN() 
.................... { 
....................    if(arg > 0 && arg < 3501) { 
16EBE:  MOVF   48,F
16EC0:  BNZ   16ECE
16EC2:  MOVF   49,F
16EC4:  BNZ   16ECE
16EC6:  MOVF   4A,F
16EC8:  BNZ   16ECE
16ECA:  MOVF   4B,F
16ECC:  BZ    16F02
16ECE:  MOVF   4B,F
16ED0:  BNZ   16F02
16ED2:  MOVF   4A,F
16ED4:  BNZ   16F02
16ED6:  MOVF   49,W
16ED8:  SUBLW  0D
16EDA:  BNC   16F02
16EDC:  BNZ   16EE4
16EDE:  MOVF   48,W
16EE0:  SUBLW  AC
16EE2:  BNC   16F02
....................       nv_max_samples = arg; 
16EE4:  MOVFF  49,28
16EE8:  MOVFF  48,27
....................       write16(ADDR_MAX_SAMPLES, nv_max_samples); 
16EEC:  MOVLW  18
16EEE:  MOVLB  8
16EF0:  MOVWF  xEE
16EF2:  MOVFF  28,8F0
16EF6:  MOVFF  27,8EF
16EFA:  MOVLB  0
16EFC:  CALL   4FC8
....................    } 
16F00:  BRA    16F48
....................    else if(arg == 0) { 
16F02:  MOVF   48,F
16F04:  BNZ   16F44
16F06:  MOVF   49,F
16F08:  BNZ   16F44
16F0A:  MOVF   4A,F
16F0C:  BNZ   16F44
16F0E:  MOVF   4B,F
16F10:  BNZ   16F44
....................       nv_sample = 0; 
16F12:  CLRF   22
16F14:  CLRF   21
....................       write16(ADDR_SAMPLE, nv_sample); 
16F16:  MOVLW  16
16F18:  MOVLB  8
16F1A:  MOVWF  xEE
16F1C:  MOVFF  22,8F0
16F20:  MOVFF  21,8EF
16F24:  MOVLB  0
16F26:  CALL   4FC8
....................       nv_macro_step = 0; 
16F2A:  CLRF   38
16F2C:  CLRF   37
....................       write16(ADDR_MACRO_STEP, nv_macro_step); 
16F2E:  MOVLW  3A
16F30:  MOVLB  8
16F32:  MOVWF  xEE
16F34:  MOVFF  38,8F0
16F38:  MOVFF  37,8EF
16F3C:  MOVLB  0
16F3E:  CALL   4FC8
....................    } 
16F42:  BRA    16F48
....................    else cmd_arg(); 
16F44:  CALL   B2F2
16F48:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandO() 
.................... { 
....................    if(arg == 1) 
*
1706E:  DECFSZ 48,W
17070:  BRA    1708A
17072:  MOVF   49,F
17074:  BNZ   1708A
17076:  MOVF   4A,F
17078:  BNZ   1708A
1707A:  MOVF   4B,F
1707C:  BNZ   1708A
....................    { 
....................       bus_on(); 
1707E:  CALL   D364
....................       open_pipe(); 
17082:  BRA    16F64
....................       bus_off(); 
17084:  CALL   D388
....................    } 
17088:  BRA    1708E
....................    else cmd_arg(); 
1708A:  CALL   B2F2
1708E:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandPe() 
.................... { 
....................    if(m_fixed==1) motor=0;                          // if fixed operation set rotary 
*
1714C:  MOVLB  7
1714E:  DECFSZ x41,W
17150:  BRA    17154
17152:  CLRF   x40
....................     
....................    if (arg>0 && arg<=e_ppr[motor]){              
17154:  MOVF   48,F
17156:  BNZ   17166
17158:  MOVF   49,F
1715A:  BNZ   17166
1715C:  MOVF   4A,F
1715E:  BNZ   17166
17160:  MOVF   4B,F
17162:  BTFSC  FD8.2
17164:  BRA    1722E
17166:  BCF    FD8.0
17168:  RLCF   x40,W
1716A:  CLRF   03
1716C:  ADDLW  62
1716E:  MOVWF  FE9
17170:  MOVLW  07
17172:  ADDWFC 03,W
17174:  MOVWF  FEA
17176:  MOVFF  FEC,03
1717A:  MOVF   FED,F
1717C:  MOVFF  FEF,01
17180:  MOVF   4B,F
17182:  BNZ   1722E
17184:  MOVF   4A,F
17186:  BNZ   1722E
17188:  MOVF   49,W
1718A:  SUBWF  03,W
1718C:  BNC   1722E
1718E:  BNZ   17196
17190:  MOVF   48,W
17192:  SUBWF  01,W
17194:  BNC   1722E
....................       if(e_mode[motor]==2){     // if port mode then move 
17196:  BCF    FD8.0
17198:  RLCF   x40,W
1719A:  CLRF   03
1719C:  ADDLW  66
1719E:  MOVWF  FE9
171A0:  MOVLW  07
171A2:  ADDWFC 03,W
171A4:  MOVWF  FEA
171A6:  MOVFF  FEC,886
171AA:  MOVF   FED,F
171AC:  MOVFF  FEF,885
171B0:  MOVLB  8
171B2:  MOVF   x85,W
171B4:  SUBLW  02
171B6:  BNZ   17224
171B8:  MOVF   x86,F
171BA:  BNZ   17224
....................          switch (nv_product){ 
171BC:  MOVF   2F,W
171BE:  MOVWF  00
171C0:  MOVF   30,W
171C2:  MOVWF  03
171C4:  MOVF   03,W
171C6:  BNZ   171D0
171C8:  MOVF   00,F
171CA:  MOVLB  0
171CC:  BZ    171EE
171CE:  MOVLB  8
171D0:  MOVF   03,W
171D2:  BNZ   171DE
171D4:  MOVLW  01
171D6:  SUBWF  00,W
171D8:  MOVLB  0
171DA:  BZ    17200
171DC:  MOVLB  8
171DE:  MOVF   03,W
171E0:  BNZ   171EC
171E2:  MOVLW  03
171E4:  SUBWF  00,W
171E6:  MOVLB  0
171E8:  BZ    17212
171EA:  MOVLB  8
171EC:  BRA    17222
....................             // command_move (int8 dir_mode, int8 dir, int8 int_mode 
....................             case ECO:  command_move(1,0,1); 
171EE:  MOVLW  01
171F0:  MOVLB  8
171F2:  MOVWF  x85
171F4:  CLRF   x86
171F6:  MOVWF  x87
171F8:  MOVLB  0
171FA:  RCALL  17092
....................                break;             
171FC:  MOVLB  8
171FE:  BRA    17222
....................             case WMS4: command_move(0,0,1); 
17200:  MOVLB  8
17202:  CLRF   x85
17204:  CLRF   x86
17206:  MOVLW  01
17208:  MOVWF  x87
1720A:  MOVLB  0
1720C:  RCALL  17092
....................                break; 
1720E:  MOVLB  8
17210:  BRA    17222
....................             case WMS2: command_move(0,0,1); // 1 DIR, cw, edge = quad end 
17212:  MOVLB  8
17214:  CLRF   x85
17216:  CLRF   x86
17218:  MOVLW  01
1721A:  MOVWF  x87
1721C:  MOVLB  0
1721E:  RCALL  17092
....................                break; 
17220:  MOVLB  8
....................          } 
....................       } 
17222:  BRA    1722C
....................       else cmd_err();                           // else error 
17224:  MOVLB  0
17226:  CALL   BFB4
1722A:  MOVLB  8
....................    } 
1722C:  BRA    17236
....................    else cmd_arg(); 
1722E:  MOVLB  0
17230:  CALL   B2F2
17234:  MOVLB  8
17236:  MOVLB  0
17238:  RETURN 0
.................... } 
....................  
.................... void commandPa() 
.................... { 
....................    if (arg<49){ 
1723A:  MOVF   4B,F
1723C:  BNZ   1726A
1723E:  MOVF   4A,F
17240:  BNZ   1726A
17242:  MOVF   49,F
17244:  BNZ   1726A
17246:  MOVF   48,W
17248:  SUBLW  30
1724A:  BNC   1726A
....................       nv_port = arg; 
1724C:  MOVFF  49,2E
17250:  MOVFF  48,2D
....................       write16(ADDR_PORT, nv_port); 
17254:  MOVLW  24
17256:  MOVLB  8
17258:  MOVWF  xEE
1725A:  MOVFF  2E,8F0
1725E:  MOVFF  2D,8EF
17262:  MOVLB  0
17264:  CALL   4FC8
....................    } 
17268:  BRA    1726E
....................    else cmd_arg(); 
1726A:  CALL   B2F2
1726E:  GOTO   172AA (RETURN)
.................... } 
....................  
.................... void commandP() 
.................... { 
....................    switch(nv_product){ 
17272:  MOVF   2F,W
17274:  MOVWF  00
17276:  MOVF   30,W
17278:  MOVWF  03
1727A:  BNZ   17280
1727C:  MOVF   00,F
1727E:  BZ    172A0
17280:  MOVF   03,W
17282:  BNZ   1728A
17284:  MOVLW  01
17286:  SUBWF  00,W
17288:  BZ    172A4
1728A:  MOVF   03,W
1728C:  BNZ   17294
1728E:  MOVLW  03
17290:  SUBWF  00,W
17292:  BZ    172A4
17294:  MOVF   03,W
17296:  BNZ   1729E
17298:  MOVLW  02
1729A:  SUBWF  00,W
1729C:  BZ    172A8
1729E:  BRA    172AA
....................       case ECO : commandPe(); 
172A0:  RCALL  1714C
....................          break; 
172A2:  BRA    172AA
....................       case WMS4 :  
....................       case WMS2 : commandPe(); 
172A4:  RCALL  1714C
....................          break; 
172A6:  BRA    172AA
....................       case AWS : commandPa(); 
172A8:  BRA    1723A
....................          break;          
....................    } 
172AA:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandQa() 
.................... { 
....................    int8 valve; 
....................     
....................    if(bus_pwr_status==1){ 
*
172F6:  MOVLB  4
172F8:  DECFSZ xB6,W
172FA:  BRA    17326
....................     
....................       if(arg<33){ 
172FC:  MOVF   4B,F
172FE:  BNZ   1731E
17300:  MOVF   4A,F
17302:  BNZ   1731E
17304:  MOVF   49,F
17306:  BNZ   1731E
17308:  MOVF   48,W
1730A:  SUBLW  20
1730C:  BNC   1731E
....................          valve=arg;    
1730E:  MOVFF  48,885
....................          sol_switch(valve); 
17312:  MOVFF  885,8B5
17316:  MOVLB  0
17318:  CALL   14552
....................       }  
1731C:  BRA    17324
....................       else cmd_arg(); 
1731E:  MOVLB  0
17320:  CALL   B2F2
....................    } 
17324:  BRA    1732C
....................    else cmd_err(); 
17326:  MOVLB  0
17328:  CALL   BFB4
1732C:  GOTO   1735C (RETURN)
.................... } 
....................  
.................... void commandQw() 
.................... { 
....................    if (arg > 0 && arg < 51){ 
*
172AE:  MOVF   48,F
172B0:  BNZ   172BE
172B2:  MOVF   49,F
172B4:  BNZ   172BE
172B6:  MOVF   4A,F
172B8:  BNZ   172BE
172BA:  MOVF   4B,F
172BC:  BZ    172EE
172BE:  MOVF   4B,F
172C0:  BNZ   172EE
172C2:  MOVF   4A,F
172C4:  BNZ   172EE
172C6:  MOVF   49,F
172C8:  BNZ   172EE
172CA:  MOVF   48,W
172CC:  SUBLW  32
172CE:  BNC   172EE
....................       nv_port = arg; 
172D0:  MOVFF  49,2E
172D4:  MOVFF  48,2D
....................       write16(ADDR_SAMPLE, nv_port); 
172D8:  MOVLW  16
172DA:  MOVLB  8
172DC:  MOVWF  xEE
172DE:  MOVFF  2E,8F0
172E2:  MOVFF  2D,8EF
172E6:  MOVLB  0
172E8:  CALL   4FC8
....................    } 
172EC:  BRA    172F2
....................    else cmd_arg(); 
172EE:  CALL   B2F2
172F2:  GOTO   1735C (RETURN)
.................... } 
....................  
.................... void commandQ() 
.................... { 
....................    switch(nv_product){ 
*
17330:  MOVF   2F,W
17332:  MOVWF  00
17334:  MOVF   30,W
17336:  MOVWF  03
17338:  BNZ   17340
1733A:  MOVLW  01
1733C:  SUBWF  00,W
1733E:  BZ    17356
17340:  MOVF   03,W
17342:  BNZ   1734A
17344:  MOVLW  03
17346:  SUBWF  00,W
17348:  BZ    17356
1734A:  MOVF   03,W
1734C:  BNZ   17354
1734E:  MOVLW  02
17350:  SUBWF  00,W
17352:  BZ    1735A
17354:  BRA    1735C
....................       case WMS4 :  
....................       case WMS2 : commandQw(); 
17356:  BRA    172AE
....................          break; 
17358:  BRA    1735C
....................       case AWS : commandQa(); 
1735A:  BRA    172F6
....................          break;          
....................    } 
1735C:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandRe() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
17360:  CALL   29B4
....................     
....................    nv_macro_step = 0; 
17364:  CLRF   38
17366:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
17368:  MOVLW  3A
1736A:  MOVLB  8
1736C:  MOVWF  xEE
1736E:  MOVFF  38,8F0
17372:  MOVFF  37,8EF
17376:  MOVLB  0
17378:  CALL   4FC8
....................     
....................    user_quit = FALSE; 
1737C:  CLRF   50
....................     
....................    if (arg > 0 && arg < 3501){ 
1737E:  MOVF   48,F
17380:  BNZ   1738E
17382:  MOVF   49,F
17384:  BNZ   1738E
17386:  MOVF   4A,F
17388:  BNZ   1738E
1738A:  MOVF   4B,F
1738C:  BZ    1743A
1738E:  MOVF   4B,F
17390:  BNZ   1743A
17392:  MOVF   4A,F
17394:  BNZ   1743A
17396:  MOVF   49,W
17398:  SUBLW  0D
1739A:  BNC   1743A
1739C:  BNZ   173A4
1739E:  MOVF   48,W
173A0:  SUBLW  AC
173A2:  BNC   1743A
....................       samples = arg; 
173A4:  MOVFF  49,887
173A8:  MOVFF  48,886
....................       user_quit = FALSE; 
173AC:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
173AE:  MOVLB  8
173B0:  CLRF   x89
173B2:  CLRF   x88
173B4:  MOVF   x89,W
173B6:  SUBWF  x87,W
173B8:  BNC   17438
173BA:  BNZ   173C2
173BC:  MOVF   x86,W
173BE:  SUBWF  x88,W
173C0:  BC    17438
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
173C2:  MOVLW  01
173C4:  ADDWF  x88,W
173C6:  MOVWF  x8A
173C8:  MOVLW  00
173CA:  ADDWFC x89,W
173CC:  MOVWF  x8B
173CE:  MOVLW  AE
173D0:  MOVWF  FF6
173D2:  MOVLW  26
173D4:  MOVWF  FF7
173D6:  MOVLW  00
173D8:  MOVWF  FF8
173DA:  CLRF   1B
173DC:  BTFSC  FF2.7
173DE:  BSF    1B.7
173E0:  BCF    FF2.7
173E2:  MOVLW  05
173E4:  MOVLB  A
173E6:  MOVWF  x40
173E8:  MOVLB  0
173EA:  CALL   1018
173EE:  BTFSC  1B.7
173F0:  BSF    FF2.7
173F2:  MOVLW  09
173F4:  MOVWF  FE9
173F6:  CLRF   1B
173F8:  BTFSC  FF2.7
173FA:  BSF    1B.7
173FC:  BCF    FF2.7
173FE:  MOVFF  88B,A41
17402:  MOVFF  88A,A40
17406:  CALL   119A
1740A:  BTFSC  1B.7
1740C:  BSF    FF2.7
1740E:  MOVLW  0D
17410:  BTFSS  F9E.4
17412:  BRA    17410
17414:  MOVWF  FAD
17416:  MOVLW  0A
17418:  BTFSS  F9E.4
1741A:  BRA    17418
1741C:  MOVWF  FAD
....................          macro_cmd = master_macro_eco(); 
1741E:  CALL   15F8E
17422:  MOVFF  01,885
....................          if (macro_cmd == ';') break; 
17426:  MOVLB  8
17428:  MOVF   x85,W
1742A:  SUBLW  3B
1742C:  BTFSC  FD8.2
1742E:  BRA    17438
17430:  INCF   x88,F
17432:  BTFSC  FD8.2
17434:  INCF   x89,F
17436:  BRA    173B4
17438:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
1743A:  CALL   AEA4
1743E:  GOTO   175FE (RETURN)
.................... } 
....................  
.................... void commandRw() 
.................... { 
....................    int16 port; 
....................    int8 i,n; 
....................     
....................    if(arg > 0 && arg < 48){ 
17442:  MOVF   48,F
17444:  BNZ   17452
17446:  MOVF   49,F
17448:  BNZ   17452
1744A:  MOVF   4A,F
1744C:  BNZ   17452
1744E:  MOVF   4B,F
17450:  BZ    17496
17452:  MOVF   4B,F
17454:  BNZ   17496
17456:  MOVF   4A,F
17458:  BNZ   17496
1745A:  MOVF   49,F
1745C:  BNZ   17496
1745E:  MOVF   48,W
17460:  SUBLW  2F
17462:  BNC   17496
....................       n=arg; 
17464:  MOVFF  48,888
....................       port=2; 
17468:  MOVLB  8
1746A:  CLRF   x86
1746C:  MOVLW  02
1746E:  MOVWF  x85
....................       for(i=0;i<n;++i){ 
17470:  CLRF   x87
17472:  MOVF   x88,W
17474:  SUBWF  x87,W
17476:  BC    17492
....................          play_wms_hard_macro(port); 
17478:  MOVFF  886,88A
1747C:  MOVFF  885,889
17480:  MOVLB  0
17482:  CALL   D7F4
....................          ++port; 
17486:  MOVLB  8
17488:  INCF   x85,F
1748A:  BTFSC  FD8.2
1748C:  INCF   x86,F
1748E:  INCF   x87,F
17490:  BRA    17472
....................       } 
....................    } 
17492:  BRA    1749C
17494:  MOVLB  0
....................    else cmd_arg(); 
17496:  CALL   B2F2
1749A:  MOVLB  8
1749C:  MOVLB  0
1749E:  GOTO   175FE (RETURN)
.................... } 
....................  
.................... void commandRa() 
.................... { 
....................    int8 macro_cmd; 
....................    int16 samples, count; 
....................     
....................    busy_set(); 
174A2:  CALL   29B4
....................     
....................    nv_macro_step = 0; 
174A6:  CLRF   38
174A8:  CLRF   37
....................    write16(ADDR_MACRO_STEP, nv_macro_step); 
174AA:  MOVLW  3A
174AC:  MOVLB  8
174AE:  MOVWF  xEE
174B0:  MOVFF  38,8F0
174B4:  MOVFF  37,8EF
174B8:  MOVLB  0
174BA:  CALL   4FC8
....................     
....................    user_quit = FALSE; 
174BE:  CLRF   50
....................     
....................    if (arg > 0 && arg < 241){ 
174C0:  MOVF   48,F
174C2:  BNZ   174D2
174C4:  MOVF   49,F
174C6:  BNZ   174D2
174C8:  MOVF   4A,F
174CA:  BNZ   174D2
174CC:  MOVF   4B,F
174CE:  BTFSC  FD8.2
174D0:  BRA    175BE
174D2:  MOVF   4B,F
174D4:  BTFSS  FD8.2
174D6:  BRA    175BE
174D8:  MOVF   4A,F
174DA:  BTFSS  FD8.2
174DC:  BRA    175BE
174DE:  MOVF   49,F
174E0:  BTFSS  FD8.2
174E2:  BRA    175BE
174E4:  MOVF   48,W
174E6:  SUBLW  F0
174E8:  BNC   175BE
....................       samples = arg; 
174EA:  MOVFF  49,887
174EE:  MOVFF  48,886
....................       user_quit = FALSE; 
174F2:  CLRF   50
....................       // start from beginning of each macro 
....................       // reset_bookmarks(); 
....................       for (count=0; count<samples; ++count){ 
174F4:  MOVLB  8
174F6:  CLRF   x89
174F8:  CLRF   x88
174FA:  MOVF   x89,W
174FC:  SUBWF  x87,W
174FE:  BNC   175BC
17500:  BNZ   17508
17502:  MOVF   x86,W
17504:  SUBWF  x88,W
17506:  BC    175BC
....................          fprintf(COM_A, "@SMP %04Lu\r\n", (count+1)); 
17508:  MOVLW  01
1750A:  ADDWF  x88,W
1750C:  MOVWF  x8A
1750E:  MOVLW  00
17510:  ADDWFC x89,W
17512:  MOVWF  x8B
17514:  MOVLW  BC
17516:  MOVWF  FF6
17518:  MOVLW  26
1751A:  MOVWF  FF7
1751C:  MOVLW  00
1751E:  MOVWF  FF8
17520:  CLRF   1B
17522:  BTFSC  FF2.7
17524:  BSF    1B.7
17526:  BCF    FF2.7
17528:  MOVLW  05
1752A:  MOVLB  A
1752C:  MOVWF  x40
1752E:  MOVLB  0
17530:  CALL   1018
17534:  BTFSC  1B.7
17536:  BSF    FF2.7
17538:  MOVLW  09
1753A:  MOVWF  FE9
1753C:  CLRF   1B
1753E:  BTFSC  FF2.7
17540:  BSF    1B.7
17542:  BCF    FF2.7
17544:  MOVFF  88B,A41
17548:  MOVFF  88A,A40
1754C:  CALL   119A
17550:  BTFSC  1B.7
17552:  BSF    FF2.7
17554:  MOVLW  0D
17556:  BTFSS  F9E.4
17558:  BRA    17556
1755A:  MOVWF  FAD
1755C:  MOVLW  0A
1755E:  BTFSS  F9E.4
17560:  BRA    1755E
17562:  MOVWF  FAD
....................          macro_cmd = master_macro_aws(count+1); 
17564:  MOVLW  01
17566:  MOVLB  8
17568:  ADDWF  x88,W
1756A:  MOVWF  x8A
1756C:  MOVLW  00
1756E:  ADDWFC x89,W
17570:  MOVWF  x8B
17572:  MOVWF  x8D
17574:  MOVFF  88A,88C
17578:  MOVLB  0
1757A:  CALL   16844
1757E:  MOVFF  01,885
....................          ++nv_sample;                     // increment sample number 
17582:  INCF   21,F
17584:  BTFSC  FD8.2
17586:  INCF   22,F
....................          write16(ADDR_SAMPLE, nv_sample); // records last sample 
17588:  MOVLW  16
1758A:  MOVLB  8
1758C:  MOVWF  xEE
1758E:  MOVFF  22,8F0
17592:  MOVFF  21,8EF
17596:  MOVLB  0
17598:  CALL   4FC8
....................          if(nv_sample==nv_max_samples ||macro_cmd == ';') break; 
1759C:  MOVF   27,W
1759E:  SUBWF  21,W
175A0:  BNZ   175A8
175A2:  MOVF   28,W
175A4:  SUBWF  22,W
175A6:  BZ    175B0
175A8:  MOVLB  8
175AA:  MOVF   x85,W
175AC:  SUBLW  3B
175AE:  BNZ   175B4
175B0:  MOVLB  8
175B2:  BRA    175BC
175B4:  INCF   x88,F
175B6:  BTFSC  FD8.2
175B8:  INCF   x89,F
175BA:  BRA    174FA
175BC:  MOVLB  0
....................       } 
....................    } 
....................     
....................    busy_clear(); 
175BE:  CALL   AEA4
175C2:  GOTO   175FE (RETURN)
.................... } 
....................  
.................... void commandR() 
.................... { 
....................    switch(nv_product){ 
175C6:  MOVF   2F,W
175C8:  MOVWF  00
175CA:  MOVF   30,W
175CC:  MOVWF  03
175CE:  BNZ   175D4
175D0:  MOVF   00,F
175D2:  BZ    175F4
175D4:  MOVF   03,W
175D6:  BNZ   175DE
175D8:  MOVLW  01
175DA:  SUBWF  00,W
175DC:  BZ    175F8
175DE:  MOVF   03,W
175E0:  BNZ   175E8
175E2:  MOVLW  03
175E4:  SUBWF  00,W
175E6:  BZ    175F8
175E8:  MOVF   03,W
175EA:  BNZ   175F2
175EC:  MOVLW  02
175EE:  SUBWF  00,W
175F0:  BZ    175FC
175F2:  BRA    175FE
....................       case ECO : commandRe(); 
175F4:  BRA    17360
....................          break; 
175F6:  BRA    175FE
....................       case WMS4 :  
....................       case WMS2 : commandRw(); 
175F8:  BRA    17442
....................          break; 
175FA:  BRA    175FE
....................       case AWS : commandRa(); 
175FC:  BRA    174A2
....................          break;          
....................    } 
175FE:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandSe() 
.................... { 
....................    busy_set(); 
17602:  CALL   29B4
....................     
....................    switch(arg){ 
17606:  MOVFF  48,00
1760A:  MOVF   49,W
1760C:  MOVWF  03
1760E:  BNZ   17616
17610:  MOVLW  01
17612:  SUBWF  00,W
17614:  BZ    17622
17616:  MOVF   03,W
17618:  BNZ   17620
1761A:  MOVLW  02
1761C:  SUBWF  00,W
1761E:  BZ    17666
17620:  BRA    17676
....................    case 1: 
....................    { 
....................       if(nv_det_type==1) 
17622:  DECFSZ 45,W
17624:  BRA    1763A
17626:  MOVF   46,F
17628:  BNZ   1763A
....................       { 
....................          get_det_read(FALSE,TRUE);    // don't store, do display 
1762A:  MOVLB  8
1762C:  CLRF   xC2
1762E:  MOVLW  01
17630:  MOVWF  xC3
17632:  MOVLB  0
17634:  CALL   13714
....................       } 
17638:  BRA    17664
....................       else if(nv_det_type==2 || nv_det_type==3) 
1763A:  MOVF   45,W
1763C:  SUBLW  02
1763E:  BNZ   17644
17640:  MOVF   46,F
17642:  BZ    1764E
17644:  MOVF   45,W
17646:  SUBLW  03
17648:  BNZ   17664
1764A:  MOVF   46,F
1764C:  BNZ   17664
....................       { 
....................          read_colorimeter(200,FALSE,TRUE,FALSE); 
1764E:  MOVLB  8
17650:  CLRF   xC3
17652:  MOVLW  C8
17654:  MOVWF  xC2
17656:  CLRF   xC4
17658:  MOVLW  01
1765A:  MOVWF  xC5
1765C:  CLRF   xC6
1765E:  MOVLB  0
17660:  CALL   10000
....................       } 
....................       break;                                                        //200 scans,don't store,display 
17664:  BRA    1767A
....................    } 
....................    case 2: probe_read(FALSE,TRUE); 
17666:  MOVLB  8
17668:  CLRF   xC2
1766A:  MOVLW  01
1766C:  MOVWF  xC3
1766E:  MOVLB  0
17670:  CALL   13A16
....................       break; 
17674:  BRA    1767A
....................    default: cmd_arg(); 
17676:  CALL   B2F2
....................       break; 
....................    } 
....................     
....................    busy_clear(); 
1767A:  CALL   AEA4
1767E:  GOTO   1772A (RETURN)
.................... } 
....................  
.................... void commandSw() 
.................... { 
....................    if (arg < 1025){ 
17682:  MOVF   4B,F
17684:  BNZ   176B6
17686:  MOVF   4A,F
17688:  BNZ   176B6
1768A:  MOVF   49,W
1768C:  SUBLW  04
1768E:  BNC   176B6
17690:  BNZ   17698
17692:  MOVF   48,W
17694:  SUBLW  00
17696:  BNC   176B6
....................       nv_sample = arg; 
17698:  MOVFF  49,22
1769C:  MOVFF  48,21
....................       write16(ADDR_SAMPLE, nv_sample); 
176A0:  MOVLW  16
176A2:  MOVLB  8
176A4:  MOVWF  xEE
176A6:  MOVFF  22,8F0
176AA:  MOVFF  21,8EF
176AE:  MOVLB  0
176B0:  CALL   4FC8
....................    } 
176B4:  BRA    176BA
....................    else cmd_arg(); 
176B6:  CALL   B2F2
176BA:  GOTO   1772A (RETURN)
.................... } 
....................  
.................... void commandSa() 
.................... { 
....................    int16 setting; 
....................     
....................    if (arg < 259){ 
176BE:  MOVF   4B,F
176C0:  BNZ   176EA
176C2:  MOVF   4A,F
176C4:  BNZ   176EA
176C6:  MOVF   49,W
176C8:  SUBLW  01
176CA:  BNC   176EA
176CC:  BNZ   176D4
176CE:  MOVF   48,W
176D0:  SUBLW  02
176D2:  BNC   176EA
....................       setting = arg; 
176D4:  MOVFF  49,886
176D8:  MOVFF  48,885
....................       sol_switch_cmd(setting); 
176DC:  MOVFF  886,8B7
176E0:  MOVFF  885,8B6
176E4:  CALL   1449C
....................    } 
176E8:  BRA    176EE
....................    else cmd_arg(); 
176EA:  CALL   B2F2
176EE:  GOTO   1772A (RETURN)
.................... } 
....................  
.................... void commandS() 
.................... { 
....................    switch(nv_product){ 
176F2:  MOVF   2F,W
176F4:  MOVWF  00
176F6:  MOVF   30,W
176F8:  MOVWF  03
176FA:  BNZ   17700
176FC:  MOVF   00,F
176FE:  BZ    17720
17700:  MOVF   03,W
17702:  BNZ   1770A
17704:  MOVLW  01
17706:  SUBWF  00,W
17708:  BZ    17724
1770A:  MOVF   03,W
1770C:  BNZ   17714
1770E:  MOVLW  03
17710:  SUBWF  00,W
17712:  BZ    17724
17714:  MOVF   03,W
17716:  BNZ   1771E
17718:  MOVLW  02
1771A:  SUBWF  00,W
1771C:  BZ    17728
1771E:  BRA    1772A
....................       case ECO : commandSe(); 
17720:  BRA    17602
....................          break; 
17722:  BRA    1772A
....................       case WMS4 :  
....................       case WMS2 : commandSw(); 
17724:  BRA    17682
....................          break; 
17726:  BRA    1772A
....................       case AWS : commandSa(); 
17728:  BRA    176BE
....................          break;          
....................    } 
1772A:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandT() 
.................... {   
....................    fprintf(COM_A, "Enter date format 0=MM/DD/YY  1=DD/MM/YY\r\n"); 
*
17C90:  MOVLW  CA
17C92:  MOVWF  FF6
17C94:  MOVLW  26
17C96:  MOVWF  FF7
17C98:  MOVLW  00
17C9A:  MOVWF  FF8
17C9C:  CLRF   1B
17C9E:  BTFSC  FF2.7
17CA0:  BSF    1B.7
17CA2:  BCF    FF2.7
17CA4:  CALL   0E42
17CA8:  BTFSC  1B.7
17CAA:  BSF    FF2.7
....................    fputc('>',COM_A); 
17CAC:  MOVLW  3E
17CAE:  CALL   AEAC
....................    RTCfmt=fgetc(COM_A); 
17CB2:  CALL   0E2C
17CB6:  MOVFF  01,4F
....................    if (com_echo == TRUE) 
17CBA:  DECFSZ 4C,W
17CBC:  BRA    17CC4
....................       { 
....................       fputc(RTCfmt,COM_A); 
17CBE:  MOVF   4F,W
17CC0:  CALL   AEAC
....................       } 
....................    RTCfmt = RTCfmt - 48; // CONVERT ASCII TO INT    
17CC4:  MOVLW  30
17CC6:  SUBWF  4F,F
....................    if( (RTCfmt >= 0) && (RTCfmt < 2) ) 
17CC8:  MOVF   4F,W
17CCA:  SUBLW  01
17CCC:  BNC   17D02
....................       { 
....................        fputs("@OK!\r\n ", COM_A); 
17CCE:  MOVLW  F6
17CD0:  MOVWF  FF6
17CD2:  MOVLW  26
17CD4:  MOVWF  FF7
17CD6:  MOVLW  00
17CD8:  MOVWF  FF8
17CDA:  CALL   AE7A
17CDE:  MOVLW  0D
17CE0:  BTFSS  F9E.4
17CE2:  BRA    17CE0
17CE4:  MOVWF  FAD
17CE6:  MOVLW  0A
17CE8:  BTFSS  F9E.4
17CEA:  BRA    17CE8
17CEC:  MOVWF  FAD
....................        write16(ADDR_RTCfmt, RTCfmt); 
17CEE:  MOVLW  1A
17CF0:  MOVLB  8
17CF2:  MOVWF  xEE
17CF4:  CLRF   xF0
17CF6:  MOVFF  4F,8EF
17CFA:  MOVLB  0
17CFC:  CALL   4FC8
....................       }  
17D00:  BRA    17D06
....................    else cmd_arg(); 
17D02:  CALL   B2F2
....................     
....................    if(arg == 1) 
17D06:  DECFSZ 48,W
17D08:  BRA    17D1A
17D0A:  MOVF   49,F
17D0C:  BNZ   17D1A
17D0E:  MOVF   4A,F
17D10:  BNZ   17D1A
17D12:  MOVF   4B,F
17D14:  BNZ   17D1A
....................    { 
....................       RTC_Set(); 
17D16:  BRA    17B46
....................    } 
17D18:  BRA    17D1E
....................    else cmd_arg(); 
17D1A:  CALL   B2F2
17D1E:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandU() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
18698:  MOVF   4B,F
1869A:  BNZ   186B6
1869C:  MOVF   4A,F
1869E:  BNZ   186B6
186A0:  MOVF   49,F
186A2:  BNZ   186B6
186A4:  MOVF   48,W
186A6:  SUBLW  14
186A8:  BNC   186B6
....................       macro = arg; 
186AA:  MOVFF  48,885
....................       upload_macro(macro);    
186AE:  MOVFF  885,886
186B2:  BRA    183E6
....................    }    
186B4:  BRA    186D2
....................    else if (arg == 5525){ 
186B6:  MOVF   48,W
186B8:  SUBLW  95
186BA:  BNZ   186CE
186BC:  MOVF   49,W
186BE:  SUBLW  15
186C0:  BNZ   186CE
186C2:  MOVF   4A,F
186C4:  BNZ   186CE
186C6:  MOVF   4B,F
186C8:  BNZ   186CE
....................       write_blank_macros(); 
186CA:  BRA    1851C
....................    } 
186CC:  BRA    186D2
....................    else cmd_arg(); 
186CE:  CALL   B2F2
186D2:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandV() 
.................... { 
....................    int8 macro; 
....................     
....................    if(arg < 21) { 
*
187F0:  MOVF   4B,F
187F2:  BNZ   1880E
187F4:  MOVF   4A,F
187F6:  BNZ   1880E
187F8:  MOVF   49,F
187FA:  BNZ   1880E
187FC:  MOVF   48,W
187FE:  SUBLW  14
18800:  BNC   1880E
....................       macro = arg;  
18802:  MOVFF  48,885
....................       read_macro(macro); 
18806:  MOVFF  885,886
1880A:  BRA    1878A
....................    }    
1880C:  BRA    18812
....................    else cmd_arg(); 
1880E:  CALL   B2F2
18812:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandW() 
.................... { 
....................    if (arg == 1){ 
*
18964:  DECFSZ 48,W
18966:  BRA    18980
18968:  MOVF   49,F
1896A:  BNZ   18980
1896C:  MOVF   4A,F
1896E:  BNZ   18980
18970:  MOVF   4B,F
18972:  BNZ   18980
....................       //fprintf(COM_A,"1\r\n"); 
....................       RTC_alarm(); 
18974:  BRA    18816
....................       //fprintf(COM_A,"2\r\n"); 
....................       RTC_late(); 
18976:  CALL   15766
....................       //fprintf(COM_A,"3\r\n"); 
....................       RTC_alarm_status(); 
1897A:  CALL   15C2C
....................       //fprintf(COM_A,"4\r\n"); 
....................    } 
1897E:  BRA    18984
....................    else cmd_arg(); 
18980:  CALL   B2F2
18984:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandX() 
.................... { 
....................    switch(arg){ 
18988:  MOVF   48,W
1898A:  MOVWF  00
1898C:  MOVF   49,W
1898E:  MOVWF  03
18990:  BNZ   18996
18992:  MOVF   00,F
18994:  BZ    189CA
18996:  MOVF   03,W
18998:  BNZ   189A0
1899A:  MOVLW  02
1899C:  SUBWF  00,W
1899E:  BZ    189CA
189A0:  MOVF   03,W
189A2:  BNZ   189AA
189A4:  MOVLW  03
189A6:  SUBWF  00,W
189A8:  BZ    189CA
189AA:  MOVF   03,W
189AC:  BNZ   189B4
189AE:  MOVLW  04
189B0:  SUBWF  00,W
189B2:  BZ    189CA
189B4:  MOVF   03,W
189B6:  BNZ   189BE
189B8:  MOVLW  05
189BA:  SUBWF  00,W
189BC:  BZ    189CA
189BE:  MOVF   03,W
189C0:  BNZ   189C8
189C2:  MOVLW  06
189C4:  SUBWF  00,W
189C6:  BZ    189CA
189C8:  BRA    189E8
....................       case 0: 
....................       case 2: 
....................       case 3: 
....................       case 4:   
....................       case 5:  
....................       case 6: 
....................               nv_report_mode = arg; 
189CA:  MOVFF  49,20
189CE:  MOVFF  48,1F
....................               write16(ADDR_REPORT_MODE, nv_report_mode);  
189D2:  MOVLW  1C
189D4:  MOVLB  8
189D6:  MOVWF  xEE
189D8:  MOVFF  20,8F0
189DC:  MOVFF  1F,8EF
189E0:  MOVLB  0
189E2:  CALL   4FC8
....................          break; 
189E6:  BRA    189EC
....................       default: cmd_arg(); 
189E8:  CALL   B2F2
....................          break; 
....................    } 
189EC:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void display_status(int8 status) 
.................... { 
....................    switch(status){ 
....................       case 0: fprintf(COM_A, "@ERR\r\n"); 
....................          break; 
....................       case 1: fprintf(COM_A, "@RUN\r\n"); 
....................          break; 
....................    } 
.................... } 
....................  
.................... void commandY() 
.................... { 
....................    busy_set(); 
189F0:  CALL   29B4
....................     
....................    switch(arg){ 
189F4:  MOVFF  48,00
189F8:  MOVF   49,W
189FA:  MOVWF  03
189FC:  BNZ   18A02
189FE:  MOVF   00,F
18A00:  BZ    18A86
18A02:  MOVF   03,W
18A04:  BNZ   18A0C
18A06:  MOVLW  0A
18A08:  SUBWF  00,W
18A0A:  BZ    18A86
18A0C:  MOVF   03,W
18A0E:  BNZ   18A16
18A10:  MOVLW  01
18A12:  SUBWF  00,W
18A14:  BZ    18A8E
18A16:  MOVF   03,W
18A18:  BNZ   18A20
18A1A:  MOVLW  0B
18A1C:  SUBWF  00,W
18A1E:  BZ    18A8E
18A20:  MOVF   03,W
18A22:  BNZ   18A2A
18A24:  MOVLW  14
18A26:  SUBWF  00,W
18A28:  BZ    18A98
18A2A:  MOVF   03,W
18A2C:  BNZ   18A34
18A2E:  MOVLW  15
18A30:  SUBWF  00,W
18A32:  BZ    18A9E
18A34:  MOVF   03,W
18A36:  BNZ   18A3E
18A38:  MOVLW  1E
18A3A:  SUBWF  00,W
18A3C:  BZ    18AA4
18A3E:  MOVF   03,W
18A40:  BNZ   18A48
18A42:  MOVLW  1F
18A44:  SUBWF  00,W
18A46:  BZ    18AAA
18A48:  MOVF   03,W
18A4A:  BNZ   18A52
18A4C:  MOVLW  28
18A4E:  SUBWF  00,W
18A50:  BZ    18AB0
18A52:  MOVF   03,W
18A54:  BNZ   18A5C
18A56:  MOVLW  29
18A58:  SUBWF  00,W
18A5A:  BZ    18AB6
18A5C:  MOVF   03,W
18A5E:  BNZ   18A66
18A60:  MOVLW  32
18A62:  SUBWF  00,W
18A64:  BZ    18ABC
18A66:  MOVF   03,W
18A68:  BNZ   18A70
18A6A:  MOVLW  33
18A6C:  SUBWF  00,W
18A6E:  BZ    18AC2
18A70:  MOVF   03,W
18A72:  BNZ   18A7A
18A74:  MOVLW  3C
18A76:  SUBWF  00,W
18A78:  BZ    18AC8
18A7A:  MOVF   03,W
18A7C:  BNZ   18A84
18A7E:  MOVLW  3D
18A80:  SUBWF  00,W
18A82:  BZ    18AD6
18A84:  BRA    18AE8
....................       case  0: // for backwards compatibility 
....................       case 10: output_bit(VDET,OFF); 
18A86:  BCF    F90.7
....................                bus_pwr_status=0; 
18A88:  MOVLB  4
18A8A:  CLRF   xB6
....................          break; 
18A8C:  BRA    18AEE
....................       case  1: // for backwards compatibility 
....................       case 11: output_bit(VDET,ON); 
18A8E:  BSF    F90.7
....................                bus_pwr_status=1; 
18A90:  MOVLW  01
18A92:  MOVLB  4
18A94:  MOVWF  xB6
....................          break; 
18A96:  BRA    18AEE
....................       case 20: output_bit(VMOT,OFF); 
18A98:  BCF    F8E.1
....................          break; 
18A9A:  MOVLB  4
18A9C:  BRA    18AEE
....................       case 21: output_bit(VMOT,ON); 
18A9E:  BSF    F8E.1
....................          break; 
18AA0:  MOVLB  4
18AA2:  BRA    18AEE
....................       case 30: output_bit(VENC1,OFF); 
18AA4:  BCF    F8E.6
....................          break; 
18AA6:  MOVLB  4
18AA8:  BRA    18AEE
....................       case 31: output_bit(VENC1,ON); 
18AAA:  BSF    F8E.6
....................          break; 
18AAC:  MOVLB  4
18AAE:  BRA    18AEE
....................       case 40: output_bit(VENC2,OFF); 
18AB0:  BCF    F8E.7
....................          break; 
18AB2:  MOVLB  4
18AB4:  BRA    18AEE
....................       case 41: output_bit(VENC2,ON); 
18AB6:  BSF    F8E.7
....................          break; 
18AB8:  MOVLB  4
18ABA:  BRA    18AEE
....................       case 50: output_bit(VHBRDG,OFF); 
18ABC:  BCF    F8E.2
....................          break; 
18ABE:  MOVLB  4
18AC0:  BRA    18AEE
....................       case 51: output_bit(VHBRDG,ON); 
18AC2:  BSF    F8E.2
....................          break;          
18AC4:  MOVLB  4
18AC6:  BRA    18AEE
....................       case 60: set_heaters(0); 
18AC8:  MOVLB  8
18ACA:  CLRF   xC5
18ACC:  MOVLB  0
18ACE:  CALL   126F4
....................          break; 
18AD2:  MOVLB  4
18AD4:  BRA    18AEE
....................       case 61: set_heaters(3); 
18AD6:  MOVLW  03
18AD8:  MOVLB  8
18ADA:  MOVWF  xC5
18ADC:  MOVLB  0
18ADE:  CALL   126F4
....................          break; 
18AE2:  MOVLB  4
18AE4:  BRA    18AEE
18AE6:  MOVLB  0
....................       default : cmd_arg(); 
18AE8:  CALL   B2F2
....................          break;          
18AEC:  MOVLB  4
....................    } 
....................     
....................    busy_clear(); 
18AEE:  MOVLB  0
18AF0:  CALL   AEA4
18AF4:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandZ() 
.................... { 
....................    if(arg == 0){ 
18AF8:  MOVF   48,F
18AFA:  BNZ   18B16
18AFC:  MOVF   49,F
18AFE:  BNZ   18B16
18B00:  MOVF   4A,F
18B02:  BNZ   18B16
18B04:  MOVF   4B,F
18B06:  BNZ   18B16
....................       motor_sleep_rdy(); 
18B08:  CALL   298C
....................       shutdown(); 
18B0C:  CALL   15C4E
....................       go_to_sleep(); 
18B10:  CALL   15EC8
....................    } 
18B14:  BRA    18B1A
....................    else cmd_arg(); 
18B16:  CALL   B2F2
18B1A:  RETURN 0
.................... } 
....................  
.................... void command_a() 
.................... { 
....................    if (arg==1) poll_enc(); 
*
18C48:  DECFSZ 48,W
18C4A:  BRA    18C5C
18C4C:  MOVF   49,F
18C4E:  BNZ   18C5C
18C50:  MOVF   4A,F
18C52:  BNZ   18C5C
18C54:  MOVF   4B,F
18C56:  BNZ   18C5C
18C58:  BRA    18B42
18C5A:  BRA    18C60
....................    else cmd_arg(); 
18C5C:  CALL   B2F2
18C60:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_b() // back-lash 
.................... { 
....................    if(arg < 10001) { 
18C64:  MOVF   4B,F
18C66:  BNZ   18CF6
18C68:  MOVF   4A,F
18C6A:  BNZ   18CF6
18C6C:  MOVF   49,W
18C6E:  SUBLW  27
18C70:  BNC   18CF6
18C72:  BNZ   18C7A
18C74:  MOVF   48,W
18C76:  SUBLW  10
18C78:  BNC   18CF6
....................       m_bklsh[motor] = arg; 
18C7A:  BCF    FD8.0
18C7C:  MOVLB  7
18C7E:  RLCF   x40,W
18C80:  CLRF   03
18C82:  ADDLW  72
18C84:  MOVWF  FE9
18C86:  MOVLW  07
18C88:  ADDWFC 03,W
18C8A:  MOVWF  FEA
18C8C:  MOVFF  48,FEF
18C90:  MOVFF  49,FEC
....................       switch(motor){ 
18C94:  MOVF   x40,W
18C96:  XORLW  00
18C98:  MOVLB  0
18C9A:  BZ    18CA2
18C9C:  XORLW  01
18C9E:  BZ    18CCC
18CA0:  BRA    18CF4
....................          case 0 : write16(ADDR_M1_BKLSH, m_bklsh[motor]); 
18CA2:  BCF    FD8.0
18CA4:  MOVLB  7
18CA6:  RLCF   x40,W
18CA8:  CLRF   03
18CAA:  ADDLW  72
18CAC:  MOVWF  FE9
18CAE:  MOVLW  07
18CB0:  ADDWFC 03,W
18CB2:  MOVWF  FEA
18CB4:  MOVFF  FEC,8F0
18CB8:  MOVF   FED,F
18CBA:  MOVFF  FEF,8EF
18CBE:  MOVLW  72
18CC0:  MOVLB  8
18CC2:  MOVWF  xEE
18CC4:  MOVLB  0
18CC6:  CALL   4FC8
....................             break; 
18CCA:  BRA    18CF4
....................          case 1 : write16(ADDR_M2_BKLSH, m_bklsh[motor]); 
18CCC:  BCF    FD8.0
18CCE:  MOVLB  7
18CD0:  RLCF   x40,W
18CD2:  CLRF   03
18CD4:  ADDLW  72
18CD6:  MOVWF  FE9
18CD8:  MOVLW  07
18CDA:  ADDWFC 03,W
18CDC:  MOVWF  FEA
18CDE:  MOVFF  FEC,8F0
18CE2:  MOVF   FED,F
18CE4:  MOVFF  FEF,8EF
18CE8:  MOVLW  74
18CEA:  MOVLB  8
18CEC:  MOVWF  xEE
18CEE:  MOVLB  0
18CF0:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
18CF4:  BRA    18CFA
....................    else cmd_arg();    
18CF6:  CALL   B2F2
18CFA:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... //Turn individual dio pins on and off 
.................... void command_c(){ 
....................    if(arg == 0){ 
18CFE:  MOVF   48,F
18D00:  BNZ   18D12
18D02:  MOVF   49,F
18D04:  BNZ   18D12
18D06:  MOVF   4A,F
18D08:  BNZ   18D12
18D0A:  MOVF   4B,F
18D0C:  BNZ   18D12
....................       output_bit(PIN_J7,0); 
18D0E:  BCF    F91.7
....................    }else if(arg == 1){ 
18D10:  BRA    18D42
18D12:  DECFSZ 48,W
18D14:  BRA    18D26
18D16:  MOVF   49,F
18D18:  BNZ   18D26
18D1A:  MOVF   4A,F
18D1C:  BNZ   18D26
18D1E:  MOVF   4B,F
18D20:  BNZ   18D26
....................       output_bit(PIN_J7,1); 
18D22:  BSF    F91.7
....................    }else{ 
18D24:  BRA    18D42
....................       RTC_reset_HT(); 
18D26:  CALL   34A6
....................       output_bit(RTC_CS, ENABLE); 
18D2A:  BCF    F91.0
....................       spi_write(0x89); 
18D2C:  MOVF   FC9,W
18D2E:  MOVLW  89
18D30:  MOVWF  FC9
18D32:  RRCF   FC7,W
18D34:  BNC   18D32
....................       spi_write(arg); 
18D36:  MOVF   FC9,W
18D38:  MOVFF  48,FC9
18D3C:  RRCF   FC7,W
18D3E:  BNC   18D3C
....................       output_bit(RTC_CS, DISABLE); 
18D40:  BSF    F91.0
....................    } 
18D42:  GOTO   1B218 (RETURN)
.................... } 
.................... void command_d() // positive direction 
.................... { 
....................    if(arg < 2) { 
18D46:  MOVF   4B,F
18D48:  BNZ   18DD4
18D4A:  MOVF   4A,F
18D4C:  BNZ   18DD4
18D4E:  MOVF   49,F
18D50:  BNZ   18DD4
18D52:  MOVF   48,W
18D54:  SUBLW  01
18D56:  BNC   18DD4
....................       m_pos_dir[motor] = arg; 
18D58:  BCF    FD8.0
18D5A:  MOVLB  7
18D5C:  RLCF   x40,W
18D5E:  CLRF   03
18D60:  ADDLW  4E
18D62:  MOVWF  FE9
18D64:  MOVLW  07
18D66:  ADDWFC 03,W
18D68:  MOVWF  FEA
18D6A:  MOVFF  48,FEF
18D6E:  MOVFF  49,FEC
....................       switch(motor){ 
18D72:  MOVF   x40,W
18D74:  XORLW  00
18D76:  MOVLB  0
18D78:  BZ    18D80
18D7A:  XORLW  01
18D7C:  BZ    18DAA
18D7E:  BRA    18DD2
....................          case 0 : write16(ADDR_M1_POS_DIR, m_pos_dir[motor]); 
18D80:  BCF    FD8.0
18D82:  MOVLB  7
18D84:  RLCF   x40,W
18D86:  CLRF   03
18D88:  ADDLW  4E
18D8A:  MOVWF  FE9
18D8C:  MOVLW  07
18D8E:  ADDWFC 03,W
18D90:  MOVWF  FEA
18D92:  MOVFF  FEC,8F0
18D96:  MOVF   FED,F
18D98:  MOVFF  FEF,8EF
18D9C:  MOVLW  92
18D9E:  MOVLB  8
18DA0:  MOVWF  xEE
18DA2:  MOVLB  0
18DA4:  CALL   4FC8
....................             break; 
18DA8:  BRA    18DD2
....................          case 1 : write16(ADDR_M2_POS_DIR, m_pos_dir[motor]); 
18DAA:  BCF    FD8.0
18DAC:  MOVLB  7
18DAE:  RLCF   x40,W
18DB0:  CLRF   03
18DB2:  ADDLW  4E
18DB4:  MOVWF  FE9
18DB6:  MOVLW  07
18DB8:  ADDWFC 03,W
18DBA:  MOVWF  FEA
18DBC:  MOVFF  FEC,8F0
18DC0:  MOVF   FED,F
18DC2:  MOVFF  FEF,8EF
18DC6:  MOVLW  94
18DC8:  MOVLB  8
18DCA:  MOVWF  xEE
18DCC:  MOVLB  0
18DCE:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
18DD2:  BRA    18DD8
....................    else cmd_arg();    
18DD4:  CALL   B2F2
18DD8:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_e() // encoder cpr 
.................... { 
....................    if(arg < 10001) { 
18DDC:  MOVF   4B,F
18DDE:  BNZ   18E6E
18DE0:  MOVF   4A,F
18DE2:  BNZ   18E6E
18DE4:  MOVF   49,W
18DE6:  SUBLW  27
18DE8:  BNC   18E6E
18DEA:  BNZ   18DF2
18DEC:  MOVF   48,W
18DEE:  SUBLW  10
18DF0:  BNC   18E6E
....................       e_cpr[motor] = arg; 
18DF2:  BCF    FD8.0
18DF4:  MOVLB  7
18DF6:  RLCF   x40,W
18DF8:  CLRF   03
18DFA:  ADDLW  5E
18DFC:  MOVWF  FE9
18DFE:  MOVLW  07
18E00:  ADDWFC 03,W
18E02:  MOVWF  FEA
18E04:  MOVFF  48,FEF
18E08:  MOVFF  49,FEC
....................       switch(motor){ 
18E0C:  MOVF   x40,W
18E0E:  XORLW  00
18E10:  MOVLB  0
18E12:  BZ    18E1A
18E14:  XORLW  01
18E16:  BZ    18E44
18E18:  BRA    18E6C
....................          case 0 : write16(ADDR_E1_CPR, e_cpr[motor]); 
18E1A:  BCF    FD8.0
18E1C:  MOVLB  7
18E1E:  RLCF   x40,W
18E20:  CLRF   03
18E22:  ADDLW  5E
18E24:  MOVWF  FE9
18E26:  MOVLW  07
18E28:  ADDWFC 03,W
18E2A:  MOVWF  FEA
18E2C:  MOVFF  FEC,8F0
18E30:  MOVF   FED,F
18E32:  MOVFF  FEF,8EF
18E36:  MOVLW  A2
18E38:  MOVLB  8
18E3A:  MOVWF  xEE
18E3C:  MOVLB  0
18E3E:  CALL   4FC8
....................             break; 
18E42:  BRA    18E6C
....................          case 1 : write16(ADDR_E2_CPR, e_cpr[motor]); 
18E44:  BCF    FD8.0
18E46:  MOVLB  7
18E48:  RLCF   x40,W
18E4A:  CLRF   03
18E4C:  ADDLW  5E
18E4E:  MOVWF  FE9
18E50:  MOVLW  07
18E52:  ADDWFC 03,W
18E54:  MOVWF  FEA
18E56:  MOVFF  FEC,8F0
18E5A:  MOVF   FED,F
18E5C:  MOVFF  FEF,8EF
18E60:  MOVLW  A4
18E62:  MOVLB  8
18E64:  MOVWF  xEE
18E66:  MOVLB  0
18E68:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
18E6C:  BRA    18E72
....................    else cmd_arg();    
18E6E:  CALL   B2F2
18E72:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_f() 
.................... { 
....................    if(arg < 2) m_fixed=arg; 
18E76:  MOVF   4B,F
18E78:  BNZ   18E8E
18E7A:  MOVF   4A,F
18E7C:  BNZ   18E8E
18E7E:  MOVF   49,F
18E80:  BNZ   18E8E
18E82:  MOVF   48,W
18E84:  SUBLW  01
18E86:  BNC   18E8E
18E88:  MOVFF  48,741
18E8C:  BRA    18E92
....................    else cmd_arg();    
18E8E:  CALL   B2F2
18E92:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_g() // gearbox error 
.................... { 
....................    if(arg < 60001) { 
18E96:  MOVF   4B,F
18E98:  BNZ   18F28
18E9A:  MOVF   4A,F
18E9C:  BNZ   18F28
18E9E:  MOVF   49,W
18EA0:  SUBLW  EA
18EA2:  BNC   18F28
18EA4:  BNZ   18EAC
18EA6:  MOVF   48,W
18EA8:  SUBLW  60
18EAA:  BNC   18F28
....................       m_gb_err[motor] = arg; 
18EAC:  BCF    FD8.0
18EAE:  MOVLB  7
18EB0:  RLCF   x40,W
18EB2:  CLRF   03
18EB4:  ADDLW  5A
18EB6:  MOVWF  FE9
18EB8:  MOVLW  07
18EBA:  ADDWFC 03,W
18EBC:  MOVWF  FEA
18EBE:  MOVFF  48,FEF
18EC2:  MOVFF  49,FEC
....................       switch(motor){ 
18EC6:  MOVF   x40,W
18EC8:  XORLW  00
18ECA:  MOVLB  0
18ECC:  BZ    18ED4
18ECE:  XORLW  01
18ED0:  BZ    18EFE
18ED2:  BRA    18F26
....................          case 0 : write16(ADDR_M1_GB_ERR, m_gb_err[motor]); 
18ED4:  BCF    FD8.0
18ED6:  MOVLB  7
18ED8:  RLCF   x40,W
18EDA:  CLRF   03
18EDC:  ADDLW  5A
18EDE:  MOVWF  FE9
18EE0:  MOVLW  07
18EE2:  ADDWFC 03,W
18EE4:  MOVWF  FEA
18EE6:  MOVFF  FEC,8F0
18EEA:  MOVF   FED,F
18EEC:  MOVFF  FEF,8EF
18EF0:  MOVLW  9E
18EF2:  MOVLB  8
18EF4:  MOVWF  xEE
18EF6:  MOVLB  0
18EF8:  CALL   4FC8
....................             break; 
18EFC:  BRA    18F26
....................          case 1 : write16(ADDR_M2_GB_ERR, m_gb_err[motor]); 
18EFE:  BCF    FD8.0
18F00:  MOVLB  7
18F02:  RLCF   x40,W
18F04:  CLRF   03
18F06:  ADDLW  5A
18F08:  MOVWF  FE9
18F0A:  MOVLW  07
18F0C:  ADDWFC 03,W
18F0E:  MOVWF  FEA
18F10:  MOVFF  FEC,8F0
18F14:  MOVF   FED,F
18F16:  MOVFF  FEF,8EF
18F1A:  MOVLW  A0
18F1C:  MOVLB  8
18F1E:  MOVWF  xEE
18F20:  MOVLB  0
18F22:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
18F26:  BRA    18F2C
....................    else cmd_arg();    
18F28:  CALL   B2F2
18F2C:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_h() // hold current 
.................... { 
....................    int16 hold_pc; 
....................    if(arg < 101) { 
18F30:  MOVF   4B,F
18F32:  BNZ   18FFC
18F34:  MOVF   4A,F
18F36:  BNZ   18FFC
18F38:  MOVF   49,F
18F3A:  BNZ   18FFC
18F3C:  MOVF   48,W
18F3E:  SUBLW  64
18F40:  BNC   18FFC
....................       hold_pc=arg; 
18F42:  MOVFF  49,886
18F46:  MOVFF  48,885
....................       m_pwm_hld[motor] = (hold_pc*(((T2_MID_VAL+1)*4)-1))/100; 
18F4A:  BCF    FD8.0
18F4C:  MOVLB  7
18F4E:  RLCF   x40,W
18F50:  CLRF   03
18F52:  ADDLW  52
18F54:  MOVWF  FE9
18F56:  MOVLW  07
18F58:  ADDWFC 03,W
18F5A:  MOVWF  FEA
18F5C:  MOVFF  886,A11
18F60:  MOVFF  885,A10
18F64:  MOVLW  01
18F66:  MOVLB  A
18F68:  MOVWF  x13
18F6A:  SETF   x12
18F6C:  MOVLB  0
18F6E:  CALL   5C8C
18F72:  MOVFF  02,88A
18F76:  MOVFF  01,889
18F7A:  MOVFF  02,8DC
18F7E:  MOVFF  01,8DB
18F82:  MOVLB  8
18F84:  CLRF   xDE
18F86:  MOVLW  64
18F88:  MOVWF  xDD
18F8A:  MOVLB  0
18F8C:  CALL   2CC8
18F90:  MOVFF  01,FEF
18F94:  MOVFF  02,FEC
....................       switch(motor){ 
18F98:  MOVLB  7
18F9A:  MOVF   x40,W
18F9C:  XORLW  00
18F9E:  MOVLB  0
18FA0:  BZ    18FA8
18FA2:  XORLW  01
18FA4:  BZ    18FD2
18FA6:  BRA    18FFA
....................          case 0 : write16(ADDR_M1_PWM_HLD, m_pwm_hld[motor]); 
18FA8:  BCF    FD8.0
18FAA:  MOVLB  7
18FAC:  RLCF   x40,W
18FAE:  CLRF   03
18FB0:  ADDLW  52
18FB2:  MOVWF  FE9
18FB4:  MOVLW  07
18FB6:  ADDWFC 03,W
18FB8:  MOVWF  FEA
18FBA:  MOVFF  FEC,8F0
18FBE:  MOVF   FED,F
18FC0:  MOVFF  FEF,8EF
18FC4:  MOVLW  96
18FC6:  MOVLB  8
18FC8:  MOVWF  xEE
18FCA:  MOVLB  0
18FCC:  CALL   4FC8
....................             break; 
18FD0:  BRA    18FFA
....................          case 1 : write16(ADDR_M2_PWM_HLD, m_pwm_hld[motor]); 
18FD2:  BCF    FD8.0
18FD4:  MOVLB  7
18FD6:  RLCF   x40,W
18FD8:  CLRF   03
18FDA:  ADDLW  52
18FDC:  MOVWF  FE9
18FDE:  MOVLW  07
18FE0:  ADDWFC 03,W
18FE2:  MOVWF  FEA
18FE4:  MOVFF  FEC,8F0
18FE8:  MOVF   FED,F
18FEA:  MOVFF  FEF,8EF
18FEE:  MOVLW  98
18FF0:  MOVLB  8
18FF2:  MOVWF  xEE
18FF4:  MOVLB  0
18FF6:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
18FFA:  BRA    19000
....................    else cmd_arg();    
18FFC:  CALL   B2F2
19000:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_i() // step interval 
.................... { 
....................    if(arg < 60001) { 
19004:  MOVF   4B,F
19006:  BNZ   190D8
19008:  MOVF   4A,F
1900A:  BNZ   190D8
1900C:  MOVF   49,W
1900E:  SUBLW  EA
19010:  BNC   190D8
19012:  BNZ   1901A
19014:  MOVF   48,W
19016:  SUBLW  60
19018:  BNC   190D8
....................       m_stp_int[motor] = (arg/100); 
1901A:  BCF    FD8.0
1901C:  MOVLB  7
1901E:  RLCF   x40,W
19020:  CLRF   03
19022:  ADDLW  4A
19024:  MOVWF  FE9
19026:  MOVLW  07
19028:  ADDWFC 03,W
1902A:  MOVWF  FEA
1902C:  MOVFF  FEA,888
19030:  MOVFF  FE9,887
19034:  BCF    FD8.1
19036:  CLRF   1B
19038:  BTFSC  FF2.7
1903A:  BSF    1B.7
1903C:  BCF    FF2.7
1903E:  MOVFF  4B,A4F
19042:  MOVFF  4A,A4E
19046:  MOVFF  49,A4D
1904A:  MOVFF  48,A4C
1904E:  MOVLB  A
19050:  CLRF   x53
19052:  CLRF   x52
19054:  CLRF   x51
19056:  MOVLW  64
19058:  MOVWF  x50
1905A:  MOVLB  0
1905C:  CALL   104A
19060:  BTFSC  1B.7
19062:  BSF    FF2.7
19064:  MOVFF  888,FEA
19068:  MOVFF  887,FE9
1906C:  MOVFF  00,FEF
19070:  MOVFF  01,FEC
....................       switch(motor){ 
19074:  MOVLB  7
19076:  MOVF   x40,W
19078:  XORLW  00
1907A:  MOVLB  0
1907C:  BZ    19084
1907E:  XORLW  01
19080:  BZ    190AE
19082:  BRA    190D6
....................          case 0 : write16(ADDR_M1_STP_INT, m_stp_int[motor]); 
19084:  BCF    FD8.0
19086:  MOVLB  7
19088:  RLCF   x40,W
1908A:  CLRF   03
1908C:  ADDLW  4A
1908E:  MOVWF  FE9
19090:  MOVLW  07
19092:  ADDWFC 03,W
19094:  MOVWF  FEA
19096:  MOVFF  FEC,8F0
1909A:  MOVF   FED,F
1909C:  MOVFF  FEF,8EF
190A0:  MOVLW  8E
190A2:  MOVLB  8
190A4:  MOVWF  xEE
190A6:  MOVLB  0
190A8:  CALL   4FC8
....................             break; 
190AC:  BRA    190D6
....................          case 1 : write16(ADDR_M2_STP_INT, m_stp_int[motor]); 
190AE:  BCF    FD8.0
190B0:  MOVLB  7
190B2:  RLCF   x40,W
190B4:  CLRF   03
190B6:  ADDLW  4A
190B8:  MOVWF  FE9
190BA:  MOVLW  07
190BC:  ADDWFC 03,W
190BE:  MOVWF  FEA
190C0:  MOVFF  FEC,8F0
190C4:  MOVF   FED,F
190C6:  MOVFF  FEF,8EF
190CA:  MOVLW  90
190CC:  MOVLB  8
190CE:  MOVWF  xEE
190D0:  MOVLB  0
190D2:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
190D6:  BRA    190DC
....................    else cmd_arg();    
190D8:  CALL   B2F2
190DC:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_j() // step interval 
.................... { 
....................    if(arg < 10001) { 
190E0:  MOVF   4B,F
190E2:  BNZ   19172
190E4:  MOVF   4A,F
190E6:  BNZ   19172
190E8:  MOVF   49,W
190EA:  SUBLW  27
190EC:  BNC   19172
190EE:  BNZ   190F6
190F0:  MOVF   48,W
190F2:  SUBLW  10
190F4:  BNC   19172
....................       m_run[motor] = arg; 
190F6:  BCF    FD8.0
190F8:  MOVLB  7
190FA:  RLCF   x40,W
190FC:  CLRF   03
190FE:  ADDLW  6E
19100:  MOVWF  FE9
19102:  MOVLW  07
19104:  ADDWFC 03,W
19106:  MOVWF  FEA
19108:  MOVFF  48,FEF
1910C:  MOVFF  49,FEC
....................       switch(motor){ 
19110:  MOVF   x40,W
19112:  XORLW  00
19114:  MOVLB  0
19116:  BZ    1911E
19118:  XORLW  01
1911A:  BZ    19148
1911C:  BRA    19170
....................          case 0 : write16(ADDR_M1_RUN, m_run[motor]); 
1911E:  BCF    FD8.0
19120:  MOVLB  7
19122:  RLCF   x40,W
19124:  CLRF   03
19126:  ADDLW  6E
19128:  MOVWF  FE9
1912A:  MOVLW  07
1912C:  ADDWFC 03,W
1912E:  MOVWF  FEA
19130:  MOVFF  FEC,8F0
19134:  MOVF   FED,F
19136:  MOVFF  FEF,8EF
1913A:  MOVLW  76
1913C:  MOVLB  8
1913E:  MOVWF  xEE
19140:  MOVLB  0
19142:  CALL   4FC8
....................             break; 
19146:  BRA    19170
....................          case 1 : write16(ADDR_M2_RUN, m_run[motor]); 
19148:  BCF    FD8.0
1914A:  MOVLB  7
1914C:  RLCF   x40,W
1914E:  CLRF   03
19150:  ADDLW  6E
19152:  MOVWF  FE9
19154:  MOVLW  07
19156:  ADDWFC 03,W
19158:  MOVWF  FEA
1915A:  MOVFF  FEC,8F0
1915E:  MOVF   FED,F
19160:  MOVFF  FEF,8EF
19164:  MOVLW  78
19166:  MOVLB  8
19168:  MOVWF  xEE
1916A:  MOVLB  0
1916C:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
19170:  BRA    19176
....................    else cmd_arg();    
19172:  CALL   B2F2
19176:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_k() // encoder mode  
.................... { 
....................    if(arg < 4) { 
1917A:  MOVF   4B,F
1917C:  BNZ   19208
1917E:  MOVF   4A,F
19180:  BNZ   19208
19182:  MOVF   49,F
19184:  BNZ   19208
19186:  MOVF   48,W
19188:  SUBLW  03
1918A:  BNC   19208
....................       e_mode[motor] = arg; 
1918C:  BCF    FD8.0
1918E:  MOVLB  7
19190:  RLCF   x40,W
19192:  CLRF   03
19194:  ADDLW  66
19196:  MOVWF  FE9
19198:  MOVLW  07
1919A:  ADDWFC 03,W
1919C:  MOVWF  FEA
1919E:  MOVFF  48,FEF
191A2:  MOVFF  49,FEC
....................       switch(motor){ 
191A6:  MOVF   x40,W
191A8:  XORLW  00
191AA:  MOVLB  0
191AC:  BZ    191B4
191AE:  XORLW  01
191B0:  BZ    191DE
191B2:  BRA    19206
....................          case 0 : write16(ADDR_E1_MODE, e_mode[motor]); 
191B4:  BCF    FD8.0
191B6:  MOVLB  7
191B8:  RLCF   x40,W
191BA:  CLRF   03
191BC:  ADDLW  66
191BE:  MOVWF  FE9
191C0:  MOVLW  07
191C2:  ADDWFC 03,W
191C4:  MOVWF  FEA
191C6:  MOVFF  FEC,8F0
191CA:  MOVF   FED,F
191CC:  MOVFF  FEF,8EF
191D0:  MOVLW  82
191D2:  MOVLB  8
191D4:  MOVWF  xEE
191D6:  MOVLB  0
191D8:  CALL   4FC8
....................             break; 
191DC:  BRA    19206
....................          case 1 : write16(ADDR_E2_MODE, e_mode[motor]); 
191DE:  BCF    FD8.0
191E0:  MOVLB  7
191E2:  RLCF   x40,W
191E4:  CLRF   03
191E6:  ADDLW  66
191E8:  MOVWF  FE9
191EA:  MOVLW  07
191EC:  ADDWFC 03,W
191EE:  MOVWF  FEA
191F0:  MOVFF  FEC,8F0
191F4:  MOVF   FED,F
191F6:  MOVFF  FEF,8EF
191FA:  MOVLW  84
191FC:  MOVLB  8
191FE:  MOVWF  xEE
19200:  MOVLB  0
19202:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
19206:  BRA    1920C
....................    else cmd_arg();    
19208:  CALL   B2F2
1920C:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... // "l" is used for "list" 
....................  
.................... void command_m() // step mode (full/half) 
.................... { 
....................    if(arg < 2) { 
*
19E70:  MOVF   4B,F
19E72:  BNZ   19EFE
19E74:  MOVF   4A,F
19E76:  BNZ   19EFE
19E78:  MOVF   49,F
19E7A:  BNZ   19EFE
19E7C:  MOVF   48,W
19E7E:  SUBLW  01
19E80:  BNC   19EFE
....................       m_mode[motor] = arg; 
19E82:  BCF    FD8.0
19E84:  MOVLB  7
19E86:  RLCF   x40,W
19E88:  CLRF   03
19E8A:  ADDLW  46
19E8C:  MOVWF  FE9
19E8E:  MOVLW  07
19E90:  ADDWFC 03,W
19E92:  MOVWF  FEA
19E94:  MOVFF  48,FEF
19E98:  MOVFF  49,FEC
....................       switch(motor){ 
19E9C:  MOVF   x40,W
19E9E:  XORLW  00
19EA0:  MOVLB  0
19EA2:  BZ    19EAA
19EA4:  XORLW  01
19EA6:  BZ    19ED4
19EA8:  BRA    19EFC
....................          case 0 : write16(ADDR_M1_MODE, m_mode[motor]); 
19EAA:  BCF    FD8.0
19EAC:  MOVLB  7
19EAE:  RLCF   x40,W
19EB0:  CLRF   03
19EB2:  ADDLW  46
19EB4:  MOVWF  FE9
19EB6:  MOVLW  07
19EB8:  ADDWFC 03,W
19EBA:  MOVWF  FEA
19EBC:  MOVFF  FEC,8F0
19EC0:  MOVF   FED,F
19EC2:  MOVFF  FEF,8EF
19EC6:  MOVLW  8A
19EC8:  MOVLB  8
19ECA:  MOVWF  xEE
19ECC:  MOVLB  0
19ECE:  CALL   4FC8
....................             break; 
19ED2:  BRA    19EFC
....................          case 1 : write16(ADDR_M2_MODE, m_mode[motor]); 
19ED4:  BCF    FD8.0
19ED6:  MOVLB  7
19ED8:  RLCF   x40,W
19EDA:  CLRF   03
19EDC:  ADDLW  46
19EDE:  MOVWF  FE9
19EE0:  MOVLW  07
19EE2:  ADDWFC 03,W
19EE4:  MOVWF  FEA
19EE6:  MOVFF  FEC,8F0
19EEA:  MOVF   FED,F
19EEC:  MOVFF  FEF,8EF
19EF0:  MOVLW  8C
19EF2:  MOVLB  8
19EF4:  MOVWF  xEE
19EF6:  MOVLB  0
19EF8:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
19EFC:  BRA    19F02
....................    else cmd_arg();    
19EFE:  CALL   B2F2
19F02:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_n() // index polarity 
.................... { 
....................    if(arg < 2) { 
19F06:  MOVF   4B,F
19F08:  BNZ   19F94
19F0A:  MOVF   4A,F
19F0C:  BNZ   19F94
19F0E:  MOVF   49,F
19F10:  BNZ   19F94
19F12:  MOVF   48,W
19F14:  SUBLW  01
19F16:  BNC   19F94
....................       e_index[motor] = arg; 
19F18:  BCF    FD8.0
19F1A:  MOVLB  7
19F1C:  RLCF   x40,W
19F1E:  CLRF   03
19F20:  ADDLW  7A
19F22:  MOVWF  FE9
19F24:  MOVLW  07
19F26:  ADDWFC 03,W
19F28:  MOVWF  FEA
19F2A:  MOVFF  48,FEF
19F2E:  MOVFF  49,FEC
....................       switch(motor){ 
19F32:  MOVF   x40,W
19F34:  XORLW  00
19F36:  MOVLB  0
19F38:  BZ    19F40
19F3A:  XORLW  01
19F3C:  BZ    19F6A
19F3E:  BRA    19F92
....................          case 0 : write16(ADDR_E1_INDEX, e_index[motor]); 
19F40:  BCF    FD8.0
19F42:  MOVLB  7
19F44:  RLCF   x40,W
19F46:  CLRF   03
19F48:  ADDLW  7A
19F4A:  MOVWF  FE9
19F4C:  MOVLW  07
19F4E:  ADDWFC 03,W
19F50:  MOVWF  FEA
19F52:  MOVFF  FEC,8F0
19F56:  MOVF   FED,F
19F58:  MOVFF  FEF,8EF
19F5C:  MOVLW  BA
19F5E:  MOVLB  8
19F60:  MOVWF  xEE
19F62:  MOVLB  0
19F64:  CALL   4FC8
....................             break; 
19F68:  BRA    19F92
....................          case 1 : write16(ADDR_E2_INDEX, e_index[motor]); 
19F6A:  BCF    FD8.0
19F6C:  MOVLB  7
19F6E:  RLCF   x40,W
19F70:  CLRF   03
19F72:  ADDLW  7A
19F74:  MOVWF  FE9
19F76:  MOVLW  07
19F78:  ADDWFC 03,W
19F7A:  MOVWF  FEA
19F7C:  MOVFF  FEC,8F0
19F80:  MOVF   FED,F
19F82:  MOVFF  FEF,8EF
19F86:  MOVLW  BC
19F88:  MOVLB  8
19F8A:  MOVWF  xEE
19F8C:  MOVLB  0
19F8E:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
19F92:  BRA    19F98
....................    else cmd_arg();    
19F94:  CALL   B2F2
19F98:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_o() // adjustment extra steps  
.................... { 
....................    if(arg < 267){  // max = 1 port of steps  
19F9C:  MOVF   4B,F
19F9E:  BNZ   1A02E
19FA0:  MOVF   4A,F
19FA2:  BNZ   1A02E
19FA4:  MOVF   49,W
19FA6:  SUBLW  01
19FA8:  BNC   1A02E
19FAA:  BNZ   19FB2
19FAC:  MOVF   48,W
19FAE:  SUBLW  0A
19FB0:  BNC   1A02E
....................        evn_so[motor] = arg; 
19FB2:  BCF    FD8.0
19FB4:  MOVLB  7
19FB6:  RLCF   x40,W
19FB8:  CLRF   03
19FBA:  ADDLW  7E
19FBC:  MOVWF  FE9
19FBE:  MOVLW  07
19FC0:  ADDWFC 03,W
19FC2:  MOVWF  FEA
19FC4:  MOVFF  48,FEF
19FC8:  MOVFF  49,FEC
....................        switch(motor){ 
19FCC:  MOVF   x40,W
19FCE:  XORLW  00
19FD0:  MOVLB  0
19FD2:  BZ    19FDA
19FD4:  XORLW  01
19FD6:  BZ    1A004
19FD8:  BRA    1A02C
....................          case 0 : write16(ADDR_M1_EVN_SO, evn_so[motor]); 
19FDA:  BCF    FD8.0
19FDC:  MOVLB  7
19FDE:  RLCF   x40,W
19FE0:  CLRF   03
19FE2:  ADDLW  7E
19FE4:  MOVWF  FE9
19FE6:  MOVLW  07
19FE8:  ADDWFC 03,W
19FEA:  MOVWF  FEA
19FEC:  MOVFF  FEC,8F0
19FF0:  MOVF   FED,F
19FF2:  MOVFF  FEF,8EF
19FF6:  MOVLW  BE
19FF8:  MOVLB  8
19FFA:  MOVWF  xEE
19FFC:  MOVLB  0
19FFE:  CALL   4FC8
....................             break; 
1A002:  BRA    1A02C
....................          case 1 : write16(ADDR_M2_EVN_SO, evn_so[motor]); 
1A004:  BCF    FD8.0
1A006:  MOVLB  7
1A008:  RLCF   x40,W
1A00A:  CLRF   03
1A00C:  ADDLW  7E
1A00E:  MOVWF  FE9
1A010:  MOVLW  07
1A012:  ADDWFC 03,W
1A014:  MOVWF  FEA
1A016:  MOVFF  FEC,8F0
1A01A:  MOVF   FED,F
1A01C:  MOVFF  FEF,8EF
1A020:  MOVLW  C0
1A022:  MOVLB  8
1A024:  MOVWF  xEE
1A026:  MOVLB  0
1A028:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
1A02C:  BRA    1A032
....................    else cmd_arg();    
1A02E:  CALL   B2F2
1A032:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_p() // encoder ports per rev (PPR) 
.................... { 
....................    if(arg < 1001){ 
1A036:  MOVF   4B,F
1A038:  BNZ   1A0C8
1A03A:  MOVF   4A,F
1A03C:  BNZ   1A0C8
1A03E:  MOVF   49,W
1A040:  SUBLW  03
1A042:  BNC   1A0C8
1A044:  BNZ   1A04C
1A046:  MOVF   48,W
1A048:  SUBLW  E8
1A04A:  BNC   1A0C8
....................       e_ppr[motor] = arg; 
1A04C:  BCF    FD8.0
1A04E:  MOVLB  7
1A050:  RLCF   x40,W
1A052:  CLRF   03
1A054:  ADDLW  62
1A056:  MOVWF  FE9
1A058:  MOVLW  07
1A05A:  ADDWFC 03,W
1A05C:  MOVWF  FEA
1A05E:  MOVFF  48,FEF
1A062:  MOVFF  49,FEC
....................       switch(motor){ 
1A066:  MOVF   x40,W
1A068:  XORLW  00
1A06A:  MOVLB  0
1A06C:  BZ    1A074
1A06E:  XORLW  01
1A070:  BZ    1A09E
1A072:  BRA    1A0C6
....................          case 0 : write16(ADDR_E1_PPR, e_ppr[motor]); 
1A074:  BCF    FD8.0
1A076:  MOVLB  7
1A078:  RLCF   x40,W
1A07A:  CLRF   03
1A07C:  ADDLW  62
1A07E:  MOVWF  FE9
1A080:  MOVLW  07
1A082:  ADDWFC 03,W
1A084:  MOVWF  FEA
1A086:  MOVFF  FEC,8F0
1A08A:  MOVF   FED,F
1A08C:  MOVFF  FEF,8EF
1A090:  MOVLW  A6
1A092:  MOVLB  8
1A094:  MOVWF  xEE
1A096:  MOVLB  0
1A098:  CALL   4FC8
....................             break; 
1A09C:  BRA    1A0C6
....................          case 1 : write16(ADDR_E2_PPR, e_ppr[motor]); 
1A09E:  BCF    FD8.0
1A0A0:  MOVLB  7
1A0A2:  RLCF   x40,W
1A0A4:  CLRF   03
1A0A6:  ADDLW  62
1A0A8:  MOVWF  FE9
1A0AA:  MOVLW  07
1A0AC:  ADDWFC 03,W
1A0AE:  MOVWF  FEA
1A0B0:  MOVFF  FEC,8F0
1A0B4:  MOVF   FED,F
1A0B6:  MOVFF  FEF,8EF
1A0BA:  MOVLW  A8
1A0BC:  MOVLB  8
1A0BE:  MOVWF  xEE
1A0C0:  MOVLB  0
1A0C2:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
1A0C6:  BRA    1A0CC
....................    else cmd_arg();    
1A0C8:  CALL   B2F2
1A0CC:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_q() // shut down motor power 
.................... { 
....................    if(arg == 0) output_bit(VMOT,OFF); 
1A0D0:  MOVF   48,F
1A0D2:  BNZ   1A0E4
1A0D4:  MOVF   49,F
1A0D6:  BNZ   1A0E4
1A0D8:  MOVF   4A,F
1A0DA:  BNZ   1A0E4
1A0DC:  MOVF   4B,F
1A0DE:  BNZ   1A0E4
1A0E0:  BCF    F8E.1
1A0E2:  BRA    1A0E8
....................    else cmd_arg();    
1A0E4:  CALL   B2F2
1A0E8:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_r() // reset stepper vars 
.................... { 
....................    if (arg == 0){ 
*
1ABCC:  MOVF   48,F
1ABCE:  BNZ   1AC1E
1ABD0:  MOVF   49,F
1ABD2:  BNZ   1AC1E
1ABD4:  MOVF   4A,F
1ABD6:  BNZ   1AC1E
1ABD8:  MOVF   4B,F
1ABDA:  BNZ   1AC1E
....................       switch (nv_product) { 
1ABDC:  MOVFF  2F,00
1ABE0:  MOVF   30,W
1ABE2:  MOVWF  03
1ABE4:  BNZ   1ABEA
1ABE6:  MOVF   00,F
1ABE8:  BZ    1AC0A
1ABEA:  MOVF   03,W
1ABEC:  BNZ   1ABF4
1ABEE:  MOVLW  01
1ABF0:  SUBWF  00,W
1ABF2:  BZ    1AC10
1ABF4:  MOVF   03,W
1ABF6:  BNZ   1ABFE
1ABF8:  MOVLW  02
1ABFA:  SUBWF  00,W
1ABFC:  BZ    1AC16
1ABFE:  MOVF   03,W
1AC00:  BNZ   1AC08
1AC02:  MOVLW  03
1AC04:  SUBWF  00,W
1AC06:  BZ    1AC1A
1AC08:  BRA    1AC1C
....................          case ECO : rst_step_vars_eco(); 
1AC0A:  GOTO   1A0EC
....................             break; 
1AC0E:  BRA    1AC1C
....................          case WMS4 : rst_step_vars_wms4(); 
1AC10:  GOTO   1A3D6
....................             break; 
1AC14:  BRA    1AC1C
....................          case AWS : rst_step_vars_aws(); 
1AC16:  BRA    1A682
....................             break;             
1AC18:  BRA    1AC1C
....................          case WMS2 : rst_step_vars_wms2(); 
1AC1A:  BRA    1A91C
....................             break; 
....................       } 
....................    }  
1AC1C:  BRA    1AC22
....................    else cmd_arg(); 
1AC1E:  CALL   B2F2
1AC22:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_s() // steps per rev 
.................... { 
....................    if(arg < 65536) { 
1AC26:  MOVF   4B,F
1AC28:  BTFSS  FD8.2
1AC2A:  BRA    1AD2C
1AC2C:  MOVF   4A,W
1AC2E:  SUBLW  00
1AC30:  BTFSS  FD8.0
1AC32:  BRA    1AD2C
....................       m_spr[motor] = arg; 
1AC34:  BCF    FD8.0
1AC36:  MOVLB  7
1AC38:  RLCF   x40,W
1AC3A:  CLRF   03
1AC3C:  ADDLW  76
1AC3E:  MOVWF  FE9
1AC40:  MOVLW  07
1AC42:  ADDWFC 03,W
1AC44:  MOVWF  FEA
1AC46:  MOVFF  48,FEF
1AC4A:  MOVFF  49,FEC
....................       m_ppp[motor] = (m_spr[motor]/e_ppr[motor])*2; 
1AC4E:  BCF    FD8.0
1AC50:  RLCF   x40,W
1AC52:  CLRF   03
1AC54:  ADDLW  AB
1AC56:  MOVWF  01
1AC58:  MOVLW  07
1AC5A:  ADDWFC 03,F
1AC5C:  MOVFF  01,885
1AC60:  MOVLB  8
1AC62:  MOVFF  03,886
1AC66:  BCF    FD8.0
1AC68:  MOVLB  7
1AC6A:  RLCF   x40,W
1AC6C:  CLRF   03
1AC6E:  ADDLW  76
1AC70:  MOVWF  FE9
1AC72:  MOVLW  07
1AC74:  ADDWFC 03,W
1AC76:  MOVWF  FEA
1AC78:  MOVFF  FEC,8DC
1AC7C:  MOVF   FED,F
1AC7E:  MOVFF  FEF,8DB
1AC82:  BCF    FD8.0
1AC84:  RLCF   x40,W
1AC86:  CLRF   03
1AC88:  ADDLW  62
1AC8A:  MOVWF  FE9
1AC8C:  MOVLW  07
1AC8E:  ADDWFC 03,W
1AC90:  MOVWF  FEA
1AC92:  MOVFF  FEC,03
1AC96:  MOVF   FED,F
1AC98:  MOVFF  FEF,8DD
1AC9C:  MOVFF  03,88A
1ACA0:  MOVFF  03,8DE
1ACA4:  MOVLB  0
1ACA6:  CALL   2CC8
1ACAA:  MOVFF  02,888
1ACAE:  BCF    FD8.0
1ACB0:  MOVLB  8
1ACB2:  RLCF   01,W
1ACB4:  MOVWF  02
1ACB6:  RLCF   x88,W
1ACB8:  MOVFF  886,FEA
1ACBC:  MOVFF  885,FE9
1ACC0:  MOVWF  FEC
1ACC2:  MOVF   FED,F
1ACC4:  MOVFF  02,FEF
....................       switch(motor){ 
1ACC8:  MOVLB  7
1ACCA:  MOVF   x40,W
1ACCC:  XORLW  00
1ACCE:  MOVLB  0
1ACD0:  BZ    1ACD8
1ACD2:  XORLW  01
1ACD4:  BZ    1AD02
1ACD6:  BRA    1AD2A
....................          case 0 : write16(ADDR_M1_SPR, m_spr[motor]); 
1ACD8:  BCF    FD8.0
1ACDA:  MOVLB  7
1ACDC:  RLCF   x40,W
1ACDE:  CLRF   03
1ACE0:  ADDLW  76
1ACE2:  MOVWF  FE9
1ACE4:  MOVLW  07
1ACE6:  ADDWFC 03,W
1ACE8:  MOVWF  FEA
1ACEA:  MOVFF  FEC,8F0
1ACEE:  MOVF   FED,F
1ACF0:  MOVFF  FEF,8EF
1ACF4:  MOVLW  AE
1ACF6:  MOVLB  8
1ACF8:  MOVWF  xEE
1ACFA:  MOVLB  0
1ACFC:  CALL   4FC8
....................             break; 
1AD00:  BRA    1AD2A
....................          case 1 : write16(ADDR_M2_SPR, m_spr[motor]); 
1AD02:  BCF    FD8.0
1AD04:  MOVLB  7
1AD06:  RLCF   x40,W
1AD08:  CLRF   03
1AD0A:  ADDLW  76
1AD0C:  MOVWF  FE9
1AD0E:  MOVLW  07
1AD10:  ADDWFC 03,W
1AD12:  MOVWF  FEA
1AD14:  MOVFF  FEC,8F0
1AD18:  MOVF   FED,F
1AD1A:  MOVFF  FEF,8EF
1AD1E:  MOVLW  B0
1AD20:  MOVLB  8
1AD22:  MOVWF  xEE
1AD24:  MOVLB  0
1AD26:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
1AD2A:  BRA    1AD30
....................    else cmd_arg();    
1AD2C:  CALL   B2F2
1AD30:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_t() // encoder type (0=none, 1=quad, 2=disk) 
.................... { 
....................    if(arg < 3) { 
1AD34:  MOVF   4B,F
1AD36:  BNZ   1ADC2
1AD38:  MOVF   4A,F
1AD3A:  BNZ   1ADC2
1AD3C:  MOVF   49,F
1AD3E:  BNZ   1ADC2
1AD40:  MOVF   48,W
1AD42:  SUBLW  02
1AD44:  BNC   1ADC2
....................       e_type[motor] = arg; 
1AD46:  BCF    FD8.0
1AD48:  MOVLB  7
1AD4A:  RLCF   x40,W
1AD4C:  CLRF   03
1AD4E:  ADDLW  6A
1AD50:  MOVWF  FE9
1AD52:  MOVLW  07
1AD54:  ADDWFC 03,W
1AD56:  MOVWF  FEA
1AD58:  MOVFF  48,FEF
1AD5C:  MOVFF  49,FEC
....................       switch(motor){ 
1AD60:  MOVF   x40,W
1AD62:  XORLW  00
1AD64:  MOVLB  0
1AD66:  BZ    1AD6E
1AD68:  XORLW  01
1AD6A:  BZ    1AD98
1AD6C:  BRA    1ADC0
....................          case 0 : write16(ADDR_E1_TYPE, e_type[motor]); 
1AD6E:  BCF    FD8.0
1AD70:  MOVLB  7
1AD72:  RLCF   x40,W
1AD74:  CLRF   03
1AD76:  ADDLW  6A
1AD78:  MOVWF  FE9
1AD7A:  MOVLW  07
1AD7C:  ADDWFC 03,W
1AD7E:  MOVWF  FEA
1AD80:  MOVFF  FEC,8F0
1AD84:  MOVF   FED,F
1AD86:  MOVFF  FEF,8EF
1AD8A:  MOVLW  7A
1AD8C:  MOVLB  8
1AD8E:  MOVWF  xEE
1AD90:  MOVLB  0
1AD92:  CALL   4FC8
....................             break; 
1AD96:  BRA    1ADC0
....................          case 1 : write16(ADDR_E2_TYPE, e_type[motor]); 
1AD98:  BCF    FD8.0
1AD9A:  MOVLB  7
1AD9C:  RLCF   x40,W
1AD9E:  CLRF   03
1ADA0:  ADDLW  6A
1ADA2:  MOVWF  FE9
1ADA4:  MOVLW  07
1ADA6:  ADDWFC 03,W
1ADA8:  MOVWF  FEA
1ADAA:  MOVFF  FEC,8F0
1ADAE:  MOVF   FED,F
1ADB0:  MOVFF  FEF,8EF
1ADB4:  MOVLW  7C
1ADB6:  MOVLB  8
1ADB8:  MOVWF  xEE
1ADBA:  MOVLB  0
1ADBC:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
1ADC0:  BRA    1ADC6
....................    else cmd_arg();    
1ADC2:  CALL   B2F2
1ADC6:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... // "u" is used to change unit/motor 
....................  
.................... //currently used to test dio pins 
.................... void command_v(){ 
....................    if(arg == 00){ 
*
13DC2:  MOVF   48,F
13DC4:  BNZ   13DD6
13DC6:  MOVF   49,F
13DC8:  BNZ   13DD6
13DCA:  MOVF   4A,F
13DCC:  BNZ   13DD6
13DCE:  MOVF   4B,F
13DD0:  BNZ   13DD6
....................       output_bit(PIN_D0,0); 
13DD2:  BCF    F8C.0
....................    }else if(arg == 01){ 
13DD4:  BRA    13F1C
13DD6:  DECFSZ 48,W
13DD8:  BRA    13DEA
13DDA:  MOVF   49,F
13DDC:  BNZ   13DEA
13DDE:  MOVF   4A,F
13DE0:  BNZ   13DEA
13DE2:  MOVF   4B,F
13DE4:  BNZ   13DEA
....................       output_bit(PIN_D0,1); 
13DE6:  BSF    F8C.0
....................    }else if(arg == 10){ 
13DE8:  BRA    13F1C
13DEA:  MOVF   48,W
13DEC:  SUBLW  0A
13DEE:  BNZ   13E00
13DF0:  MOVF   49,F
13DF2:  BNZ   13E00
13DF4:  MOVF   4A,F
13DF6:  BNZ   13E00
13DF8:  MOVF   4B,F
13DFA:  BNZ   13E00
....................       output_bit(PIN_D1,0); 
13DFC:  BCF    F8C.1
....................    }else if(arg == 11){ 
13DFE:  BRA    13F1C
13E00:  MOVF   48,W
13E02:  SUBLW  0B
13E04:  BNZ   13E16
13E06:  MOVF   49,F
13E08:  BNZ   13E16
13E0A:  MOVF   4A,F
13E0C:  BNZ   13E16
13E0E:  MOVF   4B,F
13E10:  BNZ   13E16
....................       output_bit(PIN_D1,1); 
13E12:  BSF    F8C.1
....................    }else if(arg == 20){ 
13E14:  BRA    13F1C
13E16:  MOVF   48,W
13E18:  SUBLW  14
13E1A:  BNZ   13E2C
13E1C:  MOVF   49,F
13E1E:  BNZ   13E2C
13E20:  MOVF   4A,F
13E22:  BNZ   13E2C
13E24:  MOVF   4B,F
13E26:  BNZ   13E2C
....................       output_bit(PIN_D2,0); 
13E28:  BCF    F8C.2
....................    }else if(arg == 21){ 
13E2A:  BRA    13F1C
13E2C:  MOVF   48,W
13E2E:  SUBLW  15
13E30:  BNZ   13E42
13E32:  MOVF   49,F
13E34:  BNZ   13E42
13E36:  MOVF   4A,F
13E38:  BNZ   13E42
13E3A:  MOVF   4B,F
13E3C:  BNZ   13E42
....................       output_bit(PIN_D2,1); 
13E3E:  BSF    F8C.2
....................    }else if(arg == 30){ 
13E40:  BRA    13F1C
13E42:  MOVF   48,W
13E44:  SUBLW  1E
13E46:  BNZ   13E58
13E48:  MOVF   49,F
13E4A:  BNZ   13E58
13E4C:  MOVF   4A,F
13E4E:  BNZ   13E58
13E50:  MOVF   4B,F
13E52:  BNZ   13E58
....................       output_bit(PIN_D3,0); 
13E54:  BCF    F8C.3
....................    }else if(arg == 31){ 
13E56:  BRA    13F1C
13E58:  MOVF   48,W
13E5A:  SUBLW  1F
13E5C:  BNZ   13E6E
13E5E:  MOVF   49,F
13E60:  BNZ   13E6E
13E62:  MOVF   4A,F
13E64:  BNZ   13E6E
13E66:  MOVF   4B,F
13E68:  BNZ   13E6E
....................       output_bit(PIN_D3,1); 
13E6A:  BSF    F8C.3
....................    }else if(arg == 40){ 
13E6C:  BRA    13F1C
13E6E:  MOVF   48,W
13E70:  SUBLW  28
13E72:  BNZ   13E84
13E74:  MOVF   49,F
13E76:  BNZ   13E84
13E78:  MOVF   4A,F
13E7A:  BNZ   13E84
13E7C:  MOVF   4B,F
13E7E:  BNZ   13E84
....................       output_bit(PIN_D4,0); 
13E80:  BCF    F8C.4
....................    }else if(arg == 41){ 
13E82:  BRA    13F1C
13E84:  MOVF   48,W
13E86:  SUBLW  29
13E88:  BNZ   13E9A
13E8A:  MOVF   49,F
13E8C:  BNZ   13E9A
13E8E:  MOVF   4A,F
13E90:  BNZ   13E9A
13E92:  MOVF   4B,F
13E94:  BNZ   13E9A
....................       output_bit(PIN_D4,1); 
13E96:  BSF    F8C.4
....................    }else if(arg == 50){ 
13E98:  BRA    13F1C
13E9A:  MOVF   48,W
13E9C:  SUBLW  32
13E9E:  BNZ   13EB0
13EA0:  MOVF   49,F
13EA2:  BNZ   13EB0
13EA4:  MOVF   4A,F
13EA6:  BNZ   13EB0
13EA8:  MOVF   4B,F
13EAA:  BNZ   13EB0
....................       output_bit(PIN_D5,0); 
13EAC:  BCF    F8C.5
....................    }else if(arg == 51){ 
13EAE:  BRA    13F1C
13EB0:  MOVF   48,W
13EB2:  SUBLW  33
13EB4:  BNZ   13EC6
13EB6:  MOVF   49,F
13EB8:  BNZ   13EC6
13EBA:  MOVF   4A,F
13EBC:  BNZ   13EC6
13EBE:  MOVF   4B,F
13EC0:  BNZ   13EC6
....................       output_bit(PIN_D5,1); 
13EC2:  BSF    F8C.5
....................    }else if(arg == 60){ 
13EC4:  BRA    13F1C
13EC6:  MOVF   48,W
13EC8:  SUBLW  3C
13ECA:  BNZ   13EDC
13ECC:  MOVF   49,F
13ECE:  BNZ   13EDC
13ED0:  MOVF   4A,F
13ED2:  BNZ   13EDC
13ED4:  MOVF   4B,F
13ED6:  BNZ   13EDC
....................       output_bit(PIN_D6,0); 
13ED8:  BCF    F8C.6
....................    }else if(arg == 61){ 
13EDA:  BRA    13F1C
13EDC:  MOVF   48,W
13EDE:  SUBLW  3D
13EE0:  BNZ   13EF2
13EE2:  MOVF   49,F
13EE4:  BNZ   13EF2
13EE6:  MOVF   4A,F
13EE8:  BNZ   13EF2
13EEA:  MOVF   4B,F
13EEC:  BNZ   13EF2
....................       output_bit(PIN_D6,1); 
13EEE:  BSF    F8C.6
....................    }else if(arg == 70){ 
13EF0:  BRA    13F1C
13EF2:  MOVF   48,W
13EF4:  SUBLW  46
13EF6:  BNZ   13F08
13EF8:  MOVF   49,F
13EFA:  BNZ   13F08
13EFC:  MOVF   4A,F
13EFE:  BNZ   13F08
13F00:  MOVF   4B,F
13F02:  BNZ   13F08
....................       output_bit(PIN_D7,0); 
13F04:  BCF    F8C.7
....................    }else if(arg == 71){ 
13F06:  BRA    13F1C
13F08:  MOVF   48,W
13F0A:  SUBLW  47
13F0C:  BNZ   13F1C
13F0E:  MOVF   49,F
13F10:  BNZ   13F1C
13F12:  MOVF   4A,F
13F14:  BNZ   13F1C
13F16:  MOVF   4B,F
13F18:  BNZ   13F1C
....................       output_bit(PIN_D7,1); 
13F1A:  BSF    F8C.7
....................    } 
13F1C:  RETURN 0
.................... } 
....................  
.................... void command_w() // drive current 
.................... { 
....................    int16 drive_pc; 
....................    if(arg < 101) { 
*
1AE02:  MOVF   4B,F
1AE04:  BNZ   1AECE
1AE06:  MOVF   4A,F
1AE08:  BNZ   1AECE
1AE0A:  MOVF   49,F
1AE0C:  BNZ   1AECE
1AE0E:  MOVF   48,W
1AE10:  SUBLW  64
1AE12:  BNC   1AECE
....................       drive_pc=arg; 
1AE14:  MOVFF  49,886
1AE18:  MOVFF  48,885
....................       m_pwm_drv[motor] = (drive_pc*(((T2_MID_VAL+1)*4)-1))/100; 
1AE1C:  BCF    FD8.0
1AE1E:  MOVLB  7
1AE20:  RLCF   x40,W
1AE22:  CLRF   03
1AE24:  ADDLW  56
1AE26:  MOVWF  FE9
1AE28:  MOVLW  07
1AE2A:  ADDWFC 03,W
1AE2C:  MOVWF  FEA
1AE2E:  MOVFF  886,A11
1AE32:  MOVFF  885,A10
1AE36:  MOVLW  01
1AE38:  MOVLB  A
1AE3A:  MOVWF  x13
1AE3C:  SETF   x12
1AE3E:  MOVLB  0
1AE40:  CALL   5C8C
1AE44:  MOVFF  02,88A
1AE48:  MOVFF  01,889
1AE4C:  MOVFF  02,8DC
1AE50:  MOVFF  01,8DB
1AE54:  MOVLB  8
1AE56:  CLRF   xDE
1AE58:  MOVLW  64
1AE5A:  MOVWF  xDD
1AE5C:  MOVLB  0
1AE5E:  CALL   2CC8
1AE62:  MOVFF  01,FEF
1AE66:  MOVFF  02,FEC
....................       switch(motor){ 
1AE6A:  MOVLB  7
1AE6C:  MOVF   x40,W
1AE6E:  XORLW  00
1AE70:  MOVLB  0
1AE72:  BZ    1AE7A
1AE74:  XORLW  01
1AE76:  BZ    1AEA4
1AE78:  BRA    1AECC
....................          case 0 : write16(ADDR_M1_PWM_DRV, m_pwm_drv[motor]); 
1AE7A:  BCF    FD8.0
1AE7C:  MOVLB  7
1AE7E:  RLCF   x40,W
1AE80:  CLRF   03
1AE82:  ADDLW  56
1AE84:  MOVWF  FE9
1AE86:  MOVLW  07
1AE88:  ADDWFC 03,W
1AE8A:  MOVWF  FEA
1AE8C:  MOVFF  FEC,8F0
1AE90:  MOVF   FED,F
1AE92:  MOVFF  FEF,8EF
1AE96:  MOVLW  9A
1AE98:  MOVLB  8
1AE9A:  MOVWF  xEE
1AE9C:  MOVLB  0
1AE9E:  CALL   4FC8
....................             break; 
1AEA2:  BRA    1AECC
....................          case 1 : write16(ADDR_M2_PWM_DRV, m_pwm_drv[motor]); 
1AEA4:  BCF    FD8.0
1AEA6:  MOVLB  7
1AEA8:  RLCF   x40,W
1AEAA:  CLRF   03
1AEAC:  ADDLW  56
1AEAE:  MOVWF  FE9
1AEB0:  MOVLW  07
1AEB2:  ADDWFC 03,W
1AEB4:  MOVWF  FEA
1AEB6:  MOVFF  FEC,8F0
1AEBA:  MOVF   FED,F
1AEBC:  MOVFF  FEF,8EF
1AEC0:  MOVLW  9C
1AEC2:  MOVLB  8
1AEC4:  MOVWF  xEE
1AEC6:  MOVLB  0
1AEC8:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
1AECC:  BRA    1AED2
....................    else cmd_arg();    
1AECE:  CALL   B2F2
1AED2:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_x() // alignment adjustment extra motor steps  
.................... { 
....................    if(arg < 10000){  // should be < 2000 motor steps 
1AED6:  MOVF   4B,F
1AED8:  BNZ   1AF68
1AEDA:  MOVF   4A,F
1AEDC:  BNZ   1AF68
1AEDE:  MOVF   49,W
1AEE0:  SUBLW  27
1AEE2:  BNC   1AF68
1AEE4:  BNZ   1AEEC
1AEE6:  MOVF   48,W
1AEE8:  SUBLW  0F
1AEEA:  BNC   1AF68
....................        align_os[motor] = arg; 
1AEEC:  BCF    FD8.0
1AEEE:  MOVLB  7
1AEF0:  RLCF   x40,W
1AEF2:  CLRF   03
1AEF4:  ADDLW  82
1AEF6:  MOVWF  FE9
1AEF8:  MOVLW  07
1AEFA:  ADDWFC 03,W
1AEFC:  MOVWF  FEA
1AEFE:  MOVFF  48,FEF
1AF02:  MOVFF  49,FEC
....................        switch(motor){ 
1AF06:  MOVF   x40,W
1AF08:  XORLW  00
1AF0A:  MOVLB  0
1AF0C:  BZ    1AF14
1AF0E:  XORLW  01
1AF10:  BZ    1AF3E
1AF12:  BRA    1AF66
....................          case 0 : write16(ADDR_M1_ALIGN_OS, align_os[motor]); 
1AF14:  BCF    FD8.0
1AF16:  MOVLB  7
1AF18:  RLCF   x40,W
1AF1A:  CLRF   03
1AF1C:  ADDLW  82
1AF1E:  MOVWF  FE9
1AF20:  MOVLW  07
1AF22:  ADDWFC 03,W
1AF24:  MOVWF  FEA
1AF26:  MOVFF  FEC,8F0
1AF2A:  MOVF   FED,F
1AF2C:  MOVFF  FEF,8EF
1AF30:  MOVLW  C2
1AF32:  MOVLB  8
1AF34:  MOVWF  xEE
1AF36:  MOVLB  0
1AF38:  CALL   4FC8
....................             break; 
1AF3C:  BRA    1AF66
....................          case 1 : write16(ADDR_M2_ALIGN_OS, align_os[motor]); 
1AF3E:  BCF    FD8.0
1AF40:  MOVLB  7
1AF42:  RLCF   x40,W
1AF44:  CLRF   03
1AF46:  ADDLW  82
1AF48:  MOVWF  FE9
1AF4A:  MOVLW  07
1AF4C:  ADDWFC 03,W
1AF4E:  MOVWF  FEA
1AF50:  MOVFF  FEC,8F0
1AF54:  MOVF   FED,F
1AF56:  MOVFF  FEF,8EF
1AF5A:  MOVLW  C4
1AF5C:  MOVLB  8
1AF5E:  MOVWF  xEE
1AF60:  MOVLB  0
1AF62:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
1AF66:  BRA    1AF6C
....................    else cmd_arg();    
1AF68:  CALL   B2F2
1AF6C:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_y() // stepp mode (full/half) 
.................... { 
....................    if(arg < 2) { 
1AF70:  MOVF   4B,F
1AF72:  BNZ   1AFFE
1AF74:  MOVF   4A,F
1AF76:  BNZ   1AFFE
1AF78:  MOVF   49,F
1AF7A:  BNZ   1AFFE
1AF7C:  MOVF   48,W
1AF7E:  SUBLW  01
1AF80:  BNC   1AFFE
....................       m_ctrl[motor] = arg; 
1AF82:  BCF    FD8.0
1AF84:  MOVLB  7
1AF86:  RLCF   x40,W
1AF88:  CLRF   03
1AF8A:  ADDLW  42
1AF8C:  MOVWF  FE9
1AF8E:  MOVLW  07
1AF90:  ADDWFC 03,W
1AF92:  MOVWF  FEA
1AF94:  MOVFF  48,FEF
1AF98:  MOVFF  49,FEC
....................       switch(motor){ 
1AF9C:  MOVF   x40,W
1AF9E:  XORLW  00
1AFA0:  MOVLB  0
1AFA2:  BZ    1AFAA
1AFA4:  XORLW  01
1AFA6:  BZ    1AFD4
1AFA8:  BRA    1AFFC
....................          case 0 : write16(ADDR_M1_CTRL, m_ctrl[motor]); 
1AFAA:  BCF    FD8.0
1AFAC:  MOVLB  7
1AFAE:  RLCF   x40,W
1AFB0:  CLRF   03
1AFB2:  ADDLW  42
1AFB4:  MOVWF  FE9
1AFB6:  MOVLW  07
1AFB8:  ADDWFC 03,W
1AFBA:  MOVWF  FEA
1AFBC:  MOVFF  FEC,8F0
1AFC0:  MOVF   FED,F
1AFC2:  MOVFF  FEF,8EF
1AFC6:  MOVLW  86
1AFC8:  MOVLB  8
1AFCA:  MOVWF  xEE
1AFCC:  MOVLB  0
1AFCE:  CALL   4FC8
....................             break; 
1AFD2:  BRA    1AFFC
....................          case 1 : write16(ADDR_M2_CTRL, m_ctrl[motor]); 
1AFD4:  BCF    FD8.0
1AFD6:  MOVLB  7
1AFD8:  RLCF   x40,W
1AFDA:  CLRF   03
1AFDC:  ADDLW  42
1AFDE:  MOVWF  FE9
1AFE0:  MOVLW  07
1AFE2:  ADDWFC 03,W
1AFE4:  MOVWF  FEA
1AFE6:  MOVFF  FEC,8F0
1AFEA:  MOVF   FED,F
1AFEC:  MOVFF  FEF,8EF
1AFF0:  MOVLW  88
1AFF2:  MOVLB  8
1AFF4:  MOVWF  xEE
1AFF6:  MOVLB  0
1AFF8:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
1AFFC:  BRA    1B002
....................    else cmd_arg();    
1AFFE:  CALL   B2F2
1B002:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_u() 
.................... { 
....................    switch (arg){ 
*
1ADCA:  MOVF   48,W
1ADCC:  MOVWF  00
1ADCE:  MOVF   49,W
1ADD0:  MOVWF  03
1ADD2:  BNZ   1ADDA
1ADD4:  MOVLW  01
1ADD6:  SUBWF  00,W
1ADD8:  BZ    1ADE6
1ADDA:  MOVF   03,W
1ADDC:  BNZ   1ADE4
1ADDE:  MOVLW  02
1ADE0:  SUBWF  00,W
1ADE2:  BZ    1ADEC
1ADE4:  BRA    1ADF6
....................       case 1: motor = 0; 
1ADE6:  MOVLB  7
1ADE8:  CLRF   x40
....................          break; 
1ADEA:  BRA    1ADFC
....................       case 2: motor = 1; 
1ADEC:  MOVLW  01
1ADEE:  MOVLB  7
1ADF0:  MOVWF  x40
....................          break; 
1ADF2:  BRA    1ADFC
1ADF4:  MOVLB  0
....................       default : cmd_arg(); 
1ADF6:  CALL   B2F2
....................          break; 
1ADFA:  MOVLB  7
....................    } 
1ADFC:  MOVLB  0
1ADFE:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_z() // zero enc position 
.................... { 
....................    if(arg > 0 && arg < 3) { 
*
1B006:  MOVF   48,F
1B008:  BNZ   1B016
1B00A:  MOVF   49,F
1B00C:  BNZ   1B016
1B00E:  MOVF   4A,F
1B010:  BNZ   1B016
1B012:  MOVF   4B,F
1B014:  BZ    1B074
1B016:  MOVF   4B,F
1B018:  BNZ   1B074
1B01A:  MOVF   4A,F
1B01C:  BNZ   1B074
1B01E:  MOVF   49,F
1B020:  BNZ   1B074
1B022:  MOVF   48,W
1B024:  SUBLW  02
1B026:  BNC   1B074
....................       switch(arg){ 
1B028:  MOVFF  48,00
1B02C:  MOVF   49,W
1B02E:  MOVWF  03
1B030:  BNZ   1B038
1B032:  MOVLW  01
1B034:  SUBWF  00,W
1B036:  BZ    1B044
1B038:  MOVF   03,W
1B03A:  BNZ   1B042
1B03C:  MOVLW  02
1B03E:  SUBWF  00,W
1B040:  BZ    1B05C
1B042:  BRA    1B072
....................          case 1 : e_pos[0] = 0; 
1B044:  MOVLB  7
1B046:  CLRF   xC0
1B048:  CLRF   xBF
....................                   write16(ADDR_E1_POS, 0); 
1B04A:  MOVLW  7E
1B04C:  MOVLB  8
1B04E:  MOVWF  xEE
1B050:  CLRF   xF0
1B052:  CLRF   xEF
1B054:  MOVLB  0
1B056:  CALL   4FC8
....................             break; 
1B05A:  BRA    1B072
....................          case 2 : e_pos[1] = 0; 
1B05C:  MOVLB  7
1B05E:  CLRF   xC2
1B060:  CLRF   xC1
....................                   write16(ADDR_E2_POS, 0); 
1B062:  MOVLW  80
1B064:  MOVLB  8
1B066:  MOVWF  xEE
1B068:  CLRF   xF0
1B06A:  CLRF   xEF
1B06C:  MOVLB  0
1B06E:  CALL   4FC8
....................             break;             
....................       } 
....................    } 
1B072:  BRA    1B078
....................    else cmd_arg();  
1B074:  CALL   B2F2
1B078:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void step_var_list() 
.................... { 
....................    int16 hold_pc, drive_pc, step_us; 
....................     
....................    if (arg==1){ 
*
19210:  DECFSZ 48,W
19212:  GOTO   19E68
19216:  MOVF   49,F
19218:  BTFSS  FD8.2
1921A:  GOTO   19E68
1921E:  MOVF   4A,F
19220:  BTFSS  FD8.2
19222:  GOTO   19E68
19226:  MOVF   4B,F
19228:  BTFSS  FD8.2
1922A:  GOTO   19E68
....................       hold_pc  = ((m_pwm_hld[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
1922E:  MOVFF  753,A11
19232:  MOVFF  752,A10
19236:  MOVLB  A
19238:  CLRF   x13
1923A:  MOVLW  64
1923C:  MOVWF  x12
1923E:  MOVLB  0
19240:  CALL   5C8C
19244:  MOVFF  02,88C
19248:  MOVFF  01,88B
1924C:  MOVFF  02,8DC
19250:  MOVFF  01,8DB
19254:  MOVLW  01
19256:  MOVLB  8
19258:  MOVWF  xDE
1925A:  SETF   xDD
1925C:  MOVLB  0
1925E:  CALL   2CC8
19262:  MOVFF  02,886
19266:  MOVFF  01,885
....................       drive_pc = ((m_pwm_drv[0]*100) / (((T2_MID_VAL+1)*4)-1)); 
1926A:  MOVFF  757,A11
1926E:  MOVFF  756,A10
19272:  MOVLB  A
19274:  CLRF   x13
19276:  MOVLW  64
19278:  MOVWF  x12
1927A:  MOVLB  0
1927C:  CALL   5C8C
19280:  MOVFF  02,88C
19284:  MOVFF  01,88B
19288:  MOVFF  02,8DC
1928C:  MOVFF  01,8DB
19290:  MOVLW  01
19292:  MOVLB  8
19294:  MOVWF  xDE
19296:  SETF   xDD
19298:  MOVLB  0
1929A:  CALL   2CC8
1929E:  MOVFF  02,888
192A2:  MOVFF  01,887
....................       step_us  =   m_stp_int[0]*100; 
192A6:  MOVFF  74B,A11
192AA:  MOVFF  74A,A10
192AE:  MOVLB  A
192B0:  CLRF   x13
192B2:  MOVLW  64
192B4:  MOVWF  x12
192B6:  MOVLB  0
192B8:  CALL   5C8C
192BC:  MOVFF  02,88A
192C0:  MOVFF  01,889
....................        
....................       fprintf(COM_A, "[motor:1]\r\n"); 
192C4:  MOVLW  0E
192C6:  MOVWF  FF6
192C8:  MOVLW  27
192CA:  MOVWF  FF7
192CC:  MOVLW  00
192CE:  MOVWF  FF8
192D0:  CLRF   1B
192D2:  BTFSC  FF2.7
192D4:  BSF    1B.7
192D6:  BCF    FF2.7
192D8:  CALL   0E42
192DC:  BTFSC  1B.7
192DE:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[0]);       
192E0:  MOVLW  62
192E2:  BTFSS  F9E.4
192E4:  BRA    192E2
192E6:  MOVWF  FAD
192E8:  MOVLW  3A
192EA:  BTFSS  F9E.4
192EC:  BRA    192EA
192EE:  MOVWF  FAD
192F0:  MOVLW  10
192F2:  MOVWF  FE9
192F4:  CLRF   1B
192F6:  BTFSC  FF2.7
192F8:  BSF    1B.7
192FA:  BCF    FF2.7
192FC:  MOVFF  773,A41
19300:  MOVFF  772,A40
19304:  CALL   119A
19308:  BTFSC  1B.7
1930A:  BSF    FF2.7
1930C:  MOVLW  0D
1930E:  BTFSS  F9E.4
19310:  BRA    1930E
19312:  MOVWF  FAD
19314:  MOVLW  0A
19316:  BTFSS  F9E.4
19318:  BRA    19316
1931A:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[0],e_cha_cnt[0],e_pos[0]); 
1931C:  MOVLW  63
1931E:  BTFSS  F9E.4
19320:  BRA    1931E
19322:  MOVWF  FAD
19324:  MOVLW  3A
19326:  BTFSS  F9E.4
19328:  BRA    19326
1932A:  MOVWF  FAD
1932C:  MOVLW  41
1932E:  MOVWF  FE9
19330:  CLRF   1B
19332:  BTFSC  FF2.7
19334:  BSF    1B.7
19336:  BCF    FF2.7
19338:  MOVFF  7A5,A43
1933C:  MOVFF  7A4,A42
19340:  MOVFF  7A3,A41
19344:  MOVFF  7A2,A40
19348:  CALL   10DE
1934C:  BTFSC  1B.7
1934E:  BSF    FF2.7
19350:  MOVLW  2F
19352:  BTFSS  F9E.4
19354:  BRA    19352
19356:  MOVWF  FAD
19358:  MOVLW  10
1935A:  MOVWF  FE9
1935C:  CLRF   1B
1935E:  BTFSC  FF2.7
19360:  BSF    1B.7
19362:  BCF    FF2.7
19364:  MOVFF  7BC,A41
19368:  MOVFF  7BB,A40
1936C:  CALL   119A
19370:  BTFSC  1B.7
19372:  BSF    FF2.7
19374:  MOVLW  2F
19376:  BTFSS  F9E.4
19378:  BRA    19376
1937A:  MOVWF  FAD
1937C:  MOVLW  10
1937E:  MOVWF  FE9
19380:  CLRF   1B
19382:  BTFSC  FF2.7
19384:  BSF    1B.7
19386:  BCF    FF2.7
19388:  MOVFF  7C0,A41
1938C:  MOVFF  7BF,A40
19390:  CALL   119A
19394:  BTFSC  1B.7
19396:  BSF    FF2.7
19398:  MOVLW  0D
1939A:  BTFSS  F9E.4
1939C:  BRA    1939A
1939E:  MOVWF  FAD
193A0:  MOVLW  0A
193A2:  BTFSS  F9E.4
193A4:  BRA    193A2
193A6:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[0]); 
193A8:  MOVLW  64
193AA:  BTFSS  F9E.4
193AC:  BRA    193AA
193AE:  MOVWF  FAD
193B0:  MOVLW  3A
193B2:  BTFSS  F9E.4
193B4:  BRA    193B2
193B6:  MOVWF  FAD
193B8:  MOVLW  10
193BA:  MOVWF  FE9
193BC:  CLRF   1B
193BE:  BTFSC  FF2.7
193C0:  BSF    1B.7
193C2:  BCF    FF2.7
193C4:  MOVFF  74F,A41
193C8:  MOVFF  74E,A40
193CC:  CALL   119A
193D0:  BTFSC  1B.7
193D2:  BSF    FF2.7
193D4:  MOVLW  0D
193D6:  BTFSS  F9E.4
193D8:  BRA    193D6
193DA:  MOVWF  FAD
193DC:  MOVLW  0A
193DE:  BTFSS  F9E.4
193E0:  BRA    193DE
193E2:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[0]); 
193E4:  MOVLW  65
193E6:  BTFSS  F9E.4
193E8:  BRA    193E6
193EA:  MOVWF  FAD
193EC:  MOVLW  3A
193EE:  BTFSS  F9E.4
193F0:  BRA    193EE
193F2:  MOVWF  FAD
193F4:  MOVLW  10
193F6:  MOVWF  FE9
193F8:  CLRF   1B
193FA:  BTFSC  FF2.7
193FC:  BSF    1B.7
193FE:  BCF    FF2.7
19400:  MOVFF  75F,A41
19404:  MOVFF  75E,A40
19408:  CALL   119A
1940C:  BTFSC  1B.7
1940E:  BSF    FF2.7
19410:  MOVLW  0D
19412:  BTFSS  F9E.4
19414:  BRA    19412
19416:  MOVWF  FAD
19418:  MOVLW  0A
1941A:  BTFSS  F9E.4
1941C:  BRA    1941A
1941E:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19420:  MOVLW  66
19422:  BTFSS  F9E.4
19424:  BRA    19422
19426:  MOVWF  FAD
19428:  MOVLW  3A
1942A:  BTFSS  F9E.4
1942C:  BRA    1942A
1942E:  MOVWF  FAD
19430:  CLRF   1B
19432:  BTFSC  FF2.7
19434:  BSF    1B.7
19436:  BCF    FF2.7
19438:  MOVFF  741,A40
1943C:  MOVLW  1B
1943E:  MOVLB  A
19440:  MOVWF  x41
19442:  MOVLB  0
19444:  CALL   0F9A
19448:  BTFSC  1B.7
1944A:  BSF    FF2.7
1944C:  MOVLW  0D
1944E:  BTFSS  F9E.4
19450:  BRA    1944E
19452:  MOVWF  FAD
19454:  MOVLW  0A
19456:  BTFSS  F9E.4
19458:  BRA    19456
1945A:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[0]); 
1945C:  MOVLW  67
1945E:  BTFSS  F9E.4
19460:  BRA    1945E
19462:  MOVWF  FAD
19464:  MOVLW  3A
19466:  BTFSS  F9E.4
19468:  BRA    19466
1946A:  MOVWF  FAD
1946C:  MOVLW  10
1946E:  MOVWF  FE9
19470:  CLRF   1B
19472:  BTFSC  FF2.7
19474:  BSF    1B.7
19476:  BCF    FF2.7
19478:  MOVFF  75B,A41
1947C:  MOVFF  75A,A40
19480:  CALL   119A
19484:  BTFSC  1B.7
19486:  BSF    FF2.7
19488:  MOVLW  0D
1948A:  BTFSS  F9E.4
1948C:  BRA    1948A
1948E:  MOVWF  FAD
19490:  MOVLW  0A
19492:  BTFSS  F9E.4
19494:  BRA    19492
19496:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19498:  MOVLW  68
1949A:  BTFSS  F9E.4
1949C:  BRA    1949A
1949E:  MOVWF  FAD
194A0:  MOVLW  3A
194A2:  BTFSS  F9E.4
194A4:  BRA    194A2
194A6:  MOVWF  FAD
194A8:  MOVLW  10
194AA:  MOVWF  FE9
194AC:  CLRF   1B
194AE:  BTFSC  FF2.7
194B0:  BSF    1B.7
194B2:  BCF    FF2.7
194B4:  MOVFF  886,A41
194B8:  MOVFF  885,A40
194BC:  CALL   119A
194C0:  BTFSC  1B.7
194C2:  BSF    FF2.7
194C4:  MOVLW  0D
194C6:  BTFSS  F9E.4
194C8:  BRA    194C6
194CA:  MOVWF  FAD
194CC:  MOVLW  0A
194CE:  BTFSS  F9E.4
194D0:  BRA    194CE
194D2:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
194D4:  MOVLW  69
194D6:  BTFSS  F9E.4
194D8:  BRA    194D6
194DA:  MOVWF  FAD
194DC:  MOVLW  3A
194DE:  BTFSS  F9E.4
194E0:  BRA    194DE
194E2:  MOVWF  FAD
194E4:  MOVLW  10
194E6:  MOVWF  FE9
194E8:  CLRF   1B
194EA:  BTFSC  FF2.7
194EC:  BSF    1B.7
194EE:  BCF    FF2.7
194F0:  MOVFF  88A,A41
194F4:  MOVFF  889,A40
194F8:  CALL   119A
194FC:  BTFSC  1B.7
194FE:  BSF    FF2.7
19500:  MOVLW  0D
19502:  BTFSS  F9E.4
19504:  BRA    19502
19506:  MOVWF  FAD
19508:  MOVLW  0A
1950A:  BTFSS  F9E.4
1950C:  BRA    1950A
1950E:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[0]); 
19510:  MOVLW  6A
19512:  BTFSS  F9E.4
19514:  BRA    19512
19516:  MOVWF  FAD
19518:  MOVLW  3A
1951A:  BTFSS  F9E.4
1951C:  BRA    1951A
1951E:  MOVWF  FAD
19520:  MOVLW  10
19522:  MOVWF  FE9
19524:  CLRF   1B
19526:  BTFSC  FF2.7
19528:  BSF    1B.7
1952A:  BCF    FF2.7
1952C:  MOVFF  76F,A41
19530:  MOVFF  76E,A40
19534:  CALL   119A
19538:  BTFSC  1B.7
1953A:  BSF    FF2.7
1953C:  MOVLW  0D
1953E:  BTFSS  F9E.4
19540:  BRA    1953E
19542:  MOVWF  FAD
19544:  MOVLW  0A
19546:  BTFSS  F9E.4
19548:  BRA    19546
1954A:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[0]); 
1954C:  MOVLW  6B
1954E:  BTFSS  F9E.4
19550:  BRA    1954E
19552:  MOVWF  FAD
19554:  MOVLW  3A
19556:  BTFSS  F9E.4
19558:  BRA    19556
1955A:  MOVWF  FAD
1955C:  MOVLW  10
1955E:  MOVWF  FE9
19560:  CLRF   1B
19562:  BTFSC  FF2.7
19564:  BSF    1B.7
19566:  BCF    FF2.7
19568:  MOVFF  767,A41
1956C:  MOVFF  766,A40
19570:  CALL   119A
19574:  BTFSC  1B.7
19576:  BSF    FF2.7
19578:  MOVLW  0D
1957A:  BTFSS  F9E.4
1957C:  BRA    1957A
1957E:  MOVWF  FAD
19580:  MOVLW  0A
19582:  BTFSS  F9E.4
19584:  BRA    19582
19586:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[0]); 
19588:  MOVLW  6D
1958A:  BTFSS  F9E.4
1958C:  BRA    1958A
1958E:  MOVWF  FAD
19590:  MOVLW  3A
19592:  BTFSS  F9E.4
19594:  BRA    19592
19596:  MOVWF  FAD
19598:  MOVLW  10
1959A:  MOVWF  FE9
1959C:  CLRF   1B
1959E:  BTFSC  FF2.7
195A0:  BSF    1B.7
195A2:  BCF    FF2.7
195A4:  MOVFF  747,A41
195A8:  MOVFF  746,A40
195AC:  CALL   119A
195B0:  BTFSC  1B.7
195B2:  BSF    FF2.7
195B4:  MOVLW  0D
195B6:  BTFSS  F9E.4
195B8:  BRA    195B6
195BA:  MOVWF  FAD
195BC:  MOVLW  0A
195BE:  BTFSS  F9E.4
195C0:  BRA    195BE
195C2:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[0]); 
195C4:  MOVLW  6E
195C6:  BTFSS  F9E.4
195C8:  BRA    195C6
195CA:  MOVWF  FAD
195CC:  MOVLW  3A
195CE:  BTFSS  F9E.4
195D0:  BRA    195CE
195D2:  MOVWF  FAD
195D4:  MOVLW  10
195D6:  MOVWF  FE9
195D8:  CLRF   1B
195DA:  BTFSC  FF2.7
195DC:  BSF    1B.7
195DE:  BCF    FF2.7
195E0:  MOVFF  77B,A41
195E4:  MOVFF  77A,A40
195E8:  CALL   119A
195EC:  BTFSC  1B.7
195EE:  BSF    FF2.7
195F0:  MOVLW  0D
195F2:  BTFSS  F9E.4
195F4:  BRA    195F2
195F6:  MOVWF  FAD
195F8:  MOVLW  0A
195FA:  BTFSS  F9E.4
195FC:  BRA    195FA
195FE:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[0]); 
19600:  MOVLW  6F
19602:  BTFSS  F9E.4
19604:  BRA    19602
19606:  MOVWF  FAD
19608:  MOVLW  3A
1960A:  BTFSS  F9E.4
1960C:  BRA    1960A
1960E:  MOVWF  FAD
19610:  MOVLW  10
19612:  MOVWF  FE9
19614:  CLRF   1B
19616:  BTFSC  FF2.7
19618:  BSF    1B.7
1961A:  BCF    FF2.7
1961C:  MOVFF  77F,A41
19620:  MOVFF  77E,A40
19624:  CALL   119A
19628:  BTFSC  1B.7
1962A:  BSF    FF2.7
1962C:  MOVLW  0D
1962E:  BTFSS  F9E.4
19630:  BRA    1962E
19632:  MOVWF  FAD
19634:  MOVLW  0A
19636:  BTFSS  F9E.4
19638:  BRA    19636
1963A:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[0],e_ppr[0]); 
1963C:  MOVLW  70
1963E:  BTFSS  F9E.4
19640:  BRA    1963E
19642:  MOVWF  FAD
19644:  MOVLW  3A
19646:  BTFSS  F9E.4
19648:  BRA    19646
1964A:  MOVWF  FAD
1964C:  MOVLW  10
1964E:  MOVWF  FE9
19650:  CLRF   1B
19652:  BTFSC  FF2.7
19654:  BSF    1B.7
19656:  BCF    FF2.7
19658:  MOVFF  7C4,A41
1965C:  MOVFF  7C3,A40
19660:  CALL   119A
19664:  BTFSC  1B.7
19666:  BSF    FF2.7
19668:  MOVLW  2F
1966A:  BTFSS  F9E.4
1966C:  BRA    1966A
1966E:  MOVWF  FAD
19670:  MOVLW  10
19672:  MOVWF  FE9
19674:  CLRF   1B
19676:  BTFSC  FF2.7
19678:  BSF    1B.7
1967A:  BCF    FF2.7
1967C:  MOVFF  763,A41
19680:  MOVFF  762,A40
19684:  CALL   119A
19688:  BTFSC  1B.7
1968A:  BSF    FF2.7
1968C:  MOVLW  0D
1968E:  BTFSS  F9E.4
19690:  BRA    1968E
19692:  MOVWF  FAD
19694:  MOVLW  0A
19696:  BTFSS  F9E.4
19698:  BRA    19696
1969A:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[0]); 
1969C:  MOVLW  71
1969E:  BTFSS  F9E.4
196A0:  BRA    1969E
196A2:  MOVWF  FAD
196A4:  MOVLW  3A
196A6:  BTFSS  F9E.4
196A8:  BRA    196A6
196AA:  MOVWF  FAD
196AC:  MOVLW  10
196AE:  MOVWF  FE9
196B0:  CLRF   1B
196B2:  BTFSC  FF2.7
196B4:  BSF    1B.7
196B6:  BCF    FF2.7
196B8:  MOVFF  797,A41
196BC:  MOVFF  796,A40
196C0:  CALL   119A
196C4:  BTFSC  1B.7
196C6:  BSF    FF2.7
196C8:  MOVLW  0D
196CA:  BTFSS  F9E.4
196CC:  BRA    196CA
196CE:  MOVWF  FAD
196D0:  MOVLW  0A
196D2:  BTFSS  F9E.4
196D4:  BRA    196D2
196D6:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[0]);       
196D8:  MOVLW  73
196DA:  BTFSS  F9E.4
196DC:  BRA    196DA
196DE:  MOVWF  FAD
196E0:  MOVLW  3A
196E2:  BTFSS  F9E.4
196E4:  BRA    196E2
196E6:  MOVWF  FAD
196E8:  MOVLW  10
196EA:  MOVWF  FE9
196EC:  CLRF   1B
196EE:  BTFSC  FF2.7
196F0:  BSF    1B.7
196F2:  BCF    FF2.7
196F4:  MOVFF  777,A41
196F8:  MOVFF  776,A40
196FC:  CALL   119A
19700:  BTFSC  1B.7
19702:  BSF    FF2.7
19704:  MOVLW  0D
19706:  BTFSS  F9E.4
19708:  BRA    19706
1970A:  MOVWF  FAD
1970C:  MOVLW  0A
1970E:  BTFSS  F9E.4
19710:  BRA    1970E
19712:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[0]); 
19714:  MOVLW  74
19716:  BTFSS  F9E.4
19718:  BRA    19716
1971A:  MOVWF  FAD
1971C:  MOVLW  3A
1971E:  BTFSS  F9E.4
19720:  BRA    1971E
19722:  MOVWF  FAD
19724:  MOVLW  10
19726:  MOVWF  FE9
19728:  CLRF   1B
1972A:  BTFSC  FF2.7
1972C:  BSF    1B.7
1972E:  BCF    FF2.7
19730:  MOVFF  76B,A41
19734:  MOVFF  76A,A40
19738:  CALL   119A
1973C:  BTFSC  1B.7
1973E:  BSF    FF2.7
19740:  MOVLW  0D
19742:  BTFSS  F9E.4
19744:  BRA    19742
19746:  MOVWF  FAD
19748:  MOVLW  0A
1974A:  BTFSS  F9E.4
1974C:  BRA    1974A
1974E:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19750:  MOVLW  01
19752:  MOVLB  7
19754:  ADDWF  x40,W
19756:  MOVLB  8
19758:  MOVWF  x8B
1975A:  MOVLW  75
1975C:  BTFSS  F9E.4
1975E:  BRA    1975C
19760:  MOVWF  FAD
19762:  MOVLW  3A
19764:  BTFSS  F9E.4
19766:  BRA    19764
19768:  MOVWF  FAD
1976A:  CLRF   1B
1976C:  BTFSC  FF2.7
1976E:  BSF    1B.7
19770:  BCF    FF2.7
19772:  MOVFF  88B,A40
19776:  MOVLW  1B
19778:  MOVLB  A
1977A:  MOVWF  x41
1977C:  MOVLB  0
1977E:  CALL   0F9A
19782:  BTFSC  1B.7
19784:  BSF    FF2.7
19786:  MOVLW  0D
19788:  BTFSS  F9E.4
1978A:  BRA    19788
1978C:  MOVWF  FAD
1978E:  MOVLW  0A
19790:  BTFSS  F9E.4
19792:  BRA    19790
19794:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19796:  MOVLW  77
19798:  BTFSS  F9E.4
1979A:  BRA    19798
1979C:  MOVWF  FAD
1979E:  MOVLW  3A
197A0:  BTFSS  F9E.4
197A2:  BRA    197A0
197A4:  MOVWF  FAD
197A6:  MOVLW  10
197A8:  MOVWF  FE9
197AA:  CLRF   1B
197AC:  BTFSC  FF2.7
197AE:  BSF    1B.7
197B0:  BCF    FF2.7
197B2:  MOVFF  888,A41
197B6:  MOVFF  887,A40
197BA:  CALL   119A
197BE:  BTFSC  1B.7
197C0:  BSF    FF2.7
197C2:  MOVLW  0D
197C4:  BTFSS  F9E.4
197C6:  BRA    197C4
197C8:  MOVWF  FAD
197CA:  MOVLW  0A
197CC:  BTFSS  F9E.4
197CE:  BRA    197CC
197D0:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[0]); 
197D2:  MOVLW  78
197D4:  BTFSS  F9E.4
197D6:  BRA    197D4
197D8:  MOVWF  FAD
197DA:  MOVLW  3A
197DC:  BTFSS  F9E.4
197DE:  BRA    197DC
197E0:  MOVWF  FAD
197E2:  MOVLW  10
197E4:  MOVWF  FE9
197E6:  CLRF   1B
197E8:  BTFSC  FF2.7
197EA:  BSF    1B.7
197EC:  BCF    FF2.7
197EE:  MOVFF  783,A41
197F2:  MOVFF  782,A40
197F6:  CALL   119A
197FA:  BTFSC  1B.7
197FC:  BSF    FF2.7
197FE:  MOVLW  0D
19800:  BTFSS  F9E.4
19802:  BRA    19800
19804:  MOVWF  FAD
19806:  MOVLW  0A
19808:  BTFSS  F9E.4
1980A:  BRA    19808
1980C:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[0]);    
1980E:  MOVLW  79
19810:  BTFSS  F9E.4
19812:  BRA    19810
19814:  MOVWF  FAD
19816:  MOVLW  3A
19818:  BTFSS  F9E.4
1981A:  BRA    19818
1981C:  MOVWF  FAD
1981E:  MOVLW  10
19820:  MOVWF  FE9
19822:  CLRF   1B
19824:  BTFSC  FF2.7
19826:  BSF    1B.7
19828:  BCF    FF2.7
1982A:  MOVFF  743,A41
1982E:  MOVFF  742,A40
19832:  CALL   119A
19836:  BTFSC  1B.7
19838:  BSF    FF2.7
1983A:  MOVLW  0D
1983C:  BTFSS  F9E.4
1983E:  BRA    1983C
19840:  MOVWF  FAD
19842:  MOVLW  0A
19844:  BTFSS  F9E.4
19846:  BRA    19844
19848:  MOVWF  FAD
....................        
....................       hold_pc  = ((m_pwm_hld[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
1984A:  MOVFF  755,A11
1984E:  MOVFF  754,A10
19852:  MOVLB  A
19854:  CLRF   x13
19856:  MOVLW  64
19858:  MOVWF  x12
1985A:  MOVLB  0
1985C:  CALL   5C8C
19860:  MOVFF  02,88C
19864:  MOVFF  01,88B
19868:  MOVFF  02,8DC
1986C:  MOVFF  01,8DB
19870:  MOVLW  01
19872:  MOVLB  8
19874:  MOVWF  xDE
19876:  SETF   xDD
19878:  MOVLB  0
1987A:  CALL   2CC8
1987E:  MOVFF  02,886
19882:  MOVFF  01,885
....................       drive_pc = ((m_pwm_drv[1]*100) / (((T2_MID_VAL+1)*4)-1)); 
19886:  MOVFF  759,A11
1988A:  MOVFF  758,A10
1988E:  MOVLB  A
19890:  CLRF   x13
19892:  MOVLW  64
19894:  MOVWF  x12
19896:  MOVLB  0
19898:  CALL   5C8C
1989C:  MOVFF  02,88C
198A0:  MOVFF  01,88B
198A4:  MOVFF  02,8DC
198A8:  MOVFF  01,8DB
198AC:  MOVLW  01
198AE:  MOVLB  8
198B0:  MOVWF  xDE
198B2:  SETF   xDD
198B4:  MOVLB  0
198B6:  CALL   2CC8
198BA:  MOVFF  02,888
198BE:  MOVFF  01,887
....................       step_us  =   m_stp_int[1]*100; 
198C2:  MOVFF  74D,A11
198C6:  MOVFF  74C,A10
198CA:  MOVLB  A
198CC:  CLRF   x13
198CE:  MOVLW  64
198D0:  MOVWF  x12
198D2:  MOVLB  0
198D4:  CALL   5C8C
198D8:  MOVFF  02,88A
198DC:  MOVFF  01,889
....................        
....................       fprintf(COM_A, "[motor:2]\r\n"); 
198E0:  MOVLW  1A
198E2:  MOVWF  FF6
198E4:  MOVLW  27
198E6:  MOVWF  FF7
198E8:  MOVLW  00
198EA:  MOVWF  FF8
198EC:  CLRF   1B
198EE:  BTFSC  FF2.7
198F0:  BSF    1B.7
198F2:  BCF    FF2.7
198F4:  CALL   0E42
198F8:  BTFSC  1B.7
198FA:  BSF    FF2.7
....................       fprintf(COM_A, "b:%Lu\r\n",m_bklsh[1]); 
198FC:  MOVLW  62
198FE:  BTFSS  F9E.4
19900:  BRA    198FE
19902:  MOVWF  FAD
19904:  MOVLW  3A
19906:  BTFSS  F9E.4
19908:  BRA    19906
1990A:  MOVWF  FAD
1990C:  MOVLW  10
1990E:  MOVWF  FE9
19910:  CLRF   1B
19912:  BTFSC  FF2.7
19914:  BSF    1B.7
19916:  BCF    FF2.7
19918:  MOVFF  775,A41
1991C:  MOVFF  774,A40
19920:  CALL   119A
19924:  BTFSC  1B.7
19926:  BSF    FF2.7
19928:  MOVLW  0D
1992A:  BTFSS  F9E.4
1992C:  BRA    1992A
1992E:  MOVWF  FAD
19930:  MOVLW  0A
19932:  BTFSS  F9E.4
19934:  BRA    19932
19936:  MOVWF  FAD
....................       fprintf(COM_A, "c:%Lu/%Lu/%Lu\r\n",m_step_cnt[1],e_cha_cnt[1],e_pos[1]); 
19938:  MOVLW  63
1993A:  BTFSS  F9E.4
1993C:  BRA    1993A
1993E:  MOVWF  FAD
19940:  MOVLW  3A
19942:  BTFSS  F9E.4
19944:  BRA    19942
19946:  MOVWF  FAD
19948:  MOVLW  41
1994A:  MOVWF  FE9
1994C:  CLRF   1B
1994E:  BTFSC  FF2.7
19950:  BSF    1B.7
19952:  BCF    FF2.7
19954:  MOVFF  7A9,A43
19958:  MOVFF  7A8,A42
1995C:  MOVFF  7A7,A41
19960:  MOVFF  7A6,A40
19964:  CALL   10DE
19968:  BTFSC  1B.7
1996A:  BSF    FF2.7
1996C:  MOVLW  2F
1996E:  BTFSS  F9E.4
19970:  BRA    1996E
19972:  MOVWF  FAD
19974:  MOVLW  10
19976:  MOVWF  FE9
19978:  CLRF   1B
1997A:  BTFSC  FF2.7
1997C:  BSF    1B.7
1997E:  BCF    FF2.7
19980:  MOVFF  7BE,A41
19984:  MOVFF  7BD,A40
19988:  CALL   119A
1998C:  BTFSC  1B.7
1998E:  BSF    FF2.7
19990:  MOVLW  2F
19992:  BTFSS  F9E.4
19994:  BRA    19992
19996:  MOVWF  FAD
19998:  MOVLW  10
1999A:  MOVWF  FE9
1999C:  CLRF   1B
1999E:  BTFSC  FF2.7
199A0:  BSF    1B.7
199A2:  BCF    FF2.7
199A4:  MOVFF  7C2,A41
199A8:  MOVFF  7C1,A40
199AC:  CALL   119A
199B0:  BTFSC  1B.7
199B2:  BSF    FF2.7
199B4:  MOVLW  0D
199B6:  BTFSS  F9E.4
199B8:  BRA    199B6
199BA:  MOVWF  FAD
199BC:  MOVLW  0A
199BE:  BTFSS  F9E.4
199C0:  BRA    199BE
199C2:  MOVWF  FAD
....................       fprintf(COM_A, "d:%Lu\r\n",m_pos_dir[1]); 
199C4:  MOVLW  64
199C6:  BTFSS  F9E.4
199C8:  BRA    199C6
199CA:  MOVWF  FAD
199CC:  MOVLW  3A
199CE:  BTFSS  F9E.4
199D0:  BRA    199CE
199D2:  MOVWF  FAD
199D4:  MOVLW  10
199D6:  MOVWF  FE9
199D8:  CLRF   1B
199DA:  BTFSC  FF2.7
199DC:  BSF    1B.7
199DE:  BCF    FF2.7
199E0:  MOVFF  751,A41
199E4:  MOVFF  750,A40
199E8:  CALL   119A
199EC:  BTFSC  1B.7
199EE:  BSF    FF2.7
199F0:  MOVLW  0D
199F2:  BTFSS  F9E.4
199F4:  BRA    199F2
199F6:  MOVWF  FAD
199F8:  MOVLW  0A
199FA:  BTFSS  F9E.4
199FC:  BRA    199FA
199FE:  MOVWF  FAD
....................       fprintf(COM_A, "e:%Lu\r\n",e_cpr[1]); 
19A00:  MOVLW  65
19A02:  BTFSS  F9E.4
19A04:  BRA    19A02
19A06:  MOVWF  FAD
19A08:  MOVLW  3A
19A0A:  BTFSS  F9E.4
19A0C:  BRA    19A0A
19A0E:  MOVWF  FAD
19A10:  MOVLW  10
19A12:  MOVWF  FE9
19A14:  CLRF   1B
19A16:  BTFSC  FF2.7
19A18:  BSF    1B.7
19A1A:  BCF    FF2.7
19A1C:  MOVFF  761,A41
19A20:  MOVFF  760,A40
19A24:  CALL   119A
19A28:  BTFSC  1B.7
19A2A:  BSF    FF2.7
19A2C:  MOVLW  0D
19A2E:  BTFSS  F9E.4
19A30:  BRA    19A2E
19A32:  MOVWF  FAD
19A34:  MOVLW  0A
19A36:  BTFSS  F9E.4
19A38:  BRA    19A36
19A3A:  MOVWF  FAD
....................       fprintf(COM_A, "f:%u\r\n",m_fixed); 
19A3C:  MOVLW  66
19A3E:  BTFSS  F9E.4
19A40:  BRA    19A3E
19A42:  MOVWF  FAD
19A44:  MOVLW  3A
19A46:  BTFSS  F9E.4
19A48:  BRA    19A46
19A4A:  MOVWF  FAD
19A4C:  CLRF   1B
19A4E:  BTFSC  FF2.7
19A50:  BSF    1B.7
19A52:  BCF    FF2.7
19A54:  MOVFF  741,A40
19A58:  MOVLW  1B
19A5A:  MOVLB  A
19A5C:  MOVWF  x41
19A5E:  MOVLB  0
19A60:  CALL   0F9A
19A64:  BTFSC  1B.7
19A66:  BSF    FF2.7
19A68:  MOVLW  0D
19A6A:  BTFSS  F9E.4
19A6C:  BRA    19A6A
19A6E:  MOVWF  FAD
19A70:  MOVLW  0A
19A72:  BTFSS  F9E.4
19A74:  BRA    19A72
19A76:  MOVWF  FAD
....................       fprintf(COM_A, "g:%Lu\r\n",m_gb_err[1]); 
19A78:  MOVLW  67
19A7A:  BTFSS  F9E.4
19A7C:  BRA    19A7A
19A7E:  MOVWF  FAD
19A80:  MOVLW  3A
19A82:  BTFSS  F9E.4
19A84:  BRA    19A82
19A86:  MOVWF  FAD
19A88:  MOVLW  10
19A8A:  MOVWF  FE9
19A8C:  CLRF   1B
19A8E:  BTFSC  FF2.7
19A90:  BSF    1B.7
19A92:  BCF    FF2.7
19A94:  MOVFF  75D,A41
19A98:  MOVFF  75C,A40
19A9C:  CALL   119A
19AA0:  BTFSC  1B.7
19AA2:  BSF    FF2.7
19AA4:  MOVLW  0D
19AA6:  BTFSS  F9E.4
19AA8:  BRA    19AA6
19AAA:  MOVWF  FAD
19AAC:  MOVLW  0A
19AAE:  BTFSS  F9E.4
19AB0:  BRA    19AAE
19AB2:  MOVWF  FAD
....................       fprintf(COM_A, "h:%Lu\r\n",hold_pc); 
19AB4:  MOVLW  68
19AB6:  BTFSS  F9E.4
19AB8:  BRA    19AB6
19ABA:  MOVWF  FAD
19ABC:  MOVLW  3A
19ABE:  BTFSS  F9E.4
19AC0:  BRA    19ABE
19AC2:  MOVWF  FAD
19AC4:  MOVLW  10
19AC6:  MOVWF  FE9
19AC8:  CLRF   1B
19ACA:  BTFSC  FF2.7
19ACC:  BSF    1B.7
19ACE:  BCF    FF2.7
19AD0:  MOVFF  886,A41
19AD4:  MOVFF  885,A40
19AD8:  CALL   119A
19ADC:  BTFSC  1B.7
19ADE:  BSF    FF2.7
19AE0:  MOVLW  0D
19AE2:  BTFSS  F9E.4
19AE4:  BRA    19AE2
19AE6:  MOVWF  FAD
19AE8:  MOVLW  0A
19AEA:  BTFSS  F9E.4
19AEC:  BRA    19AEA
19AEE:  MOVWF  FAD
....................       fprintf(COM_A, "i:%Lu\r\n",step_us); 
19AF0:  MOVLW  69
19AF2:  BTFSS  F9E.4
19AF4:  BRA    19AF2
19AF6:  MOVWF  FAD
19AF8:  MOVLW  3A
19AFA:  BTFSS  F9E.4
19AFC:  BRA    19AFA
19AFE:  MOVWF  FAD
19B00:  MOVLW  10
19B02:  MOVWF  FE9
19B04:  CLRF   1B
19B06:  BTFSC  FF2.7
19B08:  BSF    1B.7
19B0A:  BCF    FF2.7
19B0C:  MOVFF  88A,A41
19B10:  MOVFF  889,A40
19B14:  CALL   119A
19B18:  BTFSC  1B.7
19B1A:  BSF    FF2.7
19B1C:  MOVLW  0D
19B1E:  BTFSS  F9E.4
19B20:  BRA    19B1E
19B22:  MOVWF  FAD
19B24:  MOVLW  0A
19B26:  BTFSS  F9E.4
19B28:  BRA    19B26
19B2A:  MOVWF  FAD
....................       fprintf(COM_A, "j:%Lu\r\n",m_run[1]);       
19B2C:  MOVLW  6A
19B2E:  BTFSS  F9E.4
19B30:  BRA    19B2E
19B32:  MOVWF  FAD
19B34:  MOVLW  3A
19B36:  BTFSS  F9E.4
19B38:  BRA    19B36
19B3A:  MOVWF  FAD
19B3C:  MOVLW  10
19B3E:  MOVWF  FE9
19B40:  CLRF   1B
19B42:  BTFSC  FF2.7
19B44:  BSF    1B.7
19B46:  BCF    FF2.7
19B48:  MOVFF  771,A41
19B4C:  MOVFF  770,A40
19B50:  CALL   119A
19B54:  BTFSC  1B.7
19B56:  BSF    FF2.7
19B58:  MOVLW  0D
19B5A:  BTFSS  F9E.4
19B5C:  BRA    19B5A
19B5E:  MOVWF  FAD
19B60:  MOVLW  0A
19B62:  BTFSS  F9E.4
19B64:  BRA    19B62
19B66:  MOVWF  FAD
....................       fprintf(COM_A, "k:%Lu\r\n",e_mode[1]); 
19B68:  MOVLW  6B
19B6A:  BTFSS  F9E.4
19B6C:  BRA    19B6A
19B6E:  MOVWF  FAD
19B70:  MOVLW  3A
19B72:  BTFSS  F9E.4
19B74:  BRA    19B72
19B76:  MOVWF  FAD
19B78:  MOVLW  10
19B7A:  MOVWF  FE9
19B7C:  CLRF   1B
19B7E:  BTFSC  FF2.7
19B80:  BSF    1B.7
19B82:  BCF    FF2.7
19B84:  MOVFF  769,A41
19B88:  MOVFF  768,A40
19B8C:  CALL   119A
19B90:  BTFSC  1B.7
19B92:  BSF    FF2.7
19B94:  MOVLW  0D
19B96:  BTFSS  F9E.4
19B98:  BRA    19B96
19B9A:  MOVWF  FAD
19B9C:  MOVLW  0A
19B9E:  BTFSS  F9E.4
19BA0:  BRA    19B9E
19BA2:  MOVWF  FAD
....................       fprintf(COM_A, "m:%Lu\r\n",m_mode[1]); 
19BA4:  MOVLW  6D
19BA6:  BTFSS  F9E.4
19BA8:  BRA    19BA6
19BAA:  MOVWF  FAD
19BAC:  MOVLW  3A
19BAE:  BTFSS  F9E.4
19BB0:  BRA    19BAE
19BB2:  MOVWF  FAD
19BB4:  MOVLW  10
19BB6:  MOVWF  FE9
19BB8:  CLRF   1B
19BBA:  BTFSC  FF2.7
19BBC:  BSF    1B.7
19BBE:  BCF    FF2.7
19BC0:  MOVFF  749,A41
19BC4:  MOVFF  748,A40
19BC8:  CALL   119A
19BCC:  BTFSC  1B.7
19BCE:  BSF    FF2.7
19BD0:  MOVLW  0D
19BD2:  BTFSS  F9E.4
19BD4:  BRA    19BD2
19BD6:  MOVWF  FAD
19BD8:  MOVLW  0A
19BDA:  BTFSS  F9E.4
19BDC:  BRA    19BDA
19BDE:  MOVWF  FAD
....................       fprintf(COM_A, "n:%Lu\r\n",e_index[1]); 
19BE0:  MOVLW  6E
19BE2:  BTFSS  F9E.4
19BE4:  BRA    19BE2
19BE6:  MOVWF  FAD
19BE8:  MOVLW  3A
19BEA:  BTFSS  F9E.4
19BEC:  BRA    19BEA
19BEE:  MOVWF  FAD
19BF0:  MOVLW  10
19BF2:  MOVWF  FE9
19BF4:  CLRF   1B
19BF6:  BTFSC  FF2.7
19BF8:  BSF    1B.7
19BFA:  BCF    FF2.7
19BFC:  MOVFF  77D,A41
19C00:  MOVFF  77C,A40
19C04:  CALL   119A
19C08:  BTFSC  1B.7
19C0A:  BSF    FF2.7
19C0C:  MOVLW  0D
19C0E:  BTFSS  F9E.4
19C10:  BRA    19C0E
19C12:  MOVWF  FAD
19C14:  MOVLW  0A
19C16:  BTFSS  F9E.4
19C18:  BRA    19C16
19C1A:  MOVWF  FAD
....................       fprintf(COM_A, "o:%Lu\r\n",evn_so[1]); 
19C1C:  MOVLW  6F
19C1E:  BTFSS  F9E.4
19C20:  BRA    19C1E
19C22:  MOVWF  FAD
19C24:  MOVLW  3A
19C26:  BTFSS  F9E.4
19C28:  BRA    19C26
19C2A:  MOVWF  FAD
19C2C:  MOVLW  10
19C2E:  MOVWF  FE9
19C30:  CLRF   1B
19C32:  BTFSC  FF2.7
19C34:  BSF    1B.7
19C36:  BCF    FF2.7
19C38:  MOVFF  781,A41
19C3C:  MOVFF  780,A40
19C40:  CALL   119A
19C44:  BTFSC  1B.7
19C46:  BSF    FF2.7
19C48:  MOVLW  0D
19C4A:  BTFSS  F9E.4
19C4C:  BRA    19C4A
19C4E:  MOVWF  FAD
19C50:  MOVLW  0A
19C52:  BTFSS  F9E.4
19C54:  BRA    19C52
19C56:  MOVWF  FAD
....................       fprintf(COM_A, "p:%Lu/%Lu\r\n",e_port[1],e_ppr[1]); 
19C58:  MOVLW  70
19C5A:  BTFSS  F9E.4
19C5C:  BRA    19C5A
19C5E:  MOVWF  FAD
19C60:  MOVLW  3A
19C62:  BTFSS  F9E.4
19C64:  BRA    19C62
19C66:  MOVWF  FAD
19C68:  MOVLW  10
19C6A:  MOVWF  FE9
19C6C:  CLRF   1B
19C6E:  BTFSC  FF2.7
19C70:  BSF    1B.7
19C72:  BCF    FF2.7
19C74:  MOVFF  7C6,A41
19C78:  MOVFF  7C5,A40
19C7C:  CALL   119A
19C80:  BTFSC  1B.7
19C82:  BSF    FF2.7
19C84:  MOVLW  2F
19C86:  BTFSS  F9E.4
19C88:  BRA    19C86
19C8A:  MOVWF  FAD
19C8C:  MOVLW  10
19C8E:  MOVWF  FE9
19C90:  CLRF   1B
19C92:  BTFSC  FF2.7
19C94:  BSF    1B.7
19C96:  BCF    FF2.7
19C98:  MOVFF  765,A41
19C9C:  MOVFF  764,A40
19CA0:  CALL   119A
19CA4:  BTFSC  1B.7
19CA6:  BSF    FF2.7
19CA8:  MOVLW  0D
19CAA:  BTFSS  F9E.4
19CAC:  BRA    19CAA
19CAE:  MOVWF  FAD
19CB0:  MOVLW  0A
19CB2:  BTFSS  F9E.4
19CB4:  BRA    19CB2
19CB6:  MOVWF  FAD
....................       fprintf(COM_A, "q:%Lu\r\n",m_error[1]); 
19CB8:  MOVLW  71
19CBA:  BTFSS  F9E.4
19CBC:  BRA    19CBA
19CBE:  MOVWF  FAD
19CC0:  MOVLW  3A
19CC2:  BTFSS  F9E.4
19CC4:  BRA    19CC2
19CC6:  MOVWF  FAD
19CC8:  MOVLW  10
19CCA:  MOVWF  FE9
19CCC:  CLRF   1B
19CCE:  BTFSC  FF2.7
19CD0:  BSF    1B.7
19CD2:  BCF    FF2.7
19CD4:  MOVFF  799,A41
19CD8:  MOVFF  798,A40
19CDC:  CALL   119A
19CE0:  BTFSC  1B.7
19CE2:  BSF    FF2.7
19CE4:  MOVLW  0D
19CE6:  BTFSS  F9E.4
19CE8:  BRA    19CE6
19CEA:  MOVWF  FAD
19CEC:  MOVLW  0A
19CEE:  BTFSS  F9E.4
19CF0:  BRA    19CEE
19CF2:  MOVWF  FAD
....................       fprintf(COM_A, "s:%Lu\r\n",m_spr[1]);             
19CF4:  MOVLW  73
19CF6:  BTFSS  F9E.4
19CF8:  BRA    19CF6
19CFA:  MOVWF  FAD
19CFC:  MOVLW  3A
19CFE:  BTFSS  F9E.4
19D00:  BRA    19CFE
19D02:  MOVWF  FAD
19D04:  MOVLW  10
19D06:  MOVWF  FE9
19D08:  CLRF   1B
19D0A:  BTFSC  FF2.7
19D0C:  BSF    1B.7
19D0E:  BCF    FF2.7
19D10:  MOVFF  779,A41
19D14:  MOVFF  778,A40
19D18:  CALL   119A
19D1C:  BTFSC  1B.7
19D1E:  BSF    FF2.7
19D20:  MOVLW  0D
19D22:  BTFSS  F9E.4
19D24:  BRA    19D22
19D26:  MOVWF  FAD
19D28:  MOVLW  0A
19D2A:  BTFSS  F9E.4
19D2C:  BRA    19D2A
19D2E:  MOVWF  FAD
....................       fprintf(COM_A, "t:%Lu\r\n",e_type[1]);       
19D30:  MOVLW  74
19D32:  BTFSS  F9E.4
19D34:  BRA    19D32
19D36:  MOVWF  FAD
19D38:  MOVLW  3A
19D3A:  BTFSS  F9E.4
19D3C:  BRA    19D3A
19D3E:  MOVWF  FAD
19D40:  MOVLW  10
19D42:  MOVWF  FE9
19D44:  CLRF   1B
19D46:  BTFSC  FF2.7
19D48:  BSF    1B.7
19D4A:  BCF    FF2.7
19D4C:  MOVFF  76D,A41
19D50:  MOVFF  76C,A40
19D54:  CALL   119A
19D58:  BTFSC  1B.7
19D5A:  BSF    FF2.7
19D5C:  MOVLW  0D
19D5E:  BTFSS  F9E.4
19D60:  BRA    19D5E
19D62:  MOVWF  FAD
19D64:  MOVLW  0A
19D66:  BTFSS  F9E.4
19D68:  BRA    19D66
19D6A:  MOVWF  FAD
....................       fprintf(COM_A, "u:%u\r\n",(motor+1)); 
19D6C:  MOVLW  01
19D6E:  MOVLB  7
19D70:  ADDWF  x40,W
19D72:  MOVLB  8
19D74:  MOVWF  x8B
19D76:  MOVLW  75
19D78:  BTFSS  F9E.4
19D7A:  BRA    19D78
19D7C:  MOVWF  FAD
19D7E:  MOVLW  3A
19D80:  BTFSS  F9E.4
19D82:  BRA    19D80
19D84:  MOVWF  FAD
19D86:  CLRF   1B
19D88:  BTFSC  FF2.7
19D8A:  BSF    1B.7
19D8C:  BCF    FF2.7
19D8E:  MOVFF  88B,A40
19D92:  MOVLW  1B
19D94:  MOVLB  A
19D96:  MOVWF  x41
19D98:  MOVLB  0
19D9A:  CALL   0F9A
19D9E:  BTFSC  1B.7
19DA0:  BSF    FF2.7
19DA2:  MOVLW  0D
19DA4:  BTFSS  F9E.4
19DA6:  BRA    19DA4
19DA8:  MOVWF  FAD
19DAA:  MOVLW  0A
19DAC:  BTFSS  F9E.4
19DAE:  BRA    19DAC
19DB0:  MOVWF  FAD
....................       fprintf(COM_A, "w:%Lu\r\n",drive_pc); 
19DB2:  MOVLW  77
19DB4:  BTFSS  F9E.4
19DB6:  BRA    19DB4
19DB8:  MOVWF  FAD
19DBA:  MOVLW  3A
19DBC:  BTFSS  F9E.4
19DBE:  BRA    19DBC
19DC0:  MOVWF  FAD
19DC2:  MOVLW  10
19DC4:  MOVWF  FE9
19DC6:  CLRF   1B
19DC8:  BTFSC  FF2.7
19DCA:  BSF    1B.7
19DCC:  BCF    FF2.7
19DCE:  MOVFF  888,A41
19DD2:  MOVFF  887,A40
19DD6:  CALL   119A
19DDA:  BTFSC  1B.7
19DDC:  BSF    FF2.7
19DDE:  MOVLW  0D
19DE0:  BTFSS  F9E.4
19DE2:  BRA    19DE0
19DE4:  MOVWF  FAD
19DE6:  MOVLW  0A
19DE8:  BTFSS  F9E.4
19DEA:  BRA    19DE8
19DEC:  MOVWF  FAD
....................       fprintf(COM_A, "x:%Lu\r\n",align_os[1]); 
19DEE:  MOVLW  78
19DF0:  BTFSS  F9E.4
19DF2:  BRA    19DF0
19DF4:  MOVWF  FAD
19DF6:  MOVLW  3A
19DF8:  BTFSS  F9E.4
19DFA:  BRA    19DF8
19DFC:  MOVWF  FAD
19DFE:  MOVLW  10
19E00:  MOVWF  FE9
19E02:  CLRF   1B
19E04:  BTFSC  FF2.7
19E06:  BSF    1B.7
19E08:  BCF    FF2.7
19E0A:  MOVFF  785,A41
19E0E:  MOVFF  784,A40
19E12:  CALL   119A
19E16:  BTFSC  1B.7
19E18:  BSF    FF2.7
19E1A:  MOVLW  0D
19E1C:  BTFSS  F9E.4
19E1E:  BRA    19E1C
19E20:  MOVWF  FAD
19E22:  MOVLW  0A
19E24:  BTFSS  F9E.4
19E26:  BRA    19E24
19E28:  MOVWF  FAD
....................       fprintf(COM_A, "y:%Lu\r\n",m_ctrl[1]);  
19E2A:  MOVLW  79
19E2C:  BTFSS  F9E.4
19E2E:  BRA    19E2C
19E30:  MOVWF  FAD
19E32:  MOVLW  3A
19E34:  BTFSS  F9E.4
19E36:  BRA    19E34
19E38:  MOVWF  FAD
19E3A:  MOVLW  10
19E3C:  MOVWF  FE9
19E3E:  CLRF   1B
19E40:  BTFSC  FF2.7
19E42:  BSF    1B.7
19E44:  BCF    FF2.7
19E46:  MOVFF  745,A41
19E4A:  MOVFF  744,A40
19E4E:  CALL   119A
19E52:  BTFSC  1B.7
19E54:  BSF    FF2.7
19E56:  MOVLW  0D
19E58:  BTFSS  F9E.4
19E5A:  BRA    19E58
19E5C:  MOVWF  FAD
19E5E:  MOVLW  0A
19E60:  BTFSS  F9E.4
19E62:  BRA    19E60
19E64:  MOVWF  FAD
....................    } 
19E66:  BRA    19E6C
....................    else cmd_arg(); 
19E68:  CALL   B2F2
19E6C:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_star() 
.................... { 
....................    if(arg == 1805) file_list(file_ptr_events); 
*
0BF3A:  MOVF   48,W
0BF3C:  SUBLW  0D
0BF3E:  BNZ   BF5E
0BF40:  MOVF   49,W
0BF42:  SUBLW  07
0BF44:  BNZ   BF5E
0BF46:  MOVF   4A,F
0BF48:  BNZ   BF5E
0BF4A:  MOVF   4B,F
0BF4C:  BNZ   BF5E
0BF4E:  MOVLW  03
0BF50:  MOVLB  8
0BF52:  MOVWF  x8A
0BF54:  MOVLW  15
0BF56:  MOVWF  x89
0BF58:  MOVLB  0
0BF5A:  RCALL  BB18
0BF5C:  BRA    BF80
....................    else if (arg == 1944) f_unlink(file_ptr_events); 
0BF5E:  MOVF   48,W
0BF60:  SUBLW  98
0BF62:  BNZ   BF80
0BF64:  MOVF   49,W
0BF66:  SUBLW  07
0BF68:  BNZ   BF80
0BF6A:  MOVF   4A,F
0BF6C:  BNZ   BF80
0BF6E:  MOVF   4B,F
0BF70:  BNZ   BF80
0BF72:  MOVLW  03
0BF74:  MOVLB  8
0BF76:  MOVWF  x8A
0BF78:  MOVLW  15
0BF7A:  MOVWF  x89
0BF7C:  MOVLB  0
0BF7E:  RCALL  BC92
0BF80:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_prod() 
.................... { 
....................    switch (arg){ 
*
0B34C:  MOVF   48,W
0B34E:  MOVWF  00
0B350:  MOVFF  49,03
0B354:  MOVLW  15
0B356:  SUBWF  49,W
0B358:  BNZ   B360
0B35A:  MOVLW  95
0B35C:  SUBWF  00,W
0B35E:  BZ    B386
0B360:  MOVLW  15
0B362:  SUBWF  03,W
0B364:  BNZ   B36C
0B366:  MOVLW  96
0B368:  SUBWF  00,W
0B36A:  BZ    B3B8
0B36C:  MOVLW  15
0B36E:  SUBWF  03,W
0B370:  BNZ   B378
0B372:  MOVLW  97
0B374:  SUBWF  00,W
0B376:  BZ    B3EE
0B378:  MOVLW  15
0B37A:  SUBWF  03,W
0B37C:  BNZ   B384
0B37E:  MOVLW  98
0B380:  SUBWF  00,W
0B382:  BZ    B424
0B384:  BRA    B458
....................       case 5525 : nv_product = ECO; 
0B386:  CLRF   30
0B388:  CLRF   2F
....................                   write16(ADDR_PRODUCT, ECO); 
0B38A:  MOVLW  1E
0B38C:  MOVLB  8
0B38E:  MOVWF  xEE
0B390:  CLRF   xF0
0B392:  CLRF   xEF
0B394:  MOVLB  0
0B396:  CALL   4FC8
....................                   sprintf(event_str, ",ECO mode set\r\n"); 
0B39A:  MOVLW  01
0B39C:  MOVWF  1E
0B39E:  MOVLW  A7
0B3A0:  MOVWF  1D
0B3A2:  MOVLW  26
0B3A4:  MOVWF  FF6
0B3A6:  MOVLW  27
0B3A8:  MOVWF  FF7
0B3AA:  MOVLW  00
0B3AC:  MOVWF  FF8
0B3AE:  CALL   50B2
....................                   record_event(); 
0B3B2:  CALL   84CE
....................          break; 
0B3B6:  BRA    B458
....................       case 5526 : nv_product = WMS4; 
0B3B8:  CLRF   30
0B3BA:  MOVLW  01
0B3BC:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS4); 
0B3BE:  MOVLW  1E
0B3C0:  MOVLB  8
0B3C2:  MOVWF  xEE
0B3C4:  CLRF   xF0
0B3C6:  MOVLW  01
0B3C8:  MOVWF  xEF
0B3CA:  MOVLB  0
0B3CC:  CALL   4FC8
....................                   sprintf(event_str, ",WMS-4-SD mode set\r\n"); 
0B3D0:  MOVLW  01
0B3D2:  MOVWF  1E
0B3D4:  MOVLW  A7
0B3D6:  MOVWF  1D
0B3D8:  MOVLW  36
0B3DA:  MOVWF  FF6
0B3DC:  MOVLW  27
0B3DE:  MOVWF  FF7
0B3E0:  MOVLW  00
0B3E2:  MOVWF  FF8
0B3E4:  CALL   50B2
....................                   record_event();                   
0B3E8:  CALL   84CE
....................          break;    
0B3EC:  BRA    B458
....................       case 5527 : nv_product = AWS; 
0B3EE:  CLRF   30
0B3F0:  MOVLW  02
0B3F2:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, AWS); 
0B3F4:  MOVLW  1E
0B3F6:  MOVLB  8
0B3F8:  MOVWF  xEE
0B3FA:  CLRF   xF0
0B3FC:  MOVLW  02
0B3FE:  MOVWF  xEF
0B400:  MOVLB  0
0B402:  CALL   4FC8
....................                   sprintf(event_str, ",AWS mode set\r\n"); 
0B406:  MOVLW  01
0B408:  MOVWF  1E
0B40A:  MOVLW  A7
0B40C:  MOVWF  1D
0B40E:  MOVLW  4C
0B410:  MOVWF  FF6
0B412:  MOVLW  27
0B414:  MOVWF  FF7
0B416:  MOVLW  00
0B418:  MOVWF  FF8
0B41A:  CALL   50B2
....................                   record_event();                   
0B41E:  CALL   84CE
....................          break;   
0B422:  BRA    B458
....................       case 5528 : nv_product = WMS2; 
0B424:  CLRF   30
0B426:  MOVLW  03
0B428:  MOVWF  2F
....................                   write16(ADDR_PRODUCT, WMS2); 
0B42A:  MOVLW  1E
0B42C:  MOVLB  8
0B42E:  MOVWF  xEE
0B430:  CLRF   xF0
0B432:  MOVLW  03
0B434:  MOVWF  xEF
0B436:  MOVLB  0
0B438:  CALL   4FC8
....................                   sprintf(event_str, ",WMS-4-QE mode set\r\n"); 
0B43C:  MOVLW  01
0B43E:  MOVWF  1E
0B440:  MOVLW  A7
0B442:  MOVWF  1D
0B444:  MOVLW  5C
0B446:  MOVWF  FF6
0B448:  MOVLW  27
0B44A:  MOVWF  FF7
0B44C:  MOVLW  00
0B44E:  MOVWF  FF8
0B450:  CALL   50B2
....................                   record_event();                   
0B454:  CALL   84CE
....................          break;            
....................    } 
0B458:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_hash() 
.................... { 
....................    switch(arg){ 
*
0B310:  MOVF   48,W
0B312:  MOVWF  00
0B314:  MOVF   49,W
0B316:  MOVWF  03
0B318:  BNZ   B31E
0B31A:  MOVF   00,F
0B31C:  BZ    B334
0B31E:  MOVF   03,W
0B320:  BNZ   B328
0B322:  MOVLW  01
0B324:  SUBWF  00,W
0B326:  BZ    B33A
0B328:  MOVF   03,W
0B32A:  BNZ   B332
0B32C:  MOVLW  02
0B32E:  SUBWF  00,W
0B330:  BZ    B340
0B332:  BRA    B346
....................       case 0 : kill_wd(); 
0B334:  CALL   30EA
....................          break; 
0B338:  BRA    B348
....................       case 1 : start_heartbeat(); 
0B33A:  CALL   28F4
....................          break; 
0B33E:  BRA    B348
....................       case 2 : suspend_heartbeat(); 
0B340:  CALL   5548
....................          break; 
0B344:  BRA    B348
....................       default : cmd_arg(); 
0B346:  RCALL  B2F2
....................          break; 
....................    } 
0B348:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void commandFW() 
.................... { 
....................    switch(arg){ 
*
0B250:  MOVF   48,W
0B252:  MOVWF  00
0B254:  MOVF   49,W
0B256:  MOVWF  03
0B258:  BNZ   B25E
0B25A:  MOVF   00,F
0B25C:  BZ    B26C
0B25E:  MOVLW  15
0B260:  SUBWF  03,W
0B262:  BNZ   B26A
0B264:  MOVLW  95
0B266:  SUBWF  00,W
0B268:  BZ    B2CA
0B26A:  BRA    B2EE
....................       case 0:     signon(); 
0B26C:  CALL   313C
....................                   fprintf(COM_A, __DATE__); 
0B270:  MOVLW  72
0B272:  MOVWF  FF6
0B274:  MOVLW  27
0B276:  MOVWF  FF7
0B278:  MOVLW  00
0B27A:  MOVWF  FF8
0B27C:  CLRF   1B
0B27E:  BTFSC  FF2.7
0B280:  BSF    1B.7
0B282:  BCF    FF2.7
0B284:  CALL   0E42
0B288:  BTFSC  1B.7
0B28A:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B28C:  MOVLW  0D
0B28E:  BTFSS  F9E.4
0B290:  BRA    B28E
0B292:  MOVWF  FAD
0B294:  MOVLW  0A
0B296:  BTFSS  F9E.4
0B298:  BRA    B296
0B29A:  MOVWF  FAD
....................                   fprintf(COM_A, __TIME__); 
0B29C:  MOVLW  7C
0B29E:  MOVWF  FF6
0B2A0:  MOVLW  27
0B2A2:  MOVWF  FF7
0B2A4:  MOVLW  00
0B2A6:  MOVWF  FF8
0B2A8:  CLRF   1B
0B2AA:  BTFSC  FF2.7
0B2AC:  BSF    1B.7
0B2AE:  BCF    FF2.7
0B2B0:  CALL   0E42
0B2B4:  BTFSC  1B.7
0B2B6:  BSF    FF2.7
....................                   fprintf(COM_A, "\r\n"); 
0B2B8:  MOVLW  0D
0B2BA:  BTFSS  F9E.4
0B2BC:  BRA    B2BA
0B2BE:  MOVWF  FAD
0B2C0:  MOVLW  0A
0B2C2:  BTFSS  F9E.4
0B2C4:  BRA    B2C2
0B2C6:  MOVWF  FAD
....................          break; 
0B2C8:  BRA    B2EE
....................       case 5525 : kill_wd(); 
0B2CA:  CALL   30EA
....................                   fprintf(COM_A, "SEND HEX FILE (19200,N81,XON-XOFF)\r\n"); 
0B2CE:  MOVLW  86
0B2D0:  MOVWF  FF6
0B2D2:  MOVLW  27
0B2D4:  MOVWF  FF7
0B2D6:  MOVLW  00
0B2D8:  MOVWF  FF8
0B2DA:  CLRF   1B
0B2DC:  BTFSC  FF2.7
0B2DE:  BSF    1B.7
0B2E0:  BCF    FF2.7
0B2E2:  CALL   0E42
0B2E6:  BTFSC  1B.7
0B2E8:  BSF    FF2.7
....................                   load_program(); 
0B2EA:  CALL   1F800
....................          break; 
....................    } 
0B2EE:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void command_set() 
.................... { 
....................    switch (arg){ 
*
18B1C:  MOVF   48,W
18B1E:  MOVWF  00
18B20:  MOVF   49,W
18B22:  MOVWF  03
18B24:  BNZ   18B2A
18B26:  MOVF   00,F
18B28:  BZ    18B36
18B2A:  MOVF   03,W
18B2C:  BNZ   18B34
18B2E:  MOVLW  01
18B30:  SUBWF  00,W
18B32:  BZ    18B3A
18B34:  BRA    18B3E
....................       case 0 : cmd_set=0;  // user 
18B36:  CLRF   51
....................          break; 
18B38:  BRA    18B3E
....................       case 1 : cmd_set=1;  // full 
18B3A:  MOVLW  01
18B3C:  MOVWF  51
....................          break; 
....................    } 
18B3E:  GOTO   1B218 (RETURN)
.................... } 
....................  
.................... void select_cmd() 
.................... { 
....................    busy_clear(); 
*
1B07C:  CALL   AEA4
....................     
....................    switch (cmd) 
1B080:  MOVLW  23
1B082:  SUBWF  47,W
1B084:  ADDLW  A8
1B086:  BTFSC  FD8.0
1B088:  BRA    1B218
1B08A:  ADDLW  58
1B08C:  GOTO   1B21C
....................    { 
....................       case '&': commandFW(); 
1B090:  GOTO   B250
....................          break; 
1B094:  BRA    1B218
....................       case '#': command_hash(); 
1B096:  GOTO   B310
....................          break;          
1B09A:  BRA    1B218
....................       case '%': command_prod(); 
1B09C:  GOTO   B34C
....................          break; 
1B0A0:  BRA    1B218
....................       case '*': command_star(); 
1B0A2:  GOTO   BF3A
....................          break;       
1B0A6:  BRA    1B218
....................       // standard commands 
....................       case '/': command_addr(); 
1B0A8:  GOTO   BF84
....................          break; 
1B0AC:  BRA    1B218
....................       case 'A': commandA(); 
1B0AE:  GOTO   C11E
....................          break; 
1B0B2:  BRA    1B218
....................       case 'B': commandB(); 
1B0B4:  GOTO   C28A
....................          break; 
1B0B8:  BRA    1B218
....................       case 'C': commandC(); 
1B0BA:  GOTO   DCAE
....................          break; 
1B0BE:  BRA    1B218
....................       case 'D': commandD(); 
1B0C0:  GOTO   DCEC
....................          break; 
1B0C4:  BRA    1B218
....................       case 'E': commandE(); 
1B0C6:  GOTO   DD8A
....................          break;          
1B0CA:  BRA    1B218
....................       case 'F': commandF(); 
1B0CC:  GOTO   E088
....................          break;          
1B0D0:  BRA    1B218
....................       case 'G': commandG(); 
1B0D2:  GOTO   E0F2
....................          break; 
1B0D6:  BRA    1B218
....................       case 'H': commandH(); 
1B0D8:  GOTO   F250
....................          break; 
1B0DC:  BRA    1B218
....................       case 'I': commandI(); 
1B0DE:  GOTO   F290
....................          break;    
1B0E2:  BRA    1B218
....................       case 'J': commandJ(); 
1B0E4:  GOTO   F2DC
....................          break;      
1B0E8:  BRA    1B218
....................       case 'K': commandK(); 
1B0EA:  GOTO   F536
....................          break;    
1B0EE:  BRA    1B218
....................       case 'L': commandL(); 
1B0F0:  GOTO   104C2
....................          break;             
1B0F4:  BRA    1B218
....................       case 'M': commandM(FALSE); 
1B0F6:  MOVLB  8
1B0F8:  CLRF   x85
1B0FA:  MOVLB  0
1B0FC:  CALL   16DA0
....................          break;   
1B100:  BRA    1B218
....................       case 'N': commandN(); 
1B102:  GOTO   16EBE
....................          break;          
1B106:  BRA    1B218
....................       case 'O': commandO(); 
1B108:  GOTO   1706E
....................          break;    
1B10C:  BRA    1B218
....................       case 'P': commandP(); 
1B10E:  GOTO   17272
....................          break;  
1B112:  BRA    1B218
....................       case 'Q': commandQ(); 
1B114:  GOTO   17330
....................          break;              
1B118:  BRA    1B218
....................       case 'R': commandR(); 
1B11A:  GOTO   175C6
....................          break;    
1B11E:  BRA    1B218
....................       case 'S': commandS(); 
1B120:  GOTO   176F2
....................          break;  
1B124:  BRA    1B218
....................       case 'T': commandT(); 
1B126:  GOTO   17C90
....................          break;            
1B12A:  BRA    1B218
....................       case 'U': commandU(); 
1B12C:  GOTO   18698
....................          break;           
1B130:  BRA    1B218
....................       case 'V': commandV(); 
1B132:  GOTO   187F0
....................          break; 
1B136:  BRA    1B218
....................       case 'W': commandW(); 
1B138:  GOTO   18964
....................          break; 
1B13C:  BRA    1B218
....................       case 'X': commandX(); 
1B13E:  GOTO   18988
....................          break; 
1B142:  BRA    1B218
....................       case 'Y': commandY(); 
1B144:  GOTO   189F0
....................          break;  
1B148:  BRA    1B218
....................       case 'Z': commandZ(); 
1B14A:  CALL   18AF8
....................          break;    
1B14E:  BRA    1B218
....................       // stepper 
....................       case '^': command_set(); 
1B150:  GOTO   18B1C
....................          break;       
1B154:  BRA    1B218
....................       case '+': if(m_fixed==1) motor=1; 
1B156:  MOVLB  7
1B158:  DECFSZ x41,W
1B15A:  BRA    1B160
1B15C:  MOVLW  01
1B15E:  MOVWF  x40
....................                 command_move(0,0,1); 
1B160:  MOVLB  8
1B162:  CLRF   x85
1B164:  CLRF   x86
1B166:  MOVLW  01
1B168:  MOVWF  x87
1B16A:  MOVLB  0
1B16C:  CALL   17092
....................          break; 
1B170:  BRA    1B218
....................       case '-': if(m_fixed==1) motor=1; 
1B172:  MOVLB  7
1B174:  DECFSZ x41,W
1B176:  BRA    1B17C
1B178:  MOVLW  01
1B17A:  MOVWF  x40
....................                 command_move(0,1,1); 
1B17C:  MOVLB  8
1B17E:  CLRF   x85
1B180:  MOVLW  01
1B182:  MOVWF  x86
1B184:  MOVWF  x87
1B186:  MOVLB  0
1B188:  CALL   17092
....................          break; 
1B18C:  BRA    1B218
.................... //!      case 'c': command_c(); 
.................... //!         break; 
....................       case 'a': command_a(); 
1B18E:  GOTO   18C48
....................          break;     
1B192:  BRA    1B218
....................       case 'b': command_b(); 
1B194:  GOTO   18C64
....................          break; 
1B198:  BRA    1B218
....................       case 'c': command_c(); 
1B19A:  GOTO   18CFE
....................          break; 
1B19E:  BRA    1B218
....................       case 'd': command_d(); 
1B1A0:  GOTO   18D46
....................          break;          
1B1A4:  BRA    1B218
....................       case 'e': command_e(); 
1B1A6:  GOTO   18DDC
....................          break;       
1B1AA:  BRA    1B218
....................       case 'f': command_f(); 
1B1AC:  GOTO   18E76
....................          break; 
1B1B0:  BRA    1B218
....................       case 'g': command_g(); 
1B1B2:  GOTO   18E96
....................          break;          
1B1B6:  BRA    1B218
....................       case 'h': command_h(); 
1B1B8:  GOTO   18F30
....................          break; 
1B1BC:  BRA    1B218
....................       case 'i': command_i(); 
1B1BE:  GOTO   19004
....................          break;   
1B1C2:  BRA    1B218
....................       case 'j': command_j(); 
1B1C4:  GOTO   190E0
....................          break;           
1B1C8:  BRA    1B218
....................       case 'k': command_k(); 
1B1CA:  GOTO   1917A
....................          break;          
1B1CE:  BRA    1B218
....................       case 'l': step_var_list(); 
1B1D0:  GOTO   19210
....................          break;          
1B1D4:  BRA    1B218
....................       case 'm': command_m(); 
1B1D6:  GOTO   19E70
....................          break;    
1B1DA:  BRA    1B218
....................       case 'n': command_n(); 
1B1DC:  GOTO   19F06
....................          break; 
1B1E0:  BRA    1B218
....................       case 'o': command_o(); 
1B1E2:  GOTO   19F9C
....................          break;    
1B1E6:  BRA    1B218
....................       case 'p': command_p(); 
1B1E8:  GOTO   1A036
....................          break;   
1B1EC:  BRA    1B218
....................       case 'q': command_q(); 
1B1EE:  GOTO   1A0D0
....................          break; 
1B1F2:  BRA    1B218
....................       case 'r': command_r(); 
1B1F4:  BRA    1ABCC
....................          break;    
1B1F6:  BRA    1B218
....................       case 's': command_s(); 
1B1F8:  BRA    1AC26
....................          break;           
1B1FA:  BRA    1B218
....................       case 't': command_t(); 
1B1FC:  BRA    1AD34
....................          break;          
1B1FE:  BRA    1B218
....................       case 'u': command_u(); 
1B200:  BRA    1ADCA
....................          break; 
1B202:  BRA    1B218
....................       case 'v': command_v(); 
1B204:  CALL   13DC2
....................          break; 
1B208:  BRA    1B218
....................       case 'w': command_w(); 
1B20A:  BRA    1AE02
....................          break; 
1B20C:  BRA    1B218
....................       case 'x': command_x(); 
1B20E:  BRA    1AED6
....................          break;    
1B210:  BRA    1B218
....................       case 'y': command_y(); 
1B212:  BRA    1AF70
....................          break;  
1B214:  BRA    1B218
....................       case 'z': command_z(); 
1B216:  BRA    1B006
....................          break;           
....................    } 
1B218:  GOTO   1B33C (RETURN)
.................... } 
....................  
....................  
....................  
.................... // --------------------------------------------------------------------// 
....................  
.................... #define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c" 
.................... #define BYTE_TO_BINARY(byte)  \ 
....................   (byte & 0x80 ? '1' : '0'), \ 
....................   (byte & 0x40 ? '1' : '0'), \ 
....................   (byte & 0x20 ? '1' : '0'), \ 
....................   (byte & 0x10 ? '1' : '0'), \ 
....................   (byte & 0x08 ? '1' : '0'), \ 
....................   (byte & 0x04 ? '1' : '0'), \ 
....................   (byte & 0x02 ? '1' : '0'), \ 
....................   (byte & 0x01 ? '1' : '0')  
....................  
.................... void proc_arg2() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
.................... void proc_arg() 
.................... { 
....................   int8 number; 
....................   int8 good_arg; 
....................   char temp_number = 0; 
....................  
....................   number = 0; 
....................   arg = 0; 
....................   good_arg = FALSE; 
....................    
....................   while (number != CARRIAGE_RET) 
....................   {                     // 13 = CR = terminator 
....................      number = fgetc(COM_A); 
....................      temp_number = number; 
....................      if (number != CARRIAGE_RET) fputc(number, COM_A); 
....................      if (number > 47 && number < 58) 
....................      {       // ASCII 0 = 48 
....................         number = number - 48; 
....................         arg = arg * 10;                    // increase significance 
....................         arg = arg + number;                // for each number 
....................         good_arg = TRUE; 
....................      } 
....................      else if (number == CARRIAGE_RET && good_arg == TRUE) 
....................      { 
....................           fputs("@OK! ", COM_A);             // got a valid number 
....................           // *** COMMAND PROCESSOR *** // 
....................           select_cmd(); 
....................      } 
....................      else 
....................      { 
....................         good_arg = FALSE; 
....................         fputs("@ARG ", COM_A);             // bad input 
....................      } 
....................      if (good_arg == FALSE) break; 
....................   } 
.................... } 
....................  
....................  
.................... int8 check_cmd(int8 e) 
.................... { 
....................    // cmd_set - 0=user, 1=full 
....................    int8 valid; 
....................    if (cmd_set==0) valid = isamong (e, USERCMDLIST); 
*
0B18C:  MOVF   51,F
0B18E:  BNZ   B1E0
0B190:  MOVLB  8
0B192:  MOVF   x85,W
0B194:  SUBLW  24
0B196:  BC    B19E
0B198:  MOVF   x85,W
0B19A:  SUBLW  26
0B19C:  BC    B1D8
0B19E:  MOVF   x85,W
0B1A0:  SUBLW  29
0B1A2:  BC    B1AA
0B1A4:  MOVF   x85,W
0B1A6:  SUBLW  2B
0B1A8:  BC    B1D8
0B1AA:  MOVF   x85,W
0B1AC:  SUBLW  2D
0B1AE:  BZ    B1D8
0B1B0:  MOVF   x85,W
0B1B2:  SUBLW  2F
0B1B4:  BZ    B1D8
0B1B6:  MOVF   x85,W
0B1B8:  SUBLW  40
0B1BA:  BC    B1C2
0B1BC:  MOVF   x85,W
0B1BE:  SUBLW  42
0B1C0:  BC    B1D8
0B1C2:  MOVF   x85,W
0B1C4:  SUBLW  43
0B1C6:  BC    B1CE
0B1C8:  MOVF   x85,W
0B1CA:  SUBLW  5A
0B1CC:  BC    B1D8
0B1CE:  MOVF   x85,W
0B1D0:  SUBLW  5E
0B1D2:  BZ    B1D8
0B1D4:  MOVLW  00
0B1D6:  BRA    B1DA
0B1D8:  MOVLW  01
0B1DA:  MOVWF  x86
0B1DC:  BRA    B242
0B1DE:  MOVLB  0
....................    else if (cmd_set==1) valid = isamong (e, FULLCMDLIST); 
0B1E0:  DECFSZ 51,W
0B1E2:  BRA    B244
0B1E4:  MOVLB  8
0B1E6:  MOVF   x85,W
0B1E8:  SUBLW  23
0B1EA:  BZ    B23E
0B1EC:  MOVF   x85,W
0B1EE:  SUBLW  24
0B1F0:  BC    B1F8
0B1F2:  MOVF   x85,W
0B1F4:  SUBLW  26
0B1F6:  BC    B23E
0B1F8:  MOVF   x85,W
0B1FA:  SUBLW  29
0B1FC:  BC    B204
0B1FE:  MOVF   x85,W
0B200:  SUBLW  2B
0B202:  BC    B23E
0B204:  MOVF   x85,W
0B206:  SUBLW  2D
0B208:  BZ    B23E
0B20A:  MOVF   x85,W
0B20C:  SUBLW  2F
0B20E:  BZ    B23E
0B210:  MOVF   x85,W
0B212:  SUBLW  40
0B214:  BC    B21C
0B216:  MOVF   x85,W
0B218:  SUBLW  42
0B21A:  BC    B23E
0B21C:  MOVF   x85,W
0B21E:  SUBLW  43
0B220:  BC    B228
0B222:  MOVF   x85,W
0B224:  SUBLW  5A
0B226:  BC    B23E
0B228:  MOVF   x85,W
0B22A:  SUBLW  5E
0B22C:  BZ    B23E
0B22E:  MOVF   x85,W
0B230:  SUBLW  60
0B232:  BC    B23A
0B234:  MOVF   x85,W
0B236:  SUBLW  7A
0B238:  BC    B23E
0B23A:  MOVLW  00
0B23C:  BRA    B240
0B23E:  MOVLW  01
0B240:  MOVWF  x86
0B242:  MOVLB  0
....................    return(valid); 
0B244:  MOVLB  8
0B246:  MOVFF  886,01
0B24A:  MOVLB  0
0B24C:  GOTO   1B2F4 (RETURN)
.................... } 
....................  
.................... void proc_cmd() 
.................... { 
....................    if(!check_cmd(cmd)) 
*
1B2EC:  MOVFF  47,885
1B2F0:  GOTO   B18C
1B2F4:  MOVF   01,F
1B2F6:  BNZ   1B31A
....................       fputs("\r\n@INV", COM_A); 
1B2F8:  MOVLW  C4
1B2FA:  MOVWF  FF6
1B2FC:  MOVLW  27
1B2FE:  MOVWF  FF7
1B300:  MOVLW  00
1B302:  MOVWF  FF8
1B304:  CALL   AE7A
1B308:  MOVLW  0D
1B30A:  BTFSS  F9E.4
1B30C:  BRA    1B30A
1B30E:  MOVWF  FAD
1B310:  MOVLW  0A
1B312:  BTFSS  F9E.4
1B314:  BRA    1B312
1B316:  MOVWF  FAD
1B318:  BRA    1B33C
....................    else{ 
....................       fputs("\r\n@OK! ", COM_A); 
1B31A:  MOVLW  CC
1B31C:  MOVWF  FF6
1B31E:  MOVLW  27
1B320:  MOVWF  FF7
1B322:  MOVLW  00
1B324:  MOVWF  FF8
1B326:  CALL   AE7A
1B32A:  MOVLW  0D
1B32C:  BTFSS  F9E.4
1B32E:  BRA    1B32C
1B330:  MOVWF  FAD
1B332:  MOVLW  0A
1B334:  BTFSS  F9E.4
1B336:  BRA    1B334
1B338:  MOVWF  FAD
....................       select_cmd(); 
1B33A:  BRA    1B07C
....................    } 
1B33C:  GOTO   1B520 (RETURN)
.................... } 
.................... void proc_cmd2() 
.................... { 
....................    if(check_cmd(cmd)) proc_arg(); 
....................    else fputs("@INV", COM_A); 
.................... } 
....................  
.................... void command_prompt(){ 
1B340:  MOVLB  8
1B342:  CLRF   x64
1B344:  CLRF   x65
1B346:  CLRF   x66
....................    int8 good_val = FALSE; 
....................    int8 i = 0; 
....................    char temp = 0; 
....................    char input_string[30]; 
....................     
....................    output_bit(RTC_CS, ENABLE); 
1B348:  BCF    F91.0
....................    spi_write(0x89); 
1B34A:  MOVF   FC9,W
1B34C:  MOVLW  89
1B34E:  MOVWF  FC9
1B350:  RRCF   FC7,W
1B352:  BNC   1B350
....................    spi_write(0b00000000); 
1B354:  MOVF   FC9,W
1B356:  CLRF   FC9
1B358:  RRCF   FC7,W
1B35A:  BNC   1B358
....................    spi_read(0x00); 
1B35C:  MOVF   FC9,W
1B35E:  CLRF   FC9
1B360:  RRCF   FC7,W
1B362:  BNC   1B360
....................    output_bit(RTC_CS, DISABLE); 
1B364:  BSF    F91.0
....................     
....................     
....................    nv_cmd_mode = TRUE; 
1B366:  CLRF   32
1B368:  MOVLW  01
1B36A:  MOVWF  31
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
1B36C:  MOVLW  02
1B36E:  MOVWF  x89
1B370:  MOVFF  31,88A
1B374:  MOVLB  0
1B376:  CALL   3406
....................     
....................    fputs("@CMD", COM_A); 
1B37A:  MOVLW  DA
1B37C:  MOVWF  FF6
1B37E:  MOVLW  27
1B380:  MOVWF  FF7
1B382:  MOVLW  00
1B384:  MOVWF  FF8
1B386:  CALL   AE7A
1B38A:  MOVLW  0D
1B38C:  BTFSS  F9E.4
1B38E:  BRA    1B38C
1B390:  MOVWF  FAD
1B392:  MOVLW  0A
1B394:  BTFSS  F9E.4
1B396:  BRA    1B394
1B398:  MOVWF  FAD
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
1B39A:  MOVLW  01
1B39C:  MOVWF  1E
1B39E:  MOVLW  A7
1B3A0:  MOVWF  1D
1B3A2:  MOVLW  E0
1B3A4:  MOVWF  FF6
1B3A6:  MOVLW  27
1B3A8:  MOVWF  FF7
1B3AA:  MOVLW  00
1B3AC:  MOVWF  FF8
1B3AE:  CALL   50B2
....................    record_event(); 
1B3B2:  CALL   84CE
....................     
....................    busy_clear(); 
1B3B6:  CALL   AEA4
....................     
....................    cmd_set=0; // user 
1B3BA:  CLRF   51
....................     
....................    do { 
....................       for(i = 0; i<30; i++){ 
1B3BC:  MOVLB  8
1B3BE:  CLRF   x65
1B3C0:  MOVF   x65,W
1B3C2:  SUBLW  1D
1B3C4:  BNC   1B3DA
....................          input_string[i] = 0; 
1B3C6:  CLRF   03
1B3C8:  MOVF   x65,W
1B3CA:  ADDLW  67
1B3CC:  MOVWF  FE9
1B3CE:  MOVLW  08
1B3D0:  ADDWFC 03,W
1B3D2:  MOVWF  FEA
1B3D4:  CLRF   FEF
1B3D6:  INCF   x65,F
1B3D8:  BRA    1B3C0
....................    
....................       } 
....................       i = 0; 
1B3DA:  CLRF   x65
....................       fputc('>',COM_A); 
1B3DC:  MOVLW  3E
1B3DE:  MOVLB  0
1B3E0:  CALL   AEAC
....................       temp = 0; 
1B3E4:  MOVLB  8
1B3E6:  CLRF   x66
....................       while(temp != CARRIAGE_RET){ 
1B3E8:  MOVF   x66,W
1B3EA:  SUBLW  0D
1B3EC:  BZ    1B484
....................          temp = fgetc(COM_A); 
1B3EE:  MOVLB  0
1B3F0:  CALL   0E2C
1B3F4:  MOVFF  01,866
....................          //Backspace character 
....................          if(temp != 8){ 
1B3F8:  MOVLB  8
1B3FA:  MOVF   x66,W
1B3FC:  SUBLW  08
1B3FE:  BZ    1B42A
....................             if (com_echo == TRUE) 
1B400:  DECFSZ 4C,W
1B402:  BRA    1B40E
....................             { 
....................                fputc(temp,COM_A); 
1B404:  MOVF   x66,W
1B406:  MOVLB  0
1B408:  CALL   AEAC
1B40C:  MOVLB  8
....................             } 
....................             if(temp!= CARRIAGE_RET){ 
1B40E:  MOVF   x66,W
1B410:  SUBLW  0D
1B412:  BZ    1B428
....................                input_string[i] = temp; 
1B414:  CLRF   03
1B416:  MOVF   x65,W
1B418:  ADDLW  67
1B41A:  MOVWF  FE9
1B41C:  MOVLW  08
1B41E:  ADDWFC 03,W
1B420:  MOVWF  FEA
1B422:  MOVFF  866,FEF
....................                i++; 
1B426:  INCF   x65,F
....................             } 
....................          }else{ 
1B428:  BRA    1B482
....................             if(i != 0){ 
1B42A:  MOVF   x65,F
1B42C:  BZ    1B482
....................                input_string[i-1] = 0; 
1B42E:  MOVLW  01
1B430:  SUBWF  x65,W
1B432:  CLRF   03
1B434:  ADDLW  67
1B436:  MOVWF  FE9
1B438:  MOVLW  08
1B43A:  ADDWFC 03,W
1B43C:  MOVWF  FEA
1B43E:  CLRF   FEF
....................                i--; 
1B440:  DECF   x65,F
....................                //Clear buffer and overwrite with previous minus one character 
....................                fputc('\r',COM_A); 
1B442:  MOVLW  0D
1B444:  MOVLB  0
1B446:  CALL   AEAC
....................                fprintf(COM_A,"                                       "); 
1B44A:  MOVLW  F2
1B44C:  MOVWF  FF6
1B44E:  MOVLW  27
1B450:  MOVWF  FF7
1B452:  MOVLW  00
1B454:  MOVWF  FF8
1B456:  CLRF   1B
1B458:  BTFSC  FF2.7
1B45A:  BSF    1B.7
1B45C:  BCF    FF2.7
1B45E:  CALL   0E42
1B462:  BTFSC  1B.7
1B464:  BSF    FF2.7
....................                fputc('\r',COM_A); 
1B466:  MOVLW  0D
1B468:  CALL   AEAC
....................                fprintf(COM_A,">"); 
1B46C:  MOVLW  3E
1B46E:  BTFSS  F9E.4
1B470:  BRA    1B46E
1B472:  MOVWF  FAD
....................                fprintf(COM_A,input_string); 
1B474:  MOVLW  08
1B476:  MOVWF  FEA
1B478:  MOVLW  67
1B47A:  MOVWF  FE9
1B47C:  CALL   798A
1B480:  MOVLB  8
....................                 
....................             } 
....................          } 
1B482:  BRA    1B3E8
....................       } 
....................       cmd = input_string[0]; 
1B484:  MOVFF  867,47
....................       i = 1; 
1B488:  MOVLW  01
1B48A:  MOVWF  x65
....................       //fputs("\r\n",COM_A); 
....................       while(input_string[i] != 0){ 
1B48C:  CLRF   03
1B48E:  MOVF   x65,W
1B490:  ADDLW  67
1B492:  MOVWF  FE9
1B494:  MOVLW  08
1B496:  ADDWFC 03,W
1B498:  MOVWF  FEA
1B49A:  MOVF   FEF,F
1B49C:  BZ    1B4EE
....................       //fputc(input_string[i],COM_A); 
....................          if(!isdigit(input_string[i])){ 
1B49E:  CLRF   03
1B4A0:  MOVF   x65,W
1B4A2:  ADDLW  67
1B4A4:  MOVWF  FE9
1B4A6:  MOVLW  08
1B4A8:  ADDWFC 03,W
1B4AA:  MOVWF  FEA
1B4AC:  MOVFF  FEF,885
1B4B0:  MOVF   x85,W
1B4B2:  SUBLW  2F
1B4B4:  BC    1B4BC
1B4B6:  MOVF   x85,W
1B4B8:  SUBLW  39
1B4BA:  BC    1B4E6
....................             fputs("\r\n@ARG ", COM_A); 
1B4BC:  MOVLW  1A
1B4BE:  MOVWF  FF6
1B4C0:  MOVLW  28
1B4C2:  MOVWF  FF7
1B4C4:  MOVLW  00
1B4C6:  MOVWF  FF8
1B4C8:  MOVLB  0
1B4CA:  CALL   AE7A
1B4CE:  MOVLW  0D
1B4D0:  BTFSS  F9E.4
1B4D2:  BRA    1B4D0
1B4D4:  MOVWF  FAD
1B4D6:  MOVLW  0A
1B4D8:  BTFSS  F9E.4
1B4DA:  BRA    1B4D8
1B4DC:  MOVWF  FAD
....................             good_val = FALSE; 
1B4DE:  MOVLB  8
1B4E0:  CLRF   x64
....................             break; 
1B4E2:  BRA    1B4EE
....................          }else{ 
1B4E4:  BRA    1B4EA
....................             good_val = TRUE; 
1B4E6:  MOVLW  01
1B4E8:  MOVWF  x64
....................          } 
....................          i++; 
1B4EA:  INCF   x65,F
1B4EC:  BRA    1B48C
....................       } 
....................       if(!good_val){ 
1B4EE:  MOVF   x64,F
1B4F0:  BNZ   1B4F4
....................          continue; 
1B4F2:  BRA    1B522
....................       } 
....................        
....................       arg = atoi32(input_string+1); 
1B4F4:  MOVLW  08
1B4F6:  MOVWF  x86
1B4F8:  MOVLW  68
1B4FA:  MOVWF  x85
1B4FC:  MOVLB  0
1B4FE:  GOTO   AEB4
1B502:  MOVFF  03,4B
1B506:  MOVFF  02,4A
1B50A:  MOVFF  01,49
1B50E:  MOVFF  00,48
....................        
....................       //proc_cmd(); 
....................       //fputs("\r\n@OK! ", COM_A); 
....................       //select_cmd(); 
....................        
....................       if (cmd == '?') msg_busy(); 
1B512:  MOVF   47,W
1B514:  SUBLW  3F
1B516:  BNZ   1B51E
1B518:  GOTO   B14A
1B51C:  BRA    1B520
....................       else{  
....................             proc_cmd(); 
1B51E:  BRA    1B2EC
1B520:  MOVLB  8
....................              
....................       } 
....................        
....................        
....................        
....................           
....................       /*if(cmd != 8){ 
....................          temp_cmd = cmd; 
....................          if (com_echo == TRUE) 
....................          { 
....................             fputc(cmd,COM_A); 
....................          } 
....................          if (cmd == '?') msg_busy(); 
....................          else proc_cmd(); 
....................       }else{ 
....................          if(temp_cmd != 0){ 
....................             fprintf(COM_A,"\r\n>%c",temp_cmd); 
....................          } 
....................       } 
....................       //restart_wdt();*/ 
....................    } while(nv_cmd_mode == TRUE); 
1B522:  DECFSZ 31,W
1B524:  BRA    1B52C
1B526:  MOVF   32,F
1B528:  BTFSC  FD8.2
1B52A:  BRA    1B3BE
1B52C:  MOVLB  0
1B52E:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void command_prompt2() 
.................... { 
....................    //disable_interrupts(INT_EXT); 
....................    char temp_cmd = 0; 
....................    nv_cmd_mode = TRUE; 
....................    write8(ADDR_CMD_MODE, nv_cmd_mode); 
....................     
....................    fputs("@CMD", COM_A); 
....................     
....................    sprintf(event_str, ",command prompt\r\n"); 
....................    record_event(); 
....................     
....................    busy_clear(); 
....................     
....................    cmd_set=0; // user 
....................     
....................    do { 
....................       fputc('>',COM_A); 
....................       cmd=fgetc(COM_A); 
....................          temp_cmd = cmd; 
....................          if (com_echo == TRUE) 
....................          { 
....................             fputc(cmd,COM_A); 
....................          } 
....................          if (cmd == '?') msg_busy(); 
....................          else proc_cmd(); 
....................       //restart_wdt(); 
....................    } while(nv_cmd_mode == TRUE); 
.................... } 
....................  
....................  
.................... void main() 
1B530:  CLRF   FF8
1B532:  BCF    FD0.7
1B534:  BSF    07.7
1B536:  MOVLW  70
1B538:  MOVWF  FD3
1B53A:  MOVLW  40
1B53C:  MOVWF  F9B
1B53E:  CLRF   F64
1B540:  CLRF   1C
1B542:  BSF    F65.3
1B544:  MOVWF  FAF
1B546:  MOVLW  03
1B548:  MOVWF  FD4
1B54A:  MOVLW  A6
1B54C:  MOVWF  FAC
1B54E:  MOVLW  90
1B550:  MOVWF  FAB
1B552:  MOVLB  F
1B554:  BSF    x20.3
1B556:  MOVLW  82
1B558:  MOVWF  x1E
1B55A:  MOVLW  06
1B55C:  MOVWF  x1F
1B55E:  MOVLW  A6
1B560:  MOVWF  x21
1B562:  MOVLW  90
1B564:  MOVWF  x22
1B566:  BSF    F65.3
1B568:  MOVLW  40
1B56A:  MOVWF  FAF
1B56C:  MOVLW  03
1B56E:  MOVWF  FD4
1B570:  MOVLW  A6
1B572:  MOVWF  FAC
1B574:  MOVLW  90
1B576:  MOVWF  FAB
1B578:  CLRF   1E
1B57A:  CLRF   1D
1B57C:  SETF   3A
1B57E:  SETF   39
1B580:  SETF   3C
1B582:  SETF   3B
1B584:  CLRF   46
1B586:  MOVLW  01
1B588:  MOVWF  45
1B58A:  MOVWF  4C
1B58C:  BCF    4D.0
1B58E:  BCF    4D.1
1B590:  BCF    4D.2
1B592:  MOVLB  0
1B594:  CLRF   x66
1B596:  MOVLB  2
1B598:  MOVWF  xD9
1B59A:  MOVLB  3
1B59C:  CLRF   x3B
1B59E:  MOVLB  4
1B5A0:  CLRF   xE7
1B5A2:  MOVWF  xED
1B5A4:  MOVLW  04
1B5A6:  MOVLB  7
1B5A8:  MOVWF  x13
1B5AA:  MOVLW  EE
1B5AC:  MOVWF  x12
1B5AE:  CLRF   xCD
1B5B0:  MOVLB  8
1B5B2:  CLRF   x58
1B5B4:  CLRF   x57
1B5B6:  CLRF   x5C
1B5B8:  CLRF   x5B
1B5BA:  CLRF   x5A
1B5BC:  CLRF   x59
1B5BE:  CLRF   x60
1B5C0:  CLRF   x5F
1B5C2:  CLRF   x5E
1B5C4:  CLRF   x5D
1B5C6:  MOVLW  00
1B5C8:  MOVLB  F
1B5CA:  MOVWF  x23
1B5CC:  MOVWF  x24
1B5CE:  MOVWF  x25
1B5D0:  BCF    FC1.3
1B5D2:  BCF    FC1.4
1B5D4:  BCF    FC1.5
1B5D6:  CLRF   x2E
1B5D8:  CLRF   x2F
1B5DA:  CLRF   x54
1B5DC:  BRA    1B69E
1B5DE:  DATA 44,02
1B5E0:  DATA DD,20
1B5E2:  DATA 64,72
1B5E4:  DATA 61,77
1B5E6:  DATA 5F,61
1B5E8:  DATA 6C,6C
1B5EA:  DATA 2E,63
1B5EC:  DATA 73,76
1B5EE:  DATA 00,20
1B5F0:  DATA 64,72
1B5F2:  DATA 61,77
1B5F4:  DATA 5F,6E
1B5F6:  DATA 65,77
1B5F8:  DATA 2E,63
1B5FA:  DATA 73,76
1B5FC:  DATA 00,20
1B5FE:  DATA 64,72
1B600:  DATA 65,6C
1B602:  DATA 5F,61
1B604:  DATA 6C,6C
1B606:  DATA 2E,63
1B608:  DATA 73,76
1B60A:  DATA 00,20
1B60C:  DATA 64,72
1B60E:  DATA 65,6C
1B610:  DATA 5F,6E
1B612:  DATA 65,77
1B614:  DATA 2E,63
1B616:  DATA 73,76
1B618:  DATA 00,20
1B61A:  DATA 65,76
1B61C:  DATA 65,6E
1B61E:  DATA 74,73
1B620:  DATA 2E,74
1B622:  DATA 78,74
1B624:  DATA 00,02
1B626:  DATA 03,39
1B628:  DATA 2C,00
1B62A:  DATA 02,04
1B62C:  DATA D8,00
1B62E:  DATA 00,10
1B630:  DATA 07,14
1B632:  DATA 46,41
1B634:  DATA 54,31
1B636:  DATA 32,46
1B638:  DATA 41,54
1B63A:  DATA 31,36
1B63C:  DATA 46,41
1B63E:  DATA 54,33
1B640:  DATA 32,00
1B642:  DATA 57,07
1B644:  DATA CE,0D
1B646:  DATA 0A,00
1B648:  DATA 00,03
1B64A:  DATA 00,0F
1B64C:  DATA 00,1B
1B64E:  DATA 00,27
1B650:  DATA 00,33
1B652:  DATA 00,3F
1B654:  DATA 00,4B
1B656:  DATA 00,57
1B658:  DATA 00,63
1B65A:  DATA 00,6F
1B65C:  DATA 00,7B
1B65E:  DATA 00,87
1B660:  DATA 00,93
1B662:  DATA 00,9F
1B664:  DATA 00,AB
1B666:  DATA 00,B7
1B668:  DATA 00,C3
1B66A:  DATA 48,B1
1B66C:  DATA 70,D4
1B66E:  DATA 98,F7
1B670:  DATA C0,1A
1B672:  DATA 00,CF
1B674:  DATA 28,F2
1B676:  DATA 50,15
1B678:  DATA 78,38
1B67A:  DATA A0,5B
1B67C:  DATA C8,7E
1B67E:  DATA F0,A1
1B680:  DATA 18,C5
1B682:  DATA 40,E8
1B684:  DATA 68,0B
1B686:  DATA 90,2E
1B688:  DATA B8,51
1B68A:  DATA E0,74
1B68C:  DATA 08,98
1B68E:  DATA 30,BB
1B690:  DATA 58,DE
1B692:  DATA 80,01
1B694:  DATA A8,24
1B696:  DATA D0,47
1B698:  DATA F8,6A
1B69A:  DATA 20,8E
1B69C:  DATA 00,00
1B69E:  MOVLW  01
1B6A0:  MOVWF  FF8
1B6A2:  MOVLW  B5
1B6A4:  MOVWF  FF7
1B6A6:  MOVLW  DE
1B6A8:  MOVWF  FF6
1B6AA:  TBLRD*+
1B6AC:  MOVF   FF5,W
1B6AE:  MOVWF  00
1B6B0:  XORLW  00
1B6B2:  BZ    1B6DA
1B6B4:  TBLRD*+
1B6B6:  MOVF   FF5,W
1B6B8:  MOVWF  01
1B6BA:  BTFSC  FE8.7
1B6BC:  BRA    1B6C8
1B6BE:  ANDLW  0F
1B6C0:  MOVWF  FEA
1B6C2:  TBLRD*+
1B6C4:  MOVFF  FF5,FE9
1B6C8:  BTFSC  01.6
1B6CA:  TBLRD*+
1B6CC:  BTFSS  01.6
1B6CE:  TBLRD*+
1B6D0:  MOVFF  FF5,FEE
1B6D4:  DCFSNZ 00,F
1B6D6:  BRA    1B6AA
1B6D8:  BRA    1B6CC
1B6DA:  CLRF   FF8
1B6DC:  MOVLB  8
1B6DE:  CLRF   x61
1B6E0:  CLRF   x63
1B6E2:  CLRF   x62
.................... {  int8 EscNum=0; 
....................    int16 EscCount=0; 
.................... //   int32 timeout_A;  
....................     
....................    disable_interrupts(GLOBAL); 
1B6E4:  BCF    FF2.6
1B6E6:  BCF    FF2.7
1B6E8:  BTFSC  FF2.7
1B6EA:  BRA    1B6E6
....................     
....................    setup_spi(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B6EC:  BCF    FC6.5
1B6EE:  MOVLW  21
1B6F0:  MOVWF  FC6
1B6F2:  MOVLW  40
1B6F4:  MOVWF  FC7
....................    setup_spi2(SPI_MASTER | SPI_MODE_0_0 | SPI_CLK_DIV_16 ); 
1B6F6:  BCF    F67.5
1B6F8:  MOVLW  21
1B6FA:  MOVWF  F67
1B6FC:  MOVLW  40
1B6FE:  MOVWF  F68
....................     
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|VSS_4V096); 
1B700:  MOVLW  00
1B702:  MOVLB  F
1B704:  MOVWF  x23
1B706:  MOVWF  x24
1B708:  MOVLW  1F
1B70A:  MOVWF  x25
1B70C:  BCF    FC1.3
1B70E:  BSF    FC1.4
1B710:  BSF    FC1.5
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
1B712:  MOVF   FC0,W
1B714:  ANDLW  C0
1B716:  IORLW  07
1B718:  MOVWF  FC0
1B71A:  BSF    FC0.7
1B71C:  BSF    FC2.0
....................  
....................    // TIMER 0 is being used to service the WTD 
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
1B71E:  MOVLW  87
1B720:  MOVWF  FD5
....................    /* sets the internal clock as source and prescale 256.  
....................       At 10 Mhz timer0 will increment every 0.4us (Fosc*4) in this setup and overflows every 
....................       6.71 seconds. Timer0 defaults to 16-bit if RTCC_8_BIT is not used. 
....................       Fosc = 10 MHz, Fosc/4 = 2.5 Mhz, div 256 = 0.0001024 s, 65536 increments = 6.71 sec 
....................       Fosc = 64 MHz, Fosc/4 = 16 Mhz, div 256 = 0.000016 s, 65536 increments = 1.05 sec 
....................       .. pre-load with 3036 to get exact 1.0000 sec value 
....................    */ 
....................     
....................    // TIMER 1 is used to extinguish the LED 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8); 
1B722:  MOVLW  37
1B724:  MOVWF  FCD
1B726:  CLRF   FAA
....................    /* sets the internal clock as source and prescale 4.  
....................       At 10Mhz timer0 will increment every 0.4us in this setup and overflows every 
....................       104.8 ms. Timer1 is 16-bit. 
....................       Fosc = 10 Mhz ... 2.5 MHz / div 4  = 0.00000160 s * 65536 = 0.104858 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 4  = 0.00000025 s * 65536 = 0.016384 sec 
....................       Fosc = 64 Mhz ... 16 MHz /  div 8  = 0.00000200 s * 65536 = 0.032768 sec 
....................    */    
....................     
....................    setup_stepper_pwm();  // Uses TIMER 2 
1B728:  MOVLB  0
1B72A:  GOTO   28B8
....................     
....................    // TIMER 3 is used for stepper motor intervals 
....................    setup_timer_3(T3_INTERNAL | T3_DIV_BY_1);   // 16 bit timer 
1B72E:  CLRF   FB0
1B730:  MOVLW  07
1B732:  MOVWF  FB1
....................  
....................    setup_comparator(NC_NC_NC_NC); 
1B734:  MOVLW  04
1B736:  MOVLB  F
1B738:  MOVWF  x2E
1B73A:  MOVWF  x2F
1B73C:  MOVWF  x54
....................  
....................    setup_oscillator(OSC_16MHZ | OSC_PLL_ON);  // Fosc = 64 MHz 
1B73E:  MOVLW  70
1B740:  MOVWF  FD3
1B742:  MOVLW  40
1B744:  MOVWF  F9B
1B746:  CLRF   F64
....................     
....................    //setup_wdt(WDT_4S); 
....................  
....................    ext_int_edge(0, H_TO_L);         // Set up PIC18 EXT0 
1B748:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
1B74A:  BSF    FF2.4
....................  
....................    start_heartbeat(); 
1B74C:  MOVLB  0
1B74E:  CALL   28F4
....................  
....................    enable_interrupts(GLOBAL); 
1B752:  MOVLW  C0
1B754:  IORWF  FF2,F
....................     
....................     
....................  
....................    init_hardware(); 
1B756:  CALL   292E
....................    motor_sleep_rdy(); 
1B75A:  CALL   298C
....................  
....................    sleep_mode = FALSE;    
1B75E:  BCF    4D.1
....................    busy_set(); 
1B760:  CALL   29B4
....................     
....................    init_nv_vars(); 
1B764:  CALL   2AAC
....................    get_step_vars(); 
1B768:  CALL   2D0E
....................    init_aws(); 
1B76C:  GOTO   30D0
....................    kill_wd();   // VK - added May 5 2017 to prevent resets on detector readings 
1B770:  CALL   30EA
....................    blink(); 
1B774:  GOTO   30F0
....................     
....................    //Add for TCP/IP interface 
....................    //delay_ms(15000); 
....................     
....................    signon(); 
1B778:  CALL   313C
....................     
....................    RTC_read(); 
1B77C:  CALL   3338
....................    RTC_last_power(); 
1B780:  GOTO   3436
....................    RTC_reset_HT();   
1B784:  CALL   34A6
....................    RTC_read(); 
1B788:  CALL   3338
1B78C:  CLRF   1B
1B78E:  BTFSC  FF2.7
1B790:  BSF    1B.7
1B792:  BCF    FF2.7
....................    RTC_read_flags(); 
1B794:  CALL   0DCC
1B798:  BTFSC  1B.7
1B79A:  BSF    FF2.7
....................  
....................    if(nv_sd_status>0) fprintf(COM_A,"@SD=%Lu\r\n", nv_sd_status); 
1B79C:  MOVF   3F,F
1B79E:  BNZ   1B7A4
1B7A0:  MOVF   40,F
1B7A2:  BZ    1B7F4
1B7A4:  MOVLW  3A
1B7A6:  MOVWF  FF6
1B7A8:  MOVLW  28
1B7AA:  MOVWF  FF7
1B7AC:  MOVLW  00
1B7AE:  MOVWF  FF8
1B7B0:  CLRF   1B
1B7B2:  BTFSC  FF2.7
1B7B4:  BSF    1B.7
1B7B6:  BCF    FF2.7
1B7B8:  MOVLW  04
1B7BA:  MOVLB  A
1B7BC:  MOVWF  x40
1B7BE:  MOVLB  0
1B7C0:  CALL   1018
1B7C4:  BTFSC  1B.7
1B7C6:  BSF    FF2.7
1B7C8:  MOVLW  10
1B7CA:  MOVWF  FE9
1B7CC:  CLRF   1B
1B7CE:  BTFSC  FF2.7
1B7D0:  BSF    1B.7
1B7D2:  BCF    FF2.7
1B7D4:  MOVFF  40,A41
1B7D8:  MOVFF  3F,A40
1B7DC:  CALL   119A
1B7E0:  BTFSC  1B.7
1B7E2:  BSF    FF2.7
1B7E4:  MOVLW  0D
1B7E6:  BTFSS  F9E.4
1B7E8:  BRA    1B7E6
1B7EA:  MOVWF  FAD
1B7EC:  MOVLW  0A
1B7EE:  BTFSS  F9E.4
1B7F0:  BRA    1B7EE
1B7F2:  MOVWF  FAD
....................    init_rtc(); // This is the FAT RTC 
1B7F4:  CALL   34FC
....................    sd_status = init_sdcard(); 
1B7F8:  CALL   502E
1B7FC:  MOVFF  01,2DC
....................    if(sd_status>0) msg_card_fail(); 
1B800:  MOVLB  2
1B802:  MOVF   xDC,F
1B804:  BZ    1B80E
1B806:  MOVLB  0
1B808:  CALL   5074
1B80C:  MOVLB  2
....................    
....................     
....................     
....................    reset_event(); 
1B80E:  MOVLB  0
1B810:  GOTO   ABBA
....................     
....................    if(m_error[0] > 0 || m_error[1] > 0) msg_mer();   
1B814:  MOVLB  7
1B816:  MOVF   x96,F
1B818:  BNZ   1B826
1B81A:  MOVF   x97,F
1B81C:  BNZ   1B826
1B81E:  MOVF   x98,F
1B820:  BNZ   1B826
1B822:  MOVF   x99,F
1B824:  BZ    1B82E
1B826:  MOVLB  0
1B828:  CALL   9CF6
1B82C:  MOVLB  7
....................     
....................    if (m_comp[0]==FALSE) { 
1B82E:  MOVF   xAF,F
1B830:  BNZ   1B8B4
1B832:  MOVF   xB0,F
1B834:  BNZ   1B8B4
....................       e_port[0]=0; 
1B836:  CLRF   xC4
1B838:  CLRF   xC3
....................       write16(ADDR_E1_PORT,0); 
1B83A:  MOVLW  AA
1B83C:  MOVLB  8
1B83E:  MOVWF  xEE
1B840:  CLRF   xF0
1B842:  CLRF   xEF
1B844:  MOVLB  0
1B846:  CALL   4FC8
....................       fprintf(COM_A, "@MC1,%Lu,%Ld\r\n", m_comp[0],e_port[0]); 
1B84A:  MOVLW  44
1B84C:  MOVWF  FF6
1B84E:  MOVLW  28
1B850:  MOVWF  FF7
1B852:  MOVLW  00
1B854:  MOVWF  FF8
1B856:  CLRF   1B
1B858:  BTFSC  FF2.7
1B85A:  BSF    1B.7
1B85C:  BCF    FF2.7
1B85E:  MOVLW  05
1B860:  MOVLB  A
1B862:  MOVWF  x40
1B864:  MOVLB  0
1B866:  CALL   1018
1B86A:  BTFSC  1B.7
1B86C:  BSF    FF2.7
1B86E:  MOVLW  10
1B870:  MOVWF  FE9
1B872:  CLRF   1B
1B874:  BTFSC  FF2.7
1B876:  BSF    1B.7
1B878:  BCF    FF2.7
1B87A:  MOVFF  7B0,A41
1B87E:  MOVFF  7AF,A40
1B882:  CALL   119A
1B886:  BTFSC  1B.7
1B888:  BSF    FF2.7
1B88A:  MOVLW  2C
1B88C:  BTFSS  F9E.4
1B88E:  BRA    1B88C
1B890:  MOVWF  FAD
1B892:  MOVLW  10
1B894:  MOVWF  FE9
1B896:  MOVFF  7C4,8F1
1B89A:  MOVFF  7C3,8F0
1B89E:  CALL   8FD8
1B8A2:  MOVLW  0D
1B8A4:  BTFSS  F9E.4
1B8A6:  BRA    1B8A4
1B8A8:  MOVWF  FAD
1B8AA:  MOVLW  0A
1B8AC:  BTFSS  F9E.4
1B8AE:  BRA    1B8AC
1B8B0:  MOVWF  FAD
1B8B2:  MOVLB  7
....................    } 
....................    if (m_comp[1]==FALSE) { 
1B8B4:  MOVF   xB1,F
1B8B6:  BNZ   1B93A
1B8B8:  MOVF   xB2,F
1B8BA:  BNZ   1B93A
....................       m_lin_pos[1]=-1; 
1B8BC:  SETF   xB6
1B8BE:  SETF   xB5
....................       write16(ADDR_M2_LIN_POS, -1); 
1B8C0:  MOVLW  B8
1B8C2:  MOVLB  8
1B8C4:  MOVWF  xEE
1B8C6:  SETF   xF0
1B8C8:  SETF   xEF
1B8CA:  MOVLB  0
1B8CC:  CALL   4FC8
....................       fprintf(COM_A, "@MC2,%Lu,%Ld\r\n", m_comp[1],m_lin_pos[1]); 
1B8D0:  MOVLW  54
1B8D2:  MOVWF  FF6
1B8D4:  MOVLW  28
1B8D6:  MOVWF  FF7
1B8D8:  MOVLW  00
1B8DA:  MOVWF  FF8
1B8DC:  CLRF   1B
1B8DE:  BTFSC  FF2.7
1B8E0:  BSF    1B.7
1B8E2:  BCF    FF2.7
1B8E4:  MOVLW  05
1B8E6:  MOVLB  A
1B8E8:  MOVWF  x40
1B8EA:  MOVLB  0
1B8EC:  CALL   1018
1B8F0:  BTFSC  1B.7
1B8F2:  BSF    FF2.7
1B8F4:  MOVLW  10
1B8F6:  MOVWF  FE9
1B8F8:  CLRF   1B
1B8FA:  BTFSC  FF2.7
1B8FC:  BSF    1B.7
1B8FE:  BCF    FF2.7
1B900:  MOVFF  7B2,A41
1B904:  MOVFF  7B1,A40
1B908:  CALL   119A
1B90C:  BTFSC  1B.7
1B90E:  BSF    FF2.7
1B910:  MOVLW  2C
1B912:  BTFSS  F9E.4
1B914:  BRA    1B912
1B916:  MOVWF  FAD
1B918:  MOVLW  10
1B91A:  MOVWF  FE9
1B91C:  MOVFF  7B6,8F1
1B920:  MOVFF  7B5,8F0
1B924:  CALL   8FD8
1B928:  MOVLW  0D
1B92A:  BTFSS  F9E.4
1B92C:  BRA    1B92A
1B92E:  MOVWF  FAD
1B930:  MOVLW  0A
1B932:  BTFSS  F9E.4
1B934:  BRA    1B932
1B936:  MOVWF  FAD
1B938:  MOVLB  7
....................    } 
....................  
....................    if (nv_cmd_mode == FALSE) 
1B93A:  MOVF   31,F
1B93C:  BNZ   1B9E0
1B93E:  MOVF   32,F
1B940:  BNZ   1B9E0
....................    { 
....................       fprintf(COM_A, "Press and hold the Esc key to return to Command Mode\r\n"); 
1B942:  MOVLW  64
1B944:  MOVWF  FF6
1B946:  MOVLW  28
1B948:  MOVWF  FF7
1B94A:  MOVLW  00
1B94C:  MOVWF  FF8
1B94E:  CLRF   1B
1B950:  BTFSC  FF2.7
1B952:  BSF    1B.7
1B954:  BCF    FF2.7
1B956:  MOVLB  0
1B958:  CALL   0E42
1B95C:  BTFSC  1B.7
1B95E:  BSF    FF2.7
....................       
....................       while (EscCount < 100 && EscNum != ESCAPE) 
1B960:  MOVLB  8
1B962:  MOVF   x63,F
1B964:  BNZ   1B992
1B966:  MOVF   x62,W
1B968:  SUBLW  63
1B96A:  BNC   1B992
1B96C:  MOVF   x61,W
1B96E:  SUBLW  1B
1B970:  BZ    1B992
....................       { 
....................          EscNum=TestForEsc(); 
1B972:  MOVLB  0
1B974:  GOTO   AE20
1B978:  MOVFF  01,861
....................          if(EscNum == ESCAPE) command_prompt(); 
1B97C:  MOVLB  8
1B97E:  MOVF   x61,W
1B980:  SUBLW  1B
1B982:  BNZ   1B98A
1B984:  MOVLB  0
1B986:  RCALL  1B340
1B988:  MOVLB  8
....................          EscCount++; 
1B98A:  INCF   x62,F
1B98C:  BTFSC  FD8.2
1B98E:  INCF   x63,F
1B990:  BRA    1B962
....................       } 
....................       
....................       if(MaxSamples == TRUE)  
1B992:  DECFSZ 33,W
1B994:  BRA    1B9AA
1B996:  MOVF   34,F
1B998:  BNZ   1B9AA
....................       { 
....................          arg=0; 
1B99A:  CLRF   4B
1B99C:  CLRF   4A
1B99E:  CLRF   49
1B9A0:  CLRF   48
....................          commandZ(); 
1B9A2:  MOVLB  0
1B9A4:  CALL   18AF8
1B9A8:  MOVLB  8
....................       } 
....................  
....................       fprintf(COM_A, "Returning to Logging Mode\r\n"); 
1B9AA:  MOVLW  9C
1B9AC:  MOVWF  FF6
1B9AE:  MOVLW  28
1B9B0:  MOVWF  FF7
1B9B2:  MOVLW  00
1B9B4:  MOVWF  FF8
1B9B6:  CLRF   1B
1B9B8:  BTFSC  FF2.7
1B9BA:  BSF    1B.7
1B9BC:  BCF    FF2.7
1B9BE:  MOVLB  0
1B9C0:  CALL   0E42
1B9C4:  BTFSC  1B.7
1B9C6:  BSF    FF2.7
....................       arg = 0; 
1B9C8:  CLRF   4B
1B9CA:  CLRF   4A
1B9CC:  CLRF   49
1B9CE:  CLRF   48
....................       commandM(TRUE); 
1B9D0:  MOVLW  01
1B9D2:  MOVLB  8
1B9D4:  MOVWF  x85
1B9D6:  MOVLB  0
1B9D8:  CALL   16DA0
....................    } 
1B9DC:  BRA    1B9E4
1B9DE:  MOVLB  7
....................    else 
....................    { 
....................       /*int8 RTC_buffer = 0; 
....................       unsigned int8 a0 = 0; 
....................       unsigned int8 a1 = 0; 
....................       unsigned int8 a2 = 0; 
....................       unsigned int8 a3 = 0; 
....................       unsigned int8 a4 = 0; 
....................       unsigned int8 a5 = 0; 
....................       unsigned int8 a6 = 0; 
....................       unsigned int8 a7 = 0; 
....................       unsigned int8 a8 = 0; 
....................       unsigned int8 a9 = 0; 
....................       unsigned int8 a10 = 0; 
....................       unsigned int8 a11 = 0; 
....................        
....................       RTC_reset_HT(); 
....................       output_bit(RTC_CS, ENABLE); 
....................       spi_write(0x89); 
....................       spi_write(0b11000011); 
....................       output_bit(RTC_CS, DISABLE); 
....................        
....................       output_bit(RTC_CS, ENABLE); 
....................       RTC_buffer = spi_read(0x00); 
....................       a0 = RTC_buffer; 
....................       fprintf(COM_A,"crap: %u\r\n",RTC_buffer); 
....................       a1 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg0: %u\r\n",a1); 
....................       a2 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg1: %u\r\n",a2); 
....................       a3 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg2: %u\r\n",a3); 
....................       a4 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg3: %u\r\n",a4); 
....................       a5 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg4: %u\r\n",a5); 
....................       a6 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg5: %u\r\n",a6); 
....................       a7 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg6: %u\r\n",a7); 
....................       a8 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg7: %u\r\n",a8); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg8: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"reg9: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regA: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regB: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regC: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regD: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regE: %u\r\n",a9); 
....................       a9 = spi_read(RTC_buffer); 
....................       fprintf(COM_A,"regF: %u\r\n",a9); 
....................        
....................       output_bit(RTC_CS, DISABLE);*/ 
....................     
....................       command_prompt(); 
1B9E0:  MOVLB  0
1B9E2:  RCALL  1B340
....................    } 
....................  
....................    reset_cpu(); 
1B9E4:  RESET
.................... } 
....................  
1B9E6:  SLEEP 

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 2878   PUT NOBROWNOUT BORV18 ZPBORM NOWDT WDT1024
   Word  3: 8BF0   RTCOSC_INT NOEXTADDRSFT ABW8 BW16 NOWAIT CCP2C1 ECCPE MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C0FF   NOPROTECT NOCPB NOCPD
   Word  6: E0FF   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 40FF   NOEBTR NOEBTRB
